<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Webservice</title>
  
  <!-- Meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="webservice,wsdl,soap,wsimport,jaxws,cxf,spring">
  
  
    <meta name="description" content="Set up webservice (jaxws,cxf)">
  

  <!-- Feed -->
  
    <link rel="alternative" href="/atom.xml" title="SixDegree" type="application/atom+xml">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/bootstrap/dist/css/bootstrap.css">
  
	
		<link rel="stylesheet" href="/highlight/demo/styles/tomorrow-night-bright.css">
	
    
  
  <link rel="stylesheet" href="/css/fontello.css">
  <link rel="stylesheet" href="/css/style.css">

  <!-- Site Analyse -->
  
	<script>
	var userID='2bbb83cc0f781dd7502e9d5e19661866';
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?"+userID;
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>


</head>

<body data-spy="scroll" data-target="#nav-catalog">
  <div id="top-push"></div>
<a href="#top-push" id="go-top">
	<span class="glyphicon glyphicon-chevron-up"></span>
</a>
  <aside id="sidebar">
    <section class="sidebar-header">Catalog</section>
     <nav id="nav-catalog">
        <ol class="sidebar-nav nav"><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-1"><span class="sidebar-nav nav-text">简介</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-2"><span class="sidebar-nav nav-text">WSDL</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-3"><span class="sidebar-nav nav-text">type</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-4"><span class="sidebar-nav nav-text">message</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-5"><span class="sidebar-nav nav-text">portType</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-6"><span class="sidebar-nav nav-text">binding</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-7"><span class="sidebar-nav nav-text">service</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-8"><span class="sidebar-nav nav-text">SOAP</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-9"><span class="sidebar-nav nav-text">Eclipse工具</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-10"><span class="sidebar-nav nav-text">Apache TCPMon工具</span></a></li></ol></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-11"><span class="sidebar-nav nav-text">Jax-ws (wsimport命令)</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-12"><span class="sidebar-nav nav-text">Jax-ws (Server端)</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-13"><span class="sidebar-nav nav-text">代码优先</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-14"><span class="sidebar-nav nav-text">契约优先（推荐）</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-15"><span class="sidebar-nav nav-text">发布服务（Application中）</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-16"><span class="sidebar-nav nav-text">发布服务（Web中）</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-17"><span class="sidebar-nav nav-text">发布独立的JAX-WS端点</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-18"><span class="sidebar-nav nav-text">发布兼容JAX-WS端点的Web</span></a></li></ol></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-19"><span class="sidebar-nav nav-text">Jax-ws (Client端)</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-20"><span class="sidebar-nav nav-text">基于SOAP的通讯方式（直接传递SOAP消息）</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-21"><span class="sidebar-nav nav-text">Message方式（xml）</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-22"><span class="sidebar-nav nav-text">Payload方式（String）</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-23"><span class="sidebar-nav nav-text">扩展：增加消息头</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-24"><span class="sidebar-nav nav-text">基于Jax-ws的通讯方式（封装了SOAP消息）</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-25"><span class="sidebar-nav nav-text">据wsdl中的service创建Service</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-26"><span class="sidebar-nav nav-text">据wsdl中的definitions创建Service</span></a></li></ol></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-27"><span class="sidebar-nav nav-text">Jax-ws (Handler)</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-28"><span class="sidebar-nav nav-text">自定义SOAPHandler</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-29"><span class="sidebar-nav nav-text">配置使用</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-30"><span class="sidebar-nav nav-text">CXF</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-31"><span class="sidebar-nav nav-text">依赖包</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-32"><span class="sidebar-nav nav-text">生成代码</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-33"><span class="sidebar-nav nav-text">使用</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-34"><span class="sidebar-nav nav-text">Server端</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-35"><span class="sidebar-nav nav-text">Client端</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-36"><span class="sidebar-nav nav-text">结合Spring</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-37"><span class="sidebar-nav nav-text">Server端</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-38"><span class="sidebar-nav nav-text">Client端</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-39"><span class="sidebar-nav nav-text">拦截器</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-40"><span class="sidebar-nav nav-text">自定义拦截器</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-41"><span class="sidebar-nav nav-text">添加拦截器</span></a></li></ol></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-42"><span class="sidebar-nav nav-text">扩展应用</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-43"><span class="sidebar-nav nav-text">Upload附件</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-44"><span class="sidebar-nav nav-text">消息头处理</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-45"><span class="sidebar-nav nav-text">显示处理</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-46"><span class="sidebar-nav nav-text">通过SOAPHandler处理</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-47"><span class="sidebar-nav nav-text">通过SoapInterceptor处理</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-48"><span class="sidebar-nav nav-text">Exception异常处理</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-49"><span class="sidebar-nav nav-text">异步调用</span></a></li></ol></li></ol>
    </nav>
  </aside>
  <span id="sidebar-ctrl" class="glyphicon glyphicon-list-alt circle"></span>
  <div id="wrapper">
    <header>
  <nav class="navbar navbar-default">
    <div class="container-fluid">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#nav-menu" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/">SixDegree</a>
      </div>
      <div class="collapse navbar-collapse" id="nav-menu">
        <ul class="nav navbar-nav navbar-right">
          
              <li  >
                <a href="/">Blogs</a>
              </li>
          
              <li  >
                <a href="/tags.html">Tags</a>
              </li>
          
              <li  >
                <a href="/about.html">About</a>
              </li>
          
          
              <li>
                <a href="/atom.xml" target="_blank">
                  <span class="icon-rss"></span>
                </a>
              </li>
          
              <li>
                <a href="http://github.com/sixdegree" target="_blank">
                  <span class="icon-github"></span>
                </a>
              </li>
          
        </ul>
      </div>
    </div>
  </nav>
</header>



    <div class="container">
      <article class="detail" role="main">
  <section class="post-header">
    <h1 class="post-title">Webservice</h1>
    <ul class="post-meta">
      <li>
        <span class="glyphicon glyphicon-calendar"></span>
        <time datetime="2013-08-31T16:00:00.000Z">2013-09-01</time>
      </li>
      
        <li>
         <span class="glyphicon glyphicon-tags"></span>
          
            <a href="/tags.html#tag-Java">Java</a>
          
        </li>
      
    </ul>
  </section>
  <section class="post-content">
    <h2 id="header-1">简介</h2>
<p>WebService 用于异构平台之间的交互</p>
<p>JAVA 中共有三种WebService 规范：</p>
<ul>
<li>JAXM&amp;SAAJ</li>
<li>JAX-WS（JAX-RPC）</li>
<li>JAX-RS</li>
</ul>
<p>有很多框架可以帮助实现：</p>
<ul>
<li><code>JAX-WS</code><ul>
<li>Java API Xml for WebService （JDK 1.6后)</li>
<li>JDK1.6以前，RMI方式，以SOAPMessage encode方式传递消息</li>
</ul>
</li>
<li><code>CXF</code> （60%）<ul>
<li><code>Apache CXF  =  Celtix + Xfire</code> （即Object Web Celtix和Codehaus XFire 合并而成）</li>
<li>是一种可插拨的架构<ul>
<li>既可以支持 XML ，也可以支持非 XML 的类型绑定</li>
<li>比如：JSON 和 CORBA</li>
</ul>
</li>
<li>基于SOAP通讯（REST也可），在<code>Jax-ws</code>基础上扩展<ul>
<li>JAX-WS 和JAX-RS 规范我们采用Apache CXF 作为实现</li>
</ul>
</li>
<li>本身就和Spring整合<ul>
<li>配置bean.xml,web.xml（CXFServlet）</li>
<li>核心是<code>org.apache.cxf.Bus</code>（总线，类似Spring 的ApplicationContext），由BusFactory 创建（默认的BUS ID 为cxf）</li>
</ul>
</li>
<li>可通过Interceptor代替Handler的处理</li>
</ul>
</li>
<li><code>Axis</code> （20%）</li>
<li><code>Metro</code></li>
</ul>
<p>专有名词介绍：</p>
<ul>
<li><code>SEI</code> (Service Endpoint Interface) 服务端提供的接口（公开为Web服务的接口）</li>
<li><code>SIB</code> （Service Implemention Bean） 服务实现类<ul>
<li>注意： 如果还实现了其他的接口，需在<code>@WebService</code> 注解的<code>endpointInterface</code>属性中指定哪个接口是SEI（全类名）</li>
</ul>
</li>
</ul>
<p>JaxB 编排与反编排：</p>
<ul>
<li><code>marshal</code> 编排： <code>object-&gt;stream(xml)</code></li>
<li><code>unmarshal</code> 反编排： <code>stream(xml)-&gt;object</code></li>
</ul>
<p>WebService 有个专门控制安全的协议：<code>WS-Security</code></p>
<p>WebService 通讯方式：</p>
<ul>
<li>基于SOAP的通讯方式</li>
<li>基于jax-ws的通讯方式（已经帮助封装了SOAP消息）</li>
<li>基于CXF的通讯方式</li>
<li>基于REST的通讯方式</li>
</ul>
<h3 id="header-2">WSDL</h3>
<p>以XML的形式描述方法签名：<code>返回值 方法名（传入参数）</code></p>
<pre><code class="lang-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
&lt;wsdl:definitions xmlns:soap=&quot;http://schemas.xmlsoap.org/wsdl/soap/&quot; 
    xmlns:tns=&quot;http://ws.cj.com/student&quot; 
    xmlns:wsdl=&quot;http://schemas.xmlsoap.org/wsdl/&quot; 
    xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; 
    name=&quot;OperationWsService&quot; 
    targetNamespace=&quot;http://ws.cj.com/student&quot;&gt;

    &lt;!-- type：定义访问类型 --&gt;
    &lt;!-- message：定义消息，用来传递信息 --&gt;
    &lt;!-- portType：指明接口名称和接口中的服务 --&gt;
    &lt;!-- binding：绑定接口，指定消息传递和呈现所使用的格式 --&gt;
    &lt;!-- service ：指定服务发布的一些信息 --&gt;

&lt;/wsdl:definitions&gt;
</code></pre>
<h4 id="header-3">type</h4>
<p>定义访问类型 (complexType：复杂type定义，即对“tns”的对象进行定义)</p>
<pre><code class="lang-xml">&lt;wsdl:types&gt;
    &lt;xsd:schema targetNamespace=&quot;http://www.example.org/student/&quot;&gt;
        &lt;xsd:element name=&quot;addUser&quot; type=&quot;tns:addUser&quot;/&gt;
        &lt;xsd:element name=&quot;addUserResponse&quot; type=&quot;tns:addUserResponse&quot;/&gt;
        &lt;xsd:element name=&quot;listUser&quot; type=&quot;tns:listUser&quot;/&gt;
        &lt;xsd:element name=&quot;listUserResponse&quot; type=&quot;tns:listUserResponse&quot;/&gt;
        &lt;xsd:element name=&quot;UserException&quot; type=&quot;tns:UserException&quot;/&gt;
        &lt;xsd:element name=&quot;licenseInfo&quot; type=&quot;tns:licenseInfo&quot;/&gt;

        &lt;!-- 复杂类型定义 --&gt;
        &lt;xsd:complexType name=&quot;user&quot;&gt;
            &lt;xsd:sequence&gt;
                &lt;xsd:element name=&quot;id&quot; type=&quot;xsd:int&quot;/&gt;
                &lt;xsd:element name=&quot;username&quot; type=&quot;xsd:string&quot;/&gt;
                &lt;xsd:element name=&quot;password&quot; type=&quot;xsd:string&quot; /&gt;
            &lt;/xsd:sequence&gt;
        &lt;/xsd:complexType&gt;

        &lt;xsd:complexType name=&quot;addUser&quot;&gt;
            &lt;xsd:sequence&gt;
                &lt;xsd:element name=&quot;user&quot; type=&quot;tns:user&quot;/&gt;
            &lt;/xsd:sequence&gt;
        &lt;/xsd:complexType&gt;
        &lt;xsd:complexType name=&quot;addUserResponse&quot;&gt;
            &lt;xsd:sequence&gt;
                &lt;xsd:element name=&quot;id&quot; type=&quot;xsd:int&quot;/&gt;
            &lt;/xsd:sequence&gt;
        &lt;/xsd:complexType&gt;

        &lt;xsd:complexType name=&quot;listUser&quot;&gt;
            &lt;xsd:sequence/&gt;
        &lt;/xsd:complexType&gt;
        &lt;xsd:complexType name=&quot;listUserResponse&quot;&gt;
            &lt;xsd:sequence minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
                &lt;xsd:element name=&quot;user&quot; type=&quot;tns:user&quot;/&gt;
            &lt;/xsd:sequence&gt;
        &lt;/xsd:complexType&gt;

        &lt;xsd:complexType name=&quot;UserException&quot;&gt;
            &lt;xsd:sequence&gt;
                &lt;xsd:element name=&quot;message&quot; type=&quot;xsd:string&quot;/&gt;
            &lt;/xsd:sequence&gt;
        &lt;/xsd:complexType&gt;

        &lt;xsd:complexType name=&quot;licenseInfo&quot;&gt;
            &lt;xsd:sequence&gt;
                &lt;xsd:element name=&quot;registerUser&quot; type=&quot;tns:user&quot;/&gt;
            &lt;/xsd:sequence&gt;
        &lt;/xsd:complexType&gt;

    &lt;/xsd:schema&gt;
&lt;/wsdl:types&gt;
</code></pre>
<p>可定义在外部文件xsd中然后再wsdl中引用</p>
<pre><code class="lang-xml">&lt;wsdl:types&gt;
    &lt;!-- 引入xsd,没有搭建web服务器时使用wsimport会找不到xsd文件 --&gt;
    &lt;!--方法一
    &lt;xsd:schema&gt;
        &lt;xsd:import namespace=&quot;http://ws.cj.com/student/&quot; schemaLocation=&quot;student.xsd&quot;/&gt;
    &lt;/xsd:schema&gt;--&gt;

    &lt;!-- 方法二 --&gt;
    &lt;xsd:schema targetNamespace=&quot;http://ws.cj.com/student/&quot;&gt;
        &lt;xsd:include schemaLocation=&quot;operation.xsd&quot;/&gt;
    &lt;/xsd:schema&gt;
&lt;/wsdl:types&gt;
</code></pre>
<p>xsd文件:</p>
<pre><code class="lang-xml">&lt;xsd:schema xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
    targetNamespace=&quot;http://ws.cj.com/student&quot;
    xmlns:tns=&quot;http://ws.cj.com/student&quot;
    elementFormDefault=&quot;unqualified&quot;&gt; &lt;!-- 默认为 qualified --&gt;
    ...
&lt;/xsd:schema&gt;
</code></pre>
<h4 id="header-4">message</h4>
<p>定义消息，用来传递信息 （SOPA协议通过Soap Message来传递）</p>
<p>公布了多少服务就有2倍于服务的消息 ：</p>
<ul>
<li>request(in)</li>
<li>response(out)</li>
</ul>
<pre><code class="lang-xml">&lt;wsdl:message name=&quot;addUser&quot;&gt;
    &lt;wsdl:part element=&quot;tns:addUser&quot; name=&quot;addUser&quot;/&gt;
&lt;/wsdl:message&gt;
&lt;wsdl:message name=&quot;addUserResponse&quot;&gt;
    &lt;wsdl:part element=&quot;tns:addUserResponse&quot; name=&quot;addUserResponse&quot;/&gt;
&lt;/wsdl:message&gt;
&lt;wsdl:message name=&quot;listUser&quot;&gt;
    &lt;wsdl:part element=&quot;tns:listUser&quot; name=&quot;listUser&quot;/&gt;
&lt;/wsdl:message&gt;
&lt;wsdl:message name=&quot;listUserResponse&quot;&gt;
    &lt;wsdl:part element=&quot;tns:listUserResponse&quot; name=&quot;listUserResponse&quot;/&gt;
&lt;/wsdl:message&gt;
&lt;!-- Exception message --&gt;
&lt;wsdl:message name=&quot;UserException&quot;&gt;
    &lt;wsdl:part element=&quot;tns:UserException&quot; name=&quot;UserException&quot;/&gt;
&lt;/wsdl:message&gt;
&lt;!-- Header message --&gt;
&lt;wsdl:message name=&quot;licenseInfo&quot;&gt;
    &lt;wsdl:part element=&quot;tns:licenseInfo&quot; name=&quot;licenseInfo&quot;/&gt;
&lt;/wsdl:message&gt;
</code></pre>
<h4 id="header-5">portType</h4>
<p>portType：指明接口名称和接口中的服务</p>
<p>通过operation指定接口中的方法（服务），绑定相应的in和out的消息<br>（其中input表示参数，output表示返回值）</p>
<pre><code class="lang-xml">&lt;wsdl:portType name=&quot;IUserWsService&quot;&gt;
    &lt;wsdl:operation name=&quot;addUser&quot;&gt;
          &lt;wsdl:input message=&quot;tns:addUser&quot;/&gt;
          &lt;wsdl:output message=&quot;tns:addUserResponse&quot;/&gt;
          &lt;!-- Exception fault--&gt;
          &lt;wsdl:fault name=&quot;UserException&quot; message=&quot;tns:UserException&quot;/&gt;
    &lt;/wsdl:operation&gt;
    &lt;wsdl:operation name=&quot;listUser&quot;&gt;
          &lt;wsdl:input message=&quot;tns:listUser&quot;/&gt;
          &lt;wsdl:output message=&quot;tns:listUserResponse&quot;/&gt;
    &lt;/wsdl:operation&gt;
&lt;/wsdl:portType&gt;
</code></pre>
<h4 id="header-6">binding</h4>
<p>绑定接口，指定消息传递和呈现所使用的格式</p>
<p>两种风格：</p>
<ul>
<li>document</li>
<li>rpc</li>
</ul>
<p>两种传递方式：</p>
<ul>
<li>encode(早期，jdk6以前)</li>
<li>literal(jdk1.6以后)</li>
</ul>
<pre><code class="lang-xml">&lt;wsdl:binding name=&quot;UserWsServiceSOAP&quot; type=&quot;tns:IUserWsService&quot;&gt;
    &lt;soap:binding style=&quot;document&quot; transport=&quot;http://schemas.xmlsoap.org/soap/http&quot;/&gt;
    &lt;wsdl:operation name=&quot;addUser&quot;&gt;
        &lt;wsdl:input&gt;
            &lt;soap:body use=&quot;literal&quot;/&gt;
            &lt;!-- Header --&gt;
            &lt;soap:header use=&quot;literal&quot; part=&quot;licenseInfo&quot; message=&quot;tns:licenseInfo&quot;/&gt;
        &lt;/wsdl:input&gt;
        &lt;wsdl:output&gt;
            &lt;soap:body use=&quot;literal&quot;/&gt;
        &lt;/wsdl:output&gt;
        &lt;wsdl:fault name=&quot;UserException&quot;&gt;
            &lt;soap:fault name=&quot;UserException&quot; use=&quot;literal&quot;/&gt;
        &lt;/wsdl:fault&gt;
    &lt;/wsdl:operation&gt;

    &lt;wsdl:operation name=&quot;listUser&quot;&gt;
        &lt;wsdl:input&gt;
            &lt;soap:body use=&quot;literal&quot;/&gt;
        &lt;/wsdl:input&gt;
        &lt;wsdl:output&gt;
            &lt;soap:body use=&quot;literal&quot;/&gt;
        &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
&lt;/wsdl:binding&gt;
</code></pre>
<h4 id="header-7">service</h4>
<p>指定服务发布的一些信息</p>
<pre><code class="lang-xml">&lt;wsdl:service name=&quot;UserWsService&quot;&gt;
    &lt;wsdl:port binding=&quot;tns:UserWsServiceSOAP&quot; name=&quot;UserWsServicePort&quot;&gt;
      &lt;soap:address location=&quot;http://localhost:9090/us&quot;/&gt;
    &lt;/wsdl:port&gt;
&lt;/wsdl:service&gt;
</code></pre>
<h3 id="header-8">SOAP</h3>
<p>SOAP （Simple Object Access Protocal）简单对象访问协议<br>通过xml存储对象，通过element元素组装信息，通过Soap Message传递信息</p>
<p>通过SOAP协议进行消息传递</p>
<p><img src="/2013/09/01/soap.png" alt="SOAP"></p>
<h4 id="header-9">Eclipse工具</h4>
<p>通过Eclipse中J2EE视图下的“Launch the Web Services Explore“功能调用webservice</p>
<p>例如：</p>
<p>输入wsdl地址：<code>http://localhost:8888/ns?wsdl</code>，查看Status下的Source，得到如下：</p>
<ol>
<li><p>SOAP Request Envelope: </p>
<pre><code class="lang-xml">&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;     xmlns:q0=&quot;http://first.ws.my.cj.com/&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;
 &lt;soapenv:Body&gt;
     &lt;q0:minus&gt;
           &lt;a&gt;50&lt;/a&gt;
           &lt;b&gt;30&lt;/b&gt;
       &lt;/q0:minus&gt;
 &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;
</code></pre>
</li>
<li><p>SOAP Response Envelope:</p>
<pre><code class="lang-xml">&lt;S:Envelope xmlns:S=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:SOAP-    ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;
 &lt;S:Body&gt;
     &lt;ns2:minusResponse xmlns:ns2=&quot;http://first.ws.my.cj.com/&quot;&gt;
           &lt;minusResult&gt;20&lt;/minusResult&gt;
       &lt;/ns2:minusResponse&gt;
   &lt;/S:Body&gt;
&lt;/S:Envelope&gt;
</code></pre>
</li>
</ol>
<h4 id="header-10">Apache TCPMon工具</h4>
<ul>
<li><a href="http://ws.apache.org/commons/tcpmon/download.cgi" target="_blank" rel="noopener">下载地址</a></li>
<li>运行：解压后进去<code>build</code>目录，双击<code>tcpmon.bat</code>就可以执行</li>
<li>实际上是个代理，起一个消息转发的作用，监视的是转发出去的消息</li>
<li>这样就可以截获转发在WebService服务器和客户机之间会传递的SOAP消息，帮助查看调试</li>
<li>最终消息还是要送到具体的地址和端口，它的前后都应该配置正确才行，否则响应就不正确了</li>
</ul>
<p><img src="/2013/09/01/tcpmon-proc.png" alt="TCPMon Process"></p>
<p>使用举例：</p>
<ol>
<li><p>配置（监听发布在<a href="http://localhost:9876上的webservice）" target="_blank" rel="noopener">http://localhost:9876上的webservice）</a><br><img src="/2013/09/01/tcpmon-config.png" alt="TCPMon Config"></p>
</li>
<li><p>运行结果：<br><img src="/2013/09/01/tcpmon-result.png" alt="TCPMon Result"></p>
</li>
</ol>
<h2 id="header-11">Jax-ws (wsimport命令)</h2>
<p>根据wsdl文件生成Java平台的webservice接口（JDK1.6及以后，都包含此命令）</p>
<ul>
<li><code>wsimport -d d:/webservice/01/ -keep -verbose http://localhost:8888/ns?wsdl</code></li>
<li><code>wsimport -d d:/webservice/01/ -p test –verbose http://localhost:8888/ns?wsdl</code></li>
<li>参数说明：<ul>
<li>-d 指定生成目录</li>
<li>-p 指定生成的包 eg: -p com.cj.sms.first.client</li>
<li>-keep 指定是否生成.java的源文件</li>
<li>-verbose 显示生成的详细信息</li>
<li>最后指定wsdl文件位置：可以是网络中的，也可以是本地文件</li>
</ul>
</li>
</ul>
<p><img src="/2013/09/01/wsimport.png" alt="wsimport"></p>
<h2 id="header-12">Jax-ws (Server端)</h2>
<ul>
<li>代码优先：先编写接口，由接口生成wsdl</li>
<li>契约优先：先编写wsdl，由wsdl生成接口</li>
</ul>
<p>（wsdl即契约）</p>
<p><strong>PS: </strong><br>使用代码优先会破坏方法原有的结构，而使用契约优先可以定制wsdl，将一些验证信息置于SOAPHeader中，然后通过Handler预处理或者修改接口类显示声明来获取处理</p>
<h3 id="header-13">代码优先</h3>
<ol>
<li><p>编写WebService接口（加Annotation）</p>
<ul>
<li>@WebService</li>
<li>@WebMethod</li>
<li>@WebResult</li>
<li>@WebParam</li>
</ul>
</li>
<li><p>编写WebService实现类（加Annotation ）</p>
<pre><code> @WebService(endpointInterface=&quot;指定webservice接口-包名加类名&quot;,targetNamespace=&quot;&quot;)
</code></pre></li>
<li><p>发布服务（会自动生成wsdl）</p>
</li>
</ol>
<h3 id="header-14">契约优先（推荐）</h3>
<p>发布的服务是根据编写的wsdl文件生成的，wsdl文件变化，服务即变化</p>
<ol>
<li>编写wsdl文件<ul>
<li>在类路径下创建 META-INF/wsdl下</li>
<li>在tomcat中发布服务需置于WEB-INF/wsdl/下</li>
</ul>
</li>
<li>根据wsdl生成WebService接口类<ul>
<li>使用<code>wsimport</code>命令根据wsdl文件生成</li>
<li>生成的Interface接口类将作为Server端的WebService接口，如<pre><code class="lang-java">@WebService(name = &quot;IUserWsService&quot;, targetNamespace = &quot;http://www.my.org/user&quot;)
public interface IUserWsService {...}
</code></pre>
</li>
</ul>
</li>
<li>实现WebService接口（指定 wsdlLocation）<pre><code class="lang-java"> @WebService(endpointInterface=&quot;com.cj.my.ws.thrid.IUserWsService&quot;
     ,targetNamespace=&quot;http://www.my.org/user&quot;
     //,wsdlLocation=&quot;/WEB-INF/wsdl/user.wsdl&quot;  //在tomcat中发布服务
     ,wsdlLocation=&quot;META-INF/wsdl/user.wsdl&quot;
     ,serviceName=&quot;UserWsService&quot;
     ,portName=&quot;UserWsServicePort&quot;)
 public class UserWsService implements IUserWsService
</code></pre>
</li>
<li>发布服务</li>
</ol>
<h3 id="header-15">发布服务（Application中）</h3>
<ul>
<li>默认命名空间targetNamespace为倒置包名（eg: <a href="http://first.sms.cj.com）" target="_blank" rel="noopener">http://first.sms.cj.com）</a></li>
<li>可以重新制定命名空间</li>
<li>注意：需要在实现类中也重新指定命名空间（<code>@WebService(targetNamespace=&quot;http://www.cj.test/&quot;)</code>）</li>
</ul>
<pre><code class="lang-java">public class ServerApp{
    public static void main(String[] args){
        //wsdl文件发布地址
        String address=&quot;http://localhost:8888/ns&quot;;
        Endpoint.publish(address, new OperationWsServiceImpl()); //IOperationWsService实现类
    }
}
</code></pre>
<h3 id="header-16">发布服务（Web中）</h3>
<ol>
<li>将wsdl文件置于WEB-INF下</li>
<li>修改服务实现类注解中的wsdlLocation属性（eg：<code>wsdlLocation=&quot;/WEB-INF/wsdl/user.wsdl&quot;</code>）</li>
<li>编写<code>sun-jaxws.xml</code>置于WEB-INF下<pre><code class="lang-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;endpoints xmlns=&quot;http://java.sun.com/xml/ns/jax-ws/ri/runtime&quot; version=&quot;2.0&quot;&gt;
&lt;endpoint name=&quot;UserWsService&quot; 
    implementation=&quot;com.cj.my.ws.thrid.UserWsService&quot; url-pattern=&quot;/us&quot;/&gt;
&lt;/endpoints&gt;
</code></pre>
</li>
<li>发布服务</li>
</ol>
<h4 id="header-17">发布独立的JAX-WS端点</h4>
<p>通过Spring独立发布</p>
<p>加入依赖包：</p>
<pre><code class="lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.sun.xml.ws&lt;/groupId&gt;
    &lt;artifactId&gt;jaxws-rt&lt;/artifactId&gt;
    &lt;version&gt;2.2.9-b14002&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol>
<li><p>web.xml中添加（在配置Spring基础上）：</p>
<pre><code class="lang-xml"> &lt;!--发布WebService到Web容器中（需配置在SpringListener之前） --&gt;
 &lt;listener&gt;
     &lt;listener-class&gt;
         com.sun.xml.ws.transport.http.servlet.WSServletContextListener
     &lt;/listener-class&gt;
 &lt;/listener&gt;

 &lt;servlet&gt;
     &lt;!--和sun-jaxws.xml中的name一致 --&gt;
     &lt;servlet-name&gt;UserWsService&lt;/servlet-name&gt;
     &lt;servlet-class&gt;com.sun.xml.ws.transport.http.servlet.WSServlet&lt;/servlet-class&gt;
 &lt;/servlet&gt;
 &lt;servlet-mapping&gt;
     &lt;servlet-name&gt;UserWsService&lt;/servlet-name&gt; 
     &lt;url-pattern&gt;/us&lt;/url-pattern&gt;
 &lt;/servlet-mapping&gt;
</code></pre>
</li>
<li><p>beans.xml</p>
<pre><code class="lang-xml"> &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
         xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
         xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
         xsi:schemaLocation=&quot;...&quot;&gt;
     &lt;context:annotation-config/&gt;
     &lt;context:component-scan base-package=&quot;com.cj.my.ws&quot; /&gt;
     &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;

     &lt;bean class=&quot;org.springframework.remoting.jaxws.SimpleJaxWsServiceExporter&quot;&gt;
         &lt;property name=&quot;baseAddress&quot; value=&quot;http://localhost:8080/ss/&quot;&gt;&lt;/property&gt;
     &lt;/bean&gt;
 &lt;/beans&gt;
</code></pre>
</li>
</ol>
<h4 id="header-18">发布兼容JAX-WS端点的Web</h4>
<p>通过jax-spring整合</p>
<p>加入依赖包：</p>
<pre><code class="lang-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.jvnet.jax-ws-commons.spring&lt;/groupId&gt;
  &lt;artifactId&gt;jaxws-spring&lt;/artifactId&gt;
  &lt;version&gt;1.9&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol>
<li><p>web.xml中添加（在配置Spring基础上）：</p>
<pre><code class="lang-xml"> &lt;!-- 使用WSSpringServlet来管理--&gt;
 &lt;servlet&gt;
     &lt;servlet-name&gt;UserWsService&lt;/servlet-name&gt;
     &lt;servlet-class&gt;com.sun.xml.ws.transport.http.servlet.WSSpringServlet&lt;/servlet-class&gt;
 &lt;/servlet&gt;
 &lt;servlet-mapping&gt;
     &lt;servlet-name&gt;UserWsService&lt;/servlet-name&gt;
     &lt;url-pattern&gt;/us&lt;/url-pattern&gt;
 &lt;/servlet-mapping&gt;
</code></pre>
</li>
<li><p>beans.xml</p>
<pre><code class="lang-xml"> &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
         xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
         xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
         xmlns:ws=&quot;http://jax-ws.dev.java.net/spring/core&quot;
         xmlns:wss=&quot;http://jax-ws.dev.java.net/spring/servlet&quot;
         xsi:schemaLocation=&quot;...
     http://jax-ws.dev.java.net/spring/core http://jax-ws.dev.java.net/spring/core.xsd
     http://jax-ws.dev.java.net/spring/servlet http://jax-ws.dev.java.net/spring/servlet.xsd&quot;&gt;

     &lt;context:annotation-config/&gt;
     &lt;context:component-scan base-package=&quot;com.cj.my.ws&quot; /&gt;    
     &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;

     &lt;!-- 让userWsService被Spring管理 --&gt;
     &lt;wss:binding url=&quot;/us&quot;&gt;
         &lt;wss:service&gt;
             &lt;ws:service bean=&quot;#userWsService&quot;&gt; &lt;!-- 指明webservice的注入对象，注意需加个# --&gt;
                 &lt;!-- 将wsdl的外部xsd文件加入 --&gt;
                 &lt;ws:metadata&gt;
                     &lt;value&gt;/WEB-INF/wsdl/user.xsd&lt;/value&gt;
                 &lt;/ws:metadata&gt;
             &lt;/ws:service&gt;
         &lt;/wss:service&gt;
     &lt;/wss:binding&gt;

     &lt;!-- 建议在配置文件中手动注入，若使用Annotation：@Service(&quot;userWsService&quot;)可能会找不到--&gt;
     &lt;bean id=&quot;userWsService&quot; class=&quot;com.cj.my.ws.thrid.UserWsService&quot; /&gt; 
 &lt;/beans&gt;
</code></pre>
</li>
</ol>
<h2 id="header-19">Jax-ws (Client端)</h2>
<h3 id="header-20">基于SOAP的通讯方式（直接传递SOAP消息）</h3>
<ul>
<li>Message方式：格式化为xml进行消息传递<pre><code class="lang-java">  Dispatch&lt;SOAPMessage&gt; dispatch=service.createDispatch(
      new QName(this.ns,&quot;MyServiceImplPort&quot;),
      SOAPMessage.class,
      Service.Mode.MESSAGE);
  SOAPMessage message=MessageFactory.newInstance().createMessage();
  ...
  SOAPMessage response=dispatch.invoke(message);
  ...
</code></pre>
</li>
<li>Payload方式：格式化为String(将对象编排与反编排)进行消息传递<pre><code class="lang-java">  Dispatch&lt;Source&gt; dispatch=service.createDispatch(
      new QName(this.ns,&quot;MyServiceImplPort&quot;),
      Source.class,
      Service.Mode.PAYLOAD);
  ...
  StreamSource rs=new StreamSource(new StringReader(payload));
  Source response=dispatch.invoke(rs);
  ...
</code></pre>
</li>
</ul>
<p><strong>PS：</strong>通过Dispatch发送</p>
<h4 id="header-21">Message方式（xml）</h4>
<p>格式化为xml进行处理</p>
<pre><code class="lang-java">// ClientTest:
@Test
public void test02(){
    try{
        //1.创建服务Service
        URL url = new URL(this.wsdl);
        QName qname = new QName(this.ns,&quot;MyServiceImplService&quot;);
        Service service=Service.create(url, qname);

        //2.创建Dispatch(基于Message方式：格式化为xml进行处理)
        QName pname=new QName(this.ns,&quot;MyServiceImplPort&quot;);
        //createDispatch(portName,classType,mode)
        Dispatch&lt;SOAPMessage&gt; dispatch=service.createDispatch(pname,
            SOAPMessage.class,Service.Mode.MESSAGE);

        //3.创建SOAPMessage
        SOAPMessage message=MessageFactory.newInstance().createMessage();
        SOAPEnvelope envelope=message.getSOAPPart().getEnvelope();
        SOAPBody body=envelope.getBody();

        //4.创建QName即节点以指定消息中传递的数据
        QName ename=new QName(this.ns,&quot;minus&quot;,&quot;ns&quot;);
        SOAPBodyElement bodyElement=body.addBodyElement(ename);
        bodyElement.addChildElement(&quot;a&quot;).setValue(&quot;50&quot;);
        bodyElement.addChildElement(&quot;b&quot;).setValue(&quot;30&quot;);
        message.writeTo(System.out);
        System.out.println();

        //5.通过Dispatch传递消息，会返回响应消息
        SOAPMessage response=dispatch.invoke(message);
        response.writeTo(System.out);
        System.out.println();

        //将响应的消息转换为dom对象（可通过Xpath等多种方式完成对响应数据的处理）
        SOAPBody responseBody=response.getSOAPPart().getEnvelope().getBody();
        Document doc=responseBody.extractContentAsDocument();
        String str=doc.getElementsByTagName(&quot;minusResult&quot;).item(0).getTextContent();
        System.out.println(str);

    }catch (Exception e){
        System.out.println(e.getMessage());
    }
}
</code></pre>
<p>发送的消息如下：</p>
<pre><code class="lang-xml">&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;
    &lt;SOAP-ENV:Header/&gt;
    &lt;SOAP-ENV:Body&gt;
        &lt;ns:minus xmlns:ns=&quot;http://first.ws.my.cj.com/&quot;&gt;
            &lt;a&gt;50&lt;/a&gt;
            &lt;b&gt;30&lt;/b&gt;
        &lt;/ns:minus&gt;
    &lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;
</code></pre>
<p>得到响应消息如下：</p>
<pre><code class="lang-xml">&lt;S:Envelope xmlns:S=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;
    &lt;S:Header/&gt;
    &lt;S:Body&gt;
        &lt;ns2:minusResponse xmlns:ns2=&quot;http://first.ws.my.cj.com/&quot;&gt;
            &lt;minusResult&gt;20&lt;/minusResult&gt;
        &lt;/ns2:minusResponse&gt;
    &lt;/S:Body&gt;
&lt;/S:Envelope&gt;
</code></pre>
<h4 id="header-22">Payload方式（String）</h4>
<p>通过字符串(将对象编排与反编排)进行消息的传递，会自动对字符串进行编码</p>
<p>发送（payload）：</p>
<pre><code class="lang-xml">&lt;ns:addStudent xmlns:ns=&quot;http://first.ws.my.cj.com/&quot;&gt;
    &lt;ns2:student xmlns:ns2=&quot;http://first.ws.my.cj.com/&quot;&gt;
        &lt;age&gt;18&lt;/age&gt;
        &lt;id&gt;0&lt;/id&gt;
        &lt;name&gt;Lucy&lt;/name&gt;
        &lt;sex&gt;Female&lt;/sex&gt;
    &lt;/ns2:student&gt;
&lt;/ns:addStudent&gt;
</code></pre>
<pre><code class="lang-java">// ClientTest:
@Test
public void test03(){
    try{
        //1.创建服务Service
        URL url = new URL(this.wsdl);
        QName qname = new QName(this.ns,&quot;MyServiceImplService&quot;);
        Service service=Service.create(url, qname);

        //2.创建Dispatch(基于Payload,通过源数据Source的方式传递)
        QName dname=new QName(this.ns,&quot;MyServiceImplPort&quot;);
        Dispatch&lt;Source&gt; dispatch=service.createDispatch(dname,
        Source.class,Service.Mode.PAYLOAD);

        //3. 创建对象
        Student student=new Student();
        student.setId(5);
        student.setName(&quot;Lucy&quot;);
        student.setAge(18);
        student.setSex(Gender.FEMALE);

        //4. 使用Marshaller编排对象：根据对象组建xml字符串
        JAXBContext ctx=JAXBContext.newInstance(AddStudent.class);
        AddStudent addStudent=new AddStudent();
        addStudent.setStudent(student);
        QName sname=new QName(this.ns,&quot;addStudent&quot;);
        JAXBElement&lt;AddStudent&gt; element=new JAXBElement&lt;AddStudent&gt;(sname,AddStudent.class,addStudent);

        Marshaller mar=ctx.createMarshaller();
        //fragement 默认为false，会创建头信息：&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
        mar.setProperty(Marshaller.JAXB_FRAGMENT,true);
        StringWriter writer= new StringWriter();
        mar.marshal(element, writer);

        String payload=writer.toString();
        System.out.println(&quot;payload:&quot;+payload);

        //6.通过Dispatch传递payload
        StreamSource rs=new StreamSource(new StringReader(payload));
        Source response=dispatch.invoke(rs);

        //7.处理响应信息
        System.out.println(response instanceof StAXSource);

        //使用Transformer对象将Source转换为dom对象
        Transformer trans=TransformerFactory.newInstance().newTransformer();
        DOMResult result=new DOMResult();
        trans.transform(response, result);

        //通过XPath处理相应信息
        XPath xpath=XPathFactory.newInstance().newXPath();
        NodeList nodeList=(NodeList)xpath.evaluate(&quot;//student&quot;,
            result.getNode(),XPathConstants.NODESET);

        //使用Unmarshaller反编排：将xml节点转换回对象
        //Student stu=(Student)ctx.createUnmarshaller().unmarshal(nodeList.item(0));
        JAXBElement&lt;Student&gt; resultElement=ctx.createUnmarshaller()
                            .unmarshal(nodeList.item(0), Student.class);
        Student stu=resultElement.getValue();
        System.out.println(stu.getId()+&quot;|&quot;+stu.getName()+&quot;|&quot;+stu.getAge()+&quot;|&quot;+stu.getSex());
    }catch (Exception e){
        System.out.println(&quot;Exception:&quot;+e.getMessage());
        e.printStackTrace();
    }
}
</code></pre>
<h4 id="header-23">扩展：增加消息头</h4>
<pre><code class="lang-java">//创建SOAPHeader
SOAPHeader header=envelope.getHeader();
if(header==null)
    header=envelope.addHeader();
QName hName=new QName(this.ns,&quot;authInfo&quot;,&quot;ns&quot;);
header.addHeaderElement(hName).setValue(&quot;auth:tom&quot;);
</code></pre>
<p>创建的消息（Result）如下：</p>
<pre><code class="lang-xml">&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;
    &lt;SOAP-ENV:Header&gt;
        &lt;ns:authInfo xmlns:ns=&quot;http://first.ws.my.cj.com/&quot;&gt;auth:tom&lt;/ns:authInfo&gt;
    &lt;/SOAP-ENV:Header&gt;
    &lt;SOAP-ENV:Body&gt;
        &lt;ns:list xmlns:ns=&quot;http://first.ws.my.cj.com/&quot;/&gt;
    &lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;
</code></pre>
<h3 id="header-24">基于Jax-ws的通讯方式（封装了SOAP消息）</h3>
<ol>
<li>使用wsimport命令根据wsdl（不依赖于平台）生成客户端代码</li>
<li>将生成的java类导入到client端项目中<ul>
<li>注意：这里生成的interface是Client根据wsdl生成的，与Server端的不是同一个</li>
</ul>
</li>
<li>创建Service，调用发布的方法</li>
</ol>
<h4 id="header-25">据wsdl中的service创建Service</h4>
<p>wsdl文件中：</p>
<pre><code class="lang-xml">&lt;wsdl:service name=&quot;OperationWsService&quot;&gt;
    &lt;wsdl:port name=&quot;OperationWsServicePort&quot; binding=&quot;tns:OperationWsServiceSOAP&quot; &gt;
        &lt;soap:address location=&quot;http://localhost:8888/ns&quot;/&gt;
    &lt;/wsdl:port&gt;
&lt;/wsdl:service&gt;
</code></pre>
<pre><code class="lang-java">public static void main(String[] args){
    OperationWsService service=new OperationWsService ();
    IOperationWsService operationWsService=service.getOperationWsServicePort();
    //调用实现方法
    System.out.println(operationWsService.plus(34, 56));
}
</code></pre>
<h4 id="header-26">据wsdl中的definitions创建Service</h4>
<pre><code class="lang-xml">&lt;wsdl:definitions xmlns:soap=&quot;http://schemas.xmlsoap.org/wsdl/soap/&quot; 
        xmlns:tns=&quot;http://ws.cj.com/student&quot; 
        xmlns:wsdl=&quot;http://schemas.xmlsoap.org/wsdl/&quot; 
        xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; 
        name=&quot;OperationWsService&quot; 
        targetNamespace=&quot;http://ws.cj.com/student&quot;&gt;
</code></pre>
<pre><code class="lang-java">public static void main(String[] args) throws MalformedURLException{
    URL url=new URL(&quot;http://localhost:8888/ns?wsdl&quot;); 
    //命名Qname(命名空间,服务名称)
    QName qname=new QName(&quot;http://ws.cj.com/student&quot;,&quot;OperationWsService&quot;);
    //相当于创建了&lt;OperationWsService xmln=”http://ws.cj.com/student”&gt;节点

    OperationWsService service=new OperationWsService(url, qname);
    IOperationWsService operationWsService=service.getPort(IOperationWsService.class);

    //调用实现方法
    System.out.println(operationWsService.plus(34, 56));
}
</code></pre>
<h2 id="header-27">Jax-ws (Handler)</h2>
<p>Handler处理SOAP消息 (类似过滤器)：</p>
<ul>
<li>逻辑处理器<code>LogicalHandler</code>：只能获取<code>SOAPBody</code>的信息</li>
<li>消息处理器<code>SOAPHandler</code>：可以获取<code>SOAPMessage</code>的信息</li>
<li>Out处理顺序：先逻辑处理器再消息处理器</li>
</ul>
<p><img src="/2013/09/01/handler1.png" alt="Handler"><br><img src="/2013/09/01/handler2.png" alt="Handler"></p>
<h3 id="header-28">自定义SOAPHandler</h3>
<p><code>implements SOAPHandler&lt;SOAPMessageContext&gt;</code></p>
<ul>
<li><p><code>@Override handleMessage</code>方法</p>
<ul>
<li>可处理 <code>in</code> 和 <code>out</code> 消息 （out消息必须 return true，否则Exception）</li>
<li><code>return true</code>：<ul>
<li>交由下一个Handler处理</li>
<li><code>in</code>消息最终到达Server端WebService实现类处理；</li>
<li><code>out</code>消息最终将响应消息发送到Client端。</li>
</ul>
</li>
<li><code>return false</code>:<ul>
<li><code>in</code>消息被阻断，交由handleFault方法处理；</li>
<li><code>out</code>消息引发Exception</li>
</ul>
</li>
</ul>
</li>
<li><p><code>@Override handleFault</code>方法：</p>
<ul>
<li>可捕获处理<code>SOAPException</code> (对WebService而言，相当于Exception)</li>
<li>无法捕获处理<code>SOAPFaultException</code>（对WebService而言，相当于RuntimeException，必须在Client端调用处捕获）</li>
<li><code>return true</code>:交由下一个Handler处理； </li>
<li><code>return false</code>:阻断</li>
</ul>
</li>
</ul>
<p>示例：</p>
<pre><code class="lang-java">public class XxxHandler implements SOAPHandler&lt;SOAPMessageContext&gt;
    @Override
    public boolean handleMessage(SOAPMessageContext context){
        Boolean out=(Boolean)context.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
        if(out)
            System.out.println(&quot;XxxHandler out&quot;);
        else
            System.out.println(&quot;XxxHandler in&quot;);
        return true;
    }

    @Override
    public boolean handleFault(SOAPMessageContext context){
        System.out.println(&quot;XxxHandle Fault&quot;);
        try{
            SOAPMessage message =context.getMessage();
            SOAPEnvelope envelope=message.getSOAPPart().getEnvelope();
            SOAPFault fault=envelope.getBody().getFault();
            if(fault!=null)
                System.out.println(&quot;Handle1 Fault:&quot;+fault.getFaultString());
        } catch (SOAPException e){
            e.printStackTrace();
        } catch (IOException e){
            e.printStackTrace();
        }catch(SOAPFaultException e)//不会触发此异常！
        {
            System.out.println(&quot;Handler1 Fault catch SOAPFaultException&quot;);
        }
        return true;
    }

    @Override
    public void close(MessageContext context)
    {}

    @Override
    public Set&lt;QName&gt; getHeaders(){
        return null;
    }
}
</code></pre>
<h3 id="header-29">配置使用</h3>
<ul>
<li>配置Handler过滤链文件 (eg: <code>handler-chain.xml</code>， 置于classpath下)<pre><code class="lang-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;javaee:handler-chains 
   xmlns:javaee=&quot;http://java.sun.com/xml/ns/javaee&quot; 
   xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
&lt;javaee:handler-chain&gt;
  &lt;javaee:handler&gt;
    &lt;javaee:handler-class&gt;com.cj.my.ws.handler.LicenseHandler&lt;/javaee:handler-class&gt;
  &lt;/javaee:handler&gt;
&lt;/javaee:handler-chain&gt;
&lt;/javaee:handler-chains&gt;
</code></pre>
</li>
<li>在WebService实现类上添加@HandlerChain注解（eg：<code>@HandlerChain(file=&quot;handler-chain.xml&quot;)</code></li>
</ul>
<p><strong>PS：</strong><br>在下面介绍的CXF中，可通过其他方式加载使用Handler，还可以使用Inteceptor代替Handler</p>
<h2 id="header-30">CXF</h2>
<p>基于CXF的通讯方式 （<a href="http://cxf.apache.org/" target="_blank" rel="noopener">Apache CXF官网</a>）</p>
<ul>
<li>基于jax-ws，开发方式和jax-ws基本类似，仅仅是为jax-ws增加了一些功能</li>
<li>可以使用Interceptor替代SOAPHandler</li>
<li>生命周期（阶段）：<br><img src="/2013/09/01/cxfLifeCycle.png" alt="LifeCycle"></li>
<li>有多种Interceptor拦截器，用的比较多的是：<ul>
<li>extends AbstractPhaseInterceptor<message></message></li>
<li>extends AbstractSoapInterceptor</li>
</ul>
</li>
</ul>
<h3 id="header-31">依赖包</h3>
<pre><code class="lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;
    &lt;artifactId&gt;cxf-rt-frontend-jaxws&lt;/artifactId&gt;
    &lt;version&gt;${cxf.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;
    &lt;artifactId&gt;cxf-rt-transports-http&lt;/artifactId&gt;
    &lt;version&gt;${cxf.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- 使用jetty容器时才需要此包--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;
    &lt;artifactId&gt;cxf-rt-transports-http-jetty&lt;/artifactId&gt;
    &lt;version&gt;${cxf.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="header-32">生成代码</h3>
<p>示例：使用契约优先的方式</p>
<ol>
<li>编写wsdl</li>
<li>使用wsimport命令生成sourcecode</li>
<li>Server端<ul>
<li>拷贝wsimport命令生成的interface（eg: IUserWsService）到Server端（去除@XmlSeeAlso注解）</li>
<li>wsdl放置到WEB-INF(web项目)或META-INF(local项目)下</li>
<li>编写服务实现类（eg:<code>public class UserWsService implements IUserWsService</code>）</li>
<li>发布服务</li>
</ul>
</li>
<li>Client端<ul>
<li>拷贝wsimport命令生成的所有代码到Client端</li>
<li>调用服务</li>
</ul>
</li>
</ol>
<h3 id="header-33">使用</h3>
<h4 id="header-34">Server端</h4>
<p>方式一：使用JaxWs API 发布服务</p>
<pre><code class="lang-java">Endpoint.publish(&quot;http://localhost:9090/my/us&quot;, new UserWsService());
</code></pre>
<p>方式二：使用服务发布工厂<code>JaxWsServerFactoryBean</code>发布服务（默认使用“代码优先”）</p>
<pre><code class="lang-java">JaxWsServerFactoryBean serverFactory=new JaxWsServerFactoryBean();
serverFactory.setAddress(&quot;http://localhost:9090/my/us&quot;);
serverFactory.setServiceBean(new UserWsService());
serverFactory.setServiceClass(IUserWsService.class);

//为访问增加相应的Interceptor来处理in/out消息
serverFactory.getInInterceptors().add(new LoggingInInterceptor());
serverFactory.getOutInterceptors().add(new LoggingOutInterceptor());

//需要设置以下参数才能基于“契约优先”发布(会自动对应外部xsd文件)
serverFactory.setWsdlLocation(&quot;META-INF/wsdl/user.wsdl&quot;);
serverFactory.setServiceName(new QName(&quot;http://www.my.org/user&quot;,&quot;UserWsService&quot;));

//增加自定义Handler
//serverFactory.getHandlers().add(new LicenseHandler());
//可使用Interceptor代替Handler
serverFactory.getInInterceptors().add(new LicenseInInterceptor());

serverFactory.create();
</code></pre>
<h4 id="header-35">Client端</h4>
<p>方式一：使用 JaxWs API 进行客户端调用</p>
<pre><code class="lang-java">UserWsService service=new UserWsService();
IUserWsService userService=service.getUserWsServicePort();
System.out.println(userService.addTest(23, 45));
</code></pre>
<p>方式二：使用代理工厂<code>JaxWsProxyFactoryBean</code>进行客户端调用</p>
<pre><code class="lang-java">JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean();
factory.setAddress(&quot;http://localhost:9090/my/us&quot;);
factory.setServiceClass(IUserWsService.class);

//为访问增加相应的Interceptor来处理in/out消息
factory.getInInterceptors().add(new LoggingInInterceptor());
factory.getOutInterceptors().add(new LoggingOutInterceptor());

//增加SOAPHandler
//factory.getHandlers().add(new LicenseHandler());
//可以使用Interceptor代替Handler
factory.getOutInterceptors().add(new LicenseOutInterceptor());

IUserWsService userService=(IUserWsService)factory.create();
System.out.println(userService.addTest(23, 45));
</code></pre>
<h3 id="header-36">结合Spring</h3>
<p>使用Spring管理</p>
<h4 id="header-37">Server端</h4>
<p>发布WebService到Web容器中，并通过Spring管理WebService</p>
<ol>
<li><p>配置<code>web.xml</code></p>
<pre><code class="lang-xml"> &lt;!-- 添加CXF的servlet监听请求 --&gt;
 &lt;servlet&gt;
     &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt;
     &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt;
 &lt;/servlet&gt;
 &lt;servlet-mapping&gt;
     &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt;
     &lt;url-pattern&gt;/service/*&lt;/url-pattern&gt;
 &lt;/servlet-mapping&gt;
</code></pre>
</li>
<li><p>配置<code>beans.xml</code></p>
<pre><code class="lang-xml"> &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
         xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
         xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
         xmlns:jaxws=&quot;http://cxf.apache.org/jaxws&quot;
         xsi:schemaLocation=&quot; ...
             http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd&quot;&gt;

     &lt;context:annotation-config/&gt;
     &lt;context:component-scan base-package=&quot;com.cj.my.ws.service&quot; /&gt;
     &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;

     &lt;!-- 导入cxf--&gt;
     &lt;import resource=&quot;classpath:META-INF/cxf/cxf.xml&quot;/&gt;
     &lt;import resource=&quot;classpath:META-INF/cxf/cxf-extension-jaxws.xml&quot;/&gt;
     &lt;import resource=&quot;classpath:META-INF/cxf/cxf-servlet.xml&quot;/&gt;

     &lt;!-- 发布服务--&gt;
 &lt;/beans&gt;
</code></pre>
<ul>
<li>发布方式一：使用<code>&lt;jaxws:endpoint&gt;</code><pre><code class="lang-xml">&lt;bean id=&quot;userWsService&quot; class=&quot;com.cj.my.ws.cxf.UserWsService&quot; /&gt;
&lt;jaxws:endpoint id=&quot;userWS&quot; implementor=&quot;#userWsService&quot; address=&quot;/us&quot;&gt;
  &lt;jaxws:inInterceptors&gt;
      &lt;bean id=&quot;ipInInterceptor&quot; class=&quot;com.cj.my.ws.cxf.interceptor.IpInInterceptor&quot;/&gt;
  &lt;/jaxws:inInterceptors&gt;
  &lt;!--  &lt;jaxws:outFaultInterceptors&gt;
      &lt;bean id=&quot;loggerOutInterceptor&quot; class=&quot;org.apache.cxf.interceptor.LoggingOutInterceptor&quot;/&gt;
      &lt;bean id=&quot;faultOutInterceptor&quot; class=&quot;org.apache.cxf.interceptor.FaultOutInterceptor&quot;/&gt;
  &lt;/jaxws:outFaultInterceptors&gt; --&gt;
  &lt;jaxws:handlers&gt;
      &lt;bean id=&quot;backWsLogHandler&quot; class=&quot;com.cj.my.ws.cxf.handler.BackWsLogHandler&quot;&gt;&lt;/bean&gt;
      &lt;!-- &lt;bean id=&quot;licenseHandler&quot; class=&quot;com.cj.my.ws.cxf.handler.LicenseHandler&quot;&gt;&lt;/bean&gt; --&gt;
  &lt;/jaxws:handlers&gt;
&lt;/jaxws:endpoint&gt;
</code></pre>
</li>
<li>发布方式二：使用<code>&lt;jaxws:server&gt;</code><pre><code class="lang-xml">&lt;jaxws:server id=&quot;userWS&quot; serviceClass=&quot;com.cj.my.ws.cxf.IUserWsService&quot; address=&quot;/us&quot;&gt;
  &lt;jaxws:serviceBean&gt;
      &lt;bean class=&quot;com.cj.my.ws.cxf.UserWsService&quot;/&gt;
  &lt;/jaxws:serviceBean&gt;
&lt;/jaxws:server&gt;
</code></pre>
</li>
<li>其实<code>&lt;jaxws:server&gt;</code> 和<code>&lt;jaxws:endpoint&gt;</code> 是等效的，都用于发布Web 服务<ul>
<li>JAX-WS 规范中使用EndPoint 发布Web 服务，CXF 为了和JAX-WS 对应，提供了这个与<code>&lt;jaxws:server&gt;</code> 功能一样的配置元素<code>&lt;jaxws:endpoint&gt;</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="header-38">Client端</h4>
<p>通过Spring注入WebService Client</p>
<p>使用<code>&lt;jaxws:client&gt;</code>:</p>
<pre><code class="lang-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xmlns:jaxws=&quot;http://cxf.apache.org/jaxws&quot;
        xmlns:cxf=&quot;http://cxf.apache.org/core&quot;
        xsi:schemaLocation=&quot;
            http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd
            http://cxf.apache.org/core http://cxf.apache.org/schemas/core.xsd&quot;&gt;

&lt;context:component-scan base-package=&quot;com.cj.my.ws&quot;/&gt;

&lt;jaxws:client id=&quot;userWsService&quot; 
        serviceClass=&quot;com.cj.my.ws.cxf.client.IUserWsService&quot; 
        address=&quot;http://localhost:9090/my/service/us&quot; &gt;
    &lt;!-- &lt;jaxws:handlers&gt;
        &lt;ref bean=&quot;licenseHandler&quot;/&gt;
    &lt;/jaxws:handlers&gt; --&gt;
&lt;/jaxws:client&gt;
</code></pre>
<p>测试：</p>
<pre><code class="lang-java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&quot;classpath:beans.xml&quot;)
public class ClientSpringTest
{
    @Inject
    private IUserWsService userWsService=null;

    @Test
    public void testAddTest(){
        System.out.println(userWsService.addTest(23, 45));
    }
}
</code></pre>
<h3 id="header-39">拦截器</h3>
<h4 id="header-40">自定义拦截器</h4>
<p>CXF中有一些常用的拦截器（例如：LoggingOutInterceptor，LoggingInInterceptor）</p>
<p>也可自定义拦截器，例如：</p>
<pre><code class="lang-java">public class TestOutInterceptor extends AbstractSoapInterceptor{
    private String ns=&quot;http://www.my.org/user&quot;;
    public TestOutInterceptor(){
        super(Phase.WRITE);
    }

    @Override
    public void handleMessage(SoapMessage message) throws Fault{
        System.out.println(&quot;TestOutInterceptor------------&quot;);
        try{
            DataBinding dataBinding=new JAXBDataBinding(String.class);
            QName qname=new QName(this.ns,&quot;testInfo&quot;);
            Header header=new Header(qname, &quot;test 88&quot;, dataBinding);
            message.getHeaders().add(header);
        } catch (JAXBException e){
            e.printStackTrace();
        }
    }
}
</code></pre>
<h4 id="header-41">添加拦截器</h4>
<p>方法一：<code>JaxWsServerFactoryBean</code></p>
<p>Server端：</p>
<pre><code class="lang-java">JaxWsServerFactoryBean serverFactory=new JaxWsServerFactoryBean();
...
serverFactory.getInInterceptors().add(new LicenseInInterceptor());
</code></pre>
<p>Client端：</p>
<pre><code class="lang-java">JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean();
...
factory.getOutInterceptors().add(new LicenseOutInterceptor());
</code></pre>
<p>方法二：Annotation</p>
<p>Server端：</p>
<pre><code class="lang-java">@InInterceptors(interceptors={&quot;com.cj.my.ws.cxf.interceptor.LicenseInInterceptor&quot;})
public class UserWsService implements IUserWsService
</code></pre>
<p>Client端：</p>
<pre><code class="lang-java">@OutInterceptors(interceptors={
        &quot;com.cj.my.ws.cxf.interceptor.TestOutInterceptor&quot;,
        &quot;com.cj.my.ws.cxf.interceptor.LicenseOutInterceptor&quot;,
        &quot;org.apache.cxf.interceptor.LoggingOutInterceptor&quot;})
public interface IUserWsService
</code></pre>
<p>方法三：基于Spring，在Spring配置文件(eg: <code>beans.xml</code>)中添加</p>
<ul>
<li>全局配置（使用<code>&lt;cxf:bus&gt;</code>）<ul>
<li>即作为Client端和Server端都有效（即：对你访问第三方的WebService接口和别人访问你发布出去的WebService接口,都起到拦截作用 ）<pre><code class="lang-xml">&lt;cxf:bus&gt;
  &lt;cxf:outInterceptors&gt;
      &lt;ref bean=&quot;loggingOutInterceptor&quot;/&gt;
  &lt;/cxf:outInterceptors&gt;
  &lt;cxf:inInterceptors&gt;
      &lt;ref bean=&quot;loggingInInterceptor&quot;/&gt;
  &lt;/cxf:inInterceptors&gt;
&lt;/cxf:bus&gt;
&lt;bean id=&quot;loggingOutInterceptor&quot; class=&quot;org.apache.cxf.interceptor.LoggingOutInterceptor&quot;/&gt;
&lt;bean id=&quot;loggingInInterceptor&quot; class=&quot;org.apache.cxf.interceptor.LoggingInInterceptor&quot;/&gt;
</code></pre>
</li>
</ul>
</li>
<li>局部（针对某个WebService）：<ul>
<li>Server端：配置在<code>&lt;jaxws:server&gt;</code>或<code>&lt;jaxws:endpoint&gt;</code>中</li>
<li>Client端：配置在<code>&lt;jaxws:client&gt;</code>中，例如：<pre><code class="lang-xml">&lt;jaxws:client id=&quot;userWsService&quot;
      serviceClass=&quot;com.cj.my.ws.cxf.client.IUserWsService&quot; 
      address=&quot;http://localhost:9090/my/service/us&quot; &gt;
  &lt;jaxws:handlers&gt;
      &lt;ref bean=&quot;licenseHandler&quot;/&gt;
  &lt;/jaxws:handlers&gt;
&lt;/jaxws:client&gt;
&lt;bean id=&quot;licenseHandler&quot; class=&quot;com.cj.my.ws.cxf.handler.LicenseHandler&quot;/&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="header-42">扩展应用</h2>
<h3 id="header-43">Upload附件</h3>
<p>二进制MTOM</p>
<ul>
<li>字节数组<code>byte[]</code> 放于SOAPBody不好，若太大，会有内存溢出异常</li>
<li>使用MTOM二进制处理（优化过）</li>
<li><code>@MTOM</code>：以附件AttachmentPart传送，即以流的方式传送</li>
</ul>
<ol>
<li><p>wsdl文件中：</p>
<pre><code class="lang-xml"> &lt;xsd:complexType name=&quot;uploadFile&quot;&gt;
     &lt;xsd:sequence&gt;
         &lt;xsd:element name=&quot;file&quot; type=&quot;xsd:base64Binary&quot; nillable=&quot;true&quot; minOccurs=&quot;0&quot;/&gt;
     &lt;/xsd:sequence&gt;
 &lt;/xsd:complexType&gt;
</code></pre>
</li>
<li><p>Server端WebService实现类</p>
<pre><code class="lang-java"> @MTOM
 public class UserWsService implements IUserWsService{
     ...
     @Override
     public boolean uploadFile(byte[] file){
         SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyymmddhhMMss&quot;);
         String fileName=sdf.format(new Date());    
         FileOutputStream fos = null;
         System.out.println(file);
         try {
             fos = new FileOutputStream(&quot;d:/webservice/&quot;+fileName+&quot;.jpg&quot;);
             fos.write(file);
             fos.flush();
             return true;
         } catch (Exception e) {
             return false;
         } finally {
             try {
                 fos.close();
             } catch (IOException e) {
                 return false;
             }
         }
     }
 }
</code></pre>
</li>
<li><p>Client端调用测试</p>
<pre><code class="lang-java"> @Before
 public void init() throws MalformedURLException{
     URL url=new URL(this.wsdl);
     QName qname = new QName(this.ns, &quot;UserWsService&quot;);
     this.service=new UserWsService(url,qname);
     //this.userService=service.getUserWsServicePort();
     this.userService=service.getUserWsServicePort(new MTOMFeature());
 }

 @Test
 public void testUploadFile(){
     try {
         byte[] file = FileUtils.readFileToByteArray(new File(&quot;E:\\picture\\123.jpg&quot;));
         boolean result=userService.uploadFile(file);
         System.out.println(result);
     } catch (IOException e) {
         e.printStackTrace();
     }
 }
</code></pre>
</li>
</ol>
<h3 id="header-44">消息头处理</h3>
<p>wsdl文件中：</p>
<pre><code class="lang-xml">&lt;!-- 创建消息头元素 --&gt;
&lt;xsd:element name=&quot;licenseInfo&quot; type=&quot;xsd:string&quot; /&gt;

&lt;!-- 创建消息头信息 --&gt;
&lt;wsdl:message name=&quot;licenseInfo&quot;&gt;
      &lt;wsdl:part name=&quot;licenseInfo&quot; element=&quot;tns:licenseInfo&quot; /&gt;
&lt;/wsdl:message&gt;

&lt;!-- 为某个特定的方法绑定消息头（也可不加，作为全局，通过Handler统一判断处理）--&gt;
&lt;wsdl:binding name=&quot;OperationWsServiceSOAP&quot; type=&quot;tns:IOperationWsService&quot;&gt;
    &lt;soap:binding style=&quot;document&quot; transport=&quot;http://schemas.xmlsoap.org/soap/http&quot;/&gt;
    &lt;wsdl:operation name=&quot;divide&quot;&gt;
        &lt;wsdl:input&gt;
            &lt;soap:body use=&quot;literal&quot;/&gt;
            &lt;soap:header use=&quot;literal&quot; part=&quot;licenseInfo&quot; message=&quot;tns:licenseInfo&quot; /&gt;
        &lt;/wsdl:input&gt;
        &lt;wsdl:output&gt;
            &lt;soap:body use=&quot;literal&quot;/&gt;
            &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
&lt;/wsdl:binding&gt;
</code></pre>
<h4 id="header-45">显示处理</h4>
<p>Server端声明（显示的声明一个参数获取头部信息 ）：</p>
<pre><code class="lang-java">public interface IOperationWsService{
    ...

    //添加接口，用于显示获取licenseInfo
    @WebMethod
    @WebResult(name = &quot;divideResult&quot;, targetNamespace = &quot;&quot;)
    @RequestWrapper(localName = &quot;divide&quot;, targetNamespace = &quot;http://www.example.org/student/&quot;,     className = &quot;com.cj.my.ws.second.client.Divide&quot;)
    @ResponseWrapper(localName = &quot;divideResponse&quot;, targetNamespace = &quot;http://www.example.org/student/&quot;,     className = &quot;com.cj.my.ws.second.client.DivideResponse&quot;)
    public int divide(
    @WebParam(name = &quot;a&quot;, targetNamespace = &quot;&quot;) int a,
    @WebParam(name = &quot;b&quot;, targetNamespace = &quot;&quot;) int b,
    @WebParam(name=&quot;licenseInfo&quot;,header=true) String licenseInfo);
}
</code></pre>
<p>Client端调用：</p>
<pre><code class="lang-java">public class ClientApp{
    public static void main(String[] args){
    OperationWsService service=new OperationWsService ();
    IOperationWsService operationWsService=service.getOperationWsServicePort();
    System.out.println(operationWsService.divide(30, 0,&quot;123&quot;));
    }
}
</code></pre>
<h4 id="header-46">通过SOAPHandler处理</h4>
<p>Server端自定义SOAPHandler：<code>LicenseHandler</code> （in 时使用）</p>
<pre><code class="lang-java">public class LicenseHandler implements SOAPHandler&lt;SOAPMessageContext&gt;{
    @Override
    public boolean handleMessage(SOAPMessageContext context){
        try{
            Boolean out=(Boolean)context.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
            if(!out){
                SOAPMessage message=context.getMessage();
                SOAPEnvelope envelope=message.getSOAPPart().getEnvelope();
                SOAPBody body=envelope.getBody();

                String partName=body.getChildNodes().item(0).getLocalName();
                if(&quot;list&quot;.equals(partName) || &quot;addUser&quot;.equals(partName)){
                SOAPHeader header=envelope.getHeader();
                if(header==null || header.getFirstChild()==null){
                    //将错误信息加入SOAPBody中
                    SOAPFault fault=body.addFault();
                    fault.setFaultString(&quot;头部信息不能为空&quot;);
                    //return false;
                    throw new SOAPFaultException(fault);
                }

                /*
                //此方法会将头信息detach分离出来，接下来的程序就不能再取到了
                @SuppressWarnings(&quot;unchecked&quot;)
                Iterator&lt;SOAPHeaderElement&gt; it =header.extractAllHeaderElements();
                while(it.hasNext()){
                    System.out.println(&quot;header:&quot;+it.next().getTextContent());
                }*/

                NodeList nodeList=header.getChildNodes();
                //NodeList nodeList=header.getElementsByTagName(&quot;ns:licenseInfo&quot;);
                System.out.println(&quot;header--&quot;+nodeList.item(0).getTextContent());
                }
            }
        } catch (SOAPException e){
            e.printStackTrace();
        } catch (IOException e){
            e.printStackTrace();
        }
        return true;
    }

    @Override
    public boolean handleFault(SOAPMessageContext context){
        return false;
    }
}
</code></pre>
<p>Client端自定义SOAPHandler：<code>LicenseHandler</code> （out 时使用）</p>
<pre><code class="lang-java">public class LicenseHandler implements SOAPHandler&lt;SOAPMessageContext&gt;{
    private String wsdl=&quot;http://localhost:9090/us?wsdl&quot;;
    private String ns=&quot;http://www.my.org/user&quot;;

    @Override
    public boolean handleMessage(SOAPMessageContext context){    
        try{
            Boolean out=(Boolean)context.get(MessageContext.MESSAGE_OUTBOUND_PROPERTY);
            if(out){
                SOAPMessage message=context.getMessage();
                SOAPEnvelope envelope=message.getSOAPPart().getEnvelope();
                SOAPBody body=envelope.getBody();
                String partName=body.getFirstChild().getLocalName();
                System.out.println(&quot;partName:&quot;+partName);
                if(!&quot;addUser&quot;.equals(partName))
                    return true;

                SOAPHeader header=envelope.getHeader();
                if(header==null)
                    header=envelope.addHeader();

                User regUser=new User();
                regUser.setId(18);
                regUser.setUsername(&quot;RegisterUser&quot;);
                regUser.setPassword(&quot;888&quot;);
                LicenseInfo licenseInfo=new LicenseInfo();
                licenseInfo.setRegisterUser(regUser);

                JAXBContext ctx=JAXBContext.newInstance(LicenseInfo.class);
                QName sname=new QName(this.ns,&quot;licenseInfo&quot;);
                JAXBElement&lt;LicenseInfo&gt; element=new JAXBElement&lt;LicenseInfo&gt;(sname,LicenseInfo.class,licenseInfo);

                Marshaller mar=ctx.createMarshaller();
                mar.setProperty(Marshaller.JAXB_FRAGMENT,true);
                mar.setProperty(Marshaller.JAXB_ENCODING, &quot;UTF-8&quot;);
                mar.marshal(element, header);

                message.writeTo(System.out);
                System.out.println();
            }
        } catch (SOAPException e){
            e.printStackTrace();
        } catch (JAXBException e){
            e.printStackTrace();
        }catch (IOException e){
            e.printStackTrace();
        }
        return true;
    }

    @Override
    public boolean handleFault(SOAPMessageContext context){
        try{
            SOAPMessage message=context.getMessage();
            message.writeTo(System.out);
            System.out.println();
        } catch (SOAPException e){
            e.printStackTrace();
        } catch (IOException e){
            e.printStackTrace();
        }
        return false;
    }

}
</code></pre>
<h4 id="header-47">通过SoapInterceptor处理</h4>
<p>Server端In Interceptor</p>
<pre><code class="lang-java">public class LicenseInInterceptor extends AbstractSoapInterceptor{
    public LicenseInInterceptor(){
        super(Phase.POST_UNMARSHAL);
    }
    @Override
    public void handleMessage(SoapMessage message) throws Fault{
        QName qname=new QName(&quot;http://www.my.org/user&quot;,&quot;licenseInfo&quot;);
        Header header=message.getHeader(qname);
        if(header!=null){
            Object obj=header.getObject();
            if(obj instanceof  Node){
                Element e=(Element) obj;
                NodeList nodeList=e.getChildNodes();
                //System.out.println(nodeList.item(0).getTextContent());
                Node node=nodeList.item(0);
                if(node==null || !node.getTextContent().equals(&quot;RegisterUser888&quot;))
                    throw new Fault(new Exception(&quot;licenseInfo isn&#39;t correct!&quot;));
            }
        }
    }
}
</code></pre>
<p>Client端Out Interceptor</p>
<pre><code class="lang-java">public class LicenseOutInterceptor extends AbstractSoapInterceptor{
    private String ns=&quot;http://www.my.org/user&quot;;
    public LicenseOutInterceptor(){
        super(Phase.WRITE);
    }

    @Override
    public void handleMessage(SoapMessage message) throws Fault{
        try{
            User regUser=new User();
            regUser.setId(18);
            regUser.setUsername(&quot;RegisterUser&quot;);
            regUser.setPassword(&quot;888&quot;);
            LicenseInfo licenseInfo=new LicenseInfo();
            licenseInfo.setRegisterUser(regUser);

            DataBinding dataBinding=new JAXBDataBinding(LicenseInfo.class);
            QName qname=new QName(this.ns,&quot;licenseInfo&quot;);

            Header header=new Header(qname, licenseInfo, dataBinding);
            message.getHeaders().add(header);

        } 
        catch (JAXBException e){
            e.printStackTrace();
        }
    }
}
</code></pre>
<h3 id="header-48">Exception异常处理</h3>
<p>使用非运行期异常</p>
<p>wsdl文件中（将异常对象封装成一个Message）：</p>
<pre><code class="lang-xml">&lt;!-- 创建异常对象 --&gt;
&lt;xsd:element name=&quot;StudentException&quot; type=&quot;tns:StudentException&quot;/&gt;
&lt;xsd:complexType name=&quot;StudentException&quot;&gt;
&lt;xsd:sequence&gt;
&lt;xsd:element name=&quot;message&quot; type=&quot;xsd:string&quot; /&gt;
&lt;/xsd:sequence&gt;
&lt;/xsd:complexType&gt;

&lt;!-- 创建异常消息 --&gt;
&lt;wsdl:message name=&quot;StudentException&quot;&gt;
      &lt;wsdl:part name=&quot;StudentException&quot; element=&quot;tns:StudentException&quot; /&gt;
&lt;/wsdl:message&gt;

&lt;!-- 声明某接口（服务）的异常消息 --&gt;
&lt;wsdl:portType name=&quot;IOperationWsService&quot;&gt;
    &lt;wsdl:operation name=&quot;plus&quot;&gt;
      &lt;wsdl:input message=&quot;tns:plus&quot;/&gt;
      &lt;wsdl:output message=&quot;tns:plusResponse&quot;/&gt;
      &lt;wsdl:fault name=&quot;StudentException&quot; message=&quot;tns:StudentException&quot;/&gt;
    &lt;/wsdl:operation&gt;
&lt;/wsdl:portType&gt;

&lt;!-- 为特定方法绑定异常形式 --&gt;
&lt;wsdl:binding name=&quot;OperationWsServiceSOAP&quot; type=&quot;tns:IOperationWsService&quot;&gt;
   &lt;soap:binding style=&quot;document&quot; transport=&quot;http://schemas.xmlsoap.org/soap/http&quot;/&gt;
    &lt;wsdl:operation name=&quot;plus&quot;&gt;
      &lt;wsdl:input&gt;
        &lt;soap:body use=&quot;literal&quot;/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;soap:body use=&quot;literal&quot;/&gt;
      &lt;/wsdl:output&gt;
      &lt;wsdl:fault name=&quot;StudentException&quot;&gt;
        &lt;soap:fault name=&quot;StudentException&quot; use=&quot;literal&quot;/&gt;
      &lt;/wsdl:fault&gt;
    &lt;/wsdl:operation&gt;
&lt;/wsdl:binding&gt;
</code></pre>
<p>Server端处理</p>
<ul>
<li>Server端发生Exception,被JAX截获：判断wsdl中是否有定义此异常</li>
<li>无则向上抛出Exception；</li>
<li>有则表明此Exception需抛到Client端，将此异常信息封装为SOAPFault放于SOAPBody中反馈给Client端，由Client端捕获此异常。</li>
<li>注意：此时Server端不会报异常（因为已经被封装成Soap消息了）。</li>
</ul>
<p>模拟：</p>
<p>Server端 （WebService实现类）：</p>
<pre><code class="lang-java">@Override
public boolean isExist(Integer id) throws StudentException{
    if(id&lt;0)
        throw new StudentException(&quot;illegal input param:&quot;+id);
    for(Student student:studentList){
        if(student.getId()==id)
            return true;
    }
    return false;
}
</code></pre>
<p>Client端调用：</p>
<pre><code class="lang-java">//调用实现方法isExist,获取StudentException(wsimport命令自动生成的是：StudentException_Exception)
try{
boolean result = myService.isExist(-1);
System.out.println(result);
System.out.println(&quot;--------------------------&quot;);
}
catch (StudentException_Exception e){
    System.out.println(e.getMessage());
}
</code></pre>
<h3 id="header-49">异步调用</h3>
<p>CXF支持如下两种形式的异步调用模式：</p>
<ul>
<li><p>轮询方法（Polling approach）</p>
<ul>
<li>调用一个特殊的无参方法，返回一个 <code>javax.xml.ws.Response</code> 实例</li>
<li>通过轮询该 Response 对象来检查是否有应答消息到达</li>
<li><code>Response implements java.util.concurrency.Future&lt;T&gt;</code></li>
<li><code>Non-blocking polling</code>（非阻塞轮询）<ul>
<li>尝试获得结果之前，调用非阻塞方法<code>Response&lt;T&gt;.isDone()</code>来检查响应消息是否到达<pre><code class="lang-java">Response&lt;StartResponse&gt; rs=backService.startAsync();
while(!rs.isDone()){
Thread.sleep(100);
System.out.println(&quot;Non-blocking polling(无阻塞轮询)-------&quot;);
}
StartResponse startResponse = rs.get();
System.out.println(startResponse.getResult());
</code></pre>
</li>
</ul>
</li>
<li><code>Blocking polling</code> (阻塞轮询）<ul>
<li>立即调用<code>Response&lt;T&gt;.get()</code>，阻塞至响应到达（可以指定一个超时时长作为可选项）<pre><code class="lang-java">Response&lt;StartResponse&gt; rs=backService.startAsync();
StartResponse startResponse=rs.get(5L, java.util.concurrent.TimeUnit.SECONDS);
System.out.println(startResponse.getResult());
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>回调方法（Callback approach）</p>
<ul>
<li>调用另外一个特殊的方法：使用一个回调对象的引用作为一个参数（<code>javax.xml.ws.AsyncHandler</code>类型）</li>
<li>只要有应答消息到达客户端，CXF运行时就会回调该 <code>AsyncHandler 对象</code>，并将应答消息的内容传给它</li>
</ul>
</li>
</ul>
<p>使用示例：</p>
<ol>
<li><p>新建<code>binding.xml</code>文件（打开异步调用特性，进行绑定声明）</p>
<pre><code class="lang-xml"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;bindings xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
     xmlns:wsdl=&quot;http://schemas.xmlsoap.org/wsdl/&quot; 
     wsdlLocation=&quot;http://localhost:9090/sms/comm/service/bs?wsdl&quot;  
     xmlns=&quot;http://java.sun.com/xml/ns/jaxws&quot;&gt;

     &lt;!-- 只想对一个端口“iHelloWorld”生成异步方法，可以在绑定声明中指定
     &lt;bindings node=&quot;wsdl:definitions/wsdl:portType[@name=&#39;iHelloWorld&#39;]&quot;&gt;
      --&gt;
     &lt;!-- 把node设为“wsdl:definitions”，表示对整个WSDL契约起作用 --&gt;
     &lt;bindings node=&quot;wsdl:definitions&quot;&gt;
         &lt;enableAsyncMapping&gt;true&lt;/enableAsyncMapping&gt;
     &lt;/bindings&gt;
 &lt;/bindings&gt;
</code></pre>
</li>
<li><p>生成相应的带异步支持的stub代码</p>
<ul>
<li>方式一：使用wsdl2java命令<pre><code>wsdl2java -b binding.xml hello.wsdl
</code></pre></li>
<li>方式二：使用wsimport命令<pre><code>wsimport -d d:/webservice/sms -keep http://localhost:9090/sms/comm/service/bs?wsdl -p com.cj.sms.client.back -b d:/webservice/binding.xml
</code></pre></li>
<li>服务接口类的方法多出两个方法声明</li>
<li><p>例如<code>destroy()</code>方法，会多出：</p>
<pre><code class="lang-java">  /**
  * 异步调用的轮询方式
  * @return returns javax.xml.ws.Response&lt;com.cj.sms.client.back.DestroyResponse&gt;
  */
  @WebMethod(operationName = &quot;destroy&quot;)
  @RequestWrapper(localName = &quot;destroy&quot;, targetNamespace = &quot;http://ws.sms.cj.com/back&quot;, className = &quot;com.cj.sms.client.back.Destroy&quot;)
  @ResponseWrapper(localName = &quot;destroyResponse&quot;, targetNamespace = &quot;http://ws.sms.cj.com/back&quot;, className = &quot;com.cj.sms.client.back.DestroyResponse&quot;)
  public Response&lt;DestroyResponse&gt; destroyAsync();

  /**
  * 异步调用的回调方式
  * @param asyncHandler
  * @return returns java.util.concurrent.Future&lt;? extends java.lang.Object&gt;
  */
  @WebMethod(operationName = &quot;destroy&quot;)
  @RequestWrapper(localName = &quot;destroy&quot;, targetNamespace = &quot;http://ws.sms.cj.com/back&quot;, className = &quot;com.cj.sms.client.back.Destroy&quot;)
  @ResponseWrapper(localName = &quot;destroyResponse&quot;, targetNamespace = &quot;http://ws.sms.cj.com/back&quot;, className = &quot;com.cj.sms.client.back.DestroyResponse&quot;)
  public Future&lt;?&gt; destroyAsync(
  @WebParam(name = &quot;asyncHandler&quot;, targetNamespace = &quot;&quot;)AsyncHandler&lt;DestroyResponse&gt; asyncHandler);
</code></pre>
</li>
</ul>
</li>
<li><p>测试</p>
<ul>
<li>测试轮询方式<pre><code class="lang-java">public void testStart(){
  try{
      Response&lt;StartResponse&gt; rs=backService.startAsync();
      while(!rs.isDone()){  
              Thread.sleep(100);
              System.out.println(&quot;Non-blocking polling(无阻塞轮询)-------&quot;);  
         }
      //如果没有前面isDone的检测，此处就退化为阻塞式轮询
      StartResponse startResponse = rs.get();
      //也可设置一个超时时长做为选项
      //StartResponse startResponse=rs.get(5L, java.util.concurrent.TimeUnit.SECONDS);
      System.out.println(startResponse.getResult());
  }catch(SOAPFaultException e){
      System.out.println(e.getMessage());
  }catch (InterruptedException e){
      e.printStackTrace();
  } catch (ExecutionException e){
      e.printStackTrace();
  }
}
</code></pre>
</li>
<li><p>测试回调方式</p>
<pre><code class="lang-java">@Test
public void testDestroy(){
  try{
      //destroyHandler=new WsDestroyAsyncHandler();

      //返回的 Future&lt;?&gt; 对象只是用来检测一个响应是否已经到达
      //响应消息的值只在回调对象WsDestroyAsyncHandler中可得
      Future&lt;?&gt; future=backService.destroyAsync(destroyHandler);
      while(!future.isDone()){  
              Thread.sleep(10000);  
              System.out.println(&quot;异步方法(回调)--------------&quot;);  
          }  
      System.out.println(destroyHandler.getResponseText());    
  }catch(SOAPFaultException e){
      System.out.println(e.getMessage());
  }catch (InterruptedException e){
      e.printStackTrace();
  }
}
</code></pre>
<pre><code class="lang-java">//自定义回调类
public class WsDestroyAsyncHandler implements AsyncHandler&lt;DestroyResponse&gt;{
  private DestroyResponse destroyResponse;
  @Override
  public void handleResponse(Response&lt;DestroyResponse&gt; res){
      try{
          //获取响应数据，并把它存放到成员变量destroyResponse中
          destroyResponse=res.get();
          System.out.println(&quot;result:&quot;+destroyResponse.getResult());
      } catch (InterruptedException e){
          e.printStackTrace();
      } catch (ExecutionException e){
          e.printStackTrace();
      }
  }
  //方便从响应中提炼出主要的输出参数
  public String getResponseText(){
      return destroyResponse.getResult();
  }
}
</code></pre>
</li>
</ul>
</li>
</ol>
  </section>
</article>

      <hr/>
      
<section class="post-comment">
	
		<div id="gitment_container"></div>

<link rel="stylesheet" href="/gitment/default.css">
<script src="/gitment/gitment.browser.js"></script>


<script type="text/javascript">
	var gitment = new Gitment({
	  id: document.location.pathname,
	  owner: 'chenjin-zero',
	  repo: 'blogComment',
	  oauth: {
	    client_id: '36a09bb7399efe69c6ce',
	    client_secret: 'ad9ad546b23b708c71d92e513dc36e0486179dea',
	  }
	})
      
	gitment.render('gitment_container')
</script>
	
</section>

    </div>
  </div>
</body>

<script src="/jquery/dist/jquery.min.js"></script>
<script src="/bootstrap/dist/js/bootstrap.min.js"></script>


	<script src="/highlight/highlight.pack.js"></script>
	<script type="text/javascript">
		hljs.initHighlightingOnLoad();
	</script>



<script type="text/javascript">

  $(document).ready(function(){
    var sidebarCtrl=$("#sidebar-ctrl");
    var sidebar=$("#sidebar");
    var wrapper=$("#wrapper");
    sidebarCtrl.on("click",function(event){
        //alert("click");
        sidebar.toggleClass("sidebar-toggle");
        wrapper.toggleClass("sidebar-toggle");
        sidebarCtrl.toggleClass("sidebar-toggle");
        sidebarCtrl.toggleClass("active");
    })
  });
</script>


</html>
