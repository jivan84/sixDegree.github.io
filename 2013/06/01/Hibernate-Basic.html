<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Hibernate基础</title>
  
  <!-- Meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="hibernate,jpa,orm,lucene">
  
  
    <meta name="description" content="Hibernate Baisic Functional Introduce">
  

  <!-- Feed -->
  
    <link rel="alternative" href="/atom.xml" title="SixDegree" type="application/atom+xml">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/bootstrap/dist/css/bootstrap.css">
  
	
		<link rel="stylesheet" href="/highlight/demo/styles/tomorrow-night-bright.css">
	
    
  
  <link rel="stylesheet" href="/css/fontello.css">
  <link rel="stylesheet" href="/css/style.css">

  <!-- Site Analyse -->
  
	<script>
	var userID='2bbb83cc0f781dd7502e9d5e19661866';
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?"+userID;
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>


</head>

<body data-spy="scroll" data-target="#nav-catalog">
  <div id="top-push"></div>
<a href="#top-push" id="go-top">
	<span class="glyphicon glyphicon-chevron-up"></span>
</a>
  <aside id="sidebar">
    <section class="sidebar-header">Catalog</section>
     <nav id="nav-catalog">
        <ol class="sidebar-nav nav"><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-1"><span class="sidebar-nav nav-text">概念介绍</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-2"><span class="sidebar-nav nav-text">数据状态</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-3"><span class="sidebar-nav nav-text">DAO</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-4"><span class="sidebar-nav nav-text">ORM</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-5"><span class="sidebar-nav nav-text">JPA & Hibernate</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-6"><span class="sidebar-nav nav-text">Starter</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-7"><span class="sidebar-nav nav-text">SessionFactory & Session</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-8"><span class="sidebar-nav nav-text">主键</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-9"><span class="sidebar-nav nav-text">生成策略</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-10"><span class="sidebar-nav nav-text">联合主键</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-11"><span class="sidebar-nav nav-text">对象状态</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-12"><span class="sidebar-nav nav-text">映射</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-13"><span class="sidebar-nav nav-text">关系映射</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-14"><span class="sidebar-nav nav-text">组件映射</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-15"><span class="sidebar-nav nav-text">集合映射</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-16"><span class="sidebar-nav nav-text">继承映射</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-17"><span class="sidebar-nav nav-text">综合实例</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-18"><span class="sidebar-nav nav-text">查询</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-19"><span class="sidebar-nav nav-text">NativeSQL</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-20"><span class="sidebar-nav nav-text">HQL</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-21"><span class="sidebar-nav nav-text">QBC & QBE</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-22"><span class="sidebar-nav nav-text">命名的数据库查询</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-23"><span class="sidebar-nav nav-text">直接使用JDBC</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-24"><span class="sidebar-nav nav-text">缓存</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-25"><span class="sidebar-nav nav-text">一级缓存（Session）</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-26"><span class="sidebar-nav nav-text">二级缓存（SessionFactory）</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-27"><span class="sidebar-nav nav-text">三级缓存（Query）</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-28"><span class="sidebar-nav nav-text">事务</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-29"><span class="sidebar-nav nav-text">事务并发问题</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-30"><span class="sidebar-nav nav-text">事务隔离机制</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-31"><span class="sidebar-nav nav-text">锁</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-32"><span class="sidebar-nav nav-text">性能优化</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-33"><span class="sidebar-nav nav-text">动态局部插入&更新</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-34"><span class="sidebar-nav nav-text">cascade参数对CUD影响</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-35"><span class="sidebar-nav nav-text">1+N问题</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-36"><span class="sidebar-nav nav-text">防止内存泄漏</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-37"><span class="sidebar-nav nav-text">延迟加载</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-38"><span class="sidebar-nav nav-text">list & iterate</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-39"><span class="sidebar-nav nav-text">Hibernate 扩展组件</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-40"><span class="sidebar-nav nav-text">Hibernate Filter</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-41"><span class="sidebar-nav nav-text">Hibernate Interceptor</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-42"><span class="sidebar-nav nav-text">Hibernate Listener</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-43"><span class="sidebar-nav nav-text">Hibernate Search</span></a></li></ol></li></ol>
    </nav>
  </aside>
  <span id="sidebar-ctrl" class="glyphicon glyphicon-list-alt circle"></span>
  <div id="wrapper">
    <header>
  <nav class="navbar navbar-default">
    <div class="container-fluid">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#nav-menu" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/">SixDegree</a>
      </div>
      <div class="collapse navbar-collapse" id="nav-menu">
        <ul class="nav navbar-nav navbar-right">
          
              <li  >
                <a href="/">Blogs</a>
              </li>
          
              <li  >
                <a href="/tags.html">Tags</a>
              </li>
          
              <li  >
                <a href="/about.html">About</a>
              </li>
          
          
              <li>
                <a href="/atom.xml" target="_blank">
                  <span class="icon-rss"></span>
                </a>
              </li>
          
              <li>
                <a href="http://github.com/sixdegree" target="_blank">
                  <span class="icon-github"></span>
                </a>
              </li>
          
        </ul>
      </div>
    </div>
  </nav>
</header>



    <div class="container">
      <article class="detail" role="main">
  <section class="post-header">
    <h1 class="post-title">Hibernate基础</h1>
    <ul class="post-meta">
      <li>
        <span class="glyphicon glyphicon-calendar"></span>
        <time datetime="2013-05-31T16:00:00.000Z">2013-06-01</time>
      </li>
      
        <li>
         <span class="glyphicon glyphicon-tags"></span>
          
            <a href="/tags.html#tag-Java">Java</a>
          
            <a href="/tags.html#tag-Hibernate">Hibernate</a>
          
        </li>
      
    </ul>
  </section>
  <section class="post-content">
    <h2 id="header-1">概念介绍</h2>
<h3 id="header-2">数据状态</h3>
<p>数据在计算机中有两种状态：</p>
<ul>
<li>瞬时状态：保存在内存的程序数据，程序退出后，数据就消失了，称为瞬时状态</li>
<li>持久状态：保存在磁盘上的程序数据，程序退出后依然存在，称为程序数据的持久状态</li>
</ul>
<p><strong>持久化：</strong> 将程序数据在瞬时状态和持久状态之间相互转换的机制</p>
<pre><code>Transient    ------------------&gt; Persistent
(瞬时状态)            持久化        （持久状态）
</code></pre><p>现在的项目大多使用三层构架: </p>
<ul>
<li>表示层</li>
<li>业务逻辑层（服务层）</li>
<li>持久化层 (这里的持久化层就是持久化的意思)</li>
</ul>
<h3 id="header-3">DAO</h3>
<p>Data Access Object 数据访问对象</p>
<p>DAO与持久化的<strong>关系</strong>是：DAO一种程序数据访问层（持久化层）的设计思想,供逻辑层使用。</p>
<p>DAO不仅仅是其中的DAO类， DAO完整组件如下：</p>
<ul>
<li><strong>DAO 工厂类</strong> （暂时不使用,使用工厂设计模式）, 根据不同的数据源与访问特性生产对应的DAO产品，供业务逻辑类使用</li>
<li><strong>DAO接口</strong>（一个）</li>
<li><strong>实现了DAO接口的具体类</strong> ，根据数据源或者数据访问方式的不同有一个或多个</li>
<li>实体类<ul>
<li>DTO：Data Transfer Object数据传输对象 （实现Serializable接口）</li>
<li>VO：Value Object 值对象</li>
<li>POJO：实体类</li>
</ul>
</li>
</ul>
<h3 id="header-4">ORM</h3>
<p>Object-Relational Mapping 对象关系映射</p>
<p>对象-关系映射：完成<strong>应用程序对象数据</strong>到<strong>关系型数据</strong>映射的机制
（利用程序我们把一个实体类的数据转化为关系型数据库表中的一行数据，或者把关系型数据库表中的一行数据转化为应用程序中的一个实体类）</p>
<ul>
<li><strong>ORM与DAO的关系：</strong>ORM是DAO接口针对关系型数据库的一种实现，本质上就是一个DAO实现类。</li>
<li><strong>ORM思想：</strong>将关系型数据库中的表记录映射成对象，程序员可以把对DB的操作转化为对Object的操作</li>
<li><strong>ORM框架：</strong>ORM思想的一个优雅实现，例如：Hibernate（JBoss），iBatis，Apache OJB，TopLink（Oracle），Castor JDO，...</li>
</ul>
<pre><code>应用对象数据 &lt;--------------------&gt; 关系型数据库
（实体类）        映射                （表）
</code></pre><p>一大堆类库，用面向对象的方式调用，它帮忙翻译成面向关系的方式
建立对象与表间关联，以简化编程，跨数据库平台</p>
<h3 id="header-5">JPA &amp; Hibernate</h3>
<p><strong>JPA</strong></p>
<p>Java Persistent API
一个ORM规范（即一个持久层规范，类（较少）与接口（较多）的集合），通过注解Annotation或XML描述的方式完成对象关系映射</p>
<p>意愿统一天下：像JDBC那样定义一个ORM规范，各ORM框架实现此规范（即各ORM框架实现JPA中的接口），这样只要学习了这个ORM规范就可以使用所有ORM框架了</p>
<p><strong>Hibernate</strong></p>
<p>hibernate是ORM思想的一个实现框架，先有Hibernate后有JPA，用Annotation来支持JPA官方标准</p>
<pre><code>Client –Object  save() -&gt;Hibernate-&gt; Persist()—DB
</code></pre><p>通过Hibernate实现Persist持久化到DB</p>
<p>Hibernate应用场景：</p>
<ul>
<li>不适合OLAP（On-Line Analytical Processing 联机分析处理）：以查询分析统计数据为主的系统，一般是条记录，不是对象</li>
<li>适合OLTP（On-Line Transaction Processing 联机事务处理）</li>
</ul>
<p>最佳实现：
1．设计细粒度的持久类，使用组件Component映射
。。。</p>
<h2 id="header-6">Starter</h2>
<ol>
<li>添加Hibernate依赖包<pre><code class="lang-xml"> &lt;dependency&gt;
     &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
     &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
     &lt;version&gt;xxx&lt;/version&gt;
 &lt;/dependency&gt;
</code></pre>
</li>
<li><p>建立hibernate 主配置文件hibernate.cfg.xml (可参考Hibernate jar包/project/etc/下的配置文件)</p>
<pre><code class="lang-xml"> &lt;hibernate-configuration&gt;
     &lt;session-factory&gt;
         &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.SQLServerDialect&lt;/property&gt;    &lt;!-- 方言，用来区别不同数据库--&gt;
         &lt;property name=&quot;connection.url&quot;&gt;jdbc:sqlserver://localhost:1433;databaseName=Bike&lt;/property&gt;
         &lt;property name=&quot;connection.username&quot;&gt;sa&lt;/property&gt;
         &lt;property name=&quot;connection.password&quot;&gt;Aa123456&lt;/property&gt;
         &lt;property name=&quot;connection.driver_class&quot;&gt;com.microsoft.sqlserver.jdbc.SQLServerDriver&lt;/property&gt;
         &lt;!--  &lt;property name=&quot;myeclipse.connection.profile&quot;&gt;Sql2008&lt;/property&gt;--&gt;
         &lt;!-- JDBC connection pool (use the built-in) --&gt;
                 &lt;property name=&quot;connection.pool_size&quot;&gt;2&lt;/property&gt;
         &lt;!--使用connection 数据库连接管理事务，使用connection连接管理事务(当前线程中找Session，只针对一个数据库) --&gt;
         &lt;property name=&quot;current_session_context_class&quot;&gt;thread&lt;/property&gt;

         &lt;!-- hbm：hibernate mapping; ddl：data defination language ; hbm2ddl：Hibernate自动生成建表语句 --&gt;
         &lt;property name=&quot;hbm2ddl.auto&quot;&gt;Validate&lt;/property&gt;    
         &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt;
         &lt;!-- 格式化显示输出sql --&gt;
         &lt;property name=&quot;format_sql&quot;&gt;true&lt;/property&gt;

         &lt;!-- 指明映射配置，两种方式：
         使用xml映射文件：&lt;mapping resource=&quot;com/java/entity/Guestbook.hbm.xml&quot; /&gt;，
         使用Annotation：&lt;mapping class=&quot;bike.entity.Product&quot;/&gt;--&gt;
         &lt;mapping class=&quot;bike.entity.Product&quot;/&gt;    
     &lt;/session-factory&gt;
 &lt;/hibernate-configuration&gt;
</code></pre>
</li>
<li>编写pojo实体类（可通过Hibernate反向工程自动生成）<pre><code class="lang-java">@Entity
@Table(name = &quot;product&quot;)
public class Product implements java.io.Serializable{
 //...
 @Id
 @GeneratedValue(strategy=IDENTITY)
 @Column(name = &quot;id&quot;, unique = true, nullable = false)
 public int getId(){
     return this.id;
 }
}
</code></pre>
</li>
</ol>
<h3 id="header-7">SessionFactory &amp; Session</h3>
<table class="table">
<thead>
<tr>
<th>SessionFactory</th>
<th>Session</th>
</tr>
</thead>
<tbody>
<tr>
<td>类似ConnectionPool数据库连接池, 用来产生和管理Session</td>
<td>从DB连接池中获取一个Connection挂到Session上,管理一个数据库的任务单元（简单说就是增 删 改 查）</td>
</tr>
<tr>
<td>线程安全，生命期长，一个数据库对应一个SessionFactory</td>
<td>非线程安全，生命期短，内部维护一级缓存和DB连接</td>
</tr>
</tbody>
</table>
<p><img src="/2013/06/01/hibernate-session.png" alt="Hibernate Session"></p>
<ol>
<li><p>创建SessionFactory ，通常情况下每个应用只需要一个SessionFactory（除非要访间多个数据库的情况）</p>
<pre><code class="lang-java"> //主要维护DB连接池,很消费资源，一般创建一个，可使用单例，放在static语句块中
 private static SessionFactory sf=null;
 static{
     try{
         //Hibernate3
         //Configuration config=new Configuration().configure();
         //sf=config.buildSessionFactory();

         //Hibernate4
         //Configuration cfg=new AnnotationConfiguration().configure();
         Configuration cfg = new Configuration().configure();
         ServiceRegistry serviceRegistry = new ServiceRegistryBuilder()
                 .applySettings(cfg.getProperties()).buildServiceRegistry();
         sf = cfg.buildSessionFactory(serviceRegistry);
     } 
     catch (HibernateException e){
         e.printStackTrace();
     }
 }
</code></pre>
</li>
<li><p>获取session</p>
<ul>
<li>使用<code>openSession</code> ,每次都是新的，需要手动close<pre><code class="lang-java">Session session=sf.openSession();
//使用session执行CRUD
...
session.close();
</code></pre>
</li>
<li>使用<code>getCurrentSession</code> 从上下文找，如果有，用旧的，如果没有，建新的, 界定事务边界，无需手动close，事务提交会自动close<pre><code class="lang-java">/* 使用getCurrentSession需在hibernate的xml主配置文件中配置：
&lt;property name=&quot;current_session_context_classs&quot;&gt;thread&lt;/property&gt;
*/
Session session=sf.getCurrentSession();
session.beginTransaction();
//使用session执行CRUD
...
session.getTransaction().commit();
</code></pre>
</li>
<li>hibernate的xml主配置文件中<code>current_session_context_class</code>说明：<ul>
<li><code>thread</code> 使用connection连接管理事务<ul>
<li>当前线程中找Session，只针对一个数据库</li>
</ul>
</li>
<li><code>jta</code> 全称java transaction api，-java分布式事务管理distributed transaction<ul>
<li>多数据库访问，分布在多台不同数据库上</li>
<li>eg：两个数据库操作放在一个事务里</li>
<li>ApplicationServer提供Transaction Manager（JTA事务）</li>
<li>Tomcat本身不可以，结合Spring可以，Jbass可以</li>
<li>jta由中间件提供（jboss WebLogic等，tomcat不支持）</li>
</ul>
</li>
<li><code>managed</code></li>
<li><code>custom.Class</code></li>
</ul>
</li>
</ul>
</li>
<li><p>使用Session执行CRUD</p>
<ul>
<li>save</li>
<li>get,load(Xxx.class,id): 都会首先査找缓存（一级缓存)，如果没有，才会去数据库査找<table class="table">
<thead>
<tr>
<th>方法</th>
<th>不同</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>load</td>
<td>返回的实际上是一个代理对象</td>
<td>等到真正用到对象的内容时才发出sql语句，即会产生延迟加载，故在真正使用前若不存在此对象不会报错</td>
</tr>
<tr>
<td>get</td>
<td>返回的是实际对象</td>
<td>马上会发出sql语句，直接从DB中加载，不会产生延迟</td>
</tr>
</tbody>
</table>
</li>
<li>update<ul>
<li>用来更新detached对象，更新完成后转为persistent状态</li>
<li>更新transient对象会报错，更新自己设定id的transient对象可以（数据库有对应记录）</li>
<li>persistent状态的对象只要设定（如:t.setName…）不同字段提交时就会发生更新，若跟原来字段值相同则不更新</li>
</ul>
</li>
<li>delete</li>
<li>saveOrUpdate,merge</li>
<li>clear 强制清空Session缓存</li>
<li>flush 强制将内存(session缓存)与数据库同步,即将Session缓存中内容提交到DB<ul>
<li>默认情况下是当session的事务提交后，强制将内存(session缓存)与数据库同步</li>
<li>设定何时同步缓存与数据库session.FlushMode(FlushMode.XXX) ，很少用</li>
<li>例如: <code>session.setFlushMode(FlushMode.AUTO)</code>（需在session.beginTransaction()前调用，默认为AUTO；在调节性能时可能会用到此方法）</li>
</ul>
</li>
<li>...</li>
</ul>
</li>
<li><p>可使用泛型DAO封装SessionFactory，Transaction事务，方便在项目中调用</p>
</li>
</ol>
<h2 id="header-8">主键</h2>
<h3 id="header-9">生成策略</h3>
<ol>
<li><code>AUTO</code> 相当于NATIVE，取决于底层数据库类型,eg:<ul>
<li>对 MySQL使用auto_increment</li>
<li>对 Oracle使用hibernate_sequence(sequence名称固定为hibernate_sequence）</li>
</ul>
</li>
<li><code>IDENTITY</code> 自动增长</li>
<li><code>SEQUENCE</code> 序列<ul>
<li>对于Oracle，默认使用<code>hibernate_sequence</code>（插入数据时先执行<code>Select hibernate_sequence.nextval from dual</code>然后执行insert）</li>
<li>可自定义在数据库生成指定的sequence名，结合<code>@SequenceGenerator</code>使用</li>
</ul>
</li>
<li><code>TABLE</code> 借助数据库表，表中保存当前标识属性的最大值<ul>
<li>一张表可提供无限多个ID值</li>
<li>跨数据平台时有用， eg： 类库可应用在任何数据库平台上</li>
<li>结合<code>@TableGenerator</code>使用</li>
</ul>
</li>
<li><code>uuid</code>结合<code>@GenericGenerator</code>使用</li>
</ol>
<p>使用举例：</p>
<ul>
<li><p>使用<strong>Annotation</strong>方式（加在get主键方法上）</p>
<pre><code class="lang-java">  //auto
  @Id
  @GeneratedValue(strategy=GenerationType.AUTO)

  //identity
  @Id
  @GeneratedValue(strategy=GenerationType.IDENTITY)

  //sequence（默认使用hibernate_sequence）
  @Id
  @GeneratedValue(strategy=GenerationType.SEQUENCE)

  //指定sequence名
  //&quot;teacherSEQ&quot;为@SequenceGenerator的标识名
  //&quot;teacherSEQ_DB&quot;为指定到数据库生成的Sequence名
  @Id
  @GeneratedValue(strategy=GenerationType.SEQUENCE,generator=&quot;teacherSEQ&quot;)
  @SequenceGenerator(name=&quot;teacherSEQ&quot;, sequenceName=&quot;teacherSEQ_DB&quot;) 

  //table
  @Id
  @GeneratedValue(strategy=GenerationType.TABLE,generator=&quot;teacherID&quot;)
  @TableGenerator(name=&quot;teacherID&quot;,
          table=&quot;teacherID_DB&quot;,
          pkColumnName=&quot;key_value&quot;,
          pkColumnValue=&quot;pk_value&quot;,
          valueColumnName=&quot;teacher&quot;,
          allocationSize=1)

  public int getId() 
  {
      return id;
  }
</code></pre>
</li>
<li>使用<strong>xml</strong>方式：<pre><code class="lang-xml">  &lt;!-- 常用四个：native identity sequence uuid（native uuid跨平台）--&gt;
  &lt;id name=&quot;id&quot; &gt;
      &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt;
  &lt;/id&gt;
</code></pre>
</li>
</ul>
<h3 id="header-10">联合主键</h3>
<ol>
<li><p>将联合主键的属性提取出来,重新编写一个pojo类</p>
<pre><code class="lang-java">/*
实现 java.io.Serializable 序列化接口（此为标记性接口，不用实现任何方法）
重写equals和hashCode方法 （用于确保内存PK的唯一性）
*/
public class StudentPK  implements Serializable 
{
    private String id;
    private String name;
    … …
    //get/set 方法
    ... ...

    //重写equals方法
    @Override
    public boolean equals(Object o) 
    {
        if(o instanceof StudentPk) 
        {
            StudentPk pk = (StudentPk)o;
            if(this.id == pk.getId() &amp;&amp; this.name.equals(pk.getName())) 
            {
                  return true;
            }
        }
        return false;
    }

    //重写hashcode方法
    @Override
    public int hashCode()
    {
        return this.name.hashCode();
    }
}
</code></pre>
</li>
<li><p>XML配置方式(composite-id)</p>
<pre><code class="lang-xml"> &lt;!-- 原pojo类Student中删除id，name属性，并加入新属性“StudentPK”--&gt;
 &lt;hibernate-mapping&gt;
     &lt;class name=&quot;com.bjsxt.pojo.Student&quot; &gt;
         &lt;composite-id name=&quot;studentPK&quot; class=&quot;com.bjsxt.pojo.StudentPK&quot;&gt;
             &lt;key-property name=&quot;id&quot;&gt;&lt;/key-property&gt;
             &lt;key-property name=&quot;name&quot;&gt;&lt;/key-property&gt;
         &lt;/composite-id&gt;
         &lt;property name=&quot;age&quot; /&gt;
         &lt;property name=&quot;sex&quot; /&gt;
         &lt;property name=&quot;good&quot; type=&quot;yes_no&quot;&gt;&lt;/property&gt;
     &lt;/class&gt;
 &lt;/hibernate-mapping&gt;
</code></pre>
</li>
<li><p><strong>Annotation 配置方式</strong></p>
<ul>
<li><p>方法1: 使用<code>@Embeddable</code></p>
<pre><code class="lang-java">//提取主键的主键类StudentPK上加 @Embeddable（可导入的，可注入的）
@Embeddable
public class StudentPK implements Serializable 
{
  private String id;
  private String name;
      … …
}

//pojo类Student的新属性“StudentPK“的get方法前加@Id
@Entity
public class Student 
{
  private StudentPK studentPK ;
  @Id
  public StudentPK getStudentPK() 
  {
      return studentPK;
  }
  … … 
}
</code></pre>
</li>
<li><p>方法2：联合主键上使用<code>@EmbeddedlD</code></p>
<pre><code class="lang-java">//主键类StudentPK不加注解
public class StudentPK implements Serializable{
  private String id;
  private String name;
      … …
}

//pojo类Student新属性“studentPK”的get方法前写@EmbeddedlD
@Entity
public class Student{
  private StudentPK studentPK ;
  @EmbeddedlD
  public StudentPK getStudentPK() {
      return studentPK;
  }
  … … 
}
</code></pre>
</li>
<li><p>方法3(推荐)：pojo类上使用<code>@IdClass</code></p>
<pre><code class="lang-java">//主键类StudentPK不加注解
public class StudentPK implements Serializable{
  private String id;
  private String name;
      … …
}

//pojo类Student前加“@IdClass(StudentPK).class)”,保留 id，name属性并加@Id
@Entity
@IdClass(StudentPK.class)
public class Student {
  private String id;
  private String name;
  @Id
  public String getId() {
      return id;
  }
  @Id
  public String getName() {
      return name;
  }
  ... ...
}
</code></pre>
</li>
</ul>
</li>
</ol>
<p>说明：</p>
<ol>
<li>序列化应用环境<ul>
<li>系统集群</li>
<li>虚拟内存（内存空间满了，需要通过序列化将对象暂存到虚拟空间（硬盘上））</li>
</ul>
</li>
<li>DB记录读入内存，从内存读取对象：<ul>
<li>从表Student中读取记录装入内存的哈希表中，需计算对象Student主键PK的HashCode然后插入哈希表中；</li>
<li>在哈希表中查找内容是否相同时：首先遍历HashCode，然后使用equals判断HashCode相同的各个对象</li>
<li>可使用Commonclipse：Commons lang builder插件帮助生成</li>
</ul>
</li>
</ol>
<h3 id="header-11">对象状态</h3>
<p>三种状态：</p>
<table class="table">
<thead>
<tr>
<th>状态</th>
<th>Session缓存中</th>
<th>DB中</th>
</tr>
</thead>
<tbody>
<tr>
<td>Transient 瞬时透明</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>Persistent 持久化的</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>Detached 托管的（脱离Session管理）</td>
<td>无</td>
<td>有</td>
</tr>
</tbody>
</table>
<p>三种状态的区分关键在于:</p>
<ol>
<li>有没有ID</li>
<li>ID在数据库中有没有</li>
<li>在内存中有没有（session缓存）</li>
</ol>
<p><img src="/2013/06/01/object-state.png" alt="object state"></p>
<h2 id="header-12">映射</h2>
<h3 id="header-13">关系映射</h3>
<p>对象之间的关系（不是指数据库的关系）</p>
<ol>
<li><p>映射关系：<code>@OneToOne</code>,<code>@OneToMany</code>,<code>@ManyToOne</code>,<code>@ManyToMany</code></p>
<ul>
<li><code>mappedBy</code>： 设置双向关联</li>
<li><code>cascade</code> ：设置对象间的级联操作<ul>
<li>只对增删改<code>CUD</code>起作用 （Create,Update,Delete）</li>
<li><code>cascade={CascadeType.xxx}</code>，CascadeType取值：<ul>
<li><code>ALL</code>：Cascade all operations所有情况</li>
<li><code>MERGE</code>：Cascade merge operation合并(merge=save+update)</li>
<li><code>PERSIST</code>：Cascade persist operation存储 persist()</li>
<li><code>REFRESH</code>：Cascade refresh operation刷新</li>
<li><code>REMOVE</code>：Cascade remove operation删除</li>
</ul>
</li>
</ul>
</li>
<li><code>fetch</code> ：设置抓起策略<ul>
<li>只对读取<code>R</code>起作用（Select）</li>
<li><code>fetch=FetchType.xxx</code>，FetchType取值：<ul>
<li><code>EAGER</code>：取出关联 （注意：双向不要两边设置Eager，否则会有多余的査询语句发出）</li>
<li><code>LAZY</code>：不取关联，即延迟加载 （注意：需要在commit()之前， session还存在时取关联对象）</li>
</ul>
</li>
</ul>
</li>
<li><p>例如：</p>
<pre><code class="lang-java">@OneToMany(mappedBy=&quot;parent&quot;, cascade={CascadeType.ALL}, fetch=FetchType.EAGER)
public List&lt;Tree&gt; getChildren() {...}
</code></pre>
</li>
</ul>
</li>
<li><p>关联外键字段设置：</p>
<ul>
<li><code>@JoinColumn</code> 指定关联的DB字段<ul>
<li><code>@JoinColumn(name=”对应DB表中的列名”)</code></li>
</ul>
</li>
<li><code>@JoinColumns</code> 关联联合主键<ul>
<li><code>@JoinColumns({ @JoinColumn(name=”...”, referencedColumnName=”...”) , ... })</code></li>
<li>例如：<pre><code class="lang-java">@OneToOne
@JoinColumns( { 
  @JoinColumn(name = &quot;wifeid&quot;, referencedColumnName = &quot;id&quot;),
  @JoinColumn(name = &quot;wifename&quot;, referencedColumnName = &quot;name&quot;) 
})
public Wife getWife() {……}
</code></pre>
</li>
</ul>
</li>
<li><p><code>@JoinTable</code> 多对多关联，指定中间表</p>
<ul>
<li><code>@JoinTable(name=”中间表名”,joinColumns={@JoinColumn(...)},inverseJoinColumns={@JoinColumn(...)})</code></li>
<li><code>name</code>指明中间表表名；</li>
<li><code>joinColumns</code>包含@JoinColumn数组，指明本类主键在中间表中对应的字段名；</li>
<li><code>inverseJoinColumns</code>包含@JoinColumn数组，指明对方类主键在中间表中的字段名</li>
<li><p>例如：</p>
<pre><code class="lang-java">@ManyToMany
@JoinTable(name=&quot;t_s&quot;, //指定中间表表名
      joinColumns={@JoinColumn(name=&quot;teacherid&quot;)},//本类主键在中间表生成的对应字段名
      inverseJoinColumns={@JoinColumn(name=&quot;studentid&quot;)}//对方类主键在中间表生成的对应字段名
  )
public Set&lt;Student&gt; getStudents(){...}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>使用举例：</p>
<ol>
<li><p>OneToOne （使用外键 mappedBy）</p>
<table class="table">
<thead>
<tr>
<th>名称</th>
<th>表</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>Husband</td>
<td>id,name,<strong>wifeid</strong> （FK：wifeid）</td>
<td>id,name,<strong>wife</strong></td>
</tr>
<tr>
<td>Wife</td>
<td>id,name</td>
<td>id,name,<strong>(husband)</strong></td>
</tr>
</tbody>
</table>
<p> xml方式：</p>
<pre><code class="lang-xml"> &lt;!-- 单向 many-to-one， unique=&quot;true&quot;，保证生成的字段唯一,这样many-to-one 也达到了一对一的效果 --&gt;
 &lt;class name=&quot;com.bjsxt.pojo.Husband&quot;&gt;
         &lt;id name=&quot;id&quot;&gt;
             &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt;
         &lt;/id&gt;
         &lt;property name=&quot;num&quot;/&gt;
         &lt;many-to-one name=&quot;wife&quot; column=&quot;wifeId&quot; unique=&quot;true&quot;&gt;
 &lt;/many-to-one&gt;
 &lt;/class&gt;

 &lt;!-- 双向many-to-one unique ，one-to-one property-ref（相当于mappedBy）,Wife.hbm.xml文件中加 ：--&gt;
 &lt;one-to-one name=&quot;husband&quot; property-ref=&quot;wife&quot;&gt;&lt;/one-to-one&gt;
</code></pre>
<p> Annotation方式：</p>
<pre><code class="lang-java"> @Entity
 public class Husband
 {
     private int id;
     private String name;
     private Wife wife;
     ...
     @OneToOne
     @JoinColumn(name=&quot;wifeid&quot;) //指定对应的DB字段名
     public Wife getWife()
     {
         return wife;
     }
 }

 //设置双向关联：增加husband属性，getHusband方法（若不加mappedby会生成2个映射关系FK）
 @Entity
 public class Wife
 {
     private int id;
     private String name;
     private Husband husband;
     ...
     @OneToOne(mappedBy=&quot;wife&quot;) //指定这个一对一关联是被Husband类的 wife属性(准确说是getWife方法)映射
     public Husband getHusband()
     {
         return husband;
     }
 }
</code></pre>
</li>
<li><p>OneToOne （使用主键  @PrimaryKeyJoinColumn）</p>
<table class="table">
<thead>
<tr>
<th>名称</th>
<th>表</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>Husband</td>
<td>id,name</td>
<td>id,name,<strong>wife</strong></td>
</tr>
<tr>
<td>Wife</td>
<td>id,name</td>
<td>id,name,<strong>husband</strong></td>
</tr>
<tr>
<td>Husband(id)  reference wife（id）</td>
<td>/</td>
<td>/</td>
</tr>
</tbody>
</table>
<p> xml方式：</p>
<pre><code class="lang-xml"> &lt;!-- 单项：one-to-one id （有bug，不会为两张表生成外键的参考关系,容易产生id不一致的现象）--&gt;
 &lt;one-to-one  name=&quot;wife&quot; constrained=&quot;true&quot;/&gt;
     &lt;id&gt;
         &lt;!--Husband的主键应参考Wife的主键生成--&gt;
         &lt;generator class=&quot;foreign&quot;&gt;
             &lt;!-- 指定靠哪个属性上的外键关系生成主键 --&gt;
             &lt;param name=&quot;property&quot;&gt;wife&lt;/param&gt; 
         &lt;/generator&gt;
     &lt;/id&gt;
 &lt;/one-to-one&gt;

 &lt;!-- 双向：one-to-one id 使用foreign class和one-to-one property-ref --&gt;
 &lt;one-to-one name=”husband”,property-ref=”wife”/&gt;
</code></pre>
<p> Annotation方式：</p>
<pre><code class="lang-java"> @Entity
 public class Husband
 {
     private int id;
     private String name;
     private Wife wife;
     ...
     @oneToOne
     @PrimaryKeyJoinColumn
     public Wife getWife()
     {
         return wife;
     }
 }

 @Entity
 public class Wife
 {
     private int id;
     private String name;
     private Husband husband;
     ...
     @oneToOne
     @PrimaryKeyJoinColumn(mappedBy=”wife”)
     public Husband getHusband()
     {
         return husband;
     }
 }
</code></pre>
</li>
<li><p>OneToOne （使用联合主键 @JoinColumns）</p>
<table class="table">
<thead>
<tr>
<th>名称</th>
<th>表</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>Husband</td>
<td>id,name,<strong>wifeId</strong>,<strong>wifeName</strong></td>
<td>id,name,<strong>wife</strong></td>
</tr>
<tr>
<td>Wife</td>
<td><strong>id</strong>,<strong>name</strong> （联合主键）</td>
<td>id,name</td>
</tr>
</tbody>
</table>
<pre><code class="lang-java"> @Entity
 public class Husband
 {
     private int id;
     private String name;
     private Wife wife;
     ...
     @OneToOne
     @JoinColumns( { @JoinColumn(name = &quot;wifeid&quot;, referencedColumnName = &quot;id&quot;),
             @JoinColumn(name = &quot;wifename&quot;, referencedColumnName = &quot;name&quot;) })
     public Wife getWife() {……}
 }

 //Wife类中建立联合主键,建立方式参考 ID生成策略中的联合主键部分
 ...
</code></pre>
</li>
<li><p>@ManyToOne （多对一，单项）</p>
<table class="table">
<thead>
<tr>
<th>名称</th>
<th>表</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>User</td>
<td>id,name,<strong>groupId</strong> (FK:groupId)</td>
<td>id,name,<strong>group</strong>  (多)</td>
</tr>
<tr>
<td>Group</td>
<td>id,name</td>
<td>id,name  (一)</td>
</tr>
</tbody>
</table>
<p> xml方式：</p>
<pre><code class="lang-xml"> &lt;many-to-one name=&quot;group&quot; column=&quot;groupid&quot; cascade=&quot;all&quot;/&gt;
</code></pre>
<p> Annotation方式：</p>
<pre><code class="lang-java"> @Entity
 public class User
 {
     private int id;
     private String name;
     private Group group;
     ...
     @ManyToOne
     @JoinColumn(name=”groupId”)  //指定对应的DB字段名
     public Group getGroup() {...}
 }
</code></pre>
</li>
<li><p>@OneToMany （一对多，单项）</p>
<table class="table">
<thead>
<tr>
<th>名称</th>
<th>表</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>User</td>
<td>id,name,<strong>groupId</strong> (FK:groupId)</td>
<td>id,name (多)</td>
</tr>
<tr>
<td>Group</td>
<td>id,name</td>
<td>id,name,<strong>Set<User> users</strong> (一)</td>
</tr>
</tbody>
</table>
<p> xml方式：</p>
<pre><code class="lang-xml"> &lt;class name=&quot;com.hibernate.Group&quot; table=&quot;t_group&quot;&gt;
     &lt;id name=&quot;id&quot;&gt;
         &lt;generator class=&quot;native&quot;/&gt;
     &lt;/id&gt;
     &lt;property name=&quot;name&quot;/&gt;
     &lt;set name=&quot;users&quot;&gt;
         &lt;key column=&quot;groupId&quot;/&gt;    &lt;!-- 指定生成外键字段的名字--&gt;
         &lt;one-to-many class=&quot;com.pojo.User&quot;/&gt;
     &lt;/set&gt;
 &lt;/class&gt;
</code></pre>
<p> Annotation方式：</p>
<pre><code class="lang-java"> public class Group
 {
     private int id;
     private String name;
     private Set&lt;User&gt; users = new HashSet&lt;User&gt;();
     ...
     @OneToMany
     @JoinColumn(name=”groupId”) //指定User表中生成与Group对应的字段名
     public Set&lt;User&gt; getUsers() {...}
 }
</code></pre>
</li>
<li><p>@ManyToOne &amp; @OneToMany （一对多和多对一，双向）</p>
<table class="table">
<thead>
<tr>
<th>名称</th>
<th>表</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>User</td>
<td>id,name,<strong>groupId</strong> (FK:groupId)</td>
<td>id,name,<strong>group</strong>  (多)</td>
</tr>
<tr>
<td>Group</td>
<td>id,name</td>
<td>id,name,<strong>Set<User> users</strong> (一)</td>
</tr>
</tbody>
</table>
<p> xml方式：
 务必确保在多的一端生成的生成的外键和一的一方生成的外键的名字相同,都为groupId.如果名字不同则会在多的一端生成多余的外键</p>
<p> Annotation方式：</p>
<pre><code class="lang-java"> //在多的一端User配置group
 @ManyToOne
 @JoinColumn(name=&quot;groupid&quot;)

 //在一的一端Group配置users
 @OneToMany(mappedBy=&quot;group&quot;)
</code></pre>
</li>
<li><p>@ManyToMany (多对多)</p>
<table class="table">
<thead>
<tr>
<th>名称</th>
<th>表</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>Teacher</td>
<td>id,name</td>
<td>id,name,Set<Student> students</td>
</tr>
<tr>
<td>Student</td>
<td>id,name</td>
<td>id,name,Set<Teacher> teacher</td>
</tr>
<tr>
<td>中间表t_s</td>
<td>teacherId，studentId</td>
<td>/</td>
</tr>
</tbody>
</table>
<p> xml方式：</p>
<pre><code class="lang-xml"> &lt;!-- 单项：--&gt;
 &lt;class name=&quot;com.xxx.Teacher&quot;&gt;
     &lt;id name=&quot;id&quot;&gt;
         &lt;generator class=&quot;native&quot;/&gt;
     &lt;/id&gt;
     &lt;property name=&quot;name&quot;/&gt;
     &lt;set name=&quot;students&quot; table=&quot;t_s&quot;&gt;table定义中间表的表名
         &lt;key column=&quot;teacher_id&quot;&gt;&lt;/key&gt;
         &lt;many-to-many class=&quot;com.xxx.Student&quot; column=&quot;student_id&quot;/&gt;
     &lt;/set&gt;
 &lt;/class&gt;

 &lt;!-- 双向:两端配置一样,注意表名和生成的中间表的字段属性名要一致（table=”t_s”,column错开对应）--&gt;
 &lt;!-- Teacher那一端配置：--&gt;
 &lt;set name=&quot;students&quot; table=&quot;t_s&quot;&gt;
         &lt;key column=&quot;teacher_id&quot;/&gt;
         &lt;many-to-many class=&quot;com.xxx.Student&quot; column=&quot;student_id&quot;/&gt;
 &lt;/set&gt;
 &lt;!-- 在Student那一端配置：--&gt;
 &lt;set name=&quot;teachers&quot; table=&quot;t_s&quot;&gt;
         &lt;key column=&quot;student_id&quot;&gt;&lt;/key&gt;
         &lt;many-to-many class=&quot;com.xxx.Teacher&quot; column=&quot;teacher_id&quot;/&gt;
 &lt;/set&gt;
</code></pre>
<p> Annotation方式：</p>
<pre><code class="lang-java"> //Teacher是主的一方 Student是附属的一方
 @Entity
 public class Teacher
 {
     private int id;
     private String name;
     private Set&lt;Student&gt; students=new HashSet&lt;Student&gt;();
     ...
     @ManyToMany
     @JoinTable(name=&quot;t_s&quot;, //指定中间表表名
         joinColumns={@JoinColumn(name=&quot;teacherid&quot;)},//本类主键在中间表生成的对应字段名
         inverseJoinColumns={@JoinColumn(name=&quot;studentid&quot;)}//对方类主键在中间表生成的对应字段名
     )
     public Set&lt;Student&gt; getStudents(){...}
 }

 //双向关联，注意：mappedBy 与 @JoinTable等一类的配置要分开，不然表字段可能乱
 @Entity
 public class Student
 {
     private int id;
     private String name;
     private Set&lt;Teacher&gt; teacher=new HashSet&lt;Teacher&gt;();
     ...
     @ManyToMany(mappedBy=”students”)
     public Set&lt;Teacher&gt; getTeachers(){...}
 }
</code></pre>
</li>
</ol>
<h3 id="header-14">组件映射</h3>
<p>对象关系：一个对象是另外一个对象的一部分
数据库表：一张表</p>
<table class="table">
<thead>
<tr>
<th>表</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>Husband：id,name,wifename,wifeage</td>
<td>对象Husband ：id,name,<strong>Wife wife</strong></td>
</tr>
<tr>
<td>/</td>
<td>对象Wife：name,age</td>
</tr>
</tbody>
</table>
<pre><code class="lang-java">public class Husband
{
    //id,name,wife
    ...
    @Embedded //表明该对象是从别的位置嵌入过来的,是不需要单独映射的表
    Public Wife getWife()
    { return wife;}
}

@Embeddable //写在分类（Wife类）的类名前的，不过好像不写也行
public class Wife {… …}
</code></pre>
<p><strong>PS</strong>: 若Husband与Wife两个类中都有name字段,这样在生成表的时候会有冲突</p>
<p>解决方案：</p>
<ul>
<li>方法一：重新指定生成的Wife类组件生成的字段名<ul>
<li>使用 @AttributeOverride注解，写在getWife方法上 （不常用）</li>
<li>指定Wife类中的name属性对应新的字段名—“wifename”</li>
</ul>
</li>
<li>方法二（更好的解决方法）：<ul>
<li>不要在组件的两个映射类中写同名属性；</li>
<li>如果真的有重复，在分类中（此处为Wife类）的重复名称的属性上使用@Column指定新的字段名</li>
<li>Annotation方式：<pre><code class="lang-java">@Column(name=&quot;wifename&quot;)
public String getName() 
{return name;}
</code></pre>
</li>
<li>xml方式: component<pre><code class="lang-xml">&lt;class name=&quot;Husband&quot; &gt;
  &lt;id name=&quot;id&quot;&gt;
      &lt;generator class=&quot;native&quot;/&gt;
  &lt;/id&gt;
  &lt;property name=&quot;name&quot;&gt;&lt;/property&gt;
  &lt;component name=&quot;wife&quot;&gt;
      &lt;property name=&quot;wifeName&quot;/&gt;
      &lt;property name=&quot;wifeAge&quot;/&gt;
  &lt;/component&gt;
&lt;/class&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="header-15">集合映射</h3>
<p>Set,List,Map （注意：JPA1.0 目前不支持基础数据映射）</p>
<pre><code class="lang-java">//List (与Set差不多 多个@OrderBy)
@OrderBy(&quot; name asc&quot;)
getXXX(){...}

//Map
@Mapkey(name=&quot;id&quot;)
getXXX(){...}

for(Map.Entry&lt;Integer,User&gt; entity:g.getUsers().entrySet())
{ System.out.println(entry.getValue().getName());}
</code></pre>
<h3 id="header-16">继承映射</h3>
<p>继承映射：<code>@Inheritance</code>子类的Id都由父类中指定的方式生成，三种方式(InheritanceType)：<code>SINGLE_TABLE</code>,<code>TABLE_PER_CLASS</code>,<code>JOINED</code></p>
<ol>
<li><p><code>SINGLE_TABLE</code> 一张总表, 字段多的话会造成大冗余</p>
<table class="table">
<thead>
<tr>
<th>表</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>Person (id,name,score,title,discriminator)</td>
<td>Student：id,name,score</td>
</tr>
<tr>
<td>/</td>
<td>Teacher：id,name,title</td>
</tr>
</tbody>
</table>
<pre><code class="lang-java"> @Entity
 @Inheritance(strategy=InheritanceType.SINGLE_TABLE)    
 @DiscriminatorColumn(name=&quot;discriminator&quot;,discriminatorType=DiscriminatorType.STRING)
 @DiscriminatorValue(&quot;person&quot;)
 public class Person
 {    ...            //属性id,name 
     @Id
     @GenerateValue
     public void getId(){return id;}
 }

 @Entity
 @DiscriminatorValue(&quot;student&quot;)
 public class Student extends Person    //注意不要标注@Id了
 {... }    //属性score

 @Entity
 @DiscriminatorValue(&quot;teacher&quot;)
 public class Teacher extends Person    //注意不要标注@Id了
 {...}    //属性title
</code></pre>
</li>
<li><p><code>TABLE_PER_CLASS</code> 每个类分别一张表</p>
<ul>
<li>在load或get数据时建议直接用子类</li>
<li>若用多态去获取，会Union所有对象再根据id查询</li>
<li><p>例如：使用(Person.class,1),会 select from ( person  union student union teacher ) =&gt; 包含所有字段的表，相当于Single Table</p>
<table class="table">
<thead>
<tr>
<th>表</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>Person(id,name)</td>
<td>Person(id,name)</td>
</tr>
<tr>
<td>Student(id,name,score)</td>
<td>Student (score) extends Person</td>
</tr>
<tr>
<td>Teacher(id,name,title)</td>
<td>Teacher (title)  extends Person</td>
</tr>
<tr>
<td>t_gen_table(t_pk,t_value)</td>
<td>/</td>
</tr>
</tbody>
</table>
<p>注意： Person，Student，Teacher表的id各不相同</p>
<pre><code class="lang-java">@Entity
@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)
@TableGenerator{
  name=&quot;t_gen&quot;,table=&quot;t_gen_table&quot;,
  pkColumnName=&quot;t_pk&quot;,valueColumnName=&quot;t_value&quot;,
  pkColumnValue=&quot;person_pk&quot;,initialValue=1,allocationSize=1}   //Oracle 可用一个Sequence
public class Person    //属性 id,name
{    ...
  @Id
  @GeneratedValue(generator=&quot;t_gen&quot;,strategy=GenerationType.TABLE)
  public int getId(){ return id; }
} 

@Entity
public class Student extends Person   //其他注解什么都不需要加
{..} // 属性score

@Entity
public class Teacher extends Person  /其他注解什么都不需要加
{...} //属性title
</code></pre>
</li>
</ul>
</li>
<li><p><code>JOINED</code> 每个子类一张表（这种用的相对多些）</p>
<ul>
<li>用子对象插入和读取是都会关联两张表（父和子）</li>
<li><p>用多态父类获取时会关联所有表</p>
<table class="table">
<thead>
<tr>
<th>表</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>Person(id,name)</td>
<td>Person(id,name)</td>
</tr>
<tr>
<td>Student(id,score)</td>
<td>Student (score) extends Person</td>
</tr>
<tr>
<td>Teacher(id,title)</td>
<td>Teacher (title)  extends Person</td>
</tr>
</tbody>
</table>
<p>注意： Student id 参考Person(id) ，Teacher id 参考 Person(id)</p>
<pre><code class="lang-java">@Entity
@Inheritance(strategy=InheritanceType.JOINED)
public class Person //属性 id,name
{...
@Id
@GenerateValue
public void getId(){return id;}
}

@Entity
public class Student extends Person   //其他注解什么都不需要加
{..} // 属性score

@Entity
public class Teacher extends Person  /其他注解什么都不需要加
{...} //属性title
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="header-17">综合实例</h3>
<ol>
<li><p>Student，Score(中间表),Course</p>
<table class="table">
<thead>
<tr>
<th>名称</th>
<th>表</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>Student</td>
<td>id,name</td>
<td>（多）   id,name,Set<Course> courses</td>
</tr>
<tr>
<td>Course</td>
<td>id,name</td>
<td>（多）  id,name,Set<Student> students</td>
</tr>
<tr>
<td>Score</td>
<td>id,student_id,course_id，score</td>
<td>（中间）  id,student,course,score</td>
</tr>
</tbody>
</table>
<pre><code class="lang-java"> @Entity
 public class Student
 {
     private int id;
     private string name;
     private Set&lt;Course&gt; courses=new HashSet&lt;Course&gt;();
     ...
     @ManyToMany
     @JoinColumns(name=&quot;score&quot;,
         joinColumns={@JoinColumn(name=&quot;student_id&quot;)},
         inverseJoinColumns={@JoinColumn(name=&quot;course_id&quot;)}
         )
     public Set&lt;Course&gt; getCourses(){ return courses;}
 } 

 @Entity
 public class Course
 {
     private int id;
     private string name;
     ...
 } 

 @Entity
 public class Score
 {
     private int id;
     private int score;
     private Student student;
     private Course course;
     ....
     @ManyToOne
     @JoinColumn(name=&quot;student_id&quot;)
     public Student getStudent(){return student;}

     @ManyToOne
     @JoinColumn(name=&quot;course_id&quot;)
     public Course getCourse(){return course;}
     ...
 }
</code></pre>
</li>
<li><p>Tree树状结构(在同—个类中使用OneToMany和ManyTo0ne)</p>
<table class="table">
<thead>
<tr>
<th>名称</th>
<th>表</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tree</td>
<td>id,name,<strong>parentId</strong></td>
<td>id,name,<strong>Tree parent</strong>,<strong>List<Tree> children</strong></td>
</tr>
</tbody>
</table>
<pre><code class="lang-java"> public class Tree{
     private int id;
     private String name;
     private Tree parent;
     private List&lt;Tree&gt; children = new ArrayList&lt;Tree&gt;();  // 可用Set
     ...
     @ManyToOne
     @JoinColumn(name=&quot;parent_id&quot;)
     public Tree getParent(){ 
         return parent; 
     }

     //@OneToMany的fetch默认为LAZY
     //若树形较小 可使用EAGER 一次全部载入内存
     //若为LAZY则查询树形时不会一次全部载入内存(适用于较大的树形),会每取一个叶子节点就select一次(可结合Ajax，异步调用)
         @OneToMany(mappedBy=&quot;parent&quot;,
             cascade={CascadeType.ALL},
             fetch=FetchType.EAGER   )
     public List&lt;Tree&gt; getChildren() {
         return children;
     }
 }

 //调用打印树：
 public void print(Tree root){    //递归打印
     System.out.println(root.getName());
     for(Tree t : root.getChildren())
     {
          print(t);
     }
 }
 public void print(Tree root,int level ){    //递归打印成树状结构
     String preStr=&quot;&quot;;
     for(int i=0;i&lt;level;i++)
         preStr+=&quot;----&quot;;
     System.out.println(preStr+root.getName());
     for(Tree t : root.getChildren()){
          print(t,level+1); 
     }
 }
</code></pre>
</li>
</ol>
<h2 id="header-18">查询</h2>
<p>查询效率：
NativeSQL &gt;HQL.&gt; EJBQL(JPQL 1.0) &gt; QBC(Query By Criteria) &gt; QBE(Query By Example)</p>
<h3 id="header-19">NativeSQL</h3>
<p>原生SQL查询（使用数据库本身的查询语言），使用<code>session.createSQLQuery</code></p>
<p>举例：</p>
<pre><code class="lang-java">SQLQuery q=session.createSQLQuery(&quot;select * from category limit 2,4&quot;).addEntity(Category.class);
List&lt;Category&gt; categoryList=(List&lt;Category&gt;)q.list();

//使用别名，将c这个别名映射为Category类
SQLQuery q=session.createSQLQuery(&quot;select  {c.*}  from category c,topic t where c.topicid=topic.id and c.id=:categoryId&quot;);
q.addEntity(&quot;c&quot;,Category.class);
q.setInteger(&quot;categoryId&quot;,2);
List&lt;Category&gt; categoryList=(List&lt;Category&gt;)q.list();

//投影查询
SQLQuery q=session.createSQLQuery(&quot;select  c.id,c.name  from category c,topic t where c.topicid=t.id&quot;);
q.addScalar(&quot;id&quot;,Hibernate.INTEGER).addScalar(&quot;name&quot;,Hibernate.STRING);
q.setResultTransformer(Transformers.aliasToBean(Category.class));
List&lt;Category&gt; categoryList=(List&lt;Category&gt;)q.list();
</code></pre>
<h3 id="header-20">HQL</h3>
<p>Hibernate Query Language （Hibernate查询语言），使用<code>session.createQuery</code></p>
<p>方法举例：</p>
<ul>
<li>sql中设置参数，使用<code>:XXX</code> 相当于prepareStatement 预留变量,可以是基本变量，也可以是对象</li>
<li><code>q.setParameter(XXX,value);</code> 自动转换</li>
<li><code>q.setXXX(...);</code> 指定转换类型，eg：<code>setInteger(XXX,value);</code></li>
<li><code>q.list();</code>    </li>
<li><code>q.uniqueResult();</code></li>
<li><code>q.executeUpdate();</code></li>
</ul>
<p>使用举例：</p>
<ol>
<li><p>连接查询 （对象需建立关联）</p>
<pre><code class="lang-sql"> -- 不需要再写on连接条件，这里是inner join
 -- 注意：这里必须写t.category
 select t.title,c.name from Topic t join t.category c

 //迫切连接查询
 Select c from Category c join fetch c.topics
</code></pre>
</li>
<li><p>&quot;from ...&quot; 返回实体对象:</p>
<pre><code class="lang-java"> q=session.createQuery(&quot;from Category c where c.id&gt;:min and c.id&lt;:max&quot;);
 q.setParameter(&quot;min&quot;,2);
 q.setInteger(&quot;max&quot;,6);

 q=session.createQuery(&quot;from Topic t where t.createData&lt;:date&quot;);
 q.setParameter(&quot;date&quot;,new Date());

 q=session.createQuery(&quot;from Msg m where m=:MsgToSearch&quot;);
 Msg m=new Msg();
 m.setId(1);
 q.setParameter(&quot;MsgToSearch&quot;,m);
 Msg mResult=(Msg)q.uniqueResult(); //只有一条记录时使用
</code></pre>
</li>
<li><p>&quot;select ...&quot; 返回Object[]:</p>
<pre><code class="lang-java"> q=session.creatQuery(&quot;select t.id,t.name from Topic t&quot;)
 List&lt;Object[]&gt; topicList=(List&lt;Object[]&gt;)q.list();
</code></pre>
</li>
<li><p>VO(Value Object)~DTO(Data Transfer Object), Hibernate 让开发者摆脱了繁琐的DTO</p>
<pre><code class="lang-java"> q=session.creatQuery(&quot;select new com.pojo.MsgInfo(m.id,m.content,m.topic.title,m.topic.category.name) from Msg m&quot;);
 List&lt;MsgInfo&gt; list=q.list();
</code></pre>
</li>
<li>update<pre><code class="lang-java"> Query q=session.createQuery(&quot;update Topic t set t.title=upper(t.title)&quot;);
 q.executeUpdate();
</code></pre>
</li>
<li>in: 用in可以实现exists的功能，但是exists的执行效率高<pre><code class="lang-sql"> // Topic 中设置了msgs的@OneToMany导航    
 from Topic t where t.msgs is empty    
 from Topic t where not exists (select m.id from msg m where m.topic.id=t.id)
 from Topic t where t.id not in ( select m.topic.id from msg m )
</code></pre>
</li>
</ol>
<h3 id="header-21">QBC &amp; QBE</h3>
<p>标准化对象查询(Criteria Query):以对象的方式进行查询，将查询语句封装为对象操作</p>
<ul>
<li>优点：可读性好，符合Java 程序员的编码习惯。</li>
<li>缺点：不够成熟，不支持投影（projection）或统计函数（aggregation）</li>
</ul>
<p>QBC，QBE 以对象的方式进行查询
应用场景： 按条件搜索对象时，使用QBC，QBE 则不用手动拼写SQL了
使用session. createCriteria (Criterion 标准/准则/约束 , Criteria为复数形式)</p>
<ol>
<li><p>QBC: </p>
<pre><code class="lang-java"> Criteria c=session.createCriteria(Topic.class)       // from Topic
         .add(Restrictions.gt(&quot;id&quot;,2))        // greater than:id&gt;2
         .add(Restrictions.like(&quot;title&quot;,&quot;t_&quot;)    // like &#39;t_&#39;
         .createCriteria(&quot;category&quot;)
         .add(Restrictions.between(&quot;id&quot;,3,5)) ; //category.id between 3 and 5
 c.list();

 session.createCriteria(Topic.class).setFetchMode(“msgs”,FetchMode.JOIN);

 //若先创建，不绑定session，需要时再绑定session  —— 使用 DetachedCriteria
 ...
</code></pre>
</li>
<li>QBE<pre><code class="lang-java"> Topic tExample=new Topic();
 tExample.setTitle=&quot;T_&quot;;
 Example e=Example.create(tExample)
         .ignoreCase().enableLike();
 Criteria c=session.createCriteria(Topic.class)
         .add(Restrictions.gt(&quot;id&quot;,2))
         .add(e);
</code></pre>
</li>
</ol>
<h3 id="header-22">命名的数据库查询</h3>
<ol>
<li><p>使用Annotation方式，写在类前面：<code>@NamedQueries</code>, <code>@NamedNativeQueries</code>
（命名的本地化数据库查询 ，3.5前不支持）</p>
<pre><code class="lang-java"> @NamedQueries(
     {
         @NamedQuery(name=&quot;topic.selectCertainTopic&quot;,query=&quot;from Topic t where t.id=:id&quot;)
     }
 )
</code></pre>
</li>
<li><p>xml方式，写在配置文档中：</p>
<pre><code class="lang-xml"> &lt;hibernate-mapping&gt;
         ...
     &lt;query name=” topic.selectCertainTopic”&gt;
         &lt;![CDATA[from Topic t where t.id=:id]]&gt;
     &lt;/query&gt;

     &lt;sql-query name=””&gt;
         &lt;![CDATA[select {t.*} from Topic t where t.id=:id]]&gt;
         &lt;return alias=”c” class=”com.pojo.Topic” /&gt;
     &lt;/sql-query&gt;
 &lt;/hibernate-mapping&gt;
</code></pre>
</li>
<li>调用：<pre><code class="lang-java"> Query q=session.getNamedQuery(&quot;topic.selectCertainTopic&quot;);
 q.setParameter(&quot;id&quot;,5);
 Topic t=(Topic)q.uniqueResult();
</code></pre>
</li>
</ol>
<h3 id="header-23">直接使用JDBC</h3>
<p>通过Session对象的connection()方法获取java.sql.Connection对象，执行SQL语句，提交后会自动关闭
在Hibernate中不支持非读取数据的存储过程（查询需有数据返回）</p>
<pre><code class="lang-java">Transaction tx=session.beginTransaction();
Connection conn=session.connection();
String procedure=”{call updateGuestbookById(?,?)}”;
try
{
    CallableStatement stmt=conn.prepareCall(procedure);
    stmt.setInt(1,1);
    stmt.setString(2,”修改了留言主题”);
    stmt.executeUpdate();
    tx.commit();
}
catch(SQLException e)
{
    e.printStackTrace();
}
</code></pre>
<h2 id="header-24">缓存</h2>
<p>缓存算法：缓存满时，新来的对象该替换掉哪个旧的（指定哪个先完蛋）</p>
<ul>
<li>LRU：Least Recently Used –最近很少被使用</li>
<li>LFU：Least Frequently Used (命中率高低)</li>
<li>FIFO：First In First Out 按顺序替换</li>
</ul>
<p>持久层缓存，级别：</p>
<ol>
<li>事务级（eg:Hibernate一级缓存），</li>
<li>应用（进程）级(eg: Hibernate二级缓存)</li>
<li>分布式级</li>
</ol>
<p>下面介绍Hibernate缓存</p>
<h3 id="header-25">一级缓存（Session）</h3>
<p>Hibernate一级缓存：session级别的缓存
（内置的缓存，不能通过程序或配置修改，通过Session实现的缓存）</p>
<p>一级缓存的管理：</p>
<ul>
<li>evict() 移除Session缓存中某个对象； eg:session.evict(gb1);</li>
<li>clear() 清空Session缓存中所有对象；eg:session.clear();</li>
<li>contains();</li>
<li>flush();</li>
<li>setReadOnly();</li>
</ul>
<pre><code class="lang-java">public void getGuestbook(){
    Session session=HibernateSessionFactoryUtil.getSessionFactory().getCurrentSession();
    session.beginTransaction();
    Guestbook gb1=(Guestbook)session.get(Guestbook.class,100);
    Guestbook gb2=(Guestbook)session.get(Guestbook.class,100);
    System.out.printIn(gb1==gb2);

    gb1.setEmail(&quot;test@123.com&quot;);
    gb2.setTitle(&quot;Test2&quot;);

    session.getTransaction().commit();
}
</code></pre>
<p>=&gt; gb1与gb2相同，总共一条select，一条update</p>
<pre><code class="lang-java">public void getGuestbook(){
    Session session=HibernateSessionFactoryUtil.getSessionFactory().getCurrentSession();
    session.beginTransaction();
    Guestbook gb1=(Guestbook)session.get(Guestbook.class,100);
    session.getTransaction().commit();

    Session session=HibernateSessionFactoryUtil.getSessionFactory().getCurrentSession();
    session.beginTransaction();
    Guestbook gb2=(Guestbook)session.get(Guestbook.class,100);
    System.out.printIn(gb1==gb2);
    session.getTransaction().commit();
}
</code></pre>
<p>=&gt; gb1与gb2不同，两条select</p>
<h3 id="header-26">二级缓存（SessionFactory）</h3>
<p>用于应用中降低数据库的负载，缓存数据库查询结果以减少数据库访问次数，提高应用的访问速度</p>
<p>Hibernate二级缓存：SessionFactory级别的缓存
(可以跨越session存在，所有session都能用)</p>
<ul>
<li>由SessionFactory对象负责管理，可以缓存整个应用的持久化对象,即应用级别，又称SessionFactory缓存（插件式）</li>
<li>应用场景：经常被访间；改动不大不会经常改动；数重有限</li>
<li>二级缓存的策略：read-only -&gt; nonstrict-read-write  -&gt; read-write -&gt; transactional</li>
<li>缓存组件对缓存策略的支持：<table class="table">
<thead>
<tr>
<th>缓存名称</th>
<th>缓存类型</th>
<th>对应的适配器类</th>
<th>read-only</th>
<th>nonstrict-read-write</th>
<th>read-write</th>
<th>transactional</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hashtable</td>
<td>内存</td>
<td>org.hibernate.cache.HashtableCacheProvider</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>EHCache</td>
<td>内存，硬盘</td>
<td>org.hibernate.cache.EhCacheProvider</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>OSCache</td>
<td>内存，硬盘</td>
<td>org.hibernate.cache.OSCacheProvider</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>SwarmCache</td>
<td>分布式（不支持分布式事务）</td>
<td>org.hibernate.cache.swarmCacheProvider</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>JBoss Cache 1.x</td>
<td>分布式（支持分布式事务）</td>
<td>org.hibernate.cache.TreeCacheProvider</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>JBoss Cache2</td>
<td>分布式（支持分布式事务）</td>
<td>org.hibernate.cache.jbc2.JBossCacheRegionFactory</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>Y</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>使用举例：</p>
<ol>
<li><p>使用EhCache 作为二级缓存：</p>
<ul>
<li>导入包：<ul>
<li>ehcache-1.2.3.jar（hibernate包中有提供）</li>
<li>commons-logging-1.0.4.jar (apache 日志)包</li>
</ul>
</li>
<li>在hibernate.cfg.xml 中设定：<pre><code class="lang-xml">&lt;property name= &quot;cache.use_second_level_cache&quot;&gt;true&lt;/property&gt;
&lt;property name=&quot;cache.provider_class&quot;&gt;org.hibernate.cache.EhCacheProvider&lt;/property&gt;
</code></pre>
</li>
<li>加入EhCache配置文件<code>echache.xml</code>（可从hibernate包的etc中copy一份）<ul>
<li>配置<code>memoryStoreEvictionPolicy = &quot;LRU&quot;</code></li>
<li>EHCache配置文件ehcache.xml 中参数说明：<table class="table">
<thead>
<tr>
<th>名称</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>maxElementsInMemory</td>
<td>设置保存在内存中缓存对象的最大数量</td>
</tr>
<tr>
<td>etemal</td>
<td>设置缓存中对象是否永远不过去（true 活了超时设置，缓存对象永不过期）</td>
</tr>
<tr>
<td>timeToIdleSeconds</td>
<td>最大空闲时间，单位秒</td>
</tr>
<tr>
<td>timeToLiveSeconds</td>
<td>最大生存时间，单位秒</td>
</tr>
<tr>
<td>overflowToDisk</td>
<td>内存中缓存对象达到maxElementInMemory限制是，是否将缓存对象保存到硬盘中</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>使用<code>@Cache</code>注解指定需要使用二级缓存的对象(此注解在JPA1.0中还未提供，固在此由hibernate扩展提供)</li>
<li><p>例如：</p>
<pre><code class="lang-java">  @Entity
  @Cache(usage=CacheConcurrencyStrategy.READ_WRITE)
  public class Category
  {...}
</code></pre>
<ul>
<li><p>验证效果：</p>
<pre><code class="lang-java">public void list(){
  SessionFactory sessionFactory=HibernateSessionFactoryUtil.getSessionFactory();
  Session session1=sessionFactory.getCurrentSession();
  session1.beginTransaction();
  Product p1=(Product)session1.get(Product.class,1);
  System.out.printIn(p1.getName());
  session1.getTransaction().commit();

  Session session2=sessionFactory.getCurrentSession();
  session2.beginTransaction();
  Product p2=(Product)session1.get(Product.class,1);
  System.out.printIn(p2.getName());
  session2.getTransaction().commit();
}
</code></pre>
<p>=&gt;session1与session2不同，p1与p2相同，一条select</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>应用memcached作为二级缓存(分布式的内存对象缓存系统，通用，不一定在Hibernate中使用)</p>
<ul>
<li>导入包: <ul>
<li>hibernate-memched.jar</li>
<li>memcached.jar</li>
<li>spy.jar</li>
<li>commons-codec.jar</li>
</ul>
</li>
<li>下载安装memcached服务器程序，执行<code>memcached –vv</code></li>
<li>在hibernate.cfg.xml 中设定：<pre><code class="lang-xml">      &lt;property name= &quot;cache.use_second_level_cache&quot;&gt;true&lt;/property&gt;
      &lt;property name=&quot;cache.provider_class&quot;&gt;com.googlecode.hibernate.memcached.MemcachedCacheProvider&lt;/property&gt;
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="header-27">三级缓存（Query）</h3>
<p>Hibernate三级缓存：查询缓存 Query cache 
（相同的查询可使用，需在二级缓存的基础上）</p>
<ul>
<li>对查询的要求严格，必须条件参数也一致</li>
<li>在二级缓存的基础上再打开查询缓存 <code>&lt;property name=&quot;cache.use_query_cache&quot;&gt;true&lt;/property&gt;</code></li>
<li>调用Query的<code>setCachable (true)</code>方法指明使用缓存，例如：<code>session.createQuery(&quot;from Category&quot;).setCacheable(true).list();</code></li>
</ul>
<h2 id="header-28">事务</h2>
<p>ACID：</p>
<ul>
<li>Atomic原子性（执行或不执行）； </li>
<li>Consistency一致性（完整性约束）； </li>
<li>Itegrity 独立性（多事务不会交错）；</li>
<li>Durability持久性（提交后更改是永久的）</li>
</ul>
<h3 id="header-29">事务并发问题</h3>
<table class="table">
<thead>
<tr>
<th>并发问题</th>
<th>名称</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lost Update</td>
<td>第一类丢失更新</td>
<td>撤销一个事务会影响另一个事务，只要数据库支持事务,就不可能出现第一类丢失更新</td>
</tr>
<tr>
<td>Dirty Read</td>
<td>脏读</td>
<td>读了别的事务还未提交的数据（比如另一事物回滚则刚才读取的数据就会不对）</td>
</tr>
<tr>
<td>Non-repeatable Read</td>
<td>不可重复读</td>
<td>同一事务中前后读取的数据不一样，即被另一个事务所影响了（一个事务在另一个事务提交前和后读取同一对象的结果不一致）</td>
</tr>
<tr>
<td>Second Lost Update</td>
<td>第二类丢失更新</td>
<td>不可重复读的特殊情况</td>
</tr>
<tr>
<td>Phantom Read</td>
<td>幻读</td>
<td>插入删除时，会多读或少读数据</td>
</tr>
</tbody>
</table>
<h3 id="header-30">事务隔离机制</h3>
<p>不同隔离级别可以发生的并发问题：</p>
<table class="table">
<thead>
<tr>
<th>隔离级别</th>
<th>解释</th>
<th>更新丢失 Lost Update</th>
<th>脏读 Dirty Read</th>
<th>不可重复读Non-repeatable Read</th>
<th>幻读Phantom Read</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read Uncommitted</td>
<td>允许读取未提交的数据，效率最高</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>Read Committed</td>
<td>读取已提交的数据，oracle默认使用的级别</td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>Repeatable Read</td>
<td>可重复读，给读出的数据加把锁，类似于select ... for update，MySQL 引擎默认使用的级别 （当前事务未结束，其他事务无法执行修改或插入操作，较安全）</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
</tr>
<tr>
<td>Serializable</td>
<td>顺序执行事务， 不并发，实际中很少用，最消耗资源</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody>
</table>
<p>设定hibernate的事务隔离级别（查看 java.sql.Connection 文件）：</p>
<ul>
<li>配置<code>hibernate.connection.isolation</code>属性， 取值值<strong>1 2 4 8</strong> （1=0000,2=0010,4=0100,8=1000  位移计算效率高)<ul>
<li><code>read-uncommitted=1</code></li>
<li><code>read-committed=2</code></li>
<li><code>repeatable read  =4</code></li>
<li><code>serializable =8</code> </li>
</ul>
</li>
<li>如果不设 默认依赖数据库本身的级别</li>
<li>eg： <code>hibernate.connection.isolation = 2</code> 表示使用<code>read-committed</code>隔离级别</li>
</ul>
<h3 id="header-31">锁</h3>
<p>一般项目中使用<code>read-commited</code>事务隔离机制，在程序中设置悲观锁或乐观锁解决<code>non-repeatable read</code> 和 <code>phantom-read</code>问题</p>
<ol>
<li><p><strong>悲观锁 Pessimistic Locking</strong>，依赖于数据库的锁</p>
<ul>
<li>悲观锁认为每次读取或修改数据库数据时，其他事务也在并发访问相同的数据，有很强的排他性，即对于这个数据其他事务是不准碰的</li>
<li>load 时加锁：<code>session.load(xx.class , i , LockMode.Upgrade)</code>
相当于 select ... for update，事务提交后会解除</li>
<li>其他LockMode说明：<ul>
<li><code>LockMode.None</code>：无锁的机制，Transaction结束时，切换到此模式</li>
<li><code>LockMode.read</code>：在査询的时候hibernate会自动获取锁</li>
<li><code>LockMode.write</code> ：insert  update hibernate 会自动获取锁</li>
<li><code>LockMode.UPGRADE_NOWAIT</code>： ORACLE 支持的锁的方式</li>
</ul>
</li>
<li>注意： <code>None</code>,<code>read</code>,<code>write</code> 3种锁的模式，是hibernate内部执行时自己使用的(自己加自己解，不需要设)</li>
</ul>
</li>
<li><p><strong>乐观锁 Optimistic Locking</strong>，依赖Hibernate(JPA)的锁</p>
<ul>
<li>乐观锁认为数据库中的数据很少发生同时被操作问题，通过数据的版本号<code>Version</code>比较机制或时间戳<code>timestamp</code>实现</li>
<li>使用<code>version</code>实现乐观锁原理：<ul>
<li>默认在表中增加一version字段，初始为0</li>
<li>当某一事物获取该对象并要update时，先判断version的值是否改变</li>
<li>若未改变则version+1，update成功</li>
<li>若version值于当初获取时不同，则update失败</li>
</ul>
</li>
<li><p>流程举例：</p>
<table class="table">
<thead>
<tr>
<th>时间</th>
<th>转账事务A</th>
<th>取款事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td>/</td>
<td>开始事务</td>
</tr>
<tr>
<td>T2</td>
<td>开始事务</td>
<td>/</td>
</tr>
<tr>
<td>T3</td>
<td>查询学生为10人</td>
<td>查询账户余额为1000 version=0</td>
</tr>
<tr>
<td>T4</td>
<td>查询账户余额为1000 version=0</td>
<td>/</td>
</tr>
<tr>
<td>T5</td>
<td>/</td>
<td>取出100 把余额改为900 version=1</td>
</tr>
<tr>
<td>T6</td>
<td>/</td>
<td>提交事务</td>
</tr>
<tr>
<td>T7</td>
<td>汇入100元</td>
<td>/</td>
</tr>
<tr>
<td>T8</td>
<td>提交事务 ? version&gt;0 throw Exception</td>
<td>/</td>
</tr>
<tr>
<td>T9</td>
<td>把余额改为1100元(丢失更新)</td>
<td>/</td>
</tr>
</tbody>
</table>
</li>
<li><p>示例：</p>
<pre><code class="lang-java">  //在pojo实体类中增加version属性()，在get方法前加@Version注解
  @Entity
  public class Account{   //属性：id,balance,version
      ...
      @Version
      public int getVersion()
      { return version; }
  }
</code></pre>
</li>
</ul>
</li>
</ol>
<h2 id="header-32">性能优化</h2>
<h3 id="header-33">动态局部插入&amp;更新</h3>
<ul>
<li><p>方式1：</p>
<ul>
<li>动态局部插入：在pojo类上加<code>@DynamicInsert</code></li>
<li>动态局部更新：在pojo类上加<code>@DynamicUpdate</code><ul>
<li>原理：会先根据Id获取对象（若缓存中没有，则从DB中查询加载该对象），逐个字段比对，不一致则update该字段</li>
</ul>
</li>
<li>对Persistence对象有用</li>
<li>现象：同一个session可以，跨session不行，不过可以用session.merge(XXX对象)(不重要）， 实际merge方法会先从DB中select对象到内存，然后update</li>
</ul>
</li>
<li><p>方式2：使用 HQL(EjBQL)</p>
<pre><code class="lang-java">  //Query 为org.hibernate.Query; Student 为对象，不是DB表
  Query  q=session.createQuery(“update Student s set s.name=’zhangsan’ where s.id=1”);
  q.executeUpdate();
</code></pre>
</li>
</ul>
<h3 id="header-34">cascade参数对CUD影响</h3>
<ol>
<li><p>Update时@ManyToOne()中的cascade参数关系</p>
<pre><code class="lang-java"> session.beginTransaction();
 User user = (User)session.load(User.class,1);
 //user对象属性改变 事务commit时自动判断与数据库原有数据不同 可自动update
 //此时的update与@ManyToOne()中的cascade或fetch参数取值无关
 user.setName(&quot;user1&quot;);
 user.getGroup().setName(&quot;group1&quot;);
 session.getTransaction().commit();
</code></pre>
<p> 如果user改变在commit()之后且想要执行Update方法时user与group表同时更新，则设置User类<code>cascade={CascadeType.ALL}</code>，并在程序中写如下代码：</p>
<pre><code class="lang-java"> session.beginTransaction();
 User user = (User)session.get(User.class,1);
 session.getTransaction().commit();
 user.setName(&quot;user1&quot;);
 user.getGroup().setName(&quot;group1&quot;);
 Session session2 = sessionFactory.getCurrentSession();
 session2.beginTransaction();
 session2.update(user);
 session2.getTransaction().commit();
</code></pre>
</li>
<li><p>Delete时@ManyToOne()中的cascade关系
 如果User及Group类中均设为@ManyToOne(cascade={CascadeType.All})，那么在执行如下：</p>
<pre><code class="lang-java"> session.beginTransaction();
 User user = (User)session.load(User.class,1);
 session.delete(user);
 session.getTransaction().commit();
</code></pre>
<p><strong>注意：</strong>
此处删除的是 多对一(即User对Group) 中的“多”的一方(User类)
会删除user及user对应的group，再反向对应group的user都会删除，原因就是设置了<code>@ManyToOne(cascade={CascadeType.All})</code></p>
</li>
</ol>
<p>三种方法可避免全部删除的情况：</p>
<ol>
<li>去掉@ManyToOne(cascade={CascadeType.All})设置；</li>
<li>直接写Hql语句执行删除；</li>
<li>将user对象的group属性设为null，相当于打断User与Group间的关联，代码如下<pre><code class="lang-java"> session.beginTransaction();
 User user = (User)session.load(User.class,1);
 user.setGroup(null);
 session.delete(user);
 session.getTransaction().commit();
</code></pre>
</li>
</ol>
<p><strong>注意：</strong>
如果删除的是 多对一中的“一”的一方(Group类)时，使用第3种方式(user属性设为null)来打断两个对象间的关联的话，代码与之前不同,如下：</p>
<pre><code class="lang-java">session.beginTransaction();
Group group = (Group)session.load(Group.class,1);
//循环将group中的set集合下的各个user对象设为null
//相当于先将数据库中user表中与group表关联的字段(即groupid)设为null
for(User user :group.getUsers()){
    System.out.println(user.getName());
    user.setGroup(null);
}
//再将group的set集合设为null,相当于将group表中与user表关联的字段(即userid)设为null
//此句的前提是user表中的关联字段(groupid)已经为null,如没有则相当于破坏了一对多关联,会报错
group.setUsers(null);
session.delete(group);
session.getTransaction().commit();
</code></pre>
<h3 id="header-35">1+N问题</h3>
<p><strong>现象描述</strong>：
一个对象关联另一个对象（ManyToOne），而FetchType为EAGER，那么在去这个对象时它所关联的对象也会取出，
本来一句SQL就可取出N条记录，但还要取关联对象，又会再发N条语句取关联的对象</p>
<p>查询某个对象，本来应该只发一条SQL语句查询，
若被关联对象有N条，结果就会再发N条查找关联对象的SQL数据
eg：</p>
<pre><code class="lang-sql">select * from topic
select * from category where id=?
select * from category where id=?
    ...
</code></pre>
<p><strong>解决方案</strong>：</p>
<ul>
<li>方案一，fetch=FetchType.LAZY 解决N+1问题：
  当多对一(@ManyToOne)已经设定属性&quot; fetch=FetchType.LAZY &quot;时 
  只有当需要时(如:t.getCategory().getName()时)才会去获取关联表中数据 可以解决N+1问题<pre><code class="lang-java">  @ManyToOne(fetch=FetchType.LAZY)
</code></pre>
</li>
<li>方案二，@BatchSize 解决N+1问题：
在与查询表(此例中为Topic类)关联的表类(此例中为Category类)头处加@BatchSize(size=5)
表示每次可查出5条记录 从而减少了select语句的个数<pre><code class="lang-java">  @Entity
  @BatchSize(size=5)
  public class Category
  {...}
</code></pre>
</li>
<li>方案三，join fetch 解决N+1问题：<pre><code class="lang-java">  //修改hql语句为--&quot;  from Topic t left join fetch t.category c  &quot;
  List&lt;Topic&gt; topicList=(List&lt;Topic&gt;)session.createQuery(&quot;from Topic t left join fetch t.category c&quot;).list();
</code></pre>
</li>
<li>方案四，QBC(Query By Criteria) 解决N+1问题：
  QBC 默认使用表连接来取（left join），使用QBC的 createCriteria(*.class)执行查询 <pre><code class="lang-java">  List&lt;Topic&gt; topicList=(List&lt;Topic&gt;)session.createCriteria(Topic.class).list();
</code></pre>
</li>
</ul>
<h3 id="header-36">防止内存泄漏</h3>
<p>在同一个Session中，大集合进行遍历，小心出现内存泄漏，用完的数据要及时clear下，让垃圾回收机及时回收掉</p>
<p>发生情境：</p>
<ul>
<li><p>在不断分页循环的时候</p>
<ul>
<li>同一Session中执行分页操作，Session 缓存 1～50，51～100，...  越占越多，由于有引用，java虚拟机是不会自动清除的。</li>
<li>建议适时的调用<code>session.clear();</code></li>
<li>一般不同页面会启用新的Session，但是导数据时可能会发生此问题</li>
</ul>
</li>
<li><p>在一个大集合中进行遍历</p>
<ul>
<li>eg：遍历msg，取出其中的含有敏感字样的对象</li>
</ul>
</li>
</ul>
<p>Java有内存泄漏吗？：</p>
<ul>
<li>在语法级别上没有 ，有Java虚拟机自动垃圾回收；</li>
<li>但是可由编程引起,例如:连接池中打开了一个连接不关闭,或打开文件，io读取后不关闭</li>
<li>实际上java调用c,c调用windows API，c不会自动回收</li>
</ul>
<h3 id="header-37">延迟加载</h3>
<p>Lazy Loading:真正要读取数据时才从DB中获取，在关联对象上的应用较多</p>
<p>可能导致的异常：<code>org.hibernate.LazyInitializationException:could not initialize proxy – no Session</code>
eg: 持久层gb=session.load(...); tx.commit();  控制层/表示层：gb.getTitle();</p>
<p>解决：</p>
<ul>
<li>方案一：取消延迟加载（不推荐）</li>
<li>方案二：使用Hibernate.initialize();</li>
<li>方案三：使用Open Session In View(OSIV) 设计模式，延迟session关闭，等都输出处理完后再tx.commit();<ul>
<li>可使用Servlet过滤器实现自己的OSIV模式：发出请求时开启Session对象，Servlet执行后再关闭Session对象</li>
</ul>
</li>
</ul>
<h3 id="header-38">list &amp; iterate</h3>
<p>list</p>
<ul>
<li>list 取所有；session中list第二次发出，仍会到数据库査询；</li>
<li>使用list会取出对象的所有内容，并加入到二级缓存中，</li>
<li>但第二次取同样内容会重新去DB中获取而不从二级缓存中获取</li>
</ul>
<p>iterate</p>
<ul>
<li>iterate先取ID,等用到的时候再根据ID来取对象；</li>
<li>iterate默认使用二级缓存</li>
<li>使用iterate 只会取出对象的Id，当要取该对象的其他内容时，先从二级缓存中查找，没有再重新去DB根据id查询</li>
</ul>
<p><strong>PS：</strong> 若要查询的数据已在缓存中，那用iterate是比较快的，不在就会出现上述N+1问题，这样list的效率会更高</p>
<pre><code class="lang-java">List&lt;Category&gt; categories =(List&lt;Category&gt;)session.createQuery(&quot;from Category&quot;).list();
for( Category c : categories)
{ 
    System.out.println(c.getName);}
    Iterator&lt;Category&gt; categories =(Iterator&lt;Category&gt;)session.createQuery(&quot;from Category&quot;).iterate();
    while(categories.hasNext())
    {
        Category c=categories.next();
        System.out.println(c.getName());
    }
}
</code></pre>
<h2 id="header-39">Hibernate 扩展组件</h2>
<h3 id="header-40">Hibernate Filter</h3>
<p>对查找的记录集再进行过滤</p>
<ol>
<li>使用<code>&lt;filter-def&gt;</code> 定义过滤器，使用<code>&lt;filter&gt;</code> 声明使用过滤器<pre><code class="lang-xml">&lt;hibernate-mapping&gt;
 &lt;class name=”” table=”” &gt;
     ...
     &lt;set ...&gt;
         ...
         &lt;filter name=”...” condition=”...” /&gt;     //过滤集合
     &lt;/set&gt;
     &lt;filter name=”nameFilter” condition=”NAME=:inputName” /&gt;    //NAME 为表中字段
 &lt;/class&gt;
 ...
 &lt;filter-def  name=”nameFilter”&gt;
     &lt;filter-param name=”inputName” type=”java.lang.String” /&gt;
 &lt;/filter-def&gt;
&lt;/hibernate-mapping&gt;
</code></pre>
</li>
<li>在Query调用方法前使用Filter<pre><code class="lang-java">String hql=”from Guestbook where id between 10 and 200”
Query query=session.createQuery(hql);
Filter filter=session.enableFilter(“nameFilter”);
filter.setParameter(“inputName”,”ZhangSan”);
List&lt;Guestbook&gt; list=query.list();
</code></pre>
</li>
</ol>
<h3 id="header-41">Hibernate Interceptor</h3>
<p>创建Session对象时，所有Session对象或此Session对象的所有持久化操作动作都会被指定的拦截器拦截 （org.hibernate.Interceptor 接口）</p>
<ul>
<li>应用：使用拦截器实现审计日志</li>
<li>审计日志：在应用系统中，对所以数据库的操作都做记录，包括操作内容，用户，操作时间</li>
</ul>
<pre><code class="lang-java">public class LogEntityInterceptor extends EmptyInterceptor{
    private static final long serialVersionUID=...;
    private Logger logger=Logger.getLogger(LogEntityInterceptor.class);    //使用Log4J记录日志

    public void onDelete(Object entity,Serializable id,Object[] state,String[] propertyNames,Type[] types){
        logger.info(“Delete Data”);
    }

    public boolean onFlushDirty(Object entity,Serializable id,Object[] state,String[] propertyNames,
                    Type[] types){
        logger.info(“Update Data”);
        return false;
    }

    public boolean onSave(Object entity,Serializable id,Object[] state,String[] propertyNames,
                    Type[] types){
        logger.info(“Save Data”);
        return false;
    }
}
</code></pre>
<pre><code class="lang-java">LogEntityInterceptor interceport=new LogEntityInterceptor();
//通过Configuration对象加载拦截器, 此时通过此config生成的sessionFactory，session都会使用此拦截器
Configuration config=new Configuration();
config.setInterceptor(interceptor);
config.configure();
SessionFactory sf=config.buildSessionFactory();
Session seesion=sf.getCurrentSession();
...

//也可通过Session对象加载拦截器
Session session=sf.openSession(interceptor);
</code></pre>
<h3 id="header-42">Hibernate Listener</h3>
<p>事件监听机制:能精确追踪到持久化对象的字段的修改，关联关系的变更，更新前后数值
与拦截器比较：更细粒度上的拦截，可获取修改前后值，可直接通过Event对象获取Session对象</p>
<ol>
<li>实现具体的Listener类或继承具体的Listener接口</li>
<li>在<code>hibernate.cfg.xml</code>中配置事件监听器对象，或使用<code>Configuration</code>对象注册事件监听器对象</li>
</ol>
<h3 id="header-43">Hibernate Search</h3>
<ol>
<li><p>Hibernate Search特点：</p>
<ul>
<li>支持索引数据的自动更新（通过Hibernate更新变动的数据，会同步更新索引数据）</li>
<li>支持众多搜索方式（关键词，通配符，近似，同义词）</li>
<li>支持搜索集群</li>
<li>支持直接调用Lucene API</li>
</ul>
</li>
<li><p>底层使用的是<a href="http://lucene.apache.org/">Lucene</a>:</p>
<ul>
<li>java领域的全文搜索工具包，可对文本，HTML，Excel，PDF等格式的文件建立索引并进行搜索</li>
</ul>
</li>
<li><p>Hibernate Search类库：</p>
<ul>
<li>hibernate-search.jar</li>
<li>lucene-core.jar</li>
<li>hibernate-commons-annotations.jar</li>
</ul>
</li>
<li><p>搜索引擎：</p>
<ul>
<li>全文搜索引擎</li>
<li>目录索引引擎（一般用在网页黄页中）</li>
<li>元搜索引擎（向多个搜索引擎查询汇总）</li>
</ul>
</li>
</ol>
<p><strong>全文搜索引擎原理：</strong>
<img src="/2013/06/01/lucene.png" alt="Lucene"></p>
<p><strong>使用示例：</strong></p>
<ol>
<li><p>hibernate配置文件中：</p>
<pre><code class="lang-xml"> &lt;property name=&quot;hibernate.search.default.directory_provider&quot;&gt;
     org.hibernate.search.store.FSDirectoryProvider
 &lt;/property&gt;

 &lt;property name=&quot;hibernate.search.default.indexBase&quot;&gt;
     D:/temp/index
 &lt;/property&gt;
</code></pre>
</li>
<li><p>pojo类：</p>
<pre><code class="lang-java">@Index
public class GuesBook {
    ...
    @DucumentId
    public int getId()
    { return id;}

    //保存到索引文件中（hibernate-search下的store），默认不存
    @Field(store=Store.YES)
    public String getName()
    { return name;}

    //不进行分词处理,默认使用分词处理
    @Field(store=Store.YES,index=Index.UN_TOKENIZED)
    public String getPhone()
    { return phone;}

    @Field
    public String getTitle()
    { return title;}
    ...
}
</code></pre>
</li>
<li><p>建立索引</p>
<pre><code class="lang-java"> public void index(){
     Session session=HibernateSessionFactoryUtil.getSessionFactory().getCurrentSession();

     FullTextSession ftSession=Search.getFullTextSession(session);
     ftSession.getTransaction().begin();

     List&lt;Guestbook&gt; list=session.createQuery(&quot;from Guestbook&quot;).list();
     for(Guestbook gb:list)
         ftSession.index(gb);
     ftSession.getTransaction().commit();
 }
</code></pre>
</li>
<li><p>搜索</p>
<pre><code class="lang-java"> public void query(){
     //使用庖丁分词器搜索时，使用：
     //QueryParser parser=new QueryParaser(“title”,new paoding.analysis.analyzer.PaodingAnalyzer());
     QueryParser parser=new QueryParser(&quot;title&quot;,new StandardAnalyzer());

     org.apache.lucene.search.Query luceneQuery=null;
     try{
         luceneQuery=parser.parse(&quot;title:中国&quot;);
     }catch(ParseException e){
         e.printStackTrace();
     }

     Session session=HibernateSessionFactoryUtil.getSessionFactory().getCurrentSession();
     FullTextSession ftSession=Search.getFullTextSession(session);
     ftSession.beginTransaction().begin();
     org.hibernate.Query query=ftSession.createFullTextQuery(lucenQuery,Guestbook.class);
     query.setFirstResult(0);
     query.setMaxResults(20);

     List&lt;Guestbook&gt; list=query.list();
     ftSession.getTransaction().commit();
     for(Guestbook gb:list)
         System.out.printIn(&quot;id:&quot;+gb.getId()+&quot;,title:&quot;+gb.getTitle());
 }
</code></pre>
<p> =&gt;不使用中文分词时，是分成一个字一个字的</p>
</li>
</ol>
<p><strong>使用第三方的中文分词组件</strong>，eg：“庖丁解牛” 分词组件(使用词库)</p>
<ol>
<li>建立配置文件<code>paoding.dic.home.properties: paoding.dic.home=.../paoding/dic</code> ( 配置词库位置)</li>
<li>将类库<code>paoding-analisis.jar</code>加入项目中</li>
<li>pojo类上加入注解：<code>@Analyzer(impl=net.paoding.analysis.analyzer.PaodingAnalyzer.class)</code>    </li>
</ol>
<p><strong><a href="http://www.getopt.org/luke/">Luck</a> 工具：</strong>可显示修改Lucene索引数据和模拟搜索的开源工具</p>
<ul>
<li>在Dos命令下运行： java –jar lukeall.jar</li>
<li>中文分词：将中文句子切分成有医院的单词</li>
<li>基本机制：使用词库匹配；使用自动切分算法</li>
<li>词库切分与自动切分比较：<table class="table">
<thead>
<tr>
<th></th>
<th>自动切分</th>
<th>词库表切分</th>
</tr>
</thead>
<tbody>
<tr>
<td>实现</td>
<td>实现简单</td>
<td>实现复杂</td>
</tr>
<tr>
<td>查询</td>
<td>增加了查询分析的复杂程度</td>
<td>适于实现比较复杂的查询语法规则</td>
</tr>
<tr>
<td>存储效率</td>
<td>索引冗余大，索引几乎和原文一样大</td>
<td>索引效率高，为原文大小的30%左右</td>
</tr>
<tr>
<td>维护成本</td>
<td>无词库维护成本</td>
<td>词库维护成本高，还需要包括词频统计等内容</td>
</tr>
</tbody>
</table>
</li>
<li>Luke查看效果如下：
<img src="/2013/06/01/luke.png" alt="Luke"></li>
</ul>
  </section>
</article>

      <hr/>
      
<section class="post-comment">
	
		<div id="gitment_container"></div>

<link rel="stylesheet" href="/gitment/default.css">
<script src="/gitment/gitment.browser.js"></script>


<script type="text/javascript">
	var gitment = new Gitment({
	  id: document.location.pathname,
	  owner: 'chenjin-zero',
	  repo: 'blogComment',
	  oauth: {
	    client_id: '36a09bb7399efe69c6ce',
	    client_secret: 'ad9ad546b23b708c71d92e513dc36e0486179dea',
	  }
	})
      
	gitment.render('gitment_container')
</script>
	
</section>

    </div>
  </div>
</body>

<script src="/jquery/dist/jquery.min.js"></script>
<script src="/bootstrap/dist/js/bootstrap.min.js"></script>


	<script src="/highlight/highlight.pack.js"></script>
	<script type="text/javascript">
		hljs.initHighlightingOnLoad();
	</script>






<script type="text/javascript">

  $(document).ready(function(){
    var sidebarCtrl=$("#sidebar-ctrl");
    var sidebar=$("#sidebar");
    var wrapper=$("#wrapper");
    sidebarCtrl.on("click",function(event){
        //alert("click");
        sidebar.toggleClass("sidebar-toggle");
        wrapper.toggleClass("sidebar-toggle");
        sidebarCtrl.toggleClass("sidebar-toggle");
        sidebarCtrl.toggleClass("active");
    })
  });
</script>


</html>
