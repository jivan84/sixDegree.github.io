<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Design Pattern</title>
  
  <!-- Meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="design,pattern,23,factory,adapter,strategy">
  
  
    <meta name="description" content="23 Design Patterns Introduce">
  

  <!-- Feed -->
  
    <link rel="alternative" href="/atom.xml" title="SixDegree" type="application/atom+xml">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/bootstrap/dist/css/bootstrap.css">
  
	
		<link rel="stylesheet" href="/highlight/styles/tomorrow-night-bright.css">
	
    
  
  <link rel="stylesheet" href="/css/fontello.css">
  <link rel="stylesheet" href="/css/style.css">

  <!-- Site Analyse -->
  
	<script>
	var userID='2bbb83cc0f781dd7502e9d5e19661866';
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?"+userID;
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>


</head>

<body data-spy="scroll" data-target="#nav-catalog">
  <div id="top-push"></div>
<a href="#top-push" id="go-top">
	<span class="glyphicon glyphicon-chevron-up"></span>
</a>
  <aside id="sidebar">
    <section class="sidebar-header">Catalog</section>
     <nav id="nav-catalog">
        <ol class="sidebar-nav nav"><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-1"><span class="sidebar-nav nav-text">创建类模式</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-2"><span class="sidebar-nav nav-text">Factory</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-3"><span class="sidebar-nav nav-text">Abstract Factory</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-4"><span class="sidebar-nav nav-text">Builder</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-5"><span class="sidebar-nav nav-text">Singleton</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-6"><span class="sidebar-nav nav-text">Prototype</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-7"><span class="sidebar-nav nav-text">结构类模式</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-8"><span class="sidebar-nav nav-text">Adapter</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-9"><span class="sidebar-nav nav-text">Decorator</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-10"><span class="sidebar-nav nav-text">Proxy</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-11"><span class="sidebar-nav nav-text">Facade</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-12"><span class="sidebar-nav nav-text">Bridge</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-13"><span class="sidebar-nav nav-text">Combine</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-14"><span class="sidebar-nav nav-text">Flyweight</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-15"><span class="sidebar-nav nav-text">行为类模式</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-16"><span class="sidebar-nav nav-text">Strategy</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-17"><span class="sidebar-nav nav-text">Template</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-18"><span class="sidebar-nav nav-text">Observer</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-19"><span class="sidebar-nav nav-text">Iterator</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-20"><span class="sidebar-nav nav-text">Chain of Responsibility</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-21"><span class="sidebar-nav nav-text">Command</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-22"><span class="sidebar-nav nav-text">Memento</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-23"><span class="sidebar-nav nav-text">State</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-24"><span class="sidebar-nav nav-text">Visitor</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-25"><span class="sidebar-nav nav-text">Mediator</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-26"><span class="sidebar-nav nav-text">Interpreter</span></a></li></ol></li></ol>
    </nav>
  </aside>
  <span id="sidebar-ctrl" class="glyphicon glyphicon-list-alt circle"></span>
  <div id="wrapper">
    <header>
  <nav class="navbar navbar-default">
    <div class="container-fluid">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#nav-menu" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/">SixDegree</a>
      </div>
      <div class="collapse navbar-collapse" id="nav-menu">
        <ul class="nav navbar-nav navbar-right">
          
              <li  >
                <a href="/">Blogs</a>
              </li>
          
              <li  >
                <a href="/tags.html">Tags</a>
              </li>
          
              <li  >
                <a href="/about.html">About</a>
              </li>
          
          
              <li>
                <a href="/atom.xml" target="_blank">
                  <span class="icon-rss"></span>
                </a>
              </li>
          
              <li>
                <a href="http://github.com/sixdegree" target="_blank">
                  <span class="icon-github"></span>
                </a>
              </li>
          
        </ul>
      </div>
    </div>
  </nav>
</header>



    <div class="container">
      <article class="detail" role="main">
  <section class="post-header">
    <h1 class="post-title">Design Pattern</h1>
    <ul class="post-meta">
      <li>
        <span class="glyphicon glyphicon-calendar"></span>
        <time datetime="2013-05-02T16:00:00.000Z">2013-05-03</time>
      </li>
      
        <li>
         <span class="glyphicon glyphicon-tags"></span>
          
            <a href="/tags.html#tag-Java">Java</a>
          
        </li>
      
    </ul>
  </section>
  <section class="post-content">
    <p>23中设计模式介绍，主要分为三大类：</p>
<ol>
<li>创建型（创建对象）</li>
<li>结构型（自身扩展）</li>
<li>行为型（对象间解耦）</li>
</ol>
<h2 id="header-1">创建类模式</h2>
<h3 id="header-2">Factory</h3>
<pre><code class="lang-java">public class SendFactory{
    public static Sender produce(String name){
        if(&quot;mail&quot;.equals(name))
            return new MailSender();
        else if(&quot;sms&quot;.equals(name))
            return new SmsSender();
        else
            return  null;
    }
}
</code></pre>
<pre><code class="lang-java">public interface Sender{
    public void Send();
}
public class MailSender implements Sender{...}
public class SmsSender implements Sender{...}
</code></pre>
<pre><code class="lang-java">// Test
Sender sender=SenderFactory.produce(&quot;mail&quot;);
sender.send();
</code></pre>
<h3 id="header-3">Abstract Factory</h3>
<p>拓展性比Factory Pattern好</p>
<pre><code class="lang-java">public interface Provider{
    public Sender provide();
}
public class MailFactory implements Provider{...}    // new MailSender
public class SmsFactory implements Provider{...}  // new SmsSender
</code></pre>
<pre><code class="lang-java">// Test
Provider provider = new MailFactory();
Sender sender=provider.provide();
sender.send();
</code></pre>
<h3 id="header-4">Builder</h3>
<p>工厂模式关注创建单个产品
建造者模式关注创建多个产品</p>
<pre><code class="lang-java">public class Builder {
    private List&lt;Sender&gt; list = new ArrayList&lt;Sender&gt;();
    public void produce(String name,int count){
        if(&quot;mail&quot;.equals(name)){
            for(int i=0; i&lt;count; i++){
                list.add(new MailSender());
            }
        }else{
             for(int i=0; i&lt;count; i++){
                list.add(new SmsSender());
            }
        }
    }
}
</code></pre>
<pre><code class="lang-java">Builder builder = new Builder();
builder.produce(&quot;mail&quot;,10);
builder.produce(&quot;sms&quot;,10);
</code></pre>
<h3 id="header-5">Singleton</h3>
<pre><code class="lang-java">public class Singleton{
    // 可再加入volatile：禁止指令重排序优化 （Java 5 之后修复）
    private static Singleton instance=null;

    // 构造函数私有化，防止被外部实例化
    private Singleton(){}

    // 静态方法，创建实例
    public static Singleton getInstance(){
        if(instance==null)
            syncInit()
        return instance;
    }

    private static synchronized void syncInit() {
        if (instance == null) {
            instance = new Singleton();    // 注意：这并不是一个原子操作
        }
    }
    ...
}
</code></pre>
<p>优化1：使用私有静态内部类<code>private static nested class</code></p>
<ul>
<li>懒加载</li>
<li>线程安全</li>
<li>读取实例的时候不会进行同步，没有性能缺陷</li>
<li>不依赖 JDK 版本</li>
</ul>
<pre><code class="lang-java">public class Singleton {
    private Singleton() { }

    public static Singleton getInstance() {
        return SingletonFactory.instance;
    }

    private static class SingletonFactory {
        private static Singleton instance = new Singleton();
    }

    // 可采用&quot;影子实例&quot;的办法为单例对象的属性同步更新
    private Vector properties = null;
    public Vector getProperties() {
          return properties;
    }
    public void updateProperties() {
        Singleton shadow = new Singleton();
        properties = shadow.getProperties();
    }
}
</code></pre>
<pre><code class="lang-java">//Test
Singleton singleton=Singleton.getInstance();
</code></pre>
<p>优化2：使用枚举<code>enum</code></p>
<ul>
<li>自由序列化</li>
<li>线程安全</li>
<li>保证只有一个实例（即使使用反射机制也无法多次实例化一个枚举量）</li>
</ul>
<pre><code class="lang-java">public enum Singleton{
    INSTANCE;
    private Singleton(){}
}
</code></pre>
<pre><code class="lang-java">//Test
Singleton singleton=Singleton.INSTANCE;
</code></pre>
<p>注：参考《Effective Java》</p>
<h3 id="header-6">Prototype</h3>
<p>将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象</p>
<pre><code class="lang-java">//实现Cloneable接口（空接口）
public class Prototype implements Cloneable, Serializable {
    private String str;
    private MyObject obj;

    // 浅复制（基本数据类型）
    // 需调用super.clone();
    public Object clone() throws CloneNotSupportedException {
        Prototype proto = (Prototype) super.clone();
        return proto;
    }

    // 深复制（基本数据类型+引用类型）
    // 需要采用流的形式读入当前对象，再写出
    public Object deepClone() throws IOException, ClassNotFoundException {
        // 写入当前对象的二进制流
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(this);

        // 读出二进制流产生的新对象
        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bis);
        return ois.readObject();
    }

    //get/set
    ...
}

public class MyObject implements Serializable {
    ...
}
</code></pre>
<hr>
<h2 id="header-7">结构类模式</h2>
<p><img src="/2013/05/03/adapter.png" alt="Adapter"></p>
<p>对象的适配器模式是各种模式的起源</p>
<h3 id="header-8">Adapter</h3>
<p>适配器模式</p>
<ul>
<li>将某个类的接口转换成客户端期望的另一个接口表示</li>
<li>目的：消除由于接口不匹配所造成的类的兼容性问题</li>
</ul>
<p>主要分为三类：</p>
<ol>
<li><p>类的适配器模式：</p>
<ul>
<li>Adapter类继承Source类，实现Targetable接口</li>
<li><p>场景：希望将一个类转换成满足另一个新接口的类时</p>
<pre><code class="lang-java">public class Source {
  public void method1() { ... }
}

public interface Targetable {
  public void method1();
  // 扩展方法
  public void method2();
}
</code></pre>
<pre><code class="lang-java">public class Adapter extends Source implements Targetable {
  @Override
  public void method2() {
     ...
  }
}
</code></pre>
<pre><code class="lang-java">//Test
Targetable target = new Adapter();
target.method1();
target.method2();
</code></pre>
</li>
</ul>
</li>
<li><p>对象的适配器模式：</p>
<ul>
<li>Adapter类持有Source类的实例，调用Source实例的方法</li>
<li>场景：希望将一个对象转换成满足另一个新接口的对象<pre><code class="lang-java">public class Adapter implements Targetable {
  private Source source;
  public Adapter(Source source){
      super();
      this.source = source;
  }
  @Override
  public void method1() {
      source.method1();
  }
  @Override
  public void method2() {
      ...
  }
}
</code></pre>
<pre><code class="lang-java">//Test
Targetable target = new Adapter(new Source());
target.method1();
target.method2();
</code></pre>
</li>
</ul>
</li>
<li><p>接口的适配器模式：</p>
<ul>
<li>Adapter类继承一个抽象类（实现了Targetable接口），重写方法</li>
<li>场景：不希望实现一个接口中所有的方法时<pre><code class="lang-java">public class AbstractTarget implements Targetable{
  public void method1(){
      ...
  }
  public void method2(){
      ...
  }
}
public class Adapter extends AbstractTarget{
  @Override
  public void method1(){
      ...
  }
}
</code></pre>
<pre><code class="lang-java">//Test
Targetable target=new Adapter();
target.method1();
target.method2();
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="header-9">Decorator</h3>
<p>装饰模式</p>
<ul>
<li>动态给一个对象增加一些新的功能</li>
<li>应用场景：<ul>
<li>扩展一个类的功能</li>
<li>动态的为一个对象增加撤销功能（继承的功能是静态的，不能动态增删）</li>
</ul>
</li>
<li>实现方式：<ul>
<li>Target：被装饰类</li>
<li>Decorator：装饰类</li>
<li>Target和Decorator实现同一个接口</li>
<li>Decorator对象持有Target对象，为Target动态的添加取消功能</li>
</ul>
</li>
<li><p>示例：</p>
<pre><code class="lang-java">  public interface Targetable {
      public void method();
  }
</code></pre>
<pre><code class="lang-java">  public class Target implements Targetable {
      @Override
      public void method() {
          ...
      }
  }
  public class Decorator implements Targetable {
      private Targetable target;

      // 通过构造函数传入Target对象
      public Decorator(Targetable target){
          super();
          this.target = target;
      }

      // 扩展Target方法
      @Override
      public void method() {
          ...
          target.method();
          ...
      }
  }
</code></pre>
<pre><code class="lang-java">  //Test
  Targetable obj=new Decorator(new Source());
  obj.method();
</code></pre>
</li>
<li>缺点：产生过多相似的对象，不易排错</li>
</ul>
<h3 id="header-10">Proxy</h3>
<p>代理模式：相较于Decorator，Proxy通过自己创建Target对象，来持有Targe对象
（将功能划分的更加清晰，有助于后期维护）</p>
<pre><code class="lang-java">public class Proxy implements Targetable {
    private Targetable target;

    // 在构造函数中创建Target对象
    public Proxy(){
        super();
        this.target = new Target();
    }
    // 扩展Target方法
    @Override
    public void method() {
        ...
        target.method();
        ...
    }
}
</code></pre>
<pre><code class="lang-java">//Test
Targetable obj=new Proxy();
obj.method();
</code></pre>
<h3 id="header-11">Facade</h3>
<p>外观模式：为了解决类与类之家的依赖关系
（将依赖放在一个Facade类中，降低类与类之间的耦合度，类似Spring将通过配置文件维护各个bean的依赖关系）</p>
<pre><code class="lang-java">public class A{...}
public class B{...}

public class Facade{
    private A a;
    private B b;
    public Facade(){
        a=new A();
        b=new B();
    }
    public void method(){
        a.xxx();
        b.xxx();
        ...
    }
}
</code></pre>
<pre><code class="lang-java">//Test
Facade facade = new Facade();
facade.method();
</code></pre>
<h3 id="header-12">Bridge</h3>
<p>桥接模式：将抽象与实现解耦，使得二者可以独立变化</p>
<p>类似：DriverManager与JDBC桥接（统一接口），在各个数据库（提供各自实现）之间进行切换
用一个叫做数据库驱动的程序来桥接就行了。</p>
<pre><code class="lang-java">// 统一接口
public interface Targetable {
    public void method();
}

//各自实现
public class TargetSub1 implements Targetable {
    @Override
    public void method() {... }
}
public class TargetSub2 implements Targetable {
    @Override
    public void method() { ... }
}
</code></pre>
<pre><code class="lang-java">// 桥接：抽象方法，通过set传入Target对象，自定义调用Target方法
public abstract class Bridge {
    private Targetable target;
    public void method(){
        target.method();
    }
    //get/set
    ...
}

// 桥接扩展
public class MyBridge extends Bridge {
    public void method(){
        getTarget().method();
    }
}
</code></pre>
<pre><code class="lang-java">//Test
Bridge bridge = new MyBridge();

// 调用第一个对象
bridge.setTarget(new TargetSub1());
bridge.method();

// 调用第二个对象
bridge.setTarget(new TargetSub2());
bridge.method();
</code></pre>
<h3 id="header-13">Combine</h3>
<p>组合模式：部分-整体模式，将多个对象组合在一起进行操作（常用场景：树形结构）</p>
<pre><code class="lang-java">public class Tree {
    TreeNode root = null;
    public Tree(String name) {
        root = new TreeNode(name);
    }
}
</code></pre>
<pre><code class="lang-java">public class TreeNode {
    private String name;
    private TreeNode parent;
    private Vector&lt;TreeNode&gt; children = new Vector&lt;TreeNode&gt;();

    public TreeNode(String name){
        this.name = name;
    }

    //get/set
    ...

    //添加孩子节点
    public void add(TreeNode node){
        children.add(node);
    }
    //删除孩子节点
    public void remove(TreeNode node){
        children.remove(node);
    }
}
</code></pre>
<pre><code class="lang-java">// Test
Tree tree = new Tree(&quot;A&quot;);
TreeNode nodeB = new TreeNode(&quot;B&quot;);
TreeNode nodeC = new TreeNode(&quot;C&quot;);
tree.root.add(nodeB);
nodeB.add(nodeC);
</code></pre>
<h3 id="header-14">Flyweight</h3>
<p>享元模式：实现对象的共享，即共享池
（对象多的时候可以减少内存的开销，一般为单例，可参考数据库连接池的实现）</p>
<pre><code class="lang-java">public class ConnectionPool {
    private Vector&lt;Connection&gt; pool;
    /*公有属性*/
    private String url = &quot;jdbc:mysql://localhost:3306/test&quot;;
    private String username = &quot;root&quot;;
    private String password = &quot;root&quot;;
    private String driverClassName = &quot;com.mysql.jdbc.Driver&quot;;

    private int poolSize = 100;
    Connection conn = null;

    private static ConnectionPool instance = null;
    private ConnectionPool() {
        pool = new Vector&lt;Connection&gt;(poolSize);
        for (int i = 0; i &lt; poolSize; i++) {
            try {
                Class.forName(driverClassName);
                conn = DriverManager.getConnection(url, username, password);
                pool.add(conn);
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

    /* 返回连接到连接池 */
    public synchronized void release() {
        pool.add(conn);
    }

    /* 返回连接池中的一个数据库连接 */
    public synchronized Connection getConnection() {
        if (pool.size() &gt; 0) {
            conn = pool.get(0);
            pool.remove(conn);
            return conn;
        } else {
            return null;
        }
    }
}
</code></pre>
<hr>
<h2 id="header-15">行为类模式</h2>
<p><img src="/2013/05/03/action.png" alt="Action"></p>
<h3 id="header-16">Strategy</h3>
<p>策略模式：定义了一系列算法，封装起来，可随意替换
场景：适用于当一个应用程序需要实现一种特定的服务或者功能，而且该程序有多种实现方式时使用(决定权在用户，系统本身提供不同的实现)
<strong>PS：</strong> 可参考<code>java.util</code>中<code>Collections</code>算法类的使用和实现</p>
<p><img src="/2013/05/03/strategy.png" alt="Strategy"></p>
<pre><code class="lang-java">//统一接口
public interface IStrategy {
    public void operate();
}
</code></pre>
<pre><code class="lang-java">//各个策略实现类（具体对象）
public class Strategy1 implements IStrategy {
    @Override
    public void operate() {...}
}
public class Strategy2 implements IStrategy {
    @Override
    public void operate() { ... }
}
</code></pre>
<pre><code class="lang-java">// 环境类（引用策略）
public class Context{
    private IStrategy strategy;
    public Context(IStrategy strategy){
        this.strategy=strategy;
    }
    public operate(){
        this.strategy.opreate();
    }
}
</code></pre>
<pre><code class="lang-java">// Test
Context ctx=new Context(new Strategy1());
ctx.operate();
</code></pre>
<h3 id="header-17">Template</h3>
<p>模板模式：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中，使得子类可以在不改变算法结构的情冴下，重新定义算法中的某些步骤</p>
<p>抽象类和具体子类的之间的协作</p>
<ul>
<li>抽象类：给出一个算法的骨架和搭建步骤<ul>
<li>基本方法：搭建步骤（抽象方法，由子类具体实现）</li>
<li>模板方法：骨架（基本方法的汇总）</li>
</ul>
</li>
<li>子类：提供这个算法搭建步骤的具体实现</li>
</ul>
<p><strong>PS:</strong>可参考<code>HttpServlet</code>抽象类
（提供了一个service方法，这个方法调用七个do方法中的一个或几个，完成对客户端调用的响应，这些do方法需要由HttpServlet的具体子类提供，这是典型的模板模式）</p>
<pre><code class="lang-java">public abstract class AbstractTemplate{
    protected abstract void abstractMethod1();
    protected abstract void abstractMethod2();
    protected void hookMethod(){...}

    public void templateMethod(){
        abstractMethod1();
        abstractMethod2();
        hookMethod();
        ...
    }
}
</code></pre>
<pre><code class="lang-java">public ConcreteTemplate extends AbstractTemplate{
    @Override
    public void abstractMethod1(){...}
    @Override
    public void abstractMethod2(){...}
    @Override
    public void hookMethod(){...}
}
</code></pre>
<pre><code class="lang-java">// Test
AbstractTemplate template=new ConcreteTemplate();
template.templateMethod();
</code></pre>
<h3 id="header-18">Observer</h3>
<p>订阅者模式：发布-订阅（Publish/Subscribe）模式</p>
<p>对象之间是一种一对多的关系：
让多个观察者对象同时监听某一个主题对象
这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己</p>
<ul>
<li>Subject：主题（接口/抽象类，可增加删除观察者对象）</li>
<li>Observer：观察者（接口/抽象类，在得到Subject通知时更新自己）</li>
<li>ConcreteSubject：具体主题</li>
<li>ConcreteObserver：具体观察者</li>
</ul>
<pre><code class="lang-java">public interface Subject {
    public void add(Observer observer);
    public void del(Observer observer);
    public void notifyObservers();  // 通知Observer
    public void operation();     //自身的操作
}

public interface Observer {
    public void update();
}
</code></pre>
<pre><code class="lang-java">// Subject 实现类：
public abstract class AbstractSubject implements Subject {
    private Vector&lt;Observer&gt; vector = new Vector&lt;Observer&gt;();
    @Override
    public void add(Observer observer) {
        vector.add(observer);
    }
    @Override
    public void del(Observer observer) {
        vector.remove(observer);
    }
    @Override
    public void notifyObservers() {
        Enumeration&lt;Observer&gt; enumo = vector.elements();
        while(enumo.hasMoreElements()){
            enumo.nextElement().update();
        }
    }
}
public class ConcreteSubject extends AbstractSubject {
    @Override
    public void operation() {
        System.out.println(&quot;update self!&quot;);
        notifyObservers();
    }
}
</code></pre>
<pre><code class="lang-java">// Observer 实现类：
public class ConcreteObserver1 implements Observer {
    @Override
    public void update() {
        System.out.println(&quot;observer1 has received!&quot;);
    }
}
public class ConcreteObserver2 implements Observer {
    @Override
    public void update() {
        System.out.println(&quot;observer2 has received!&quot;);
    }
}
</code></pre>
<pre><code class="lang-java">// Test
Subject subject = new ConcreteSubject();
subject.add(new ConcreteObserver1());
subject.add(new ConcreteObserver2());
subject.operation();
</code></pre>
<h3 id="header-19">Iterator</h3>
<p>迭代器模式</p>
<ul>
<li>又叫做游标（Cursor）模式</li>
<li>顺序访问容器(Container)中的各个对象，且不需暴露内部细节</li>
<li>常使用JDK提供的迭代接口<code>Iterator</code>进行<code>collection</code>的遍历<pre><code class="lang-java">Iterator it = list.iterator();
while(it.hasNext()){
　//using “it.next();”do some businesss logic
}
</code></pre>
</li>
</ul>
<p>实现：</p>
<ul>
<li>Iterator</li>
<li>Container</li>
<li>ConcreteIterator</li>
<li>ConcreteContainer</li>
</ul>
<p>一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问</p>
<p>这个思路和我们常用的一模一样，MyCollection中定义了集合的一些操作，MyIterator中定义了一系列迭代操作，且持有Collection实例</p>
<p>两个接口</p>
<pre><code class="lang-java">public interface Container {
    public Iterator iterator();
    public Object get(int i);
    public int size();
}
public interface Iterator {
    public Object previous();
    public Object next();
    public boolean hasNext();
}
public class ConcreteContainer implements Container {
    public String string[] = {&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;};
    @Override
    public Iterator iterator() {
        return new ConcreteIterator(this);
    }
    @Override
    public Object get(int i) {
        return string[i];
    }
    @Override
    public int size() {
        return string.length;
    }
}

public class ConcreteIterator implements Iterator {
    private Container container;
    private int pos = -1;
    public ConcreteIterator(Container Container){
        this.container = container;
    }
    @Override
    public Object previous() {
        if(pos &gt; 0){  pos--; }
        return container.get(pos);
    }
    @Override
    public Object next() {
        if(pos&lt;container.size()-1){pos++;   }
        return container.get(pos);
    }
    @Override
    public boolean hasNext() {
        return pos&lt;container.size()-1?true:false;
    }
}
</code></pre>
<pre><code class="lang-java">// Test
Container container = new ConcreteContainer();
Iterator it = container.iterator();
while(it.hasNext()){
    System.out.println(it.next());
}
</code></pre>
<h3 id="header-20">Chain of Responsibility</h3>
<p>责任链模式：</p>
<ul>
<li>有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链</li>
<li>请求在这条链上传递，直到某一对象决定处理该请求。</li>
<li>发出者并不清楚到底最终那个对象会处理该请求</li>
<li>所以，责任链模式可以实现在隐瞒客户端的情况下，对系统进行动态的调整</li>
</ul>
<p>实现：</p>
<ul>
<li>Handler：抽象处理者</li>
<li>ConcreteHandler：具体处理者（持有下家的引用，可将请求处理掉，或将请求传给下家）</li>
</ul>
<p><strong>PS</strong>：</p>
<ul>
<li>链接上的请求可以是一条链，可以是一个树，还可以是一个环，模式本身不约束这个；</li>
<li>在一个时刻，命令只允许由一个对象传给另一个对象，而不允许传给多个对象</li>
</ul>
<pre><code class="lang-java">public abstract class Handler {
    // 持有handler
    private Handler handler;
    public Handler getHandler() {
        return handler;
    }
    public void setHandler(Handler handler) {
        this.handler = handler;
    }
    // 处理方法，抽象
   public abstract void handlerRequest(String condition);
}
</code></pre>
<pre><code class="lang-java">public class ConcreteHandler1 extends Handler {
    @Override
    public void handlerRequest(String condition) { ... }
}
public class ConcreteHandler2 extends Handler {
    @Override
    public void handlerRequest(String condition) { ... }
}
public class ConcreteHandler3 extends Handler {
    @Override
    public void handlerRequest(String condition) { ... }
}
</code></pre>
<pre><code class="lang-java">//Test
ConcreteHandler1 handler1 = new ConcreteHandler1();
ConcreteHandler2 handler2 = new ConcreteHandler2();
ConcreteHandler3 handler3=new ConcreteHandler3();

handler1.setHandler(handler2);
handler2.setHandler(handler3);

// handler1 =&gt; handler2 =&gt; handler3
handler1.operator();
</code></pre>
<h3 id="header-21">Command</h3>
<p>命令模式：</p>
<ul>
<li>将来自客户端的不同的请求（命令）传入一个对象（根据命令执行操作）</li>
<li>达到命令的发出者和执行者之间解耦，实现请求和执行分开</li>
</ul>
<p><img src="/2013/05/03/command.png" alt="Command"></p>
<p>实现：</p>
<ul>
<li>Invoker：调用者（司令员）</li>
<li>Receiver：被调用者（士兵）</li>
<li>Command：命令</li>
<li>ConcreteCommand：实现了Command接口，持有接收对象</li>
</ul>
<pre><code class="lang-java">// 调用者（包含命令）
public class Invoker {
    private Command command;
    public void setCommand(Command command){
        this.command=command;
    }
    public void execute(){
        this.command.execute();
    }
}

// 命令接收者
public class Receiver {
    public void action(){
        // 真正执行命令操作的功能代码
        System.out.println(&quot;command received!&quot;);
    }
}
</code></pre>
<pre><code class="lang-java">// 命令
public interface Command {
    public void execute();
}
// 具体命令（包括命令接收者）
public class ConcreteCommand implements Command {
    private Receiver receiver;
    public ConcreteCommand(Receiver receiver) {
        this.receiver = receiver;
    }
    @Override
    public void execute() {
        receiver.action();
    }
}
</code></pre>
<pre><code class="lang-java">// Test
Invoker invoker = new Invoker();                      // 创建命令调用者
Command cmd = new ConcreteCommand(new Receiver());    // 构造具体命令
invoker.setCommand(cmd);     // 装入命令
invoker.execute();            // 发送命令
</code></pre>
<h3 id="header-22">Memento</h3>
<p>备忘录模式：</p>
<ul>
<li>快照模式(Snapshot Pattern)或Token模式</li>
<li>在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以后可将该对象恢复到原先保存的状态</li>
<li>场景：适用于对象在执行某些操作为防止意外而在执行操作前将对象状态备份的场景（有点类似事务回滚的意思）</li>
</ul>
<p>实现：</p>
<ul>
<li>Originator：发起人（包括内部状态和备忘录）</li>
<li>Memento：备忘录（需保存的内容）</li>
<li>Caretaker：管理备忘录</li>
</ul>
<pre><code class="lang-java">public class Originator {
    private String value;
    public String getValue() {
        return value;
    }
    public void setValue(String value) {
        this.value = value;
    }
    public Memento createMemento(){
        return new Memento(value);
    }
    public void restoreMemento(Memento memento){
        this.value = memento.getValue();
    }
}
</code></pre>
<pre><code class="lang-java">public class Memento {
    private String value;
    public Memento(String value) {
        this.value = value;
    }
    public String getValue() {
        return value;
    }
    public void setValue(String value) {
        this.value = value;
    }
}
</code></pre>
<pre><code class="lang-java">public class Caretaker  {
    private Memento memento;
    public Memento getMemento() {
        return memento;
    }
    public void setMemento(Memento memento) {
        this.memento = memento;
    }
}
</code></pre>
<pre><code class="lang-java">// Test

Originator origi=new Originator();     // 创建发起对象
Caretaker storage=new Caretaker();        // 创建管理者

origi.setValue(&quot;Test&quot;);
origi.setMemento(origi.createMemento());    // 暂存状态

origi.setValue(&quot;Test too&quot;);
origi.restoreMemento(storage.getMemento());          // 恢复状态
</code></pre>
<h3 id="header-23">State</h3>
<p>状态模式：当对象的状态改变时，同时改变其行为</p>
<ul>
<li>State</li>
<li>ConcreteState</li>
<li>Context</li>
</ul>
<pre><code class="lang-java">public interface State{
    public void handler(Context context);
}
</code></pre>
<pre><code class="lang-java">public class Context {
    private State state;
    public Context(State state){
        this.state = state;
    }
    public State getState() {
        return state;
    }
    public void setState(State state) {
        this.state = state;
    }
    public void handler() {
        this.state.handler(this);
    }
}
</code></pre>
<pre><code class="lang-java">public class ConcreteState1 extends State{
    @Override
    public void handler(Context context)(){
        System.out.println(&quot;Current State 1&quot;);
        // 设置下一状态为2
        context.setState(new ConcreteState2());
    }
}
public class ConcreteState2 extends State{
    @Override
    public void handler(Context context)(){
        System.out.println(&quot;Current State 2&quot;);
        // 设置下一状态为1
        context.setState(new ConcreteState1());
    }
}
</code></pre>
<pre><code class="lang-java">// Test
Context context = new Context(new ConcreteState1());
context.handler();
context.handler();
</code></pre>
<h3 id="header-24">Visitor</h3>
<p>访问者模式：</p>
<ul>
<li>一种分离对象数据结构与行为的方法</li>
<li>封装一些施加于某种数据结构元素之上的操作，一旦这些操作需要修改的话，接受这个操作的数据结构则可以保持不变</li>
<li>适用于数据结构相对稳定的系统，把数据结构和算法解耦</li>
</ul>
<p>实现：</p>
<ul>
<li>Vistor</li>
<li>Element</li>
<li>ObjectStructure</li>
<li>ConcreteVisitor</li>
<li>ConcreteElement</li>
</ul>
<p><strong>PS：</strong> Vistor 和 Element的都可自行扩展，会不影响（相对独立，双重分派）</p>
<pre><code class="lang-java">// 访问Element，可对Element提出某些操作
public interface Visitor {
    public void visit(Element element);
}
// 接收访问者，提供处理方法
public interface Element {
    public void accept(Visitor visitor);
    public void doSomething();
}
</code></pre>
<pre><code class="lang-java">public class ConcreteVisitor1 implements Visitor {
    @Override
    public void visit(Element element) {
        //element.doSomething();
    }
}
public class ConcreteVisitor2 implements Visitor {
    @Override
    public void visit(Element element) {
        //element.doSomething();
    }
}
public class ConcreteElement1 implements Element{
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
    @Override
    public void doSomething() {  ... }
}
public class ConcreteElement2 implements Element{
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
    @Override
    public void doSomething() {  ... }
}
</code></pre>
<pre><code class="lang-java">public class ObjectStruture{
    private List&lt;Element&gt; list = new ArrayList&lt;Element&gt;();
    public void attach(Element element){
        this.list.add(element);
    }
    public void accept(Vistor vistor){
        for(Element element:list){
            element.accept(vistor);
        }
    }
}
</code></pre>
<pre><code class="lang-java">// Test
ObjectStruture objectStructor=new ObjectStructor();
objectStructor.attach(new ConcreteElement1());
objectStructor.attach(new ConcreteElement2());
objectStructor.accept(new ConcreteVisitor1();)
objectStructor.accept(new ConcreteVisitor2();)
</code></pre>
<h3 id="header-25">Mediator</h3>
<p>中介者模式：
用一个中介者对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使耦合松散，而且可以独立地改变它们之间的交互</p>
<p><strong>PS：</strong>只需关心和Mediator类的关系（由Mediator负责具体类类之间的关系及调度，有点像spring容器的作用）</p>
<p>实现：</p>
<ul>
<li>Mediator：维护Colleague之间的关系及调度</li>
<li>Colleague：维护与Mediator的关系，自身的一些处理等</li>
<li>ConcreteMediator</li>
<li>ConcreteColleague</li>
</ul>
<pre><code class="lang-java">public interface Mediator{
    void change(Colleague colleague);
}
public class ConcreteMediator implements Mediator {
    private List&lt;Colleague&gt; list=new ArrayList&lt;Colleague&gt;();
    public void addColleague(Colleague colleague){
        this.list.add(colleague);
    }
    @Override
    public void change(Colleague colleague) {
        //各个Colleague交互协作
    }
}
</code></pre>
<pre><code class="lang-java">public abstract class Colleague{
    private Mediator mediator;
    public Colleague(Mediator mediator) {
        this.mediator = mediator;
    }
    public Mediator getMediator(){
        return mediator;
    }
}

public class ConcreteColleague1 extends Colleague {
    public ConcreteColleague1(Mediator mediator){
        super(mediator);
    }
    public void doSomething(){
        //...
    }
}
public class ConcreteColleague2 extends Colleague {
    public ConcreteColleague1(Mediator mediator){
        super(mediator);
    }
    public void doSomething(){
        //...
    }
}
</code></pre>
<pre><code class="lang-java">//Test
Mediator mediator = new  ConcreteMediator();
Colleague colleague1=new ConcreteColleague1();
Colleague cooleague2=new ConcreteColleague2();
mediator.addColleague(colleague1);
mediator.addColleague(colleague1);
mediator.change(colleague1);
</code></pre>
<h3 id="header-26">Interpreter</h3>
<p>解释器模式</p>
<ul>
<li>一种简单的语法解释器构架</li>
<li>给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器</li>
<li>客户端可以使用这个解释器来解释这个语言中的句子</li>
<li>用来做各种各样的解释器，如正则表达式等的解释器等等</li>
</ul>
<p><img src="/2013/05/03/interpreter.png" alt="Interpreter"></p>
<p>用的不多！</p>
  </section>
</article>

      <hr/>
      
<section class="post-comment">
	
		<div id="gitment_container"></div>

<link rel="stylesheet" href="/gitment/default.css">
<script src="/gitment/gitment.browser.js"></script>


<script type="text/javascript">
	var gitment = new Gitment({
	  id: document.location.pathname,
	  owner: 'chenjin-zero',
	  repo: 'blogComment',
	  oauth: {
	    client_id: '36a09bb7399efe69c6ce',
	    client_secret: 'ad9ad546b23b708c71d92e513dc36e0486179dea',
	  }
	})
      
	gitment.render('gitment_container')
</script>
	
</section>

    </div>
  </div>
</body>

<script src="/jquery/dist/jquery.min.js"></script>
<script src="/bootstrap/dist/js/bootstrap.min.js"></script>


	<script src="/highlight/highlight.pack.js"></script>
	<script type="text/javascript">
		hljs.initHighlightingOnLoad();
	</script>






<script type="text/javascript">

  $(document).ready(function(){
    var sidebarCtrl=$("#sidebar-ctrl");
    var sidebar=$("#sidebar");
    var wrapper=$("#wrapper");
    sidebarCtrl.on("click",function(event){
        //alert("click");
        sidebar.toggleClass("sidebar-toggle");
        wrapper.toggleClass("sidebar-toggle");
        sidebarCtrl.toggleClass("sidebar-toggle");
        sidebarCtrl.toggleClass("active");
    })
  });
</script>


</html>
