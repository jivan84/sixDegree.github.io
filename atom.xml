<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SixDegree</title>
  
  <subtitle>host by chenjin</subtitle>
  <link href="//atom.xml" rel="self"/>
  
  <link href="http://sixdegree.github.io/"/>
  <updated>2018-10-26T12:33:58.000Z</updated>
  <id>http://sixdegree.github.io/</id>
  
  <author>
    <name>Chen Jin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES6</title>
    <link href="http://sixdegree.github.io/2018/10/15/ES6.html"/>
    <id>http://sixdegree.github.io/2018/10/15/ES6.html</id>
    <published>2018-10-14T16:00:00.000Z</published>
    <updated>2018-10-26T12:33:58.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>变量，作用域，Symbol</li><li>Object，Function，Array，Set，Map</li><li>解构赋值，扩展运算符，箭头函数</li><li>代理器Proxy，修饰器Decorator，遍历器Iterator</li><li>类，模块</li></ol><a id="more"></a><blockquote><p>参阅 <a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="noopener">阮一峰 ECMAScript 6 入门</a> ，作一个归纳整理吧。。。</p></blockquote><p>ES6 : 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等,而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。</p><p>ES6 的第一个版本在 2015 年 6 月发布，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）</p><h2 id="header-1">声明变量</h2><ul><li>var （ES5）</li><li>function （ES5）</li><li>let</li><li>const</li><li>class</li><li>import</li></ul><p><strong> var/let/const: </strong></p><ul><li><p>scope:</p><pre><code class="lang-js">  {    var a = 1;    let b = 10;    const c = 20;  }  a               // 1  b              // ReferenceError: b is not defined.  c              // ReferenceError: c is not defined.</code></pre></li><li><code>var</code> : 声明的变量在全局范围内都有效；会发生”变量提升“现象（即变量可以在声明之前使用，值为undefined）<pre><code class="lang-js">  var a = [];  for (var i = 0; i &lt; 10; i++) {    a[i] = function () {      console.log(i);    };  }  a[6]();                     // 10</code></pre></li><li><code>let</code> : 声明的变量只在所在的代码块内有效（局部有效）；声明的变量一定要在声明后使用，否则报错（“暂时性死区”）<pre><code class="lang-js">  var a = [];  for (let i = 0; i &lt; 10; i++) {    a[i] = function () {      console.log(i);    };  }  a[6]();                     // 6</code></pre></li><li><code>const</code> : 声明一个只读的常量；与let相同，只在声明所在的块级作用域内有效，同样存在暂时性死区<ul><li>ES5 常量写法：<pre><code class="lang-js">  Object.defineProperty(window,&quot;PI&quot;,{      value:3.1415926,      writable:false  });  console.log(window.PI);</code></pre></li><li>ES6 常量写法（使用const）<pre><code class="lang-js">  const PI = 3.1415;  PI                                           // 3.1415  PI = 3;                                      // TypeError: Assignment to constant variable.</code></pre></li><li>scope:<pre><code class="lang-js">  const foo;                                // SyntaxError: Missing initializer in const declaration  if (true) {    const MAX = 5;    MAX                                      // 5  }  MAX                                        // Uncaught ReferenceError: MAX is not defined</code></pre></li></ul></li><li><p>注：</p><ul><li><code>const</code>实际上保证的是变量指向的内存地址中保存的数据不得改动</li><li><p>所以对于简单类型的数据（例如：数值、字符串、布尔值）可以保证只读，但对于复合类型的数据就无法保证了</p><pre><code class="lang-js">  const foo = {};  foo.prop = 123;              // 成功  foo = {};                    // TypeError: &quot;foo&quot; is read-only  const a = [];  a.push(&#39;Hello&#39;);             //  成功  a.length = 0;                //  成功  a = [&#39;Dave&#39;];                // 报错</code></pre></li><li>在<code>let</code>和<code>const</code>之间，建议优先使用<code>const</code>，尤其是在全局环境，不应该设置变量，只应设置常量</li></ul></li></ul><h2 id="header-2">块级作用域 <code>{}</code></h2><ol><li><p>可代替闭包</p><ul><li>ES5 闭包（执行函数表达式 IIFE）写法：<pre><code class="lang-js">  (function () {    var tmp = ...;    ...  }());</code></pre></li><li>ES6 块级作用域写法：<pre><code class="lang-js">  {    let tmp = ...;    ...  }</code></pre></li></ul></li><li><p>声明的函数在不同环境下可能会有差异，建议使用函数表达式，而不是函数声明语句</p><ul><li>使用函数声明语句 – 不推荐，不同环境下会有差异：<pre><code class="lang-js">  {    let a = &#39;secret&#39;;    function f() {return a;}  }</code></pre><ul><li>浏览器环境： 函数声明类似于var（即会提升到全局作用域和函数作用域的头部）</li><li>其他环境：函数声明类似于let （对作用域之外没有影响）</li></ul></li><li>使用函数表达式方式(推荐方式)<pre><code class="lang-js">  {    let a = &#39;secret&#39;;    let f = function () {return a;};  }</code></pre></li></ul></li></ol><h2 id="header-3">顶层对象 <code>global</code></h2><p>为同一段代码能够在各种环境，都能取到顶层对象，引入global<br>注：</p><ul><li>浏览器中顶层对象： windows，self</li><li>Node中顶层对象： global</li><li>一般通用方法是使用this，但有局限性</li></ul><p><strong> 示例：</strong></p><ol><li><p>全局变量与顶层对象</p><ul><li>ES5中，全局变量与顶层对象等价<pre><code class="lang-js">  var a = 1;  window.a                 // 1  -- Node 的 REPL 环境，可以写成 global.a，或者用通用方法this.a</code></pre></li><li>ES6中，全局变量与顶层对象不等价<pre><code class="lang-js">  let a = 1;  window.a                 // undefined</code></pre></li></ul></li><li><p>使用垫片库system.global取到global</p><pre><code class="lang-js"> // CommonJS 的写法 var global = require(&#39;system.global&#39;)(); // ES6 模块的写法 import getGlobal from &#39;system.global&#39;; const global = getGlobal();</code></pre></li></ol><h2 id="header-4">扩展运算符 <code>...</code></h2><p><code>...变量</code> ： 将剩余传入的参数值，存入一个数组变量中<br><code>...对象</code> ： 拷贝对象的可遍历属性给一个新对象</p><p><strong> 示例：</strong> </p><ol><li><p>function rest 参数</p><pre><code class="lang-js"> function add(...values) {   let sum = 0;   for (let val of values) {     sum += val;   }   return sum; } add(2, 5, 3)                 // 10</code></pre><ul><li>注：rest参数只能是最后一个参数，否则会报错<br>（ES5 使用arguments对象，类似数组，但非数组，可使用Array.prototype.slice.call(arguments)转换为数组）</li></ul></li><li><p>解构赋值</p><pre><code class="lang-js"> let [head, ...tail] = [1, 2, 3, 4]; head             // 1 tail             // [2, 3, 4]</code></pre></li><li><p>拷贝对象的可遍历属性，同<code>Object.assign</code></p><pre><code class="lang-js"> let aClone = { ...a };                                  // 等同 let aClone = Object.assign({}, a); let abClone = { ...a, ...b };                           // 等同 let abClone = Object.assign({}, a, b); let aWithOverrides = { ...a, x: 1, y: 2 };        let aWithOverrides = { ...a, ...{ x: 1, y: 2 } }; let x = 1, y = 2, aWithOverrides = { ...a, x, y }; // 以上都等同 let aWithOverrides = Object.assign({}, a, { x: 1, y: 2 });</code></pre><ul><li>注： 扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行<pre><code class="lang-js">  let obj={      a:1,      get x(){         throw new Error(&#39;get x error!&#39;);      }  }  let c={...obj};    //  get x error!</code></pre></li></ul></li></ol><h2 id="header-5">解构赋值 (Destructuring)</h2><p>从等式右边的对象中提取值，赋给左边对应变量:</p><ul><li>模式匹配：只要等号两边的模式相同，左边的变量就会被赋予对应的值</li><li>类型转换：若等号右边的值不是对象或数组，就先将其转为对象</li><li>浅拷贝：解构赋值的拷贝都是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本</li><li>注：<ul><li><code>undefined</code>/<code>null</code>: 无法转为对象，对它们进行解构赋值，会报错</li><li><code>...</code>：扩展运算符的解构赋值(<code>...a</code>)，只能读取对象自身的属性</li></ul></li></ul><p>eg：</p><pre><code class="lang-js">let a = 1;let b = 2;// 可合并成：let [a, b] = [1, 2];a    // 1b    // 2</code></pre><h3 id="header-6">解构数组赋值</h3><p>右边数据结构具有 Iterator 接口，即可用数组形式解构赋值，否则报错</p><p><strong> 示例：</strong></p><ol><li><p>完全解构</p><pre><code class="lang-js"> let [foo, [[bar], baz]] = [1, [[2], 3]]; foo                 // 1 bar                 // 2 baz                 // 3 let [x, , y] = [1, 2, 3]; x                     // 1 y                     // 3 let [head, ...tail] = [1, 2, 3, 4]; head                 // 1 tail                 // [2, 3, 4]</code></pre></li><li><p>不完全解构</p><pre><code class="lang-js"> let [a, [b], d] = [1, [2, 3], 4]; a // 1 b // 2 d // 4 let [x, y, ...z] = [&#39;a&#39;]; x                     // &quot;a&quot; y                     // undefined z                     // []</code></pre></li><li><p>解构不成功</p><pre><code class="lang-js"> let [foo] = []; foo                // undefined //报错 let [foo] = 1; let [foo] = false; let [foo] = {}; let [foo] = null;</code></pre></li><li>对数组进行对象属性的解构，使用：属性名表达式<pre><code class="lang-js"> let arr = [1, 2, 3]; let {0 : first, [arr.length - 1] : last} = arr; first                 // 1 last                 // 3</code></pre></li></ol><h3 id="header-7">解构对象赋值</h3><p>对象的属性没有次序，变量须与属性同名或给变量指定对应属性，才能取到正确的值<br>（解构数组赋值：是按照数组顺序位置给对应变量赋值的）</p><p><strong> 示例：</strong></p><ol><li><p>单层结构对象</p><pre><code class="lang-js"> let { foo, bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; foo                 // &quot;aaa&quot; bar                 // &quot;bbb&quot; let { x } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; x                    // undefined let { foo: x } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; }; x                    // aaa</code></pre></li><li><p>嵌套结构的对象</p><pre><code class="lang-js"> let obj = {   p: [ &#39;Hello&#39;,{ y: &#39;World&#39; }] }; let { p: [x, { y }] } = obj;  // 这时p是模式，不是变量，不会被赋值 x                             // &quot;Hello&quot; y                             // &quot;World&quot; let { p, p: [x, { y }] } = obj; p                             // [&quot;Hello&quot;, {y: &quot;World&quot;}] x                             // &quot;Hello&quot; y                             // &quot;World&quot; // 嵌套对象，若子对象所在的父属性不存在，会报错 let {foo: {bar}} = {baz: &#39;baz&#39;};        // 报错，因为foo不存在</code></pre></li></ol><h3 id="header-8">解构函数参数赋值</h3><pre><code class="lang-js">function add([x, y]){  return x + y;}add([1, 2]);                                    // 3</code></pre><p>函数<code>add</code>的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量<code>x</code>和<code>y</code></p><pre><code class="lang-js">[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);        // [ 3, 7 ]</code></pre><h3 id="header-9">解构基础类型赋值</h3><p>会先转为对象</p><p><strong> 示例：</strong></p><ol><li><p>字符串</p><pre><code class="lang-js"> const [a, b, c, d, e] = &#39;hello&#39;; a                 // &quot;h&quot; b                 // &quot;e&quot; let {length : len} = &#39;hello&#39;; len                 // 5</code></pre></li><li>数值<pre><code class="lang-js"> let {toString: s} = 123; s === Number.prototype.toString         // true</code></pre></li><li>布尔值<pre><code class="lang-js"> let {toString: s} = true; s === Boolean.prototype.toString         // true</code></pre></li><li><code>undefined</code>，<code>null</code>: 无法转换为对象，解构报错<pre><code class="lang-js"> let { prop: x } = undefined;             // TypeError let { prop: y } = null;                  // TypeError</code></pre></li></ol><h3 id="header-10">指定默认值</h3><p><code>undefined</code>会触发使用默认值</p><p><strong> 示例：</strong></p><ol><li><p>数组</p><pre><code class="lang-js"> let [x, y = &#39;b&#39;] = [&#39;a&#39;];         // x=&#39;a&#39;, y=&#39;b&#39; // 默认值可以是一个表达式，表达式是惰性求值的，即只有在用到的时候，才会求值 function f() {   console.log(&#39;aaa&#39;); } let [x = f()] = [1];                // x 能取到值，所以函数f根本不会执行 // 默认值可以引用解构赋值的其他变量，但该变量必须已经声明 let [x = 1, y = x] = [];         // x=1; y=1 let [x = 1, y = x] = [2];        // x=2; y=2 let [x = 1, y = x] = [1, 2];     // x=1; y=2 let [x = y, y = 1] = [];         // ReferenceError: y is not defined -- 因为x用y做默认值时，y还没有声明</code></pre></li><li><p>对象</p><pre><code class="lang-js"> // 注：默认值生效的条件是，对象的属性值严格等于（===）undefined var {x, y = 5} = {x: 1}; x                     // 1 y                     // 5 var {x: y = 3} = {}; y                     // 3 var {x = 3} = {x: null}; x                     // null</code></pre></li><li><p>函数</p><pre><code class="lang-js"> function move({x = 0, y = 0} = {}) {        // 为变量x，y指定默认值   return [x, y]; } move({x: 3, y: 8});         // [3, 8] move({x: 3});               // [3, 0] move({});                   // [0, 0] move();                     // [0, 0] function move({x, y} = { x: 0, y: 0 }) {        // 为函数参数对象整体指定默认值，而不是为变量x和y指定默认值   return [x, y];， } move({x: 3, y: 8});         // [3, 8] move({x: 3});               // [3, undefined] move({});                   // [undefined, undefined] move();                     // [0, 0]</code></pre></li></ol><h3 id="header-11">应用示例</h3><ol><li><p>交换变量的值</p><pre><code class="lang-js"> let x = 1; let y = 2; [x, y] = [y, x];        // x=2,y=1</code></pre></li><li><p>合并数组</p><pre><code class="lang-js"> // ES5 var params=[&#39;hello&#39;,true,7]; var other=[1,2].concat(params); console.log(other); // ES6 // 利用扩展运算符合并数组 var params=[&#39;hello&#39;,true,7]; var other=[1,2,...params]; console.log(other);</code></pre></li><li><p>函数返回多个值: 函数返回多个值，只能将它们放在数组或对象里，通过解构赋值，取出这些值很方便</p><pre><code class="lang-js"> function example() {   return [1, 2, 3]; } let [a, b, c] = example();</code></pre></li><li><p>函数参数的定义：方便地将一组参数与变量名对应起来</p><pre><code class="lang-js"> // 参数是一组有次序的值 function f([x, y, z]) {      ...  } f([1, 2, 3]); // 参数是一组无次序的值 function f({x, y, z}) {      ...  } f({z: 3, y: 2, x: 1});</code></pre></li><li><p>提取 JSON 数据</p><pre><code class="lang-js"> let jsonData = {   id: 42,   status: &quot;OK&quot;,   data: [867, 5309] }; let { id, status, data: number } = jsonData; console.log(id, status, number);        // 42, &quot;OK&quot;, [867, 5309]</code></pre></li><li><p>遍历 Map 结构 ：任何部署了 Iterator 接口的对象，都可以用for…of循环遍历</p><pre><code class="lang-js"> const map = new Map(); map.set(&#39;first&#39;, &#39;hello&#39;); map.set(&#39;second&#39;, &#39;world&#39;); for (let [key, value] of map) {   console.log(key + &quot; is &quot; + value); } // first is hello // second is world // 只获取键名 for (let [key] of map) { ...} // 只获取键值 for (let [,value] of map) { ...}</code></pre></li><li><p>import模块的部分项</p><pre><code class="lang-js"> const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);</code></pre></li></ol><p>注： 圆括号</p><pre><code class="lang-js">// 错误let x;{x} = {x: 1};  // SyntaxError: syntax error  因为{x}会被当成一个代码块// 正确let x;({x} = {x: 1});</code></pre><h2 id="header-12">Iterator 遍历器</h2><p>提供一种统一的遍历接口，供<code>for...of</code>（或<code>while</code>）消费（循环遍历）</p><ul><li><p>本质：创建一个指针对象，通过<code>next</code>方法移动指针，指向遍历对象的成员，返回成员信息</p></li><li><p>属性：</p><ul><li><code>value</code> : 当前成员的值</li><li><code>done</code> : 布尔值，表示遍历是否结束</li></ul></li><li><p>方法：</p><ul><li><code>next</code> ：指针跳到下一个成员（遍历器必需部署此方法）</li><li><code>return</code> : 循环遍历中提前退出（出错，break）时触发调用 （可选部署）<ul><li>注：必须返回一个对象</li><li>使用场景：一个对象在完成遍历前，需要清理或释放资源</li></ul></li><li><code>throw</code> : 主要配合 Generator 函数使用（可选部署）</li></ul></li><li><p>可遍历性（iterable）：</p><ul><li>部署了Iterator 接口的数据结构，此数据结构即是“可遍历的”</li><li><p><code>Symbol.iterator</code>属性：当前数据结构默认的遍历器生成函数（即<code>Iterator</code>接口），执行这个函数，就会返回一个遍历器对象</p><pre><code class="lang-js">  let arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];  let iter = arr[Symbol.iterator]();  iter.next() // { value: &#39;a&#39;, done: false }  iter.next() // { value: &#39;b&#39;, done: false }  iter.next() // { value: &#39;c&#39;, done: false }  iter.next() // { value: undefined, done: true }</code></pre></li></ul></li><li><p>原生具备<code>Iterator</code>接口的数据结构：</p><ul><li>Array/TypedArray</li><li>Set/Map</li><li>String</li><li>function的arguments对象</li><li>Dom NodeList</li><li>Generator对象</li></ul></li><li><p>遍历操作：</p><ul><li><code>for...of</code> 循环<ul><li>循环读取键值(value)</li><li>遍历所有数据结构的统一的方法</li><li>内部调用的是数据结构的<code>Symbol.iterator</code>方法，可以与<code>break</code>，<code>continue</code>，<code>return</code>配合使用（<code>forEach</code>不行）</li></ul></li><li><code>for...in</code> 循环<ul><li>循环读取键名(key)，</li><li>任意顺序，不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键</li><li>主要是为遍历对象而设计</li></ul></li><li><p>示例:</p><ul><li><p>遍历数组</p><pre><code class="lang-js">  let arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];  arr.foo = &#39;hello&#39;;  // for...in循环读取键名(key)，注意：数组的key为数字，但循环键名为字符串  for (let i in arr) {    console.log(i);     // &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;  }  // for...of循环读取键值(value)，注意：数组的遍历器接口只返回具有数字索引的属性  for (let i of arr) {    console.log(i);     // a,b,c -- 不会返回数组arr的foo属性  }</code></pre></li><li><p>遍历对象</p><pre><code class="lang-js">  // 对于普通的对象，for...of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用  let es6 = {    edition: 6,    committee: &quot;TC39&quot;,    standard: &quot;ECMA-262&quot;  };  for (let e of es6) {    console.log(e);        // TypeError: es6[Symbol.iterator] is not a function  }  // for...in可以遍历普通对象  for (let e in es6) {    console.log(e);        // edition,committee,standard  }</code></pre></li></ul></li></ul></li></ul><h2 id="header-13">Proxy 代理器</h2><p>用于修改某些操作的默认行为，相当于在目标对象之前架设一层“拦截”,对外界的访问进行过滤和改写</p><h3 id="header-14">Proxy 对象</h3><p><strong> 构造Proxy实例对象：</strong></p><ul><li><p>方式一：<code>var proxy = new Proxy(target, handler);</code></p><pre><code class="lang-js">  var person = {    name: &quot;张三&quot;  };  var proxy = new Proxy(person, {    get: function(target, property) {      if (property in target) {        return target[property];      } else {        throw new ReferenceError(&quot;Property \&quot;&quot; + property + &quot;\&quot; does not exist.&quot;);      }    }  });  proxy.name // &quot;张三&quot;  proxy.age // 抛出一个错误</code></pre></li><li><p>方式二：<code>let {proxy,revoke}=Proxy.revocable(target,handler);</code> : 生成一个可取消的 Proxy 实例</p><ul><li>Proxy.revocable方法返回一个对象</li><li>该对象的proxy属性是Proxy实例</li><li><p>该对象的revoke属性是一个函数，可以取消Proxy实例</p><pre><code class="lang-js">let target = {};let handler = {};let {proxy, revoke} = Proxy.revocable(target, handler);proxy.foo = 123;proxy.foo // 123revoke();proxy.foo // TypeError: Revoked</code></pre></li></ul></li><li><p>参数说明：</p><ul><li><code>target</code>：所要拦截的目标对象</li><li><code>handler</code>：对象，用于定制拦截行为，若为空对象{}，则没有任何拦截效果，访问proxy对象等同于访问target对象</li></ul></li><li><p>注：Proxy代理后，目标对象内部的<code>this</code>会指向Proxy代理对象</p><pre><code class="lang-js">  const target = {    m: function () {      console.log(this === proxy);    }  };  const handler = {};  const proxy = new Proxy(target, handler);  target.m() // false  proxy.m()  // true</code></pre></li></ul><p><strong> Proxy 支持的拦截操作：</strong></p><ul><li>对象属性<ul><li><code>get(target,propKey,receiver)</code> : 拦截对象属性的读取,eg: <code>proxy.foo,proxy[&#39;foo&#39;]</code></li><li><code>set(target,propKey,value,receiver)</code> : 拦截对象属性的设置,eg: <code>proxy.foo=v,proxy[&#39;foo&#39;]=v</code></li><li><code>has(target,propKey)</code> : propKey in proxy</li><li><code>deleteProperty(target,propKey)</code>: delete proxy[propKey]</li></ul></li><li>函数调用<ul><li><code>apply(target,ctx,args)</code>: 拦截 Proxy 实例作为函数调用的操作,eg: <code>proxy(...args)</code>,<code>proxy.call(ctx,...args)</code>,<code>proxy.apply(...)</code></li><li><code>construct(target,args)</code>: 拦截 Proxy 实例作为构造函数调用的操作,eg: <code>new proxy(...args)</code></li></ul></li><li>属性描述对象<ul><li><code>defineProperty(target,propKey,propDesc)</code>: 拦截添加新属性,eg: <code>Object.defineProperty(proxy, propKey, propDesc)</code>,<code>Object.defineProperties(proxy, propDescs)</code></li><li><code>ownKeys(target)</code>: 拦截对象自身属性的读取操作, eg: <code>Object.getOwnPropertyNames</code>,<code>Object.getOwnPropertySymbols</code>,<code>Object.keys</code>,<code>for...in</code></li><li><code>getOwnPropertyDescriptor(target,propKey)</code>: 拦截获取属性描述对象, eg: <code>Object.getOwnPropertyDescriptor(proxy, propKey)</code></li></ul></li><li>对象原型<ul><li><code>getPropertyOf(target)</code>: 拦截获取对象原型, eg: <code>Object.getPrototypeOf(proxy)</code>,<code>instanceof</code></li><li><code>setPropertyOf(target,proto)</code>: 拦截设置对象原型, eg: <code>Object.setPrototypeOf(proxy, proto)</code></li></ul></li><li>对象扩展<ul><li><code>isExtensible(target)</code>: Object.isExtensible(proxy)</li><li><code>preventExtensions(target)</code>: Object.preventExtensions(proxy)</li></ul></li></ul><p><strong> 应用示例：</strong></p><ol><li><p>Proxy对象作为普通函数调用 VS 作为构造函数调用</p><pre><code class="lang-js"> var handler = {   get: function(target, name) {     if (name === &#39;prototype&#39;) {       return Object.prototype;     }     return &#39;Hello, &#39; + name;   },   apply: function(target, thisBinding, args) {     return args[0];   },   construct: function(target, args) {     return {value: args[1]};   } }; var fproxy = new Proxy(function(x, y) {   return x + y; }, handler); fproxy(1, 2) // 1 new fproxy(1, 2) // {value: 2} fproxy.prototype === Object.prototype // true fproxy.foo === &quot;Hello, foo&quot; // true</code></pre></li><li><p>私有变量</p><ul><li><p>ES3 写法</p><pre><code class="lang-js">  var Person=function(){      var data={          name:&#39;Tom&#39;,          sex:&#39;male&#39;,          age:15      }      this.get=function(key){          return data[key];      }      this.set=function(key,value){          if(key!==&#39;sex&#39;)              data[key]=value;      }  }  var person=new Person();  person.set(&#39;name&#39;,&#39;Jack&#39;);  person.set(&#39;sex&#39;,&#39;female&#39;);  console.table({      name: person.get(&#39;name&#39;),      sex: person.get(&#39;sex&#39;),      age: person.get(&#39;age&#39;)  }); // Jack,male,15</code></pre></li><li>ES5 写法<pre><code class="lang-js">  var Person={      name:&#39;Tom&#39;,      age: 15  }  Object.defineProperty(Person,&#39;sex&#39;,{      writable:false,      value:&#39;male&#39;  })  Person.name=&#39;Jack&#39;;  console.table({      name: Person.name,      age: Person.age,      sex: Person.sex  }); // Jack,male,15  Person.sex=&#39;female&#39;;    // will throw exception</code></pre></li><li><p>ES6</p><pre><code class="lang-js">  let Person={      name:&#39;Tom&#39;,      sex:&#39;male&#39;,      age:15  };  let person=new Proxy(Person,{      get(target,key){          return target[key]      }      set(target,key){          if(key!==&#39;sex&#39;)              target[key]=value;      }  });  person.set(&#39;name&#39;,&#39;Jack&#39;);  console.table({      name: person.get(&#39;name&#39;),      sex: person.get(&#39;sex&#39;),      age: person.get(&#39;age&#39;)  }); // Jack,male,15  person.set(&#39;sex&#39;,&#39;female&#39;);    // will throw exception</code></pre></li></ul></li></ol><h3 id="header-15">Reflect 对象</h3><ol><li><p>将Object的一些方法放到Reflect上，使用Reflect代替Object的一些方法，例如：</p><ul><li><p>defineProperty方法</p><pre><code class="lang-js">  // 老写法  try {    Object.defineProperty(target, property, attributes);    // success  } catch (e) {    // failure  }  // 新写法  if (Reflect.defineProperty(target, property, attributes)) {    // success  } else {    // failure  }</code></pre></li><li><p>判断对象是否有某属性</p><pre><code class="lang-js">  // 老写法  &#39;assign&#39; in Object // true  // 新写法  Reflect.has(Object, &#39;assign&#39;) // true</code></pre></li><li><p>方法调用</p><pre><code class="lang-js">  // 老写法  Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1  // 新写法  Reflect.apply(Math.floor, undefined, [1.75]) // 1</code></pre></li></ul></li><li><p>与Proxy对象的方法一一对应，可通过Reflect获取对象原有的默认行为，例如：</p><pre><code class="lang-js"> var loggedObj = new Proxy(obj, {   get(target, name) {     console.log(&#39;get&#39;, target, name);     return Reflect.get(target, name);   },   deleteProperty(target, name) {     console.log(&#39;delete&#39; + name);     return Reflect.deleteProperty(target, name);   },   has(target, name) {     console.log(&#39;has&#39; + name);     return Reflect.has(target, name);   } });</code></pre></li></ol><h2 id="header-16">对象 <code>Object</code></h2><h3 id="header-17">对象属性</h3><p><strong> <code>Descriptor</code>属性描述对象：</strong> 对象的每个属性都有一个描述对象，用来控制该属性的行为</p><ul><li><p>数据属性描述对象包含：</p><ul><li>value</li><li>writable</li><li>enumerable</li><li>configurable</li></ul></li><li><p>获取对象自身属性（非继承属性）的描述对象</p><ul><li>Object.getOwnPropertyDescriptor</li><li>Object.getOwnPropertyDescriptors</li><li>Reflect.getOwnPropertyDescriptors</li></ul></li><li><p>某属性的描述对象的enumerable：可枚举性，若为false，即不可枚举，则一下操作会忽略该属性</p><ul><li>for…in循环</li><li>Object.keys()</li><li>JSON.stringify()</li><li>Object.assign()</li><li>注：<ul><li>以上操作除了<code>for...in</code>会包含继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性</li><li>ES6 规定，所有 Class 的原型的方法都是不可枚举的</li></ul></li></ul></li></ul><p><strong> <code>__prop__</code>属性 </strong>（前后各两个下划线）： 等于<code>Object.prototype.__proto__</code>，即一个对象的<code>__prop__</code>属性值就是对象的原型</p><ul><li>操作对象的prototype对象（原型对象）的方法：<ul><li>Object.setPrototypeOf(object, prototype); </li><li>Object.getPrototypeOf(object); </li><li>Object.create(…) </li></ul></li></ul><p><strong> 获取对象自身属性的操作 </strong>（即不包括继承属性）:</p><ul><li>可枚举属性（无Symbol）：Object.keys(obj) – ES2017 引入了Object.values,Object.entries，作为遍历一个对象的补充手段，供for…of循环使用</li><li>可枚举和不可枚举属性（无Symbol）：Object.getOwnPropertyNames(obj) </li><li>Symbol属性：Object.getOwnPropertySymbols(obj) </li><li>所有（可枚举，不可枚举，Symbol）：Reflect.ownKeys(obj) </li></ul><p><strong> 示例：</strong></p><ol><li><p>Descriptor 属性描述对象</p><pre><code class="lang-js"> const obj = {   foo: 123,   get bar() { return &#39;abc&#39; } }; Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;) Object.getOwnPropertyDescriptors(obj) // descriptor对象 // { foo: //    { value: 123, //      writable: true, //      enumerable: true,         // 可枚举性 //      configurable: true //     }, //   bar: //    { get: [Function: get bar], //      set: undefined, //      enumerable: true, //      configurable: true }  // }</code></pre></li><li><p>读取/遍历对象</p><pre><code class="lang-js"> let obj = { a: 1, b: 2, c: 3 }; Object.keys(obj)                                            // [&#39;a&#39;, &#39;b&#39;] Object.values(obj)                                         //  [1,2,3] Object.entries(obj)                                        // [ [&#39;a&#39;, 1], [&#39;b&#39;, 2],[&#39;c&#39;,3] ] for (let [key, value] of entries(obj)) {   console.log([key, value]);                                // [&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3] } const map = new Map(Object.entries(obj));    // Map {a: 1, b: 2, c: 3}</code></pre></li></ol><h3 id="header-18">对象比较</h3><ul><li><code>==</code> 相等运算符：自动转换数据类型</li><li><code>===</code> 严格相等运算符：NaN不等于自身，+0与-0相等</li><li><code>Object.is</code> 同值相等：比较两个值是否严格相等，与<code>===</code>相比，<code>NaN</code>等于自身，<code>+0</code>与<code>-0</code>不等</li></ul><pre><code class="lang-js">+0 === -0                 //trueNaN === NaN                 // falseObject.is(+0, -0)         // falseObject.is(NaN, NaN)        // trueObject.is(&#39;foo&#39;, &#39;foo&#39;)    // trueObject.is({}, {})          // false</code></pre><h3 id="header-19">对象拷贝</h3><p><strong> 浅拷贝：</strong> 只能进行值的复制，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用</p><ol><li><p><code>Object.assign(target,src1,src2,...)</code> : 拷贝可被枚举的自有属性到目标对象（浅拷贝，同名属性替换， 取值函数求值后再复制）</p><pre><code class="lang-js"> // 浅拷贝，同名属性替换 const target = { a: 1, b: 1,d:{e:&#39;hello&#39;,f:&#39;world&#39;} }; const source1 = { b: 2, c: 2 }; const source2 = { c: 3,d:{g:&#39;say&#39;} }; Object.assign(target, source1, source2);                // {a:1, b:2, c:3,d:{g:&#39;say&#39;}}</code></pre><ul><li>参数注意点：<ul><li>只有一个参数，即只有<code>target</code>，则返回<code>target</code>（不是对象会先转换成对象返回）</li><li>传入不是对象的参数，会先转成对象（eg：字符串可转换为字符数组，数组视为属性名为 0、1、2 的对象）</li><li>传入无法转成对象的参数（eg: undefined,null，数值，布尔值）：<ul><li>作为第一个参数（即target）会报错；</li><li>不是第一个参数（即source），会跳过</li></ul></li></ul></li><li>只拷贝属性值，不会拷贝它背后的赋值方法或取值方法，取值函数求值后再复制值<pre><code class="lang-js">  // 不会复制取值函数,会用取值函数求值后再复制  const source = {    get foo() { return 1 }  };  Object.assign({}, source)                                        // { foo: 1 }</code></pre></li><li><p>使用<code>Object.getOwnPropertyDescriptors方法</code>配合<code>Object.defineProperties方法</code>添加描述对象，可实现正确拷贝</p><pre><code class="lang-js">// 配合Object.defineProperties方法添加描述对象const source = {set foo(value) {  console.log(value);}};const target = {};Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));Object.getOwnPropertyDescriptor(target, &#39;foo&#39;);// {//   get: undefined,//   set: [Function: set foo],//   enumerable: true,//   configurable: true//}</code></pre></li></ul></li><li><p><code>Object.create(proto [, propertyDescriptors ])</code> ：创建一个新对象，对象继承到<code>__proto__</code>属性上</p><pre><code class="lang-js"> const person = {   isHuman: false,   printIntroduction: function () {     console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);   } }; const me = Object.create(person); me.name = &quot;Matthew&quot;;             // &quot;name&quot; is a property set on &quot;me&quot;, but not on &quot;person&quot; me.isHuman = true;               // inherited properties can be overwritten me.printIntroduction();          // &quot;My name is Matthew. Am I human? true&quot;</code></pre><ul><li><code>proto</code>：新创建对象的原型对象，可为null</li><li><p><code>propertyDescriptors</code>：可选项，新对象属性的描述对象（其自身定义的属性，不是其原型链上的属性）</p><pre><code class="lang-js">  let o = Object.create({}, { p: { value: 42 } })   // 创建一个以空对象为原型,拥有一个属性p的对象   // 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的  // p的属性描述对象的enumerable默认是false, 改成true，Object.values就会返回属性p的值  Object.values(obj)     // []  o.p                    // 42  o.p = 20               // 失败  o.__proto__            // Object {}  o.__proto__.p          // undefined</code></pre><pre><code class="lang-js">  var o = Object.create(Object.prototype, {  foo: {                                    // foo会成为所创建对象的数据属性       writable:true,      configurable:true,      value: &quot;hello&quot;    },  bar: {                                    // bar会成为所创建对象的访问器属性        configurable: false,                // false，下面set,get方法不起作用      get: function() { return 10 },      set: function(value) {        console.log(&quot;Setting `o.bar` to&quot;, value);      }    }  });  console.log(o);                         // {foo:&#39;hello&#39;}</code></pre></li></ul></li><li><p><code>Object.create()</code>,<code>new Object()</code>,<code>{}</code> 区别</p><pre><code class="lang-js"> // test1,test2,test3的__proto 一样 var test1 = {}; var test2 = new Object(); var test3 = Object.create(Object.prototype); // 创建一个原型为null的对象，test4.__proto__为undefined， 没有继承原型属性和方法，不同于test1，2，3 var test4 = Object.create(null); var test = Object.create({x:123,y:345}); console.log(test);                                               //{} console.log(test.x);                                            //123 console.log(test.__proto__.x);                            //123 console.log(test.__proto__.x === test.x);          //true var test1 = new Object({x:123,y:345}); console.log(test1);                                              //{x:123,y:345} console.log(test1.x);                                            //123 console.log(test1.__proto__.x);                            //undefined console.log(test1.__proto__.x === test1.x);        //false var test2 = {x:123,y:345}; console.log(test2);                                                 //{x:123,y:345}; console.log(test2.x);                                                //123 console.log(test2.__proto__.x);                                //undefined console.log(test2.__proto__.x === test2.x);            //false</code></pre></li></ol><p><strong> 综合示例：</strong> 克隆一个对象（包括对象原型的属性，浅拷贝）</p><pre><code class="lang-js">// 写法一，注：__proto__属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三const clone1 = {  __proto__: Object.getPrototypeOf(obj),  ...obj};// 写法二const clone2 = Object.assign(  Object.create(Object.getPrototypeOf(obj)),  obj);// 写法三const clone3 = Object.create(  Object.getPrototypeOf(obj),  Object.getOwnPropertyDescriptors(obj));</code></pre><h3 id="header-20">super对象</h3><p>指向当前对象的原型对象</p><p><strong> 示例：</strong></p><ol><li><p>调用当前对象原型对象的属性</p><pre><code class="lang-js"> const proto = { foo: &#39;hello&#39;}; const obj = {   foo: &#39;world&#39;,   find() {     return super.foo;                                        // 引用了原型对象proto的foo属性，同 Object.getPrototypeOf(this).foo   } }; Object.setPrototypeOf(obj, proto); obj.find()                                                         // &quot;hello&quot;</code></pre></li><li><p>调用当前对象原型对象的方法</p><pre><code class="lang-js"> const proto = {   x: &#39;hello&#39;,   foo() {     console.log(this.x);   }, }; const obj = {   x: &#39;world&#39;,   foo() {     super.foo();                                                    // 同 Object.getPrototypeOf(this).foo.call(this)，this绑定的是当前obj   } } Object.setPrototypeOf(obj, proto); obj.foo()                                                             // &quot;world&quot;</code></pre></li><li><p><strong> 注：</strong> 只能用在对象的方法中（注：方法为简写方式才可以让 JavaScript 引擎确认，定义的是对象的方法）</p><ul><li>super用在属性里面，报错<pre><code class="lang-js">  const obj = {    foo: super.foo  }</code></pre></li><li><p>super用在一个函数里面，然后赋值给foo属性,报错</p><pre><code class="lang-js">  // 错  const obj = {    foo: () =&gt; super.foo  }  // 错  const obj = {    foo: function () {      return super.foo    }  }</code></pre></li></ul></li></ol><h2 id="header-21">函数 <code>function</code></h2><h3 id="header-22">name属性</h3><p>返回函数的函数名</p><pre><code class="lang-js">function foo() {}foo.name                                     // &quot;foo&quot;const a = function baz() {};a.name                                       // &quot;baz&quot;</code></pre><p><strong> 注：</strong></p><ul><li>匿名函数: ES5返回空字符串，ES6返回赋给的变量名<pre><code class="lang-js">  var f = function () {};  f.name                                  // ES5 &quot;&quot;； ES6 &quot;f&quot;</code></pre></li><li>Function构造函数返回的函数实例: anonymous<pre><code class="lang-js">  (new Function).name                      // &quot;anonymous&quot;</code></pre></li><li><p>bind返回的函数: name属性值会加上<code>bound</code>前缀</p><pre><code class="lang-js">  function foo() {};  foo.bind({}).name                         // &quot;bound foo&quot;  (function(){}).bind({}).name            // &quot;bound &quot;</code></pre></li></ul><h3 id="header-23">函数参数</h3><ol><li><p>通过解构赋值设置参数</p><pre><code class="lang-js"> function add([x, y]){                        // 参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y   return x + y; } add([1, 2]);                                // 3 [[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);    // [ 3, 7 ]</code></pre></li><li><p>处理可变参数: 使用rest参数<code>...参数名</code>（类似ES5的arguments）</p><pre><code class="lang-js"> function add(...values) {    // values同ES5 Array.prototype.slice.call(arguments);   let sum = 0;   for (let val of values) {     sum += val;   }   return sum; } add(2, 5, 3)                 // 10</code></pre></li></ol><h3 id="header-24">参数默认值</h3><ul><li><p>直接写在参数定义的后面</p><pre><code class="lang-js">  function log(x, y = &#39;World&#39;) {    console.log(x, y);  }  log(&#39;Hello&#39;)              // Hello World  log(&#39;Hello&#39;, &#39;China&#39;)     // Hello China</code></pre></li><li><p>可以使用表达式/函数（惰性求值）</p><pre><code class="lang-js">  let x = 99;  function foo(p = x + 1) {    console.log(p);  }  foo()             // 100  x = 100;  foo()             // 101</code></pre></li><li><p>使用解构赋值设置默认值</p><pre><code class="lang-js">  /* 1. 为函数参数对象整体指定默认值，eg: 为{x,y}对象整体指定默认值，而不是为变量x和y指定默认值 */  function m2({x, y} = { x: 0, y: 0 }) {    return [x, y];  }  m2()                    // [0,0]  m2({})                  // [undefined,undefined]  m2({x: 3})              // [3, undefined]  m2({x:3,y:8})           // [3, 8]  /* 2. 为函数某个具体参数指定默认值，eg：为变量y指定默认值 */  function foo({x, y = 5} = {}) {    console.log(x, y);  }  foo()                     // undefined 5  foo({})                   // undefined 5  foo({x:3})                // 3 5  foo({x:3,y:8})            // 3 8</code></pre></li><li><p>注：指定了默认值后，函数的length属性将失真，会返回没有指定默认值的参数个数</p><pre><code class="lang-js">  // 函数的length属性: 函数预期传入的参数个数  (function(...args) {}).length                 // 0  (function (a) {}).length                      // 1  // 设置默认参数后，函数的length属性将失真：  (function (a, b, c = 5) {}).length             // 2  (function (a, b = 1, c) {}).length             // 1    -- 默认值以后的参数也不计数</code></pre></li></ul><p><strong> 应用示例：</strong></p><ol><li>利用参数默认值，指定某一个参数不得省略，若省略就抛出一个错误<pre><code class="lang-js"> function throwIfMissing() {   throw new Error(&#39;Missing parameter&#39;); } function foo(mustBeProvided = throwIfMissing()) {   return mustBeProvided; } foo()        // Error: Missing parameter</code></pre></li><li>利用参数默认值，指定某一个参数是可以省略的(将参数默认值设为undefined)<pre><code class="lang-js"> function foo(optional = undefined) {      //··· }</code></pre></li></ol><h3 id="header-25">函数绑定运算符 <code>::</code></h3><p>用来取代call、apply、bind调用</p><ul><li><p><code>对象::函数</code> : 会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面</p><pre><code class="lang-js">  bar.bind(foo);        // ES5  foo::bar;             // ES6  bar.apply(foo, arguments);        // ES5  foo::bar(...arguments);           // ES6</code></pre></li><li><code>::对象.方法</code> ：等于将该方法绑定在该对象上面<pre><code class="lang-js">  var log = console.log.bind(console);    // ES5  let log = ::console.log;                // ES6， 同 let log = console::console.log;</code></pre></li><li>若双冒号运算符的运算结果，还是一个对象，可采用链式写法</li></ul><h3 id="header-26">箭头函数 arrow-function</h3><p>简化函数编写形式</p><pre><code class="lang-js">// ES3,ES5function a(){    exp}// ES6// 只有一个参数，可省略&quot;()&quot;// 表达式直接作为返回值时，可省略&quot;{}&quot;(arg)=&gt;{    exp}</code></pre><p><strong> 示例：</strong></p><pre><code class="lang-js">var f = function () { return 5 };                          // ES5var f = () =&gt; 5;                                          // ES6var sum = function(num1, num2) { return num1 + num2;};    // ES5var sum = (num1, num2) =&gt; num1 + num2;                    // ES6[1,2,3,4,5].map(function(v){ return v+1; });              // ES5[1,2,3,4,5].map(v=&gt;v+1);                                  // ES6//无返回let fn = () =&gt; void doesNotReturn();//返回一个对象（为防止语法歧义报错，用圆括号包起来）let getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; });//使用rest参数const headAndTail = (head, ...tail) =&gt; [head, tail];headAndTail(1, 2, 3, 4, 5)        // [1,[2,3,4,5]]</code></pre><p><strong> 限制：</strong></p><ul><li>不能用作构造函数（即不能用new）</li><li>不能使用arguments对象，用rest参数代替</li><li>不能用作Generator函数（即不能使用yield）</li></ul><p><strong> <code>this</code>对象: </strong> 在箭头函数中，this对象的指向是固定的，为定义时所在的对象，不是使用时所在的对象</p><ul><li>实际上：箭头函数没有自己的 <code>this</code>、<code>arguments</code>、<code>super</code>、<code>new.target</code>，只能引用外层代码块的对应变量</li><li>因为没有自己的<code>this</code>（使用外层代码块的<code>this</code>），所以不能用作构造函数，也不能使用<code>call</code>，<code>apply</code>，<code>bind</code>这些方法去改变<code>this</code>的指向</li></ul><p><strong> 示例：</strong></p><ol><li><p>ES3,ES5 原始写法 : this 指向的是该函数被调用的对象</p><pre><code class="lang-js"> var factory=function(){     this.a=&#39;a&#39;;     this.b=&#39;b&#39;;     this.c={         a:&#39;a+&#39;,         b:function(){             return this.a;         }     } } console.log(new factory().c.b());            // a+     -- this指向c</code></pre></li><li><p>ES6 箭头函数 : this 指向的是定义时this的指向</p><pre><code class="lang-js"> var factory=function(){      this.a=&#39;a&#39;;      this.b=&#39;b&#39;;      this.c={         a: &#39;a+&#39;,         b: ()=&gt;{             return this.a;         }     } } console.log(new factory().c.b());    // a    -- 同外层代码this，指向factory</code></pre></li><li><p>箭头函数转成 ES5写法（注意this）</p><pre><code class="lang-js"> // ES6 箭头函数 function foo() {   setTimeout(() =&gt; {     console.log(&#39;id:&#39;, this.id);            // this -- foo   }, 100); } // ES5 原始写法 function foo() {   var _this = this;   setTimeout(function () {     console.log(&#39;id:&#39;, _this.id);   }, 100); }</code></pre></li></ol><h3 id="header-27">优化：尾调用，尾递归</h3><p><strong> 尾调用：</strong> 函数的最后一步是返回调用另一个函数</p><pre><code class="lang-js">function f(x){  return g(x);}function f(x) {  if (x &gt; 0) {    return m(x)  }  return n(x);}</code></pre><p>由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，直接用内层函数的调用帧取代外层函数的调用帧即可<br>注：</p><ul><li>ES6支持尾调用优化，且只在严格模式下开启</li><li>只有不再用到外层函数的内部变量才可取代</li><li><p>例：以下三种情况，都不属于尾调用</p><pre><code class="lang-js">  function f(x){    let y = g(x);    return y;                // 因为调用后还有赋值操作  }  function f(x){    return g(x) + 1;    // 因为调用后还有操作  }  function f(x){    g(x);                    // 函数最后一步为 return undefined；  }</code></pre></li></ul><p><strong> 尾递归：</strong> 尾调用自身</p><p>函数调用自身，因为调用栈太多，容易发生“栈溢出”错误（stack overflow）；<br>而尾递归，由于只存在一个调用帧，所以不会发生“栈溢出”错误</p><p>应用示例：</p><ol><li>计算n的阶乘: <code>n!</code><ul><li>非尾递归实现: 最多需要保存n个调用记录，复杂度 O(n) <pre><code class="lang-js">  function factorial(n) {    if (n === 1) return 1;    return n * factorial(n - 1);  }  factorial(5)             // 120</code></pre></li><li>尾递归实现（将所有用到的内部中间变量改写成函数的参数）: 只保留一个调用记录，复杂度 O(1)<pre><code class="lang-js">  function factorial(n, total=1) {    if (n === 1) return total;    return factorial(n - 1, n * total);  }  factorial(5, 1)             // 120</code></pre></li></ul></li><li><p>Fibonacci 数列</p><ul><li><p>非尾递归的 Fibonacci 数列实现</p><pre><code class="lang-js">  function Fibonacci (n) {    if ( n &lt;= 1 ) {          return 1      };    return Fibonacci(n - 1) + Fibonacci(n - 2);  }  Fibonacci(10)               // 89  Fibonacci(100)             // 堆栈溢出  Fibonacci(500)             // 堆栈溢出</code></pre></li><li><p>尾递归优化过的 Fibonacci 数列实现</p><pre><code class="lang-js">  function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {    if( n &lt;= 1 ) {          return ac2      };    return Fibonacci2 (n - 1, ac2, ac1 + ac2);  }  Fibonacci2(100)             // 573147844013817200000  Fibonacci2(1000)           // 7.0330367711422765e+208  Fibonacci2(10000)         // Infinity</code></pre></li></ul></li></ol><p><strong> 注：</strong><br>尾递归优化只在严格模式下生效，正常模式下可采用“循环”换掉“递归”的方式进行优化</p><h2 id="header-28">Symbol</h2><ol><li>ES6新增的原始数据类型，类似于字符串的数据类型 （Javascript其他原始数据类型有：undefined，null，Boolean，String，Number，Object）</li><li><strong> 表示独一无二的值 </strong>（例如：可以用来保证对象的属性名是独一无二的）</li><li>通过<code>Symbol()</code>函数生成，可以接受一个字符串作为参数，表示对Symbol实例的描述</li><li>注：不能使用<code>new</code>，基本上，它是一种类似于字符串的数据类型</li></ol><pre><code class="lang-js">let s = Symbol(); typeof s                                // &quot;symbol&quot;let s1 = Symbol(&#39;foo&#39;);s1                                     // Symbol(foo)s1.toString()                         // &quot;Symbol(foo)&quot;  //相同参数的Symbol函数的返回值是不相等let s2 = Symbol(&#39;foo&#39;);s1 === s2                             // false// 用于对象属性let mySymbol = Symbol();let a = {  [mySymbol]: &#39;Hello!&#39;};a[mySymbol]                         // &quot;Hello!&quot;</code></pre><h2 id="header-29">Set/WeakSet</h2><h3 id="header-30">Set</h3><ul><li>类似于数组，但是成员的值都是唯一，可枚举（<code>Array.from</code>方法可以将 Set 结构转为数组）</li><li>可以接受一个具有 iterable 接口的数据结构作为参数（例如数组），用来初始化</li><li>内部使用同值相等判断两个值是否相同（比严格相等<code>===</code>，多了NaN和0的比较)，注：两个对象总是不相等的</li><li>属性：<ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是Set函数。</li><li><code>Set.prototype.size</code>：返回Set实例的成员总数。</li></ul></li><li>方法（操作）：<ul><li>add(value)</li><li>delete(value)</li><li>has(value)</li><li>clear()</li></ul></li><li>方法（遍历）：<ul><li>keys()</li><li>values()</li><li>entries()</li><li>forEach()        </li></ul></li></ul><p><strong> 示例：</strong></p><ol><li><p>无参构造使用Set</p><pre><code class="lang-js"> let s= new Set(); s.add(1).add(2).add(2); s.size                                       // 2 s.has(1)                                     // true s.has(2)                                     // true s.has(3)                                     // false s.delete(2); s.has(2)                                     // false</code></pre></li><li><p>可枚举对象作为参数构造</p><pre><code class="lang-js"> const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]); items.size                                     // 5 const s = new Set(); [2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x)); // 去除数组的重复成员 [...new Set(array)]</code></pre></li><li><p>遍历</p><pre><code class="lang-js"> let s2= new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]); s2.keys()                    // [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;] s2.values()                  // [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;] s2.entries()                 // [ [&#39;red&#39;,&#39;red&#39;], [&#39;green&#39;,&#39;green&#39;], [&#39;blue&#39;,&#39;blue&#39;] ] // for...of循环遍历 for (let x of s2) {          // 默认遍历器生成函数就是它的values方法   console.log(x); } // red // green // blue // forEach循环遍历 s2.forEach((value, key) =&gt; console.log(key + &#39; : &#39; + value)) // red:red // green:green // blue:blue</code></pre><ul><li>注：<code>keys/values()</code> Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致，默认遍历器生成函数就是values方法</li></ul></li><li><p>应用：Set 实现并集（Union）、交集（Intersect）和差集（Difference）</p><pre><code class="lang-js"> let a = new Set([1, 2, 3]); let b = new Set([4, 3, 2]); // 并集 let union = new Set([...a, ...b]);                                // Set {1, 2, 3, 4} // 交集 let intersect = new Set([...a].filter(x =&gt; b.has(x)));            // set {2, 3} // 差集 let difference = new Set([...a].filter(x =&gt; !b.has(x)));          // Set {1}</code></pre></li></ol><h3 id="header-31">WeakSet</h3><ul><li>与Set区别：<ul><li>成员只能是对象，而不能是其他类型的值    </li><li>成员对象都是弱引用，随时可能消失（即如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中）</li><li>垃圾回收机制运行前后可能会导致成员数不一样，所以ES6 规定 WeakSet不可遍历</li></ul></li><li>方法：<ul><li>add(value)</li><li>delete(value)</li><li>has(value)</li></ul></li></ul><p><strong> 示例：</strong></p><ol><li><p>构造使用 WeakSet</p><pre><code class="lang-js"> const ws = new WeakSet(); const obj = {}; const foo = {}; ws.add(window); ws.add(obj); ws.has(window);             // true ws.has(foo);                // false ws.delete(window); ws.has(window);                // false // WeakSet 没有size属性，不能遍历：因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在 ws.size                     // undefined ws.forEach                     // undefined</code></pre></li><li><p>有参构造 WeakSet（注：WeakSet的成员只能是对象）</p><pre><code class="lang-js"> // 可以接受具有 Iterable 接口的对象 const a = [[1, 2], [3, 4]]; const ws1 = new WeakSet(a);            // WeakSet {[1, 2], [3, 4]} 注：a数组的成员成为 WeakSet 的成员，不是a数组本身 const b = [3, 4]; const ws2 = new WeakSet([3, 4]);      // Uncaught TypeError: Invalid value used in weak set(…) 注：b数组的成员不是对象</code></pre></li><li><p>应用：Weakset 储存 DOM 节点，不用担心这些节点从文档移除时，会引发内存泄漏</p><pre><code class="lang-js"> const foos = new WeakSet()            // foos对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑foos，也不会出现内存泄漏 class Foo {   constructor() {     foos.add(this)   }   method () {     if (!foos.has(this)) {       throw new TypeError(&#39;Foo.prototype.method 只能在Foo的实例上调用！&#39;);     }   } }</code></pre></li></ol><h2 id="header-32">Map/WeakMap</h2><h3 id="header-33">Map</h3><ul><li>键值对集合，类似对象（Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，key不限于字符串，各种类型的值包括对象都可以当作键，是一种更完善的 Hash 结构实现）</li><li>键唯一，跟内存地址绑定的，只要内存地址不一样，就视为两个键（0和-0是一个键，NaN视为同一个键）    </li><li>Map 的遍历顺序就是插入顺序</li><li>属性：<ul><li>size</li></ul></li><li>方法（操作）：<ul><li>set(key,value)</li><li>get(key)</li><li>has(key)</li><li>delete(key)</li><li>clear()</li></ul></li><li>方法（遍历）：<ul><li>keys()</li><li>values()</li><li>entries()</li><li>forEach()</li></ul></li></ul><p><strong> 示例：</strong></p><ol><li><p>无参数构造</p><pre><code class="lang-js"> const m = new Map(); const o = {p: &#39;Hello World&#39;}; m.set(o, &#39;content&#39;) m.get(o)                        // &quot;content&quot; m.set(1,&#39;Hello&#39;)  m.get(1)                        // &quot;Hello&quot; m.get(&#39;a&#39;)                        // undefined m.set(undefined, 3);             m.get(undefined)                // 3 m.set([&#39;a&#39;], 555); m.get([&#39;a&#39;])                    // undefined m.set(1,&#39;a&#39;).set(2,&#39;b&#39;)</code></pre></li><li><p>可枚举对象作为参数构造</p><pre><code class="lang-js"> const m= new Map([   [&#39;name&#39;, &#39;张三&#39;],   [&#39;title&#39;, &#39;Author&#39;] ]);                             // Map {&#39;name&#39;:&#39;张三&#39;,&#39;title&#39;:&#39;Author&#39;} // 相当于 param.forEach(   ([key, value]) =&gt; m.set(key, value) ); m.size                            // 2 m.has(&#39;name&#39;)                    // true m.get(&#39;name&#39;)                    // &quot;张三&quot;</code></pre></li><li><p>遍历</p><pre><code class="lang-js"> m.keys()        // [&#39;name&#39;,&#39;title&#39;] m.values()        // [&#39;张三&#39;,&#39;Author&#39;] m.entries()        // [ [&#39;name&#39;, &#39;张三&#39;],[&#39;title&#39;, &#39;Author&#39;] ] // forEach循环遍历 m.forEach(function(value, key, map) {   console.log(&quot;Key: %s, Value: %s&quot;, key, value); }); // for...of循环遍历 for (let [key, value] of map) {   console.log(key, value); } for (let [key, value] of map.entries()) {   console.log(key, value); } for (let item of map.entries()) {   console.log(item[0], item[1]); } // name 张三 // title Author</code></pre><ul><li>注：<code>entries()</code> 是Map结构的默认遍历器接口（部署在Symbol.iterator属性上，即<code>map[Symbol.iterator] === map.entries</code>）</li></ul></li><li><p>Map &lt;-&gt; Array 转换</p><ul><li>Map -&gt; Array: 使用扩展运算符 <code>...</code><pre><code class="lang-js">  const myMap = new Map()    .set(true, 7)    .set({foo: 3}, [&#39;abc&#39;]);  [...myMap]                                    // [ [ true, 7 ], [ { foo: 3 }, [ &#39;abc&#39; ] ] ]</code></pre></li><li>Array -&gt; Map: 直接作为参数传入Map构造函数<pre><code class="lang-js">  new Map([    [true, 7],    [{foo: 3}, [&#39;abc&#39;]]  ])                                           // Map { true:7, {foo:3}:[&#39;abc&#39;] }</code></pre></li></ul></li></ol><h3 id="header-34">Weakmap</h3><ul><li>与Map区别：<ul><li>只接受对象作为键名（null除外）</li><li>键名所指向的对象为弱引用（不计入垃圾回收机制，即一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用）</li><li>注：WeakMap 弱引用的只是键名，而不是键值，所以即使在 WeakMap 外部消除了键值的引用，WeakMap 内部的引用依然存在</li><li>没有遍历操作（即没有keys()、values()，entries()，forEach方法），也没有size属性</li><li>无法清空，即不支持clear方法</li></ul></li><li>方法：<ul><li>get()、set()、has()、delete()</li></ul></li><li>应用（WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏）<ul><li>DOM 节点作为键名（在网页的 DOM 元素上添加数据，当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除，有助于防止内存泄漏）</li><li>部署私有属性</li></ul></li></ul><p><strong> 示例：</strong></p><ol><li><p>构造使用 WeakMap</p><pre><code class="lang-js"> const wm = new WeakMap(); const key = {foo: 1}; wm.set(key, 2);                        // set 添加成员 wm.get(key)                         // get 获取成员 // 只接受对象作为键名（null除外） wm.set(1, 2)                        // TypeError: 1 is not an object! wm.set(Symbol(), 2)                    // TypeError: Invalid value used as weak map key // size、forEach、clear 方法都不存在 wm.size                             // undefined wm.forEach                             // undefined wm.clear                             // undefined // 可接受一个数组，作为构造函数的参数 const k1 = [1, 2, 3]; const k2 = [4, 5, 6]; const wm2 = new WeakMap([[k1, &#39;foo&#39;], [k2, &#39;bar&#39;]]); wm2.get(k2) // &quot;bar&quot;</code></pre></li><li><p>应用：DOM 节点作为键名存储在Weakmap中，防止内存泄漏</p><pre><code class="lang-js"> // myElement是一个 DOM 节点，每当发生click事件，就更新一下状态 // 一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险 let myElement = document.getElementById(&#39;logo&#39;); let myWeakmap = new WeakMap(); myWeakmap.set(myElement, {timesClicked: 0}); myElement.addEventListener(&#39;click&#39;, function() {   let logoData = myWeakmap.get(myElement);   logoData.timesClicked++; }, false);</code></pre></li><li><p>应用：Weakmap 部署私有属性，实例消失，它们也就随之消失</p><pre><code class="lang-js"> // Countdown类的两个内部属性_counter和_action，是实例的弱引用 // 如果删除实例，它们也就随之消失，不会造成内存泄漏 const _counter = new WeakMap(); const _action = new WeakMap(); class Countdown {   constructor(counter, action) {     _counter.set(this, counter);     _action.set(this, action);   }   dec() {     let counter = _counter.get(this);     if (counter &lt; 1) return;     counter--;     _counter.set(this, counter);     if (counter === 0) {       _action.get(this)();     }   } } const c = new Countdown(2, () =&gt; console.log(&#39;DONE&#39;)); c.dec() c.dec() // DONE</code></pre></li></ol><h2 id="header-35">类 Class</h2><p>类的数据类型就是函数，类本身就指向构造函数</p><ul><li><code>constructor</code> 构造函数<ul><li>默认返回实例对象，即this（this 代表实例对象）</li><li>无参构造，可以不显式定义，会默认添加一个空的constructor方法</li></ul></li><li><code>new</code> 创建实例对象<ul><li><code>new 构造函数(args)</code>： 从prototype对象生成一个实例对象 ( 注：ES6 class必须使用new调用,否则会报错 )</li><li><code>new.target</code>: 一般在构造函数中调用，返回new命令作用于的那个构造函数，若不是用new命令调用，返回undefined (这个属性可以用来确定构造函数是怎么调用的)</li></ul></li></ul><p><strong> 类成员: </strong></p><ul><li>变量：定义在this上，是类的实例对象自身的属性，属于类实例对象<pre><code class="lang-js">  class Point {    constructor(x, y) {      this.x = x;      this.y = y;    }  }</code></pre><ul><li>提案：实例属性: 用等式直接写入类的定义之中（以前只能写在类的constructor方法里面）<pre><code class="lang-js">  class MyClass {    myProp = 42;    constructor() {      console.log(this.myProp); // 42    }  }</code></pre></li></ul></li><li>方法: 定义在class上，是原型对象prototype的属性，属于类<pre><code class="lang-js">  class Point {      say(){          console.log(&quot;Hello&quot;);      }  }</code></pre></li><li><p>注：<code>getter/setter</code> 对某个属性设置存值函数和取值函数(部署在Descriptor属性描述对象上)，拦截该属性的存取行为</p><pre><code class="lang-js">  class MyClass {    get prop() {      return &#39;getter&#39;;    }    set prop(value) {      console.log(&#39;setter: &#39;+value);    }  }  let inst = new MyClass();  inst.prop = 123;        // setter: 123  inst.prop                    // &#39;getter&#39;</code></pre></li></ul><p><strong> 私有属性/方法: </strong> </p><ul><li><p>利用<code>Symbol</code>值的唯一性，将私有方法的名字命名为一个Symbol值</p><pre><code class="lang-js">  const bar = Symbol(&#39;bar&#39;);  const snaf = Symbol(&#39;snaf&#39;);  export default class myClass{    // 公有方法    foo(x) {      this[bar](x);    }    // 私有方法    [bar](x) {      return this[snaf] = x;    }  }</code></pre></li><li>提案：使用<code>#</code>表示<pre><code class="lang-js">  class Foo {    #a;    #b;    #sum() { return #a + #b; }    printSum() { console.log(#sum()); }    constructor(a, b) { #a = a; #b = b; }  }</code></pre></li></ul><p><strong> 静态属性/方法：</strong> 直接通过类来调用（实例上调用，会抛出错误，表示不存在）</p><ul><li><p>静态属性：ES6 没有静态属性，可在类外部定义实现</p><pre><code class="lang-js">  class Foo {}  Foo.prop = 1;        // 为Foo类定义了一个静态属性prop  Foo.prop // 1</code></pre><ul><li><p>提案：在实例属性写法前面加上static关键字</p><pre><code class="lang-js">  class MyClass {    static myStaticProp = 42;    constructor() {      console.log(MyClass.myStaticProp); // 42    }  }</code></pre></li></ul></li><li><p>静态方法: 可以与非静态方法重名 ( 注：static方法中的this指向类，不是实例 )</p><pre><code class="lang-js">  class Foo {    static classMethod() {      return &#39;hello&#39;;    }  }  Foo.classMethod() // &#39;hello&#39;  var foo = new Foo();  foo.classMethod()                // TypeError: foo.classMethod is not a function</code></pre></li></ul><p><strong> 示例：</strong></p><ol><li><p>定义使用类</p><ul><li><p>ES5方式</p><pre><code class="lang-js">  // 构造函数：  function Point(x, y) {    this.x = x;    this.y = y;  }  // 类的所有方法都定义在类的prototype属性上面：  Point.prototype={      constructor:Point,      toString:function(){          return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;};      }  }  // 使用  var p = new Point(1, 2);  console.log(p.toString());</code></pre></li><li><p>ES6方式</p><pre><code class="lang-js">  class Point {    constructor(x, y) {      this.x = x;      this.y = y;    }    toString() {      return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;    }  }  var p = new Point(1, 2);  console.log(p.toString());</code></pre></li><li><p>注: </p><ul><li>类的数据类型就是函数，类本身就指向构造函数<pre><code class="lang-js">  typeof Point // &quot;function&quot;  Point === Point.prototype.constructor // true</code></pre></li><li>类属性定义在this变量上，属于类实例对象； 类方法定义在class上 ，属于类<pre><code class="lang-js">  p.hasOwnProperty(&#39;x&#39;) // true  p.hasOwnProperty(&#39;y&#39;) // true  p.hasOwnProperty(&#39;toString&#39;) // false  p.__proto__.hasOwnProperty(&#39;toString&#39;) // true</code></pre></li><li><p>类的内部所有定义的方法，ES6定义的不可枚举，ES5方式定义的可枚举</p><pre><code class="lang-js">  /* ES5 */  Object.keys(Point.prototype)    // [&quot;toString&quot;]  Object.getOwnPropertyNames(Point.prototype)    // [&quot;constructor&quot;,&quot;toString&quot;]  /* ES6 */  Object.keys(Point.prototype)    // []  Object.getOwnPropertyNames(Point.prototype)    // [&quot;constructor&quot;,&quot;toString&quot;]</code></pre></li><li>ES6 class必须使用new调用,否则会报错<pre><code class="lang-js">  var point = Point(2, 3);        // 报错  var point = new Point(2, 3);    // 正确</code></pre></li></ul></li></ul></li><li><p>无参构造类( constructor可以不显式定义)</p><ul><li><p>ES5方式</p><pre><code class="lang-js">  /* Javascript */  function Point() {}  Point.prototype.toString=function(){...}  // 等同于  function Point(){}  Point.prototype={      constructor:Point,      toString:function(){...}  }</code></pre></li><li><p>ES6方式</p><pre><code class="lang-js">  class Point{      toString(){...}  }  // 等同于  class Point {    constructor() {}    toString(){...}  }</code></pre></li></ul></li><li><p>匿名类</p><pre><code class="lang-js"> let person = new class {   constructor(name) {         this.name = name;   }   sayName() {     console.log(this.name);   } }(&#39;张三&#39;); person.sayName();     // &quot;张三&quot;</code></pre></li><li><p><code>new.target</code>: 用在构造函数中调用，返回new命令作用于的那个构造函数</p><ul><li><p>ES5方式</p><pre><code class="lang-js">  function Person(name) {    if (new.target === Person) {      this.name = name;    } else {      throw new Error(&#39;必须使用 new 命令生成实例&#39;);    }  }  var person = new Person(&#39;张三&#39;); // 正确  var notAPerson = Person.call(person, &#39;张三&#39;);  // throw Error: 必须使用 new 命令生成实例</code></pre></li></ul><ul><li><p>ES6</p><pre><code class="lang-js">  class Rectangle {    constructor(length, width) {      console.log(new.target === Rectangle);      this.length = length;      this.width = width;    }  }  var obj = new Rectangle(3, 4);         // 输出 true  var obj2 = Rectangle(2, 3);         // 报错,ES6 class必须使用new调用</code></pre></li><li><p>应用：创建不能独立使用、必须继承后才能使用的类</p><pre><code class="lang-js">  //Class内部调用new.target，返回当前Class；子类继承父类时，返回子类  class Shape {    constructor() {      if (new.target === Shape) {        throw new Error(&#39;本类不能实例化&#39;);      }    }  }  class Rectangle extends Shape {    constructor(length, width) {      super();      // ...    }  }  var x = new Shape();  // 报错  var y = new Rectangle(3, 4);  // 正确</code></pre></li></ul></li></ol><h3 id="header-36">extened 继承</h3><pre><code class="lang-js">class A {  constructor() {    console.log(new.target.name);  // new.target 指向new命令作用于的那个构造函数  }}class B extends A {  constructor() {    super();                  // 相当于 A.prototype.constructor.call(this)， 这里this指的是B的实例 -- super代表父类的构造函数  }}new A()     // Anew B()     // B</code></pre><p><strong> 继承机制：</strong></p><ul><li>ES5：创造子类的实例对象this，再将父类的方法添加到this上面</li><li>ES6：将父类实例对象的属性和方法加到this上面，再用子类的构造函数修改this<ul><li>子类必须在constructor方法中调用super方法，且只有调用super之后，才可以使用this关键字，否则新建实例时会报错</li><li>子类会继承父类的静态方法，也可通过super对象调用父类的静态方法</li></ul></li><li>获取对象原型: <code>Object.getPrototypeof(obj)</code><ul><li>可以用来从子类上获取父类，使用这个方法判断，一个类是否继承了另一个类</li><li>eg:  <code>Object.getPrototypeOf(ColorPoint) === Point</code> 为 true</li></ul></li></ul><p><strong> 原生构造函数的继承（原生类的继承）：</strong></p><ul><li>语言内置的构造函数，ES5无法继承，ES6可以（ ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承）</li><li>ECMAScript 的原生构造函数：<ul><li>Boolean()</li><li>Number()</li><li>String()</li><li>Array()</li><li>Date()</li><li>Function()</li><li>RegExp()</li><li>Error()</li><li>Object()</li></ul></li><li><p>特例：继承Object的子类，无法通过super方法向父类Object传参</p><pre><code class="lang-js">  class NewObj extends Object{    constructor(){      super(...arguments);    }  }  var o = new NewObj({attr: true});  o.attr === true                                      // false</code></pre><ul><li>因为 ES6 改变了Object构造函数的行为，一旦发现Object方法不是通过<code>new Object()</code>这种形式调用，ES6 规定Object构造函数会忽略参数</li></ul></li><li><p>应用实例：定义一个带版本功能的数组</p><pre><code class="lang-js">  class VersionedArray extends Array {    constructor() {      super();      this.history = [[]];    }    commit() {      this.history.push(this.slice());    }    revert() {      this.splice(0, this.length, ...this.history[this.history.length - 1]);    }  }  var x = new VersionedArray();  x.push(1);  x.push(2);  x                                 // [1, 2]  x.history                     // [[]]  x.commit();  x.history                    // [[], [1, 2]]  x.push(3);  x                                 // [1, 2, 3]  x.history                     // [[], [1, 2]]  x.revert();  x                                 // [1, 2]</code></pre></li></ul><h3 id="header-37">super/this 关键字</h3><p><strong> this: </strong> 一般指向该方法运行时所在的环境</p><ul><li>在类中：<ul><li>普通方法中：指向类的实例；</li><li>静态方法中：指向类；</li></ul></li><li>在子类中：<ul><li>普通方法中：指向子类实例；注：用super对象调用父类方法时，父类方法中的this指向的也是子类实例</li><li>静态方法中：指向子类；注：用super对象调用父类方法时，父类方法中的this指向的也是子类</li></ul></li><li>在箭头函数中：<ul><li>指向是固定的，为定义时所在的对象，不是使用时所在的对象（因为箭头函数没有自己的this，只能使用外层代码块的this）</li><li>注：箭头函数不能用作构造函数，也不能使用call，apply，bind这些方法去改变this的指向</li></ul></li><li></li></ul><p><strong> 示例：</strong>    </p><pre><code class="lang-js">class Logger {  printName(name = &#39;there&#39;) {    this.print(`Hello ${name}`);            // this 指向类的实例  }  print(text) {    console.log(text);  }}const logger = new Logger();logger.printName();                        // Hello there</code></pre><p>注：单独使用类方法，而此类方法中使用this调用其他类方法，可能会报错，eg：将printName方法提取出来单独使用会报错</p><pre><code class="lang-js">const { printName } = logger;printName();                              // TypeError: Cannot read property &#39;print&#39; of undefined// 解决方案： 在构造方法中绑定thisclass Logger {  constructor() {    this.printName = this.printName.bind(this);  }  // ...}</code></pre><p><strong> super </strong></p><ul><li><code>super(...)</code>: super方法代表父类的构造函数，只能用在子类的构造函数之中，用在其他地方就会报错</li><li><code>super.xxx</code>: super对象一般指向当前对象的原型对象, 只能用在对象的方法中<ul><li>在子类：<ul><li>普通方法中: super指向父类的原型对象；注：通过super调用父类的方法时，父类方法内部的this指向的是子类实例</li><li>静态方法中：super指向父类本身；注：通过super方法调用父类的方法时，父类方法内部的this指向的是子类</li></ul></li></ul></li><li>注：使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错</li></ul><p><strong> 示例: </strong></p><ol><li><p><strong>super方法</strong> vs <strong>super对象</strong></p><pre><code class="lang-js"> class Point {   constructor(x, y) {     this.x = x;     this.y = y;   }   p() {     return 2;   } } class ColorPoint extends Point {   constructor(x, y, color) {     this.color = color;                 // ReferenceError     super(x, y);                        // 调用父类构造函数     this.color = color;                 // 正确，super之后，才可以使用this     console.log(super.p());             // 2 -- super指向父类原型对象，相当于Point.prototype.p()     console.log(super);                   // 报错： 使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错     // super.valueOf()表明super是一个对象，指向父类原型对象，super使得this指向B的实例，所以返回的是一个B的实例     console.log(super.valueOf() instanceof B);    // true    } } let cp = new ColorPoint(25, 8, &#39;green&#39;); cp instanceof ColorPoint         // true cp instanceof Point              // true</code></pre></li><li><p>super对象调用父类静态方法和普通方法</p><pre><code class="lang-js"> class Parent {   static hello() {     console.log(&#39;hello world&#39;);   }   static myMethod(msg) {     console.log(&#39;static&#39;, msg);   }   myMethod(msg) {     console.log(&#39;instance&#39;, msg);   } } class Child extends Parent {   static myMethod(msg) {     super.myMethod(msg);        // 在子类静态方法中，super对象指向父类本身，调用父类静态方法   }   myMethod(msg) {     super.myMethod(msg);        // 在子类普通方法中，super对象指向父类原型对象，调用父类方法   } } // 调用子类静态方法 Child.hello();              // hello world Child.myMethod(1);          // static 1 // 调用子类普通方法 var child = new Child(); child.myMethod(2);          // instance 2</code></pre></li></ol><h3 id="header-38">Decorator 修饰器</h3><pre><code class="lang-js">@decoratorclass A {}// 等同于class A {}A = decorator(A) || A;</code></pre><p>只能用于修饰类和类属性（eg：不能用于函数，因为存在函数提升），本质即<strong>编译时执行的函数</strong> （不是在运行时）</p><ul><li>类修饰器<ul><li>参数（只有一个）：<ul><li><code>target</code>：所要修饰的目标类（即类本身）</li></ul></li></ul></li><li>类属性修饰器<ul><li>参数（三个）：<ul><li><code>target</code> ： 类的原型对象（类.prototype）– 修饰器的本意是要“修饰”类的实例，但是这个时候实例还没生成，所以只能去修饰原型</li><li><code>name</code> ： 修饰的类属性名</li><li><code>decriptor</code>：修饰类属性的描述对象</li></ul></li><li>返回：该属性的描述对象<code>Descriptor</code></li></ul></li><li>修饰器参数扩展：<ul><li>可以通过在修饰器外面再封装一层函数来传入入其他参数</li></ul></li><li>多个修饰器：<ul><li>会像剥洋葱一样，先从外到内进入，然后由内向外执行</li></ul></li><li>第三方模块提供的修饰器：<ul><li><code>core-decorators.js</code>：<ul><li>@autobind : 使得方法中的this对象，绑定原始对象</li><li>@readonly : 使得属性或方法不可写</li><li>@override : 检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错</li><li>@deprecate/@deprecated : 在控制台显示一条警告，表示该方法将废除</li><li>@suppressWarnings : 抑制deprecated修饰器导致的console.warn()调用 （异步代码发出的调用除外）</li></ul></li><li><code>traits-decorator</code>：<ul><li>@traits : 效果与 Mixin 类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等      </li></ul></li></ul></li></ul><p><strong> 示例: </strong> </p><ol><li><p>类修饰器</p><pre><code class="lang-js"> @testable class MyTestableClass {   // ... } function testable(target) {    // target为所要修饰的目标类（类本身），即MyTestClass   target.isTestable = true;    // 为类MyTestClass添加静态属性isTestable，想添加实例属性，可以通过目标类的prototype对象操作 } MyTestableClass.isTestable     // true</code></pre></li><li><p>类属性修饰器</p><pre><code class="lang-js"> function readonly(target, name, descriptor){   descriptor.writable = false;   return descriptor; } // descriptor对象原来的值如下 // { //   value: specifiedFunction, //   enumerable: false, //   configurable: true, //   writable: true // }; class Person {   @readonly                                                                // readonly(Person.prototype, &#39;name&#39;, descriptor);   name() { return `${this.first} ${this.last}` } }</code></pre><pre><code class="lang-js"> class Math {   @log   add(a, b) {     return a + b;   } } function log(target, name, descriptor) {   var oldValue = descriptor.value;   descriptor.value = function() {     console.log(`Calling ${name} with`, arguments);     return oldValue.apply(this, arguments);   };   return descriptor; } const math = new Math(); math.add(2, 4);                            // Calling add with 2,4</code></pre></li><li><p>多个修饰器</p><pre><code class="lang-js"> function dec(id){   console.log(&#39;evaluated&#39;, id);   return (target, property, descriptor) =&gt; console.log(&#39;executed&#39;, id); } class Example {     @dec(1)     @dec(2)     method(){} } const example=new Example(); example.method(); // evaluated 1 // evaluated 2 // executed 2 // executed 1</code></pre></li><li><p>应用: 实现Mixin模式（在一个对象之中混入另外一个对象的方法）</p><ul><li><p>使用类修饰器实现</p><pre><code class="lang-js">  // mixins.js  export function mixins(...list) {              // 可以在修饰器外面再封装一层函数，以便传入其他参数    return function (target) {      Object.assign(target.prototype, ...list)   // 添加实例属性    }  }  // main.js  import { mixins } from &#39;./mixins&#39;  const Foo = {    foo() { console.log(&#39;foo&#39;) }  };  // 在MyClass类上面“混入”Foo对象的foo方法  @mixins(Foo)  class MyClass {}  let obj = new MyClass();  obj.foo()                                                 // &#39;foo&#39;</code></pre></li><li><p>通过类的继承实现 Mixin （上面的方法会改写MyClass类的prototype对象）</p><pre><code class="lang-js">  // 返回一个继承superclass的子类，该子类包含一个foo方法   let MyMixin = (superclass) =&gt; class extends superclass {               foo() {      console.log(&#39;foo from MyMixin&#39;);    }  };  class MyClass extends MyMixin(MyBaseClass) {}  let c = new MyClass();  c.foo();                                                     // &quot;foo from MyMixin&quot;</code></pre></li></ul></li><li><p>应用: React 与 Redux 库结合使用</p><pre><code class="lang-js"> class MyReactComponent extends React.Component {} export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent); // 有了装饰器，就可以写成如下方式： @connect(mapStateToProps, mapDispatchToProps) export default class MyReactComponent extends React.Component {}</code></pre></li></ol><h2 id="header-39">模块 Module</h2><p><strong> 模块加载方案：</strong></p><ul><li>CommonJS：用于服务器，动态加载（运行时加载）</li><li>AMD：用于浏览器，动态加载（运行时加载）</li><li>ES6：浏览器和服务器通用,静态加载（编译时加载）</li></ul><p><strong> 动态加载 vs 静态加载：</strong></p><ul><li>动态加载：<ul><li>运行时加载，无法在编译时做“静态优化”</li><li>模块输出的是值的拷贝，不存在动态更新</li></ul></li><li>静态加载：<ul><li>编译时加载，编译时就能确定模块的依赖关系，以及输入和输出的变量；</li><li>模块输出的是值的引用（类似Unix 系统的“符号连接”），可动态更新</li></ul></li></ul><h3 id="header-40">ES6 Module</h3><ul><li>自动采用严格模式，不管有没有在模块头部加上”use strict” （ES5引入的）</li><li>一个模块就是一个独立的文件，该文件内部的内容，外部无法获取</li><li>导出/导入<ul><li><code>export ...</code> ：定义模块的对外接口，可处于模块顶层的任何位置<ul><li>一个module可以有多条export，但只能有一条<code>export default</code></li><li><code>export default</code>：<ul><li>指定默认输出，这样 import 时就可以指定一个任意名字给加载项</li><li>本质上，就是输出一个叫做default的变量或方法 ( 将default后面的值，赋给default变量 )，然后系统允许你为它取任意名字</li></ul></li></ul></li><li><code>import ... from ...</code>：加载模块，Singleton 模式，静态加载（在静态解析阶段执行，所以它是一个模块之中最早执行的）<ul><li>静态执行，不能使用表达式和变量，不能使用逻辑判断动态加载</li><li>输入的加载项是只读的（本质是输入接口），即不允许在加载模块的脚本里面改写接口</li><li>多次重复执行同一句import语句或多次加载同一module，也只会执行一次</li><li><code>import &lt;module&gt;</code> : 不导入任何值，仅仅执行所加载的模块，eg: import ‘lodash’;</li></ul></li><li><code>export ... from ...</code>: <ul><li>在一个模块之中，输入输出同一个模块，export 和 import 可复合成一条</li><li>注： <code>export * from &#39;xxx&#39;</code> 会忽略export default输出</li></ul></li><li>可使用<code>as</code>重命名加载对象</li></ul></li></ul><ul><li>注： <ul><li>模块之中，顶层的this指向undefined（CommonJS 模块的顶层this指向当前模块）</li><li>通过 Babel 转码，CommonJS 模块的require命令和 ES6 模块的import命令，可以写在同一个模块里面 – 但不建议这样使用</li></ul></li></ul><p><strong> 示例：</strong></p><ol><li><p><code>export...</code> </p><ul><li><p>export 变量</p><pre><code class="lang-js">  // 写法一  export var m = 1;  // 写法二  var m = 1;  export {m};  // 写法三  var m = 1;  export {m as n};</code></pre></li><li><p>export 方法</p><pre><code class="lang-js">  // 写法一  export function f() {};  //写法二  function f() {}  export {f};  // 写法三  function f() {}  export {f as fun};</code></pre></li><li>export 多个，重命名<pre><code class="lang-js">  export {m,f}  export {m as n, f as fun, f as fun2}</code></pre></li></ul></li><li><p><code>import...from...</code></p><ul><li>cicle.js (module export)：<pre><code class="lang-js">  // circle.js  export function area(radius) {    return Math.PI * radius * radius;  }  export function circumference(radius) {    return 2 * Math.PI * radius;  }</code></pre></li><li><p>import 部分：</p><pre><code class="lang-js">  import { area, circumference } from &#39;./circle&#39;;  console.log(&#39;圆面积：&#39; + area(4));  console.log(&#39;圆周长：&#39; + circumference(14));  // 输入的变量都是只读的，因为它的本质是输入接口，不允许在加载模块的脚本里面，改写接口  area.foo = &#39;hello&#39;;            // 合法操作  area = {};                         // Syntax Error : &#39;area&#39; is read-only;</code></pre></li><li><p>import 所有（整体加载）：</p><pre><code class="lang-js">  import * as circle from &#39;./circle&#39;;  console.log(&#39;圆面积：&#39; + circle.area(4));  console.log(&#39;圆周长：&#39; + circle.circumference(14));  // 整体加载所在的那个对象，应该是可以静态分析的，不允许运行时改变  circle.foo = &#39;hello&#39;;                    // Syntax Error  circle.area = function () {};        // Syntax Error</code></pre></li><li><p>注：</p><ul><li>以上加载部分和整体加载的区别</li><li><p>import是静态执行，不能使用表达式和变量</p><pre><code class="lang-js">  // 报错  import { &#39;f&#39; + &#39;oo&#39; } from &#39;my_module&#39;;  // 报错  let module = &#39;my_module&#39;;  import { foo } from module;      // 报错  if (x === 1) {    import { foo } from &#39;module1&#39;;  } else {    import { foo } from &#39;module2&#39;;  }</code></pre></li><li><p>多次重复执行同一句import语句或多次加载同一module，也只会执行一次</p><pre><code class="lang-js">  import &#39;lodash&#39;;         import &#39;lodash&#39;;        // 只执行一次，等同于：import &#39;lodash&#39;;  import { foo } from &#39;my_module&#39;;  import { bar } from &#39;my_module&#39;;  // 只执行一次，等同于：import { foo, bar } from &#39;my_module&#39;;</code></pre></li></ul></li></ul></li><li><p><code>export default ...</code></p><ul><li><p>export和export default混合</p><pre><code class="lang-js">  export default function (obj) { ···}  export function each(obj, iterator, context) {···}  export { each as forEach };  import _ , { each, forEach } from &#39;lodash&#39;;        // _ 即代表export default的内容</code></pre></li><li><p>export和export default比较</p><pre><code class="lang-js">  // 第一组：export  export function crc32() { ...};  import {crc32} from &#39;crc32&#39;;            // import 使用大括号 {}  // 第二组：export default  export default function crc32() { ...}  // 同 export default function () { ... }  import a from &#39;crc32&#39;;                    // import 不使用大括号{}，且可直接指定一个任意的名字</code></pre></li><li><p>export default 变量（export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句）</p><pre><code class="lang-js">  var a = 1;   export default a;                     // 正确  export default var a = 1;            // 错误  export default 42;        // 正确  export 42;                // 错误</code></pre></li></ul></li><li><p><code>export ... from ...</code> </p><ul><li><p>部分导入导出： <code>export {...} from ...</code></p><pre><code>  export { foo, bar } from &#39;my_module&#39;;    // foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口  // 可以简单理解为  import { foo, bar } from &#39;my_module&#39;;  export { foo, bar };</code></pre></li><li><p>整体导入导出：<code>export * from ...</code>  ( 注：会忽略模块的default方法)</p><pre><code class="lang-js">  // 整体输出  export * from &#39;my_module&#39;;                    // 会忽略模块的default方法  //默认接口的写法  export { default } from &#39;my_module&#39;;  export { default as es6 } from &#39;./my_module&#39;;</code></pre></li></ul></li></ol><h3 id="header-41">浏览器环境加载</h3><p>使用<code>type=&quot;module&quot;</code> </p><ul><li>默认异步加载</li><li>按在页面出现的顺序依次执行加载</li><li>模块：<ul><li>代码是在模块作用域之中运行，而不是在全局作用域运行</li><li>可以使用<code>import</code>命令加载其他模块，<code>.js</code>后缀不可省略</li><li>顶层的this关键字返回undefined，而不是指向window，利用这个特点，可以侦测当前代码是否在 ES6 模块之中（eg：<code>const isNotModuleScript = this !== undefined;</code>）    </li></ul></li><li>转码：若浏览器不支持 ES6 Module，可以将其转为 ES5 的写法，eg：使用Babal，SystemJS</li></ul><p><strong> 示例：</strong></p><ol><li><p>浏览器加载javascript（使用 <code>type=&quot;application/javascript&quot;</code> 默认语言，可省略）</p><pre><code class="lang-js"> // 默认同步加载 &lt;script src=&quot;path/to/myModule.js&quot;&gt;&lt;/script&gt; // 异步加载 // defer： 渲染完再执行；多个defer时，会按照它们在页面出现的顺序加载； // async：下载完就执行，会中断渲染，执行完成后恢复渲染； 多个async时，不保证加载顺序； &lt;script src=&quot;path/to/myModule.js&quot; defer&gt;&lt;/script&gt; &lt;script src=&quot;path/to/myModule.js&quot; async&gt;&lt;/script&gt;</code></pre></li><li><p>浏览器加载ES6 Module</p><pre><code class="lang-js"> &lt;script type=&quot;module&quot; src=&quot;./foo.js&quot;&gt;&lt;/script&gt; &lt;!-- 等同于 --&gt; &lt;script type=&quot;module&quot; src=&quot;./foo.js&quot; defer&gt;&lt;/script&gt;</code></pre></li></ol><h3 id="header-42">Node环境加载</h3><p><strong> CommonJS Module VS ES6 Module：</strong></p><table class="table"><thead><tr><th>操作</th><th style="text-align:left">CommonJS Module</th><th style="text-align:left">ES6 Module</th></tr></thead><tbody><tr><td>输出</td><td style="text-align:left">值的拷贝，不存在动态更新</td><td style="text-align:left">值的引用，可动态更新</td></tr><tr><td>加载</td><td style="text-align:left">运行时加载，无法做“静态优化” <br> （加载的是一个对象，即module.exports属性，该对象只有在脚本运行完才会生成）</td><td style="text-align:left">编译时加载，可做“静态优化” <br> （只是一种静态定义，编译时就能确定模块的依赖关系，以及输入和输出的变量）</td></tr><tr><td>循环加载</td><td style="text-align:left">使用require命令加载脚本 <br> ( 返回的是当前已经执行的部分的值，而不是代码全部执行后的值)</td><td style="text-align:left">使用import命令加载 <br> ( 返回的是引用，需要开发者自己保证，真正取值的时候能够取到值）</td></tr><tr><td></td><td style="text-align:left">第一次加载: 会执行整个脚本，在内存中生成一个对象; <br> 第N次加载：不会再执行，直接到缓存中取值，除非手动清除缓存</td><td style="text-align:left">加载项不会被缓存，已加载项不会重复加载</td></tr></tbody></table><p>注：</p><ol><li><p>CommonJS Module第一次加载在内存中生成的对象如下：</p><pre><code class="lang-js"> {   id: &#39;...&#39;,               // 模块名   exports: { ... },        // 模块输出的各个接口（以后需要用到这个模块的时候，就会到exports属性上面取值）   loaded: true,            // 表示该模块的脚本是否执行完毕   ... }</code></pre></li><li><p>CommonJS Module 循环加载示例：（加载返回的是当前已经执行的部分的值，而不是代码全部执行后的值）</p><ul><li>a.js : 加载 b.js<pre><code class="lang-js">  exports.done = false;  var b = require(&#39;./b.js&#39;);  console.log(&#39;在 a.js 之中，b.done = %j&#39;, b.done);  exports.done = true;  console.log(&#39;a.js 执行完毕&#39;);</code></pre></li><li>b.js : 加载 a.js<pre><code class="lang-js">  exports.done = false;  var a = require(&#39;./a.js&#39;);  console.log(&#39;在 b.js 之中，a.done = %j&#39;, a.done);  exports.done = true;  console.log(&#39;b.js 执行完毕&#39;);</code></pre></li><li>main.js : 加载 a.js,b.js<pre><code class="lang-js">  var a = require(&#39;./a.js&#39;);  var b = require(&#39;./b.js&#39;);  console.log(&#39;在 main.js 之中, a.done=%j, b.done=%j&#39;, a.done, b.done);</code></pre></li><li><p>node执行</p><pre><code>  $ node main.js  在 b.js 之中，a.done = false  b.js 执行完毕  在 a.js 之中，b.done = true  a.js 执行完毕  在 main.js 之中, a.done=true, b.done=true</code></pre></li></ul></li></ol><p><strong> Node 模板加载方案：</strong></p><p>Node 有自己的 CommonJS 模块格式，与 ES6 模块格式不兼容，所以ES6 模块和 CommonJS 需采用各自的加载方案</p><ul><li>ES6<ul><li>采用<code>.mjs</code>后缀文件名</li><li>使用<code>export</code>/<code>import</code>命令，不能使用<code>require</code>命令</li></ul></li><li>CommonJS<ul><li>使用<code>module.export</code>/<code>require</code>命令</li></ul></li><li>ES6 module 加载 CommonJS module: <ul><li>使用 <code>import ... from ...</code> 命令</li><li>Node 会将<code>module.exports</code>属性，当作模块的默认输出，即等同于<code>export default ...</code></li></ul></li><li>CommonJS module 加载 ES6 module: <ul><li>使用<code>import(...)</code>函数</li><li>ES6 模块的所有输出接口，会成为输入对象的属性（注：不能使用require命令）</li></ul></li></ul><ul><li>注：<ul><li>通过 Babel 转码，CommonJS 模块的require命令和 ES6 模块的import命令，可以写在同一个模块里面，但不建议这样使用</li><li>ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量<ul><li>ES6 模块之中，顶层的this指向undefined；CommonJS 模块的顶层this指向当前模块</li><li>在 ES6 模块之中不存在的顶层变量：arguments,require,module,exports,<strong>filename,</strong>dirname</li></ul></li></ul></li></ul><p><strong> 说明：</strong>    </p><ol><li><code>import ... from ...</code> 命令：异步加载，只支持加载本地模块，不支持加载远程模块<ul><li>模块名不含路径：会去node_modules目录寻找这个模块</li><li>模块名包含路径：会按照路径去寻找这个名字的脚本文件</li><li>省略了后缀名的加载,依次尝试:<ul><li>依次尝试四个后缀名：mjs，js，json，node;</li><li>尝试加载该目录下的package.json的main字段指定的脚本；</li><li>尝试加载该目录下的名为index，后缀为mjs,js,json,node的文件</li></ul></li></ul></li><li><code>import(...)</code>函数：同步加载<ul><li>返回一个Promise对象，实现动态加载，类似于 Node 的require方法（异步加载）</li><li>与所加载的模块没有静态连接关系，可以用在任何地方，非模块的脚本也可以使用</li></ul></li></ol><p><strong> 示例：</strong> </p><ol><li><p>ES6 Module加载CommonJS Module : 使用 <code>import...from...</code>命令</p><ul><li><p>a.js （CommonJS module）： CommonJS模块的输出都定义在module.exports这个属性上面</p><pre><code class="lang-js">  module.exports = {    foo: &#39;hello&#39;,    bar: &#39;world&#39;  };  // 等同于 ES6：  export default {    foo: &#39;hello&#39;,    bar: &#39;world&#39;  };</code></pre></li><li><p>ES6 Module导入a.js （注：需使用整体输入）：使用Node的<code>import...from...</code>命令加载 CommonJS 模块，Node 会自动将<code>module.exports</code>属性，当作模块的默认输出，即等同于<code>export default ...</code></p><pre><code class="lang-js">  // 写法一  import baz from &#39;./a&#39;;  // baz = {foo: &#39;hello&#39;, bar: &#39;world&#39;};  // 写法二  import {default as baz} from &#39;./a&#39;;  // baz = {foo: &#39;hello&#39;, bar: &#39;world&#39;};  // 写法三  import * as baz from &#39;./a&#39;;  // baz = {  //   get default() {return module.exports;},  //   get foo() {return this.default.foo}.bind(baz),  //   get bar() {return this.default.bar}.bind(baz)  // }  baz.default         // {foo: &#39;hello&#39;, bar: &#39;world&#39;}  baz.foo                // hello  // 注意：ES6 模块是编译时确定输出接口，CommonJS 模块是运行时确定输出接口，只有在运行时才能确定foo，所以下面方式不正确  import { foo } from &#39;./a&#39;</code></pre></li></ul></li><li><p>CommonJS module加载ES6 module: 使用<code>import(...)</code>函数（注：不能使用require命令），ES6 模块的所有输出接口，会成为输入对象的属性</p><ul><li>ES6 Module：es.js<pre><code class="lang-js">  export let foo = { bar:&#39;my-default&#39; };  export { foo as bar };  export function f() {};  export class c {};</code></pre></li><li>CommonJS 导入 es.js<pre><code class="lang-js">  const es_namespace = await import(&#39;./es&#39;);  // es_namespace = {  //   get foo() {return foo;}  //   get bar() {return foo;}  //   get f() {return f;}  //   get c() {return c;}  // }</code></pre></li></ul></li></ol><h2 id="header-43">实践</h2><h3 id="header-44">var/let/const</h3><ol><li><p>let取代var</p><ul><li>两者语义相同，且let没有副作用：var命令存在变量提升效用，let命令没有这个问题,let只在其声明的代码块内有效</li></ul></li><li><p>优先使用const</p><ul><li>防止了无意间修改变量值所导致的错误（函数应该都设置为const）</li><li>const比较符合函数式编程思想，运算不改变值，只是新建值，这样也有利于将来的分布式运算；</li><li>JavaScript编译器会对const进行优化，有利于提高程序的运行效率（let和const的本质区别，其实是编译器内部的处理不同）</li><li>长远来看，JavaScript 可能会有多线程的实现,const利于保证线程安全</li></ul></li></ol><h3 id="header-45">解构赋值</h3><p>以下情况优先使用解构赋值</p><ol><li><p>使用数组成员对变量赋值</p><pre><code class="lang-js"> const arr = [1, 2, 3, 4]; // bad const first = arr[0]; const second = arr[1]; // good const [first, second] = arr;</code></pre></li><li><p>函数的参数是对象的成员</p><pre><code class="lang-js"> // bad function getFullName(user) {   const firstName = user.firstName;   const lastName = user.lastName; } // good function getFullName(obj) {   const { firstName, lastName } = obj; } // best function getFullName({ firstName, lastName }) { }</code></pre></li><li><p>函数返回多个值，优先使用对象的解构赋值（注：不是数组的解构赋值），便于以后添加返回值，以及更改返回值的顺序</p><pre><code class="lang-js"> // bad function processInput(input) {   return [left, right, top, bottom]; } // good function processInput(input) {   return { left, right, top, bottom }; } const { left, right } = processInput(input);</code></pre></li></ol><h3 id="header-46">String</h3><ul><li>静态字符串: 使用单引号或反引号</li><li>动态字符串: 使用反引号</li></ul><pre><code class="lang-js">// badconst a = &quot;foobar&quot;;const b = &#39;foo&#39; + a + &#39;bar&#39;;// acceptableconst c = `foobar`;// goodconst a = &#39;foobar&#39;;const b = `foo${a}bar`;</code></pre><h3 id="header-47">Array</h3><ol><li><p>拷贝数组: 使用扩展运算符<code>...</code></p><pre><code class="lang-js"> // bad const len = items.length; const itemsCopy = []; let i; for (i = 0; i &lt; len; i++) {   itemsCopy[i] = items[i]; } // good const itemsCopy = [...items];</code></pre></li><li><p>对象转为数组: 使用 <code>Array.from</code> 方法</p><pre><code class="lang-js"> const foo = document.querySelectorAll(&#39;.foo&#39;); const nodes = Array.from(foo);</code></pre></li></ol><h3 id="header-48">Object</h3><ol><li><p>定义对象</p><ul><li>单行定义：最后一个成员不以逗号结尾</li><li><p>多行定义：最后一个成员可以逗号结尾</p><pre><code class="lang-js">// badconst a = { k1: v1, k2: v2, };const b = {k1: v1,k2: v2};// goodconst a = { k1: v1, k2: v2 };const b = {k1: v1,k2: v2,};</code></pre></li></ul></li><li><p>尽量静态化</p><ul><li>定义后尽量不添加新的属性</li><li><p>使用<code>Object.assign</code>方法添加属性</p><pre><code class="lang-js">  // bad  const a = {};  a.x = 3;  // if reshape unavoidable  const a = {};  Object.assign(a, { x: 3 });  // good  const a = { x: null };  a.x = 3;</code></pre></li><li>动态属性名: 可在创造对象的时候，用属性表达式定义<pre><code class="lang-js">  // bad  const obj = {      id: 5,      name: &#39;San Francisco&#39;,  };  obj[getKey(&#39;enabled&#39;)] = true;</code></pre><pre><code class="lang-js">  // good  const obj = {    id: 5,    name: &#39;San Francisco&#39;    ,[getKey(&#39;enabled&#39;)]: true,  };</code></pre></li></ul></li><li><p>尽量简洁表达属性和方法（易于描述和书写）</p><pre><code class="lang-js"> var ref = &#39;some value&#39;; // bad const atom = {   ref: ref,   value: 1,   addValue: function (value) {     return atom.value + value;   }, }; // good const atom = {   ref,   value: 1,   addValue(value) {     return atom.value + value;   }, };</code></pre></li></ol><h3 id="header-49">Function</h3><ol><li><p>建议尽量使用箭头函数的情况：</p><ul><li>立即执行函数<pre><code class="lang-js">  (() =&gt; {    console.log(&#39;Welcome to the Internet.&#39;);  })();</code></pre></li><li><p>原来一些需要使用函数表达式的场合</p><pre><code class="lang-js">  // bad  [1, 2, 3].map(function (x) {    return x * x;  });  // good  [1, 2, 3].map((x) =&gt; {    return x * x;  });  // best  [1, 2, 3].map(x =&gt; x * x);</code></pre></li><li><p>取代Function.prototype.bind(不再用 self/_this/that 绑定 this)</p><pre><code class="lang-js">  // bad  const self = this;  const boundMethod = function(...params) {    return method.apply(self, params);  }  // acceptable  const boundMethod = method.bind(this);  // best  const boundMethod = (...params) =&gt; method.apply(this, params);</code></pre></li><li>注：简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法</li></ul></li><li><p>函数参数</p><ul><li><p>使用rest运算符<code>...</code>代替<code>arguments</code>变量 (arguments 是一个类似数组的对象，而rest运算符可以提供一个真正的数组)</p><pre><code class="lang-js">  // bad  function concatenateAll() {    const args = Array.prototype.slice.call(arguments);    return args.join(&#39;&#39;);  }  // good  function concatenateAll(...args) {    return args.join(&#39;&#39;);  }</code></pre></li><li><p>使用默认值语法设置参数的默认值</p><pre><code class="lang-js">  // bad  function handleThings(opts) {    opts = opts || {};  }  // good  function handleThings(opts = {}) {    // ...  }</code></pre></li></ul></li></ol><h3 id="header-50">Class</h3><ol><li><p>用Class取代需要 prototype的操作（Class语法更简洁易理解）</p><pre><code class="lang-js"> // bad function Queue(contents = []) {   this._queue = [...contents]; } Queue.prototype.pop = function() {   const value = this._queue[0];   this._queue.splice(0, 1);   return value; } // good class Queue {   constructor(contents = []) {     this._queue = [...contents];   }   pop() {     const value = this._queue[0];     this._queue.splice(0, 1);     return value;   } }</code></pre></li><li><p>用extends实现继承（extend语法更简单，且不会有破坏instanceof运算的危险）</p><pre><code class="lang-js"> // bad const inherits = require(&#39;inherits&#39;); function PeekableQueue(contents) {   Queue.apply(this, contents); } inherits(PeekableQueue, Queue); PeekableQueue.prototype.peek = function() {   return this._queue[0]; } // good class PeekableQueue extends Queue {   peek() {     return this._queue[0];   } }</code></pre></li></ol><h3 id="header-51">Module</h3><ol><li><p>使用import取代require</p><pre><code class="lang-js"> // bad const moduleA = require(&#39;moduleA&#39;); const func1 = moduleA.func1; const func2 = moduleA.func2; // good import { func1, func2 } from &#39;moduleA&#39;;</code></pre></li><li><p>使用export取代module.exports</p><pre><code class="lang-js"> // commonJS的写法 var React = require(&#39;react&#39;); var Breadcrumbs = React.createClass({   render() {     return &lt;nav /&gt;;   } }); module.exports = Breadcrumbs; // ES6的写法 import React from &#39;react&#39;; class Breadcrumbs extends React.Component {   render() {     return &lt;nav /&gt;;   } }; export default Breadcrumbs;</code></pre></li><li><p>尽量不使用通配符来确保至少有一个默认输出(export default)</p><pre><code class="lang-js"> // bad import * as myObject from &#39;./importModule&#39;; // good import myObject from &#39;./importModule&#39;;</code></pre></li></ol><h3 id="header-52">ESLint</h3><p>一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码</p><ol><li><p>安装</p><pre><code class="lang-shell"> // 安装ESLint $ npm i -g eslint //安装 Airbnb 语法规则 $ npm i -g eslint-config-airbnb //安装import、a11y、react 插件 $ npm i -g eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react</code></pre></li><li><p>配置（项目的根目录下新建一个.eslintrc文件）</p><pre><code class="lang-json"> {   &quot;extends&quot;: &quot;eslint-config-airbnb&quot; }</code></pre></li><li><p>使用，eg：</p><ul><li><p>index.js</p><pre><code class="lang-js">  var unusued = &#39;I have no purpose!&#39;;  function greet() {      var message = &#39;Hello, World!&#39;;      alert(message);  }  greet();</code></pre></li><li><p>使用 ESLint 检查index.js，发现错误</p><pre><code class="lang-js">  $ eslint index.js  index.js    1:1  error  Unexpected var, use let or const instead          no-var    1:5  error  unusued is defined but never used                 no-unused-vars    4:5  error  Expected indentation of 2 characters but found 4  indent    4:5  error  Unexpected var, use let or const instead          no-var    5:5  error  Expected indentation of 2 characters but found 4  indent  × 5 problems (5 errors, 0 warnings)</code></pre><ul><li>不应该使用var命令，而要使用let或const</li><li>定义了变量，却没有使用</li><li>行首缩进为 4 个空格，而不是规定的 2 个空格</li></ul></li></ul></li></ol><h2 id="header-53">Reference</h2><ul><li><a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="noopener">阮一峰 ECMAScript 6 入门</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">Object.create()</a></li></ul>]]></content>
    
    <summary type="html">
    
      ES6 Introduce
    
    </summary>
    
    
      <category term="Javascript" scheme="http://sixdegree.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Oracle Procedure &amp; Cursor &amp; Array</title>
    <link href="http://sixdegree.github.io/2018/08/15/Oracle-Script.html"/>
    <id>http://sixdegree.github.io/2018/08/15/Oracle-Script.html</id>
    <published>2018-08-14T16:00:00.000Z</published>
    <updated>2018-10-26T12:33:58.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Block,Procedure,Transaction,Exception</li><li>Cursor,Bulk Collect,Forall,Dynamic SQL</li><li>Array</li></ol><a id="more"></a><h2 id="header-1">块 Block</h2><h3 id="header-2">块的结构</h3><pre><code class="lang-sql">declare  定义部分(可选)begin  可执行部分(必选)exception  异常处</code></pre><h3 id="header-3">块的分类</h3><ol><li>无名块(也叫匿名块)：动态构造并只能执行一次，常用来测试或执行存储过程。</li><li>命名块：加了用&lt;&lt;&gt;&gt;括起了带标号的无名块。</li><li>子程序：包括存储过程、函数和包等。这些块一旦被定义便会存储在数据库中，可随时调用。</li><li>触发器：根据触发的事件调用。</li></ol><h2 id="header-4">存储过程 Procedure</h2><h3 id="header-5">创建</h3><pre><code class="lang-sql">create or replace procedure test(var_name_1 in type,var_name_2 out type) as    --声明变量(变量名 变量类型)begin    --存储过程的执行体end test;</code></pre><pre><code class="lang-sql">CREATE OR REPLACE PROCEDURE 存储过程名字(    参数1 IN NUMBER,    参数2 IN NUMBER) AS    变量1 INTEGER :=0;    变量2 DATE;BEGIN    ...END 存储过程名字</code></pre><p>示例：</p><pre><code class="lang-sql">CREATE OR REPLACE PROCEDURE proc_test AS  CURSOR c1 IS SELECT * FROM dat_trade;BEGIN  FOR x IN c1 LOOP    DBMS_OUTPUT.put_line(x.id);  END LOOP;END proc_test;</code></pre><h3 id="header-6">调用</h3><p>在PL/SQL块内运行存储过程，不需要使用<code>exec</code>，直接 <code>procedure_name[(parameter,…n)]</code></p><pre><code class="lang-sql">BEGIN   proc_helloworld;END;</code></pre><p>外部程序调用：</p><pre><code class="lang-sql">exec proc_helloworld</code></pre><h2 id="header-7">事物 Transaction</h2><p>procedure中既有<code>commit</code>也有<code>rollback</code><br><code>commit</code>之前的就提交,<code>commit</code>和<code>rollback</code>之间的就回滚<br>程序出错,<code>commit</code>之前的就已经提交了,<code>commit</code>和出错之间的强制回滚.</p><p>嵌套出错:<br>出错前<code>commit</code>的就提交了,未<code>commit</code>的强制退出程序并回滚<br>把一个procedure中所有的程序和语句看成顺序执行,不管是嵌套多少层,<code>commit</code>的就起效,未<code>commit</code>的,如果出错则从出错的地方强制退出程序,如果不出错,退出session时默认提交.</p><pre><code class="lang-sql">CREATE OR REPLACE procedure SCOTT.t1asbegin  for i in 1..10000 loop        insert into test1(id,name) values(i,&#39;leng&#39;||i);        commit;        if i=20 then             rollback;             exit;        end if;  end loop;end;</code></pre><p>设置出错就<code>rollback</code> :</p><pre><code class="lang-sql">WHENEVER SQLERROR EXIT FAILURE ROLLBACK;WHENEVER OSERROR EXIT FAILURE ROLLBACK;SET SERVEROUTPUT ON;DECLARE    ...BEGIN    ...END;/commit;exit;</code></pre><h2 id="header-8">异常 Exception</h2><pre><code class="lang-sql">DECLARE       v_empno employees.employee_id%TYPE := &amp;empno;       v_sal   employees.salary%TYPE;BEGIN       SELECT salary INTO v_sal FROM employees WHERE employee_id = v_empno;       IF v_sal&lt;=1500 THEN                UPDATE employees SET salary = salary + 100 WHERE employee_id=v_empno;                DBMS_OUTPUT.PUT_LINE(&#39;编码为&#39;||v_empno||&#39;员工工资已更新!&#39;);           ELSE                DBMS_OUTPUT.PUT_LINE(&#39;编码为&#39;||v_empno||&#39;员工工资已经超过规定值!&#39;);       END IF;EXCEPTION       WHEN NO_DATA_FOUND THEN              DBMS_OUTPUT.PUT_LINE(&#39;数据库中没有编码为&#39;||v_empno||&#39;的员工&#39;);       WHEN TOO_MANY_ROWS THEN              DBMS_OUTPUT.PUT_LINE(&#39;程序运行错误!请使用游标&#39;);       WHEN OTHERS THEN              DBMS_OUTPUT.PUT_LINE(SQLCODE||&#39;---&#39;||SQLERRM);END;</code></pre><pre><code class="lang-sql">declare    v_cnt:=800;    v_name emp.ename%type;begin    begin        select ename into v_name from emp where sal=v_cnt;    exception         when no_data_found then              v_name:=&#39;&#39;;         when too_many_rows then              v_name:=&#39;&#39;;              dbms_output.put_line(&#39;存在多个雇员具有该工资&#39;);    end;    dbms_output.put_line(&#39;姓名：&#39; || v_name);exception     when others then          rollback;          dbms_output.put_line(&#39;异常回滚退出&#39;);end;</code></pre><p>自定义异常：</p><pre><code class="lang-sql">SET VERIFY OFFWHENEVER SQLERROR EXIT FAILURE ROLLBACK;WHENEVER OSERROR EXIT FAILURE ROLLBACK;SET SERVEROUTPUT ONDeclare  ex_test Exception;  PRAGMA EXCEPTION_INIT( ex_test, -20001 );  l_version number;Begin    dbms_output.put_line(&#39;Start!&#39;);    update table_a set object_version_number=object_version_number+1 where name = &#39;test&#39;;    select max(object_version_number) into l_version from table_a where name= &#39;test&#39;;    -- 使用聚合函数，则在没有数据时不会导致NO_DATA_FOUND异常    if l_version is null then        dbms_output.put_line(&#39;NO data!&#39;);    end if;    dbms_output.put_line(&#39;version:&#39;||l_version);    raise_application_error( -20001, &#39;This is a custom error&#39; );        -- 抛出自定义异常    dbms_output.put_line(&#39;Finish!&#39;);Exception        -- 这里定义了Exception捕获，则上面的WHENEVER ERROR ROLLBACK将无法捕获到异常Rollback    When others then        dbms_output.put_line(&#39;execute fail:&#39;||SQLCODE||&#39;---&#39;||SQLERRM);End;/commit;Exit;</code></pre><p>测试：</p><ol><li><p>没有name=’test’的记录的情况下:</p><pre><code class="lang-sql"> select * from table_A; name  object_version_number tom        1 lucy        2 ----------------------------------------- PL/SQL procedure successfully completed. Start! NO data! version: execute fail:-20001---ORA-20001: This is a custom error Commit complete. Disconnected from Oracle Database 12c Enterprise Edition Release 12.1.0.2.0 - 64bit Production With the Partitioning, OLAP, Advanced Analytics and Real Application Testing options</code></pre></li><li><p>有name=’test’的记录的情况下：</p><pre><code class="lang-sql"> select * from table_A; name  object_version_number tom        1 lucy        2 test        2 ----------------------------------------- PL/SQL procedure successfully completed. Start! version:3 execute fail:-20001---ORA-20001: This is a custom error Commit complete. Disconnected from Oracle Database 12c Enterprise Edition Release 12.1.0.2.0 - 64bit Production With the Partitioning, OLAP, Advanced Analytics and Real Application Testing options ---------------------------------------- -- 执行后，name=&#39;test&#39;的object_version_number更新了 select * from table_A; name  object_version_number tom        1 lucy        2 test        3</code></pre></li></ol><h2 id="header-9">读取记录到变量</h2><h3 id="header-10">SELECT INTO STATEMENT</h3><p>将<code>select</code>查询的结果存入到变量中，可以同时将多个列存储多个变量中，必须有一条记录，否则抛出异常(如果没有记录抛出<code>NO_DATA_FOUND</code>)</p><pre><code class="lang-sql">BEGIN  SELECT col1,col2 into 变量1,变量2 FROM typestruct where xxx;EXCEPTION  WHEN NO_DATA_FOUND THEN      xxxx;END;</code></pre><h3 id="header-11">游标 Cursor</h3><ol><li><p>隐性Cursor</p><pre><code class="lang-sql"> for 变量名 in （SELECT 语句）loop      ..... END LOOP;</code></pre></li><li><p>显性Cursor</p><pre><code class="lang-sql"> -- 无参数的显性游标： CURSOR 游标名 IS SELECT 语句; -- 带参数的显性游标 -- parameter 参数形式： -- 1.  参数名 数据类型 -- 2.  参数名 数据类型 DEFAULT 默认值 -- eg:  Cursor MyCursor(pSal  Number  Default   800)  Select   JOB  From  empa Where  SAL &gt;  pSal ; CURSOR 游标名(parameter[,parameter],...) IS SELECT 语句;</code></pre></li><li><p>Cursor状态属性</p><pre><code class="lang-sql"> %Found            -- Fetch语句（获取记录）执行情况 True or False。 %NotFound        -- 最后一条记录是否提取出 True or False。 %ISOpen            -- 游标是否打开True or False。 %RowCount        -- 游标当前提取的行数</code></pre></li><li><p>使用</p><ul><li>While 循环<pre><code class="lang-sql">  WHILE 游标名%found LOOP       ...  END LOOP;</code></pre></li><li><p>For 循环: 隐式打开游标，自动滚动获取一条记录，并自动创建临时记录类型变量存储记录。处理完后自动关闭游标</p><pre><code class="lang-sql">  For  变量名  In  游标名    Loop        数据处理语句；  End Loop；  -- 示例：  Declare       Cursor myCur is select * from emp;  Begin       for varA in myCur       loop           dbms_output.put_line(myCur%rowCount || &#39;    &#39; || varA.empno || &#39;    &#39; || varA.ename || &#39;  &#39; || varA.sal);       end loop;  End;</code></pre></li><li><p>Loop 循环: 需手动打开，关闭游标</p><pre><code class="lang-sql">  open 游标名;  Loop       Fetch  游标名 InTo  临时记录或属性类型变量；       Exit  When  游标名%NotFound；        数据处理语句；  End   Loop；  Close 游标名;  -- 示例：  Declare       Cursor myCur is select ename,job,sal,empno from emp;       varE myCur%rowType;  Begin       if myCur%isopen = false then          open myCur;          dbms_output.put_line(&#39;Opening...&#39;);       end if;       loop          fetch myCur into varE;          exit when myCur%notfound;          dbms_output.put_line(myCur%rowCount || &#39;    &#39; || vare.empno || &#39;    &#39; || vare.ename || &#39;    &#39; || vare.sal);       end loop;       if myCur%isopen then          Close myCur;          dbms_output.put_line(&#39;Closing...&#39;);       end if;  End;</code></pre></li></ul></li><li><p>嵌套Cursor</p><pre><code class="lang-sql"> declare      v_id char(2);      cursor c1 is select id,name from  a;      cursor c2 is select * from  b where id0000=v_id;   begin      for i in c1 loop           v_id:=i.id;           for j in c2 loop                ...           end loop;      end loop;   end;</code></pre><ul><li>示例：<pre><code class="lang-sql">  declare      v_0 number;       v_1 number;       cursor c1 is select productordernumber from his_productorder@pro_crm where productid in (9000045516);       cursor c2 is select cust_order_id from suf_cust_order_q_his where cust_order_num like v_0||&#39;%&#39;;       cursor c3 is select * from suf_work_order_q_his where cust_order_id=v_1;   begin       for i in c1 loop           v_0:=i.productordernumber;           for j in c2 loop               v_1:=j.cust_order_id;               for k in c3 loop                    dbms_output.put_line(k.work_order_id||&#39; &#39;||k.status);               end loop;           end loop;       end loop;     end;</code></pre><pre><code class="lang-sql">  create or replace procedure proc_nest_cursor  as      cursor cur_acctinactprocess is select mediumid,acctnbr,vouchnbr from acctinactprocess;      v_mediumid ACCTINACTPROCESS.MEDIUMID%type;      v_acctnbr  ACCTINACTPROCESS.Acctnbr%type;      v_vouchnbr ACCTINACTPROCESS.Vouchnbr%type;      v_vouchname vouchinfo.vouchname%type;      cursor cur_vouchinfo(lvsvouchnbr vouchinfo.vouchnbr%type) is select vouchnbr,vouchname from vouchinfo where vouchnbr=lvsvouchnbr;  begin      open cur_acctinactprocess;      loop            fetch cur_acctinactprocess into v_mediumid,v_acctnbr,v_vouchnbr;            exit when cur_acctinactprocess%notfound;            dbms_output.put_line(&#39;外层循环开始: &#39;||&#39;介质号:&#39;||v_mediumid||&#39; 账号:&#39;||v_acctnbr||&#39; 凭证号:&#39;||v_vouchnbr);            -- 内层游标以外层游标的数据为基础，如果匹配外层游标，就进入内层游标进行处理            open cur_vouchinfo(v_vouchnbr);            loop                fetch cur_vouchinfo into v_vouchnbr,v_vouchname;                exit when cur_vouchinfo%notfound;                dbms_output.put_line(&#39;内层循环的值: &#39;||&#39; 凭证号:&#39;||v_vouchnbr||&#39; 凭证名称&#39;||v_vouchname);            end loop;            close cur_vouchinfo;        end loop;        close cur_acctinactprocess;  end;</code></pre></li></ul></li></ol><h3 id="header-12">Bulk Collect &amp; Forall</h3><p><strong> BLUK COLLECT </strong> </p><p>一次取出一个数据集合，比用游标条取数据效率高，尤其是在网络不大好的情况下 ，但需要大量内存 </p><ul><li>可将查询结果一次性地加载到<code>collections</code>中，而不是通过<code>cursor</code>一条一条地处理</li><li>可以在<code>select into</code> ，<code>fetch into</code> ， <code>returning into</code>语句中使用</li><li>使用<code>BULK COLLECT</code>时，所有的<code>INTO</code>变量都必须是<code>collections</code></li><li>可以限制<code>BULK COLLECT</code> 提取的记录数，eg：<code>FETCH cursor BULK COLLECT INTO ...[LIMIT rows];</code></li></ul><p>示例：</p><ol><li><p>可变数组取表（<code>bulk collect into</code>），执行效率高于<code>cursor</code></p><pre><code class="lang-sql"> declare      type type_array is table of t_user%rowtype index by binary_integer;   -- 类似二维数组      var_array type_array; begin      select * bulk collect into var_array from t_user;      for i in 1..var_array.count loop          dbms_output.put_line(var_array(i).user_id);                          -- 二维数组的访问          dbms_output.put_line(var_array(i).username);      end loop; end;</code></pre></li><li><p>在<code>returning into</code>中使用bulk collect :（有了<code>returning</code>子句后，我们可以轻松地确定刚刚完成的DML操作的结果，无须再做额外的查询工作）</p><pre><code class="lang-sql"> CREATE TABLE test_forall2 AS SELECT * FROM test_forall;   ----在returning into中使用bulk collect   DECLARE      TYPE IdList IS TABLE OF test_forall.User_Id%TYPE;      enums IdList;      TYPE NameList IS TABLE OF test_forall.user_name%TYPE;      names NameList;   BEGIN      DELETE FROM test_forall2 WHERE user_id = 10100           RETURNING user_id, user_name BULK COLLECT INTO enums, names;      dbms_output.put_line(&#39;Deleted &#39; || SQL%ROWCOUNT || &#39; rows:&#39;);      FOR i IN enums.FIRST .. enums.LAST      LOOP        dbms_output.put_line(&#39;User #&#39; || enums(i) || &#39;: &#39; || names(i));      END LOOP;      COMMIT;   EXCEPTION       WHEN OTHERS THEN           ROLLBACK;   END;</code></pre></li><li><p><code>bulk collection limit</code></p><pre><code class="lang-sql"> declare   type v_t_oid is table of ljz_all_objects.object_id%type;   v_oid_lst      v_t_oid;   type v_t_cur_oid is ref cursor;   v_cur_oid      v_t_cur_oid;   v_cnt          simple_integer := 1000; begin   open v_cur_oid for &#39;select object_id from ljz_all_objects where object_id&gt;:1&#39;     using 1;   fetch v_cur_oid bulk collect into v_oid_lst limit v_cnt;   while v_oid_lst.count &gt; 0 loop     for i in 1 .. v_oid_lst.count loop       --业务处理逻辑       v_oid_lst(i) := v_oid_lst(i) + 1;     end loop;     forall i in v_oid_lst.first .. v_oid_lst.last       insert into ljz_test (col) values (v_oid_lst(i));     fetch v_cur_oid bulk collect into v_oid_lst limit 1000;     commit;   end loop;   close v_cur_oid; end;</code></pre></li></ol><p><strong> Forall </strong> </p><p>比FOR效率高，只切换一次上下文 ( FOR 在循环次数一样多个上下文间切换 ) </p><ul><li>只允许一条 sql 语句</li><li>INDICES OF 当绑定数组为稀疏数组或者包含有间隙时，会有用</li><li>VALUES OF 只想使用该数组中元素的一个子集时，会有用</li></ul><p>语法：</p><pre><code class="lang-sql">FORALL index_name IN    { lower_bound .. upper_bound        | INDICES OF collection_name [ BETWEEN lower_bound AND upper_bound ]        | VALUES OF index_collection    }[ SAVE EXCEPTIONS ] dml_statement;</code></pre><p>说明：</p><ul><li><code>index_name</code> : 一个无需声明的标识符，作为集合下标使用</li><li><code>lower_bound .. upper_bound</code> : 数字表达式，来指定一组连续有效的索引数字下限和上限。该表达式只需解析一次</li><li><code>INDICES OF collection_name</code> : 用于指向稀疏数组的实际下标。跳过没有赋值的元素，例如被 <code>DELETE</code> 的元素，<code>NULL</code> 也算值</li><li><code>VALUES OF index_collection</code> : 把该集合中的值当作下标，且该集合值的类型只能是<code>PLS_INTEGER/BINARY_INTEGER</code></li><li><code>SAVE EXCEPTIONS</code> : 可选关键字，表示即使一些DML语句失败，直到<code>FORALL LOOP</code>执行完毕才抛出异常。可以使用<code>SQL%BULK_EXCEPTIONS</code> 查看异常信息</li><li><code>dml_statement</code> : 静态语句，例如：<code>UPDATE</code>或者<code>DELETE</code>；或者动态（<code>EXECUTE IMMEDIATE</code>）DML语句</li></ul><p>例如：</p><pre><code class="lang-sql">FORALL i IN dr_table.first .. dr_table.last FORALL i IN INDICES OF  demo_tableFORALL i IN VALUES OF index_poniter</code></pre><p>示例:</p><ol><li><p><code>lower_bound .. upper_bound</code></p><pre><code class="lang-sql"> declare     type dr_type is table of test1%ROWTYPE index by binary_integer;     dr_table dr_type;   begin     select id, name BULK COLLECT into dr_table from test1;     FORALL i IN dr_table.first .. dr_table.last       insert into test2 values dr_table (i);     --error statement     --1.insert into test2 values(dr_table(i));报没有足够的值错误，此处外面不可以加括号，当有多个字段的时候，单个字段可以加括号     --2.insert into test2 values(dr_table(i).id,dr_table(i).name);集合的field不可以在forall中使用，必须是整体使用     --3.insert into test2 values dr_table(i+1);错误，不可以对索引变量进行运算     --4.insert into test2 values dr_table(i);dbms_output.put_line(i);不正确，找不到i，因为forall中只能使用单条语句可以引用索引变量   end;</code></pre></li><li><p><code>indices of</code></p><pre><code class="lang-sql"> DECLARE   TYPE demo_table_type IS TABLE OF tmp_tab%rowtype INDEX BY BINARY_INTEGER;   demo_table demo_table_type; BEGIN   FOR i IN 1..10 LOOP     demo_table(i).id:=i;     demo_table(i).name:=&#39;NAME&#39;||i;   END LOOP;   -- 使用集合的delete方法移除第3、6、9三个成员    demo_table.delete(3);    demo_table.delete(6);    demo_table.delete(9);    FORALL i IN INDICES OF  demo_table      INSERT INTO tmp_tab VALUES demo_table(i);  END ;</code></pre></li><li><p><code>values of</code></p><pre><code class="lang-sql"> DECLARE   TYPE index_poniter_type IS TABLE OF pls_integer;   index_poniter index_poniter_type;   TYPE demo_table_type IS TABLE OF tmp_tab%rowtype INDEX BY BINARY_INTEGER;   demo_table demo_table_type; BEGIN    index_poniter := index_poniter_type(1,3,5,7);   FOR i IN 1..10 LOOP      demo_table(i).id:=i;      demo_table(i).name:=&#39;NAME&#39;||i;    END LOOP;    FORALL i IN VALUES OF index_poniter      INSERT INTO  tmp_tab VALUES demo_table(i);  END;</code></pre></li></ol><h2 id="header-13">动态SQL</h2><pre><code class="lang-sql">declare  compDetail_cur number;  vQuery varchar2(500);  vStat NUMBER;  vId Number;  vColDesc dbms_sql.desc_tab;  vColCnt Number;begin  vQuery := &#39;select * from pay_dir_comp_details_f where dir_card_comp_id=:pCompId&#39;;  compDetail_cur := dbms_sql.open_cursor;  dbms_sql.parse(compDetail_cur,vQuery,dbms_sql.native);  dbms_sql.bind_variable(compDetail_cur,&#39;:pCompId&#39;,&#39;300100090712274&#39;);  dbms_sql.define_column(compDetail_cur,1,vId);  dbms_sql.describe_columns(compDetail_cur, vColCnt, vColDesc);  for i in 1..vColCnt  loop    dbms_output.put_line(vColDesc(i).col_type || &#39; &#39; || vColDesc(i).col_name || &#39; &#39; || vColDesc(i).col_max_len);  end loop;  vStat := dbms_sql.execute(compDetail_cur);  loop      exit when dbms_sql.fetch_rows(compDetail_cur)&lt;=0;      dbms_sql.column_value(compDetail_cur,1,vId);      dbms_output.put_line(vId);  end loop;  dbms_sql.close_cursor(compDetail_cur);end;</code></pre><pre><code class="lang-sql">declare     v_sql varchar2(2000);begin  v_sql:=&#39;insert into test values (sysdate)&#39;;        --给sql赋值  dbms_output.put_line(v_sql);                        --打印  execute immediate v_sql;                            --执行sql  commit;end;</code></pre><h2 id="header-14">EXECUTE IMMEDIATE</h2><ul><li>不会提交一个DML(CRUD)事务执行，应该显式提交 </li><li>处理DDL命令(Create/Drop/Alter),它提交所有以前改变的数据</li></ul><pre><code class="lang-sql">EXECUTE IMMEDIATE    &#39;CREATE TABLE &#39;|| l_ctx_b_backup ||&#39; AS     ( SELECT a.* , &#39;&#39;Y&#39;&#39; AS process_flag, systimestamp as run_date from tableA a where a.protected_flag !=&#39;&#39;Y&#39;&#39; )&#39;;EXECUTE IMMEDIATE &#39;UPDATE &#39;|| l_ctx_b_backup || &#39; SET process_flag = &#39;&#39;N&#39;&#39; WHERE process_flag = &#39;&#39;Y&#39;&#39;&#39;;</code></pre><h2 id="header-15">数组 Array</h2><p>oracle 数组类型，没有现成的类型，但是可以自己随意定义</p><p>示例： </p><ol><li><p>定长字符数组</p><pre><code class="lang-sql"> /*定长字符数组，数组大小为10*/   declare       type v_arr is varray(10) of varchar2(30);       my_arr v_arr;       my_arr:=v_arr(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;);   begin       for i in 1..my_arr.count       loop           dbms_output_line(my_arr(i));       end loop;   end;</code></pre></li><li><p>可变长字符数组</p><pre><code class="lang-sql"> /*可变长字符数组，元素大小30，索引标号integer类型自增长*/   declare     type v_table is table of varchar2(30) index by binary_integer;      --类型可以是前面的类型定义，index by binary_integer子句代表以符号整数为索引，      --这样访问表类型变量中的数据方法就是“表变量名(索引符号整数)”。      my_table v_table;      begin          for i in 1..20           loop                my_table(i):=i;                dbms_output.put_line(my_table(i));            end loop;      end;</code></pre></li><li><p>定义含有多个字段的数组类型变量</p><pre><code class="lang-sql"> -- PLSQL 定义含有多个字段的数组类型变量 DECLARE   TYPE user_info_type IS RECORD(     user_name VARCHAR2(20),     user_age  NUMBER(3),     user_sex  VARCHAR2(5)   );     -- 自定义属性   TYPE user_info_arr_type IS TABLE OF user_info_type INDEX BY BINARY_INTEGER;     -- 使用这个属性来创建动态数组   user_info_arr user_info_arr_type; BEGIN   user_info_arr(0).user_name := &#39;张三&#39;;   user_info_arr(0).user_age := 19;   user_info_arr(0).user_sex := &#39;男&#39;;   user_info_arr(1).user_name := &#39;李菁菁&#39;;   user_info_arr(1).user_age := 23;   user_info_arr(1).user_sex := &#39;女&#39;;   FOR i IN 0 .. 1   LOOP     dbms_output.put_line(&#39;User Name:&#39; || user_info_arr(i).user_name);     dbms_output.put_line(&#39;User Age:&#39; || user_info_arr(i).user_age);     dbms_output.put_line(&#39;User Sex:&#39; || user_info_arr(i).user_sex);   END LOOP; END;</code></pre><ul><li>输出结果：<pre><code>  User Name:张三   User Age:19   User Sex:男   User Name:李菁菁   User Age:23   User Sex:女</code></pre></li></ul></li><li><p>可变数组取表（<code>bulk collect into</code>），执行效率高于<code>cursor</code></p><pre><code class="lang-sql"> declare      type type_array is table of t_user%rowtype index by binary_integer;   -- 类似二维数组      var_array type_array; begin      select * bulk collect into var_array from t_user;      for i in 1..var_array.count loop          dbms_output.put_line(var_array(i).user_id);          -- 二维数组的访问          dbms_output.put_line(var_array(i).username);      end loop; end;</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      Write Oracle Script
    
    </summary>
    
    
      <category term="SQL" scheme="http://sixdegree.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB</title>
    <link href="http://sixdegree.github.io/2018/08/04/MongoDB.html"/>
    <id>http://sixdegree.github.io/2018/08/04/MongoDB.html</id>
    <published>2018-08-03T16:00:00.000Z</published>
    <updated>2018-11-25T11:47:21.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="header-1">Starter</h2><blockquote><p>文档型数据库。 一条记录就是一个文档（是一个数据结构），由字段和值对组成（与JSON对象类似）</p></blockquote><p><a href="www.mongodb.org">官网</a> | <a href="http://www.mongoing.com/docs/index.html" target="_blank" rel="noopener">Doc</a> | <a href="http://www.mongoing.com/" target="_blank" rel="noopener">中文社区</a> | <a href="https://github.com/mongodb" target="_blank" rel="noopener">Github</a> | <a href="https://jira.mongodb.org" target="_blank" rel="noopener">Jira (bug fix)</a></p><ol><li>特性：<ul><li>无数据结构限制（每条记录可以有完全不同的结构）</li><li>完全的索引支持（单键／多键索引，复合索引，全文索引，地理位置索引）</li><li>丰富的查询语言（Shell内置javascript引擎可以直接执行JS代码）</li><li>方便的冗余和扩展（复制集Replica Set：保证数据安全，高可用性，分片Sharding：水平扩展数据规模）</li><li>插件化的存储引擎支持（WiredTiger, MMAPv1, In-Memory, Encrypted, 3rd Party Engine）<ul><li>WiredTiger（存储引擎）: <ul><li>MongoDB3.2 之后的默认存储引擎</li><li>拥有效率非常高的缓存机制</li><li>支持在内存中和磁盘上对索引进行压缩（压缩时使用了前缀压缩的方式以减少RAM的使用）</li><li>能够保证对于同一个文档的操作都是原子的，任意一个写操作都不能原子性地影响多个文档或者多个集合</li></ul></li></ul></li></ul></li><li>部署：<ul><li>单机 -&gt; 拥有冗余容错功能的复制集 -&gt; 分片大规模数据集群 -&gt; 集群的自动部署</li></ul></li><li>使用：<ul><li>CRUD -&gt; 索引创建和使用 -&gt; 复杂聚合查询 -&gt; 数据集分片，在不同分片间维持数据均衡 -&gt; 数据备份和恢复 -&gt; 数据迁移</li></ul></li></ol><p>智能分布数据：横向扩展，自动分片，轻松支持TB-PB数量级<br><img src="/2018/08/04/High-Deploy.png" alt="High Deploy"></p><h3 id="header-2">数据模型</h3><p><strong> RelationDB vs. MongoDB : </strong></p><ol><li>RelationDB: <ul><li>Table -&gt; Record -&gt; field &amp; value</li></ul></li><li>MongoDB: <ul><li>Collection -&gt; Document -&gt; key &amp; value</li><li>表示文档间关系的方式：<ul><li>｀Reference｀ 引用：<br>  <img src="/2018/08/04/model-reference.png" alt="model-reference"> <ul><li>标准化的数据模型，可通过某个引用值链接到其他文档（与 MySQL 的外键非常相似，但不会对引用的对象是否真正存在做出任何的约束）</li></ul></li><li>｀Embedded Data｀ 嵌入：<br>  <img src="/2018/08/04/model-embedded.png" alt="model-embeded"><ul><li>非标准化的数据模型，相关联的数据保存在同一个文档结构之内</li></ul></li></ul></li><li>注：MongoDB 不对Collection的数据结构进行限制，但在实际使用中，尽量同一个Collection中的文档具有类似的结构</li></ul></li></ol><h3 id="header-3">搭建MongoDB测试环境</h3><p>这里直接使用Docker搭建MongoDB测试环境</p><ol><li>搜索下载mongo image<pre><code class="lang-bash"> docker search mongo docker pull mongo</code></pre></li><li><p>启动一个容器(micro-mongo)作为mongo server</p><pre><code class="lang-bash"> # 建一个单独的数据卷store-mongo (为防止docker machine重启后数据丢失) $ docker create --name store-mongo mongo # 创建启动一个container as mongo server : micro-mongo，并挂载数据卷store-mongo $ docker run --volumes-from store-mongo --name micro-mongo -p 27017:27017 -e MONGO_INITDB_ROOT_USERNAME=mongoadmin -e MONGO_INITDB_ROOT_PASSWORD=123456 -d mongo:latest # 检查 $ docker ps $ docker log</code></pre></li><li>使用：<ul><li>方式一：直接进入刚才创建的mongo server容器(micro-mongo)<pre><code class="lang-bash">  $ docker exec -it micro-mongo /bin/bash  root@480e8bf33600:/# mongo -u mongoadmin -p 123456 --authenticationDatabase admin  &gt; show dbs  admin   0.000GB  config  0.000GB  demo    0.000GB  local   0.000GB</code></pre></li><li>方式二：启动一个容器(mongo)作为mongo client连接刚才的micro-mongo<pre><code class="lang-bash">  $ docker run -it --rm --link micro-mongo:mongod --name mongo-client mongo:latest mongo -host mongod -u mongoadmin -p 123456 --authenticationDatabase admin demo  &gt; show dbs  admin   0.000GB  config  0.000GB  demo    0.000GB  local   0.000GB</code></pre></li><li>方式三：客户端工具 MongoDB Compass</li></ul></li><li>导入测试数据</li></ol><h3 id="header-4">Server/Client</h3><p>Server: 启动服务，使用命令<code>mongod</code></p><pre><code>```bash$ vi conf/mongod.confport = 12345dbpath = datalogpath = log/mongod.logfork = true$ mongod -f conf/mongod.conf```</code></pre><p>Client: 连接数据库，使用命令<code>mongo</code></p><pre><code>```bash$ mongo --help$ mongo localhost:12345/testdb&gt; use admin&gt; db.shutdownServer()```</code></pre><h3 id="header-5">Mongo Shell</h3><p>MongoDB的Shell内置javascript引擎可以直接执行JS代码</p><pre><code class="lang-bash"># 列出所有可用dbshow dbs# 查看当前正在使用的dbdb# 切换当前数据库上下文，即切换当前使用db# Note：可以切换到一个不存在的db，后面执行db.&lt;collection&gt;.insert(...)操作时会自动创建use &lt;database&gt;# 查看当前db的集合集(table)show collectionsshow tables# 格式化打印结果db.myCollection.find().pretty()# 无格式打印db.myCollection.print()# JSON格式打印db.myCollection.printjson()# 多行操作# 代码行以 &#39;(&#39;，&#39;{&#39;,&#39;[&#39; 结束，则随后一行将以省略号 &quot;...&quot; 开始，直到输入对应的&#39;)&#39;，&#39;}&#39;，&#39;]&#39;if(x&gt;0){...count++;...print(x);...}# Tab命令补全# 例如下面 &lt;Tab&gt; 补全后将列出各种以‘c’开头的方法db.myCollection.c&lt;Tab&gt;</code></pre><h2 id="header-6">ACID</h2><p><img src="/2018/08/04/txn.png" alt="Transaction"></p><table class="table"><thead><tr><th>事物特性</th><th style="text-align:left">MongoDB</th><th style="text-align:left">MySQL (InnoDB)</th></tr></thead><tbody><tr><td>原子性 Atomicity</td><td style="text-align:left">单行/文档级原子性</td><td style="text-align:left">多行原子性</td></tr><tr><td>一致性 Consistency</td><td style="text-align:left">强一致或最终一致</td><td style="text-align:left">强一致</td></tr><tr><td>隔离性 Isolation</td><td style="text-align:left">提交读</td><td style="text-align:left">可重复读</td></tr><tr><td>持久性 Durability</td><td style="text-align:left">日志及复制</td><td style="text-align:left">日志</td></tr></tbody></table><h3 id="header-7">原子性 Atomicity</h3><p><img src="/2018/08/04/txn-atomicity1.png" alt="Atomicity"> <img src="/2018/08/04/txn-atomicity2.png" alt="Non-Atomicity"></p><ul><li>支持: 单行/文档级原子性<pre><code class="lang-javascript">  db.users.update({ username:&quot;Tom&quot;},{$set:{salary:5000}});</code></pre></li><li>4.0以下尚不支持: 多行/多文档/多语句原子性 <pre><code class="lang-javascript">  db.users.update({ salary:{$lt:5000}},{$set:{salary:5000}});</code></pre><ul><li>开始状态:<table class="table"><thead><tr><th style="text-align:left">username</th><th style="text-align:left">salary</th></tr></thead><tbody><tr><td style="text-align:left">James</td><td style="text-align:left">3000</td></tr><tr><td style="text-align:left">Tom</td><td style="text-align:left">4000</td></tr><tr><td style="text-align:left">Melody</td><td style="text-align:left">4500</td></tr><tr><td style="text-align:left">Frank</td><td style="text-align:left">2500</td></tr><tr><td style="text-align:left">Kelly</td><td style="text-align:left">3500</td></tr><tr><td style="text-align:left">Lucy</td><td style="text-align:left">7600</td></tr></tbody></table></li><li>结束状态：中间出错（eg：宕机）<table class="table"><thead><tr><th style="text-align:left">username</th><th style="text-align:left">salary</th></tr></thead><tbody><tr><td style="text-align:left">James</td><td style="text-align:left">5000</td></tr><tr><td style="text-align:left">Tom</td><td style="text-align:left">5000</td></tr><tr><td style="text-align:left">Melody</td><td style="text-align:left">5000</td></tr><tr><td style="text-align:left">Frank</td><td style="text-align:left">2500 &lt;- 宕机</td></tr><tr><td style="text-align:left">Kelly</td><td style="text-align:left">3500</td></tr><tr><td style="text-align:left">Lucy</td><td style="text-align:left">7600</td></tr></tbody></table></li></ul></li></ul><h3 id="header-8">一致性 Consistency</h3><p><img src="/2018/08/04/txn-consistency.png" alt="Consistency"></p><p>多文档一致性处理：</p><ul><li>通过建模来避免</li><li>二阶段提交</li><li>记录日志，人工干预</li></ul><p>注：</p><ul><li>传统数据库：规则校验主外键</li><li>分布式数据库：多节点数据一致（Read your writes）<br>  <img src="/2018/08/04/txn-consistency-nodes.png" alt="MongoDB：可调一致性"></li></ul><h3 id="header-9">隔离性 Isolation</h3><p><img src="/2018/08/04/txn-isolation.png" alt="Isolation"></p><p>隔离级别：<br>| Isolation Level | Default Setting |<br>|:-|:-|<br>| Serializable |  |<br>| Repeatable Read | MySQL |<br>| Read Committed | PostgreSQL,Oracle |<br>| Read UnCommitted | MongoDB |</p><h3 id="header-10">持久性 Durability</h3><p><img src="/2018/08/04/txn-durability.png" alt="Durability"></p><ul><li>机制：<br>  <img src="/2018/08/04/txn-durability-journal.png" alt="MongoDB vs. 传统数据库"></li><li>MongoDB单节点写操作<br>  <img src="/2018/08/04/write-single-node.png" alt="MongoDB单节点写操作"></li><li>MongoDB多节点写操作<br>  <img src="/2018/08/04/write-multiple-nodes.png" alt="MongoDB多节点写操作"></li></ul><h3 id="header-11">写关注机制 WriteConcern</h3><pre><code class="lang-javascript">{ w: &lt;value&gt;, j: &lt;boolean&gt;, wtimeout: &lt;number&gt; }</code></pre><ul><li>用来指定mongoDB对写操作的回执行为</li><li>可在｀connection level｀或者｀写操作level｀(insert/update/delete操作的最后一个参数)指定</li><li>支持以下值：<ul><li><code>w</code>: 0/1/n/majority/tag</li><li><code>j</code>: true/false 或 0/1</li><li><code>wtimeout</code>: millis – only applicable for <code>w&gt;1</code></li></ul></li></ul><ol><li><p><code>w</code>: write acknowledgement instance</p><ul><li><code>w:0</code> Unacknowledged (无任何回执,2.2及以前版本的默认行为)<br>  <img src="/2018/08/04/w0-unacknowledged.png" alt="Unacknowledged"><ul><li>网络丢包，系统崩溃，无效数据（早期版本丢数据之罪魁祸首）</li></ul></li><li><code>w:1</code> Acknowledged （Mongod在写完内存后返送确认，2.4版本以后的默认行为）<br>  <img src="/2018/08/04/w1-acknowledged.png" alt="Acknowledged"><ul><li>能够处理网络故障，无效数据等错误状态</li><li>系统崩溃时可能会丢失最多100ms数据</li></ul></li><li><code>w:2/n/majority</code> Replica Acknowledged<br>  <img src="/2018/08/04/wn-replicaAcknowledged.png" alt="Replica Acknowledged"><ul><li>等待数据复制到<code>n个/大部分</code>节点后再发送回执</li></ul></li></ul></li><li><p><code>j</code>: journal(恢复日志)</p><ul><li>用于系统宕机时恢复内存数据,保证MongoDB中数据的持久性，<code>journal</code>与检查点<code>Checkpoint</code>协作：<ul><li>在数据文件中查找上一个Checkpoint标识符；</li><li>在 journal 日志文件中查找Checkpoint标识符对应的记录；</li><li>重做对应记录之后的全部操作；</li></ul></li><li>刷盘间隔：<ul><li>MMAP: 30~100ms</li><li>WiredTiger: 100MB/Checkpoint</li><li>eg: 每隔<code>60s</code> 或在 <code>journal文件</code>数据的写入达到<code>2GB</code>时设置一次<code>检查点Checkpoint</code></li></ul></li><li>默认为异步刷盘，可用<code>j:1</code>强制同步刷盘</li><li><code>j:1/true</code> Journaled，强制 journal 文件的同步<br>  <img src="/2018/08/04/j1-journaled.png" alt="Journaled"><ul><li>Journal刷盘后再发送写回执</li></ul></li></ul></li></ol><p><strong> 场景：</strong> </p><ol><li><p>插入一些无效数据（eg：10个document同一个<code>_id</code>），检查实际插入数据数目</p><ul><li><p>不使用写关注: <code>{w:0}</code> – 未报错，本以为是10条记录但却显示1条记录</p><pre><code class="lang-bash">  &gt; db.test.count()  0  &gt; for(var i=0;i&lt;10;i++){      var res=db.test.insert({_id:10,a:i},{writeConcern:{w:0}})      if(!res.getWriteError())          print(&quot;Inserted doc #&quot;+(i+1));      else          print(res.getWriteError().errmsg);  }  Inserted doc #1  Inserted doc #2  Inserted doc #3  Inserted doc #4  Inserted doc #5  Inserted doc #6  Inserted doc #7  Inserted doc #8  Inserted doc #9  Inserted doc #10  &gt; db.test.count()  1                            # 期望值为10</code></pre></li></ul><ul><li><p>指定写关注<code>{w:1}</code> (2.4以后版本默认为1) – 会acknowledge写错误，返回给客户端，最后显示1条记录</p><pre><code class="lang-bash">  &gt; db.test.count()  0  &gt; for(var i=0;i&lt;10;i++){      var res=db.test.insert({_id:10,a:i},{writeConcern:{w:1}})      if(!res.getWriteError())          print(&quot;Inserted doc #&quot;+(i+1));      else          print(res.getWriteError().errmsg);  }  Inserted doc #1  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }  &gt; db.test.count()  1                            # 期望值为1</code></pre></li></ul></li><li><p>系统崩溃导致数据丢失（eg：<code>w:1</code> 高速持续写入数据，<code>kill -9 mongod</code>强制关闭mongo服务，然后重新启动mongo检查程序汇报写入的数据和实际插入的数据）</p><pre><code class="lang-bash"> function journalDataLoss(journal){     var count=0,start=new Date();     try{         var docs=[];         for(var i=0;i&lt;1000;i++)             docs.push({a:i});         while(true){             var res=db.test.insert(docs,{writeConcern:{j:journal}})        # 0/1             count+=res.nInserted;             if(count%100000==0)                 print(&quot;inserted &quot;+count+&quot; time used:&quot;+(((new Date()).getTime()-start.getTime())/1000)+&quot; seconds&quot;);             }     }catch(error){         print(&quot;Total doc inserted successfully:&quot;+count);     } }</code></pre><ul><li><p><code>j:0</code> 不实时刷日志</p><pre><code class="lang-bash">  &gt; journalDataLoss(0)  Inserted 10000 times used: 3.579 seconds  Inserted 20000 times used: 7.123 seconds  ...  ...                                         &lt;- execute: kill -9 mongod  Total doc inserted successfully:715000  # 重启mongod，检查插入数量  &gt; db.test.count()  713000                        # 数据丢失</code></pre><p>  <img src="/2018/08/04/j0-journaled.png" alt="No Journaled"></p></li><li><p><code>j:1</code> 实时刷日志</p><pre><code class="lang-bash">  &gt; journalDataLoss(1)  Inserted 10000 times used: 4.579 seconds  Inserted 20000 times used: 8.123 seconds  ...  ...                                         &lt;- execute: kill -9 mongod  Total doc inserted successfully:726000  # 重启mongod，检查插入数量  &gt; db.test.count()  726000                        # 数据未丢失</code></pre></li></ul></li><li><p>主备置换导致数据丢失（eg：<code>w:1/majority</code>,<code>j:1</code>高速持续写入数据，<code>kill -9 mongod</code>主节点，连接到新的主节点，检查实际插入的数据与程序汇报的插入数据）</p><ul><li><code>w:1</code><br>  <img src="/2018/08/04/write-case-1.png" alt="CaseC-1"><br>  <img src="/2018/08/04/write-case-2.png" alt="CaseC-2"><br>  <img src="/2018/08/04/write-case-3.png" alt="CaseC-3"></li><li><code>w:majority</code> 设置确认数据写到大部分节点再返回<br>  <img src="/2018/08/04/write-case-solution.png" alt="CaseC-Solution"></li></ul></li></ol><h3 id="header-12">MongoDB数据安全总结</h3><p><img src="/2018/08/04/write-concern.png" alt="WriteConcern"><br><img src="/2018/08/04/read-perference.png" alt="ReadPerference"></p><blockquote><p>Read preference describes how MongoDB clients route read operations to the members of a replica set.By default, an application directs its read operations to the primary member in a replica set.</p></blockquote><h2 id="header-13">CRUD</h2><h3 id="header-14">Create(insert)</h3><p>Insert Document into Collection<br>注：</p><ul><li>单条document操作是原子性的</li><li>每一个document都有一个唯一的<code>_id</code> 字段作为 primary_key（若未指定，则MongoDB自动为<code>_id</code>生成一个<code>ObjectId</code>）</li><li><code>_id</code>字段值无法修改</li></ul><pre><code class="lang-javascript">db.myCollection.insert({...})            # 返回WriteResult对象db.myCollection.insert([{},{},..])         # 返回BulkWriteResult对象db.myCollection.insertOne({...})db.myCollection.insertMany([{},{},..])</code></pre><h3 id="header-15">Read(find)</h3><pre><code class="lang-javascript">db.myCollection.find(&lt;query filter&gt;,&lt;projection&gt;)db.myCollection.findOne(...)// 参数&lt;query filter&gt;/&lt;projection&gt;格式：{  &lt;field1&gt;: &lt;value1&gt;,  &lt;field2&gt;: { &lt;operator&gt;: &lt;value&gt; },  ...}</code></pre><ol><li><p><code>&lt;query filter&gt;</code></p><ul><li>value：<ul><li>普通特定值</li><li><code>{ &lt;operator&gt;: &lt;value&gt; }</code>：specify conditions</li></ul></li><li><p>operator:</p><pre><code class="lang-bash">  #  Comparison  $eq,$gt,$gte,$lt,$lte,$ne,$in,$nin  # Logical  $or,$and,$not,$nor  # Element  $exists,$type  # Evaluation  $mod,$regex,$text,$where  # Geospatial  $geoWithin,$geoIntersects,$near,$nearsphere  # Array  $all,$elemMatch,$size  # Bitwise  $bitsAllSet,$bitsAnySet,$bitsAllClear,$bitsAnyClear  # Comments  $comment</code></pre></li></ul></li><li><p><code>&lt;projection&gt;</code></p><ul><li>value：<ul><li><code>1/true</code>: 返回文档包含该字段</li><li><code>0/false</code>: 返回文档排除该字段</li><li><code>{ &lt;operator&gt;: &lt;value&gt; }</code>: specify conditions</li></ul></li><li>operator：<pre><code class="lang-bash">  $,$elemMatch,$slice,$meta</code></pre></li><li>注：不能使用数组索引来指定映射的特定数组元素，eg： <code>{ &quot;ratings.0&quot;: 1 } -- wrong</code></li></ul></li><li><p>示例：</p><ul><li><p>查询</p><pre><code class="lang-bash">  db.users.find( { status:&quot;A&quot; } )  db.users.find( { status:{ $in:[&quot;P&quot;,&quot;D&quot;] } } )  db.users.find({      status:&quot;A&quot;,      $or:[ {age:{$lt:30}},{type:1} ]  })  # 嵌入式document匹配  db.users.find({      favorites:{artist:&quot;Picasso&quot;}  })  db.users.find({      &quot;favorites.artist&quot;:&quot;Picasso&quot;  })  # 精确匹配  db.users.find({      badges:[&quot;blue&quot;,&quot;black&quot;]  })      # 匹配包含black的  db.users.find({      badges:&quot;black&quot;  })      # 匹配第一个元素为black的  db.users.find({      &quot;badges.0&quot;:&quot;black&quot;  })      # 查询 finished 数组至少包含一个大于15并且小于20的元素的文档  # $elemMatch 为数组元素指定复合条件，查询数组中至少一个元素满足所有指定条件的文档  db.users.find({       finished: { $elemMatch: { $gt: 15, $lt: 20 } }   })  # 查询 finished 数组中包含大于15 ，或者小于20的元素的文档  db.users.find({       finished: { $gt: 15, $lt: 20 }   })</code></pre></li><li><p>查询返回部分字段</p><pre><code class="lang-javascript">  // 返回文档 _id,name,status 字段  db.users.find(      {status:&quot;A&quot;},      {name:1,status:1}  )  // 返回文档 name,status 字段  // Note: 除了 _id 字段，不能在映射文档中组合包含和排除语句  // Eg: name:1,status:0 -- wrong!  db.users.find({      {status:&quot;A&quot;},      {name:1,status:1,_id:0}  })  // 返回文档不显示 favorites,points字段  db.users.find({      {status:&quot;A&quot;},      {favorites:0,points:0}  })  // 返回文档显示_id,name,status,points的bonus字段  db.users.find({      {status:&quot;A&quot;},      {name:1,status:1,&quot;points.bonus&quot;:1}  })  // 使用$slice映射操作符来返回 points数组中最后的元素  db.users.find({      {status:&quot;A&quot;},      {name:1,status:1,&quot;points&quot;:{$slice:-1}}  })</code></pre></li></ul></li><li><p>注：</p><ul><li><p>查询值为Null或不存在的字段</p><pre><code class="lang-javascript">  { &quot;_id&quot; : 900, &quot;name&quot; : null },  { &quot;_id&quot; : 901 }</code></pre><ul><li><code>db.users.find({name:null})</code>: 会返回name为null和不存在name字段的记录（注：若使用了sparse稀疏索引，只会匹配到name为null的记录，不会匹配到不存在的）</li><li><code>db.users.find({name:{$type:&quot;null&quot;}})</code>: 只会返回name为null的记录 （<code>$type</code> <a href="http://www.mongoing.com/docs/reference/operator/query/type.html#op._S_type" target="_blank" rel="noopener">类型筛查</a>）</li><li><code>db.users.find({name:{$exists:false}})</code>: 只返回不存在name字段的documents (<code>$exists</code> 存在性筛查)</li></ul></li><li><p>游标Cursor</p><pre><code class="lang-javascript">  var myCursor=db.users.find({type:&quot;string&quot;})  while(myCursor.hasNext()){      printjson(myCursor.next())  }  myCursor.forEach(printjson);  myCursor.forEach(function(myDoc){      print(&quot;user:&quot;+myDoc.name);  })  var myArray=myCursor.toArray();  myArray[3];  myCursor[1]             // same with myCursor.toArray()[1]</code></pre><ul><li><code>find</code>方法返回的（若不赋给一个变量，则会自动遍历显示，默认是展示20条记录，可以使用<code>DBQuery.shellBatchSize</code> 来改变迭代结果的数量）</li><li>Cursor Method: count,hint,forEach,map,limit,sort,size,skip,toArray,… <a href="http://www.mongoing.com/docs/reference/method/js-cursor.html" target="_blank" rel="noopener">More</a></li></ul></li></ul></li></ol><h3 id="header-16">Update</h3><pre><code class="lang-javascript">db.myCollection.update(&lt;query filter&gt;,&lt;update document&gt;,&lt;option&gt;)    # 默认情况下只更新 一个 文档db.myCollection.updateOne(...)db.myCollection.updateMany(...)db.myCollection.replaceOne(...)// 更多：db.myCollection.findOneAndReplace()db.myCollection.findOneAndUpdate()db.myCollection.findAndModify()</code></pre><ol><li><code>&lt;query filter&gt;</code>: 同上</li><li><p><code>&lt;update document&gt;</code>: </p><ul><li><code>{ &lt;field1&gt;: &lt;value1&gt;, ... }</code></li><li><code>{&lt;update operator&gt;: { &lt;field1&gt;: &lt;value1&gt;, ... },...}</code></li><li><p>update operators:</p><pre><code class="lang-bash">  # Field  $inc  $mul  $rename  $setOnInsert  $set  $unset  $min  $max  $currentDate  # Array  $  $[]  $[&lt;identifier&gt;]  $addToSet  $pop  $pull  $push  $pullAll  # Modifiers  $each  $position  $slice  $sort  # Bitwise  $bit</code></pre><p>3.<code>&lt;option&gt;</code></p></li><li>multi:false/true – 配置是否更新多个文档</li><li>upsert:false/true – 表示不存在时是否插入新的document</li></ul></li><li><p>示例：</p><pre><code class="lang-javascript"> db.users.update(    { name: &quot;xyz&quot; },    { name: &quot;mee&quot;, age: 25, type: 1, status: &quot;A&quot;, favorites: { &quot;artist&quot;: &quot;Matisse&quot;, food: &quot;mango&quot; } } ) db.users.update(     {status:&quot;A&quot;},     {         $set:{status:&quot;B&quot;,type:0},         $currentDate:{lastModified:true}     },     {multi:true} )</code></pre></li></ol><h3 id="header-17">Delete</h3><pre><code class="lang-javascript">// deletedb.myCollection.deleteOne(&lt;query filter&gt;)// delete all matcheddb.myCollection.deleteMany(...)db.myCollection.remove(&lt;query filter&gt;, &lt;justOne&gt;)// delete all,include indexdb.myCollection.drop()// 删除以指定顺序排序的文档中的第一个文档.db.myCollection.findOneAndDelete().</code></pre><p>示例：</p><pre><code class="lang-javascript">// delete all documentsdb.users.deleteMany({})db.users.remove({})// delete all matcheddb.users.remove({status:&quot;D&quot;})db.users.deleteMany({status:&quot;D&quot;})// delete just one// &lt;justOne&gt;:1db.users.remove({status:&quot;D&quot;},1}db.users.deleteOne({status:&quot;D&quot;})</code></pre><h3 id="header-18">WriteConcern</h3><p>在安全写情况下,可以指定MongoDB写操作要求的确认级别（insert/update/delete 操作的最后一个参数）</p><pre><code class="lang-javascript">{ w: &lt;value&gt;, j: &lt;boolean&gt;, wtimeout: &lt;number&gt; }</code></pre><ul><li><code>w</code>:0/1/“majority” – write acknowledgement instance</li><li><code>j</code>:true/false – journal</li><li><code>wtimeout</code> – only applicable for w&gt;1</li></ul><h2 id="header-19">索引 Index</h2><ul><li>优点：加快索引相关的查询；</li><li>缺点：增加磁盘空间消耗，降低写入性能</li></ul><h3 id="header-20">CRUD</h3><ol><li><p>创建索引</p><pre><code class="lang-javascript"> // &lt;field&gt;: &lt; 1 or -1 &gt; // 1 : 索引正序，－1 : 索引倒序 db.collection.createIndex( &lt;Key Index specification&gt;, &lt;options&gt;)</code></pre></li><li><p>查看索引</p><pre><code class="lang-javascript"> db.collection.getIndexes()</code></pre></li><li><p>删除索引</p><pre><code class="lang-javascript"> db.collection.dropIndex({...}) db.collection.dropIndexs()</code></pre></li><li><p>重建索引: ( drop all indexes,include _id index,then rebuilds all in the background,rebuild _id index in the foreground,which takes the db’s write lock.)</p><pre><code class="lang-javascript"> db.collection.reIndex()</code></pre></li><li><p>检查索引</p><pre><code class="lang-javascript"> // 扫描集合中的数据和索引以检查正确性的内部命令 db.collection.validate()</code></pre></li></ol><h3 id="header-21">单字段/复合/多键索引</h3><ol><li><p>单字段索引 Single Field Index</p><pre><code class="lang-javascript"> db.users.createIndex({age:-1});</code></pre><ul><li>在任意一个field上（包括Embedded Field）建立索引</li><li>默认索引 `_id：类型ObjectId(代替递增的 id，能够解决分布式的 MongoDB 生成唯一标识符的问题)，12个字节构成-Timestamp(4)+MachineIdentifier(3)+ProcessIdentifier(2)+Coounter(3)</li><li>可配置顺序/倒序(<code>1</code>: 正序，<code>-1</code>:倒序)</li></ul></li><li><p>复合索引 Compound Index</p><pre><code class="lang-javascript"> db.users.createIndex( { username: 1, age: -1 } ) db.users.createIndex( { username: 1, age: 1 } ) // 方便按照username和age查找 db.users.find({username:&quot;Tom&quot;,age:5});</code></pre><ul><li>多个不同field组成</li><li>注：上面的两个索引是完全不同的，在磁盘上的 <code>B+树</code> 其实也按照了完全不同的顺序进行存储，在使用查询语句对集合中数据进行查找时，是会使用不同的索引，所以在索引创建时要考虑好使用的场景，避免创建无用的索引。</li></ul></li><li><p>多键索引 Multikey Index</p><pre><code class="lang-javascript"> //{ _id: 1, item: &quot;ABC&quot;, ratings: [ 2, 5, 9 ] } db.survey.createIndex( { ratings: 1 } )</code></pre><ul><li>在一个储存数组的键上添加索引，会对数组中的每个元素都添加索引项，加速对数组中元素的查找</li><li>注：不需要显示地指定索引为多键类型，MongoDB会自动地决定是否需要创建一个多键索引</li></ul></li></ol><h3 id="header-22">文本索引</h3><p>Text Index 文本索引（也叫全文索引）</p><ul><li>支持在字符串内容上的文本检索查询</li><li>一个集合只能有一个文本检索索引，但是这个索引可以覆盖多个字段</li><li>创建文本索引（<code>name:&quot;text&quot;</code>）：<pre><code class="lang-javascript">  db.stores.createIndex({name:&quot;text&quot;,description:&quot;text&quot;})        # 在name，description字段建立文本索引</code></pre></li><li>查询：使用<code>$text</code>操作符在一个创建了text index的Collection上执行文本检索<pre><code class="lang-javascript">  {    $text:      {        $search: &lt;string&gt;,        $language: &lt;string&gt;,        $caseSensitive: &lt;boolean&gt;,        $diacriticSensitive: &lt;boolean&gt;      }  }</code></pre></li><li>查询示例：<ul><li><code>$text</code> 会使用空格和标点符号作为分隔符对检索字符串进行分词 (OR操作)<pre><code class="lang-javascript">  // 包含 aa or bb or cc  db.stores.find({ $text:{$search:&quot;aa bb cc&quot;} })  // 包含 (aa or bb ) and not cc  db.stores.find({ $text:{$search:&quot;aa bb -cc&quot;} })  // 包含 aa or &quot;bb cc&quot;  db.stores.find({ $text:{$search:&quot;aa \&quot;bb cc\&quot;&quot;} })</code></pre></li><li><code>$text</code>+<code>$meta</code> 显示匹配相似度<pre><code class="lang-javascript">  # Sort by Additional Query and Text Search Score and Return top 2 matching documents  # score: 计算一个相关性分数，表明该文档与查询的匹配程度  # 显式地对 $meta:&quot;textScore&quot; 字段进行映射然后基于该字段进行sort排序  db.stores.find({      {$text:{$search:&quot;aa bb cc&quot;}},      {score:{$meta:&quot;textScore&quot;}}  }).sort({ date:1, score:{$meta:&quot;textScore&quot;} }).limit(2)</code></pre></li><li>聚合管道中，在 $match 阶段使用文本搜索（限制：只能是管道中的第一个阶段，$text只能在阶段中出现一次，$text不能出现在$or,$nor表达式中）<pre><code class="lang-javascript">  db.articles.aggregate([      { $match:{ $text:{$search:&quot;aa bb&quot;} } },      { $sort:{ score:{$meta:&quot;textScore&quot;} } },      { $project:{ title:1,_id:0 } }  ])  db.articles.aggregate([      { $match:{ $text:{$search:&quot;aa bb&quot;} } },      { $project:{ title:1,_id:0,score:{$meta:&quot;textScore&quot;} } },      { $match:{ score:{$gt:1.0} } }  ])</code></pre></li></ul></li><li>注：如果要做更细致的全文索引的话，推荐使用 Elasticsearch</li></ul><h3 id="header-23">索引属性</h3><p>创建索引时的可配置选项<code>&lt;options&gt;</code>，说明Index的一些特性</p><pre><code class="lang-javascript">db.collection.createIndex( &lt;Key Index specification&gt;, &lt;options&gt;)</code></pre><ol><li><p><code>expireAfterSeconds</code> (TTL): 过一段时间后自动移除集合中的document</p><pre><code class="lang-javascript"> db.users.createIndex(     {lastModifiedDate:1},     {expireAfterSeconds:3600} ) // 设置文档过期的时间expireAt字段的值一致 db.log_events.createIndex(      { &quot;expireAt&quot;: 1 },      { expireAfterSeconds: 0 }  )</code></pre><ul><li>index 字段存储数据类型必需是date或date数组（若是数组，则其中最低过期阈值得到匹配时，删除此document）</li><li>不能保证过期数据会被立刻删除,删除过期数据的后台任务每隔60秒运行一次</li><li>应用场景：机器生成的事件数据，日志，会话信息等，这些数据都只需要在数据库中保存有限时间</li></ul></li><li><p><code>unique</code></p><pre><code class="lang-javascript"> db.members.createIndex( { &quot;user_id&quot;: 1 }, { unique: true } )</code></pre></li><li><p><code>collation</code>: Case Insensitive Indexes</p><pre><code class="lang-javascript"> db.fruit.createIndex(      { type: 1},     { collation: { locale: &#39;en&#39;, strength: 2 } } )</code></pre></li><li><p><code>sparse</code>( 稀疏索引): null值不计入索引，常和唯一索引连用</p><pre><code class="lang-javascript"> db.users.createIndex({name:1},{sparse:true})</code></pre></li><li><p><code>partialFilterExpression</code> ( 局部索引Partial Indexes )：稀疏索引进化版，一种在指定赛道上（可跨赛道），消耗更低的索引</p><pre><code class="lang-javascript"> db.users.createIndex(     {name:1},     {unique:true,partialFilterExpression:{age:{$gt:18}}} )</code></pre><ul><li>不能作为分片的片键</li><li><code>_id</code>不能创建局部索引</li><li>同一个索引不能和sparse同时使用</li><li>一个键上不能有多个不同的局部索引</li><li>particalFilterExpression 支持的过滤操作：<pre><code>  $eq,$gt,$gte,$lt,$lte,  $exists:true,  $type,  $and -- at top level</code></pre></li></ul></li><li><p><code>background</code> : 后台创建索引会比默认的慢，但不会锁表（生产环境使用<code>background:true</code>比较好）</p><pre><code class="lang-javascript"> db.users.createIndex({username:1},{background:true})</code></pre></li></ol><h3 id="header-24">衡量索引使用情况</h3><ol><li>mongostat工具－查看mongodb运行状态的程序 <pre><code class="lang-bash"> mongostat --help mongostat -h localhost:12345</code></pre></li><li>profile集合<pre><code class="lang-javascript"> db.getProfilingLevel() db.getProfilingStatus() db.setProfilingLevel(2) show tables db.system.profile.find().sort({$natural:-1}).limit(10)</code></pre></li><li><p>日志</p><pre><code class="lang-bash"> # 配置日志 vim conf/mongod.conf ... verbose = vvvvv    # v,vv,...,vvvvv</code></pre></li><li><p>查看容量占用（注意: 确保索引与内存相适应）</p><pre><code class="lang-javascript"> // indexSizes: 查看索引在磁盘存储的大小 db.users.stats().indexSizes` // indexDetails: 查看索引占用内存的大小 (内存中会放最近使用的索引) db.users.stats({indexDetails:true}).indexDetails // totalIndexSize 查询索引大小  db.users.totalIndexSize()</code></pre></li><li><p><code>$indexStats</code> 索引具体信息</p><pre><code class="lang-javascript"> // { $indexStats: { } } 返回包括 name,key,host,accesses字段 db.orders.aggregate([      { $indexStats: { } }  ]) db.orders.aggregate([      { $indexStats: { } } ,     {$match:{name:&quot;_id_ type_1_item_1&quot;}} ]) // Eg: Return {    &quot;name&quot; : &quot;_id_&quot;,    &quot;key&quot; : {&quot;_id&quot; : 1},    &quot;host&quot; : &quot;examplehost.local:27017&quot;,    &quot;accesses&quot; : {       &quot;ops&quot; : NumberLong(0),       &quot;since&quot; : ISODate(&quot;2015-10-02T14:31:32.479Z&quot;)    } } {    &quot;name&quot; : &quot;type_1_item_1&quot;,    &quot;key&quot; : {&quot;type&quot; : 1,&quot;item&quot; : 1},    &quot;host&quot; : &quot;examplehost.local:27017&quot;,    &quot;accesses&quot; : {       &quot;ops&quot; : NumberLong(1),       &quot;since&quot; : ISODate(&quot;2015-10-02T14:31:58.321Z&quot;)    } }</code></pre></li><li><p><code>explain()</code> 返回查询计划(query plan)，即查询的详细信息</p><pre><code class="lang-javascript"> // 返回一个含有查询过程的统计数据的文档，包括所使用的索引，扫描过的文档数，查询所消耗的毫秒数 db.users.find(...).explain(&quot;executionStats&quot;)</code></pre></li><li><p><code>hint()</code> 以索引作为方法参数, 强制 MongoDB使用指定的索引来匹配查询</p><pre><code class="lang-javascript"> db.people.find(    { name: &quot;John Doe&quot;, zipcode: { $gt: &quot;63000&quot; } } ).hint( { zipcode: 1 } ).explain(&quot;executionStats&quot;) // 指定 $natural 操作符来避免MongoDB使用任何索引(注; 亦即，查询不会使用索引) db.people.find(    { name: &quot;John Doe&quot;, zipcode: { $gt: &quot;63000&quot; } } ).hint( { $natural: 1 } ).explain(&quot;executionStats&quot;)</code></pre></li></ol><h3 id="header-25">索引优化</h3><p><strong> 索引策略: </strong></p><ul><li>创建索引以支持查询</li><li>使用索引来排序查询结果</li><li>确保索引与内存相适应</li><li>创建能确保选择力的查询</li></ul><p><strong> 优化策略: </strong>    </p><ol><li>重复率越低越适合做索引（distinct／count 越接近1越适合），例如状态，性别等重复率不适合</li><li>联合索引，索引前缀由低到高，eg: <code>db.test.createIndex({a:1,b:1,c:1})</code>,则 a b c, a b, a</li><li>索引顺序：等值，范围，顺序<pre><code class="lang-javascript"> // 查询 db.test.find({     a:2,     b:{$gt2,$le:10} }).sort({c:1}) // 则建立索引如下所以更优： db.test.createIndex({a:1,c:1:b:1})</code></pre></li><li>有条件尽量匹配覆盖索引<pre><code class="lang-javascript"> db.test.createIndex({a:1,b:1,c:1}) db.test.find({a:3},{b:1,c:1,_id:0})     # select b,c from test where a=3 -&gt; 能用到索引，且获取的值在索引中</code></pre></li><li>指定<code>从节点</code>创建索引,这样不影响<code>主节点</code>的写入，不会驱逐掉常规缓存(适用于BI，报表查询，需添加大量索引的情况)，步骤：<ol><li>指定从节点priority为0 （不会变成主节点）</li><li>单机模式重启该从节点（配置文件注释）</li><li>添加索引</li><li>副本集模式重启该节点（配置文件还原）</li></ol></li></ol><h2 id="header-26">聚合 Aggregate</h2><p>MongoDB中有三种实现聚合的方式：</p><ul><li>聚合管道 Aggregator pipeline</li><li>Map-Reduce function</li><li>单目聚合方法（group,count,distinct)</li></ul><h3 id="header-27">聚合管道</h3><p>Aggregation Pipeline</p><ul><li>基于数据处理的聚合管道，使用内置的原生sql操作，效率高 （支持类似mysql的group by功能 ）</li><li>每个document通过一个由多个阶段（stage）组成的管道，经过一系列的处理（例如对每个阶段的管道进行分组、过滤等）输出相应的结果</li><li>限制：<ul><li>每个阶段管道限制为<code>100MB</code>的内存，超过将报错（可以设置<code>allowDiskUse</code>为<code>true</code>来在聚合管道节点把数据写入临时文件来解决100MB的内存的限制）</li><li>输出的结果只能保存在一个文档中，BSON Document大小限制为<code>16M</code>（2.6后：<code>DB.collect.aggregate()</code>方法返回一个指针cursor ，可以返回任何结果集的大小）</li><li>可作用在分片集合，但结果不能输在分片集合（MapReduce可作用在分片集合，结果也可输在分片集合）</li></ul></li></ul><p><img src="/2018/08/04/aggregation-pipeline.png" alt="aggregation-pipeline"></p><p><a href="https://docs.mongodb.com/manual/reference/method/db.collection.aggregate/index.html" target="_blank" rel="noopener">Doc</a>     </p><pre><code class="lang-javascript">// 方式一：db.collection.aggregate(pipeline, options)// 方式二：db.runCommand({  aggregate: &quot;&lt;collection&gt;&quot; || 1,  pipeline: [ &lt;stage&gt;, &lt;...&gt; ],  //options ( belows are optional )  explain: &lt;boolean&gt;,  allowDiskUse: &lt;boolean&gt;,  cursor: &lt;document&gt;,  maxTimeMS: &lt;int&gt;,  bypassDocumentValidation: &lt;boolean&gt;,  readConcern: &lt;document&gt;,  collation: &lt;document&gt;,  hint: &lt;string or document&gt;,  comment: &lt;string&gt;,  writeConcern: &lt;document&gt;})</code></pre><ol><li><p>参数<code>pipeline</code>: </p><pre><code class="lang-javascript"> [&lt;stage&gt;,&lt;Stage&gt;,...] //&lt;stage&gt; $stageOperator:{&lt;key&gt;:&lt;value&gt;,&lt;key&gt;:&lt;expression&gt;...} // &lt;expression&gt;  { &lt;expressionOperator&gt;:&lt;arg&gt; } { &lt;expressionOperator&gt;:[&lt;arg1&gt;,&lt;arg2&gt;,... &lt;argN&gt;] }</code></pre><ul><li><p>StageOperator <a href="https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/#aggregation-pipeline-operator-reference" target="_blank" rel="noopener">阶段操作符</a></p><pre><code class="lang-javascript">  $match          // 过滤数据,传输到下一个阶段管道  $project        // 投影，过滤显示文档字段(可选择字段，重命名字段，派生字段)  $group          // 将数据根据key进行分组,统计结果  $unwind         // 将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值  $lookup         // 进行两个集合之间左连接操作  $sort           // 将输入文档排序后输出  $skip           // 跳过指定数量的文档，返回余下的文档  $limit          // 限制返回的文档数  $redact         // 根据字段所处的document结构的级别，对文档进行“修剪”，通常和“判断语句if-else”结合使用，即＄cond  $sample         // 抽样输出  $geoNear        // 用于地理位置数据分析  $indexStats     // 返回数据集合的每个索引的使用情况 { $indexStats: { } }  $out            // 将最后计算结果写入到指定的collection中,必须为pipeline最后一个阶段管道  ...  // 常用组合  $match -&gt; $project  $match -&gt; $group  $match -&gt; $group -&gt; $sort  $match -&gt; $match -&gt; $ project -&gt; $group  $match -&gt; $lookup -&gt; $match -&gt; $sort  $match -&gt; $project -&gt; $sort -&gt; $skip -&gt; $limit  $match -&gt; $project -&gt; $unwind -&gt; $group -&gt; $sort -&gt;$skip -&gt; $limit</code></pre></li><li><p>ExpressionOperator <a href="https://docs.mongodb.com/manual/meta/aggregation-quick-reference/#aggregation-expressions" target="_blank" rel="noopener">表达式操作符</a></p><pre><code class="lang-javascript">  // 1. 布尔管道 Boolean Operators   // eg: $or: [ { $gt: [ &quot;$qty&quot;, 250 ] }, { $lt: [ &quot;$qty&quot;, 200 ] } ]  $and,$or,$not  // 2. 条件操作符 Conditinal Operator   // eg: $cond: { if: { $gte: [ &quot;$qty&quot;, 250 ] }, then: 30, else: 20 }  $cond,$ifNull,$switch  // 3. 数据类型 DataType Operators  $type  // 4. 集合操作 Set Operators  // eg: $setUnion: [ &quot;$A&quot;, &quot;$B&quot; ]   $setEquals                                     // 完全相等  $setIsSubset                                   // 完全被包含  $anyElementTrue                                // 集合中任一元素符合，则true  $allElementsTrue                               // 集合中所有元素符合，则true  $setIntersection                               // 交集  $setUnion                                      // 并集  $setDifference                                 // 差集  // 5. 比较操作符 Comparison Operators  $cmp                                         // 0/1/-1  $eq,$gt,$lt,$gte,$lte,$ne  // 6. 算术操作符 Arithmetic Operators  // eg: $abs: { $subtract: [ &quot;$start&quot;, &quot;$end&quot; ] }   $abs                                         // 绝对值  $in  $add, $substract, $multiply, $divide, $mod  $ceil, $floor ,$trunc  $log, $log10, $sqrt, $pow, $exp  // 7. 字符串操作 String Operators  // eg: $split: [&quot;$city&quot;, &quot;, &quot;]  $concat, $split  $trim, $ltrim, $rtrim  $toLower, $toUpper  $toString  $dateFromString, $dateToString  $strcasecmp                                  // case-insensitive,return 0,1/-1  $substr                                      // Deprecated!  $substrBytes, $substrCP  $indexOfBytes, $indexOfCP  $strLenBytes,$strLenCP  // 8. 数组 Array Operators  // eg: $arrayElemAt: [ &quot;$favorites&quot;, -1 ]  $arrayElemAt  $map  $filter  $slice                                      // subset  $zip                                        // merge two arrays  $reduce                                     // combine into a single value return  $isArray, $arrayToObject, $objectToArray  $concatArrays  $reverseArray  $indexOfArray  $in  $range  $size  // 9. 日期 Date Operators  $dateFromParts, $dateToParts  $dateFromString, $dateToString  $dateOfMonth, $dateOfWeek, $dateOfYear  $year,$month, $week, $hour, $minute, $second, $millisecond  $isoDayOfWeek, $isoWeek, $isoWeekYear  $toDate  ...</code></pre></li></ul></li><li><p>参数<code>options</code>:</p><pre><code class="lang-javascript"> {   explain: &lt;boolean&gt;,   allowDiskUse: &lt;boolean&gt;,   cursor: &lt;document&gt;,   maxTimeMS: &lt;int&gt;,   bypassDocumentValidation: &lt;boolean&gt;,   readConcern: &lt;document&gt;,   collation: &lt;document&gt;,   hint: &lt;string or document&gt;,   comment: &lt;string&gt;,   writeConcern: &lt;document&gt; }</code></pre></li></ol><p><strong> 示例：</strong></p><ol><li><p>Prepare Test data</p><pre><code class="lang-javascript"> // catalogues: name,description db.catalogues.insert([ {name:&quot;Spring&quot;,description:&quot;spring framework&quot;}, {name:&quot;ReactJS&quot;,description:&quot;reactJS front framework&quot;}, {name:&quot;NoSql&quot;,description:&quot;not only sql databases&quot;} {name:&quot;Docker&quot;,description:&quot;Build, Ship, and Run Any App, Anywhere&quot;} ]); // articles: title,author,description,tags,catalogue,postDate,content db.articles.insert([ {title:&quot;Spring Basic&quot;,author:&quot;Tom&quot;,description:&quot;introduce spring basic&quot;,tags:[&quot;java&quot;,&quot;spring&quot;],catalogueId:db.catalogues.findOne({name:&quot;Spring&quot;})._id,postDate:&quot;2015-01-01&quot;,content:&quot;spring basic:ioc,aop&quot;,click:1}, {title:&quot;Spring MVC&quot;,author:&quot;Tom&quot;,description:&quot;introduce spring mvc&quot;,tags:[&quot;java&quot;,&quot;spring&quot;,&quot;mvc&quot;],catalogueId:db.catalogues.findOne({name:&quot;Spring&quot;})._id,postDate:&quot;2015-01-11&quot;,content:&quot;spring mvc:dispatchServlet,restful&quot;,click:5}, {title:&quot;Spring Security&quot;,author:&quot;Tom&quot;,description:&quot;introduce spring security&quot;,tags:[&quot;java&quot;,&quot;spring&quot;,&quot;security&quot;],catalogueId:db.catalogues.findOne({name:&quot;Spring&quot;})._id,postDate:&quot;2015-01-21&quot;,content:&quot;spring security:securityFilter,authentication,accessDecide&quot;,click:20}, {title:&quot;ReactJS Basic&quot;,author:&quot;Lucy&quot;,description:&quot;introduce reactJS front framework basic&quot;,tags:[&quot;front&quot;,&quot;reateJS&quot;],catalogueId:db.catalogues.findOne({name:&quot;ReactJS&quot;})._id,postDate:&quot;2015-02-01&quot;,content:&quot;reactJS basic:component,lifecycle,props,state&quot;,click:30}, {title:&quot;ReactJS Flux&quot;,author:&quot;Lucy&quot;,description:&quot;introduce reactJS Flux&quot;,tags:[&quot;front&quot;,&quot;reateJS&quot;],catalogueId:db.catalogues.findOne({name:&quot;ReactJS&quot;})._id,postDate:&quot;2015-02-11&quot;,content:&quot;reactJS Flux:reflux,redux&quot;}, {title:&quot;Redis&quot;,author:&quot;Jack&quot;,description:&quot;introduce redis key-value db&quot;,tags:[&quot;nosql&quot;,&quot;redis&quot;],catalogueId:db.catalogues.findOne({name:&quot;NoSql&quot;})._id,postDate:&quot;2015-03-11&quot;,content:&quot;redis:install,master-slave,persist,subscribe,crud&quot;,click:0}, {title:&quot;MongoDB&quot;,author:&quot;Jack&quot;,description:&quot;introduce mongo document database&quot;,tags:[&quot;nosql&quot;,&quot;mongodb&quot;],catalogueId:db.catalogues.findOne({name:&quot;NoSql&quot;})._id,postDate:&quot;2015-03-21&quot;,content:&quot;mongodb:mongo shell,crud,index,aggregation,replica,sharding&quot;,click:25} ]);</code></pre></li><li><p><code>$lookup</code>: Join</p><pre><code class="lang-bash"> # $lookup # { #      $lookup: { #           from: &lt;collection to join&gt;, #           localField: &lt;field from the input documents&gt;, #           foreignField: &lt;field from the documents of the &quot;from&quot; collection&gt;, #           as: &lt;output array field&gt; #      } # } &gt; db.catalogues.aggregate([      {$project:{id:1,name:1}},     { $lookup:{ from:&quot;articles&quot;, localField:&quot;_id&quot;, foreignField:&quot;catalogueId&quot; ,as:&quot;articles&quot;} },     {$project:{&quot;_id&quot;:0,&quot;name&quot;:1,&quot;articles.title&quot;:1,&quot;articles.click&quot;:1}}  ]) { &quot;name&quot; : &quot;Spring&quot;, &quot;articles&quot; : [ { &quot;title&quot; : &quot;Spring Basic&quot;, &quot;click&quot; : 1 }, { &quot;title&quot; : &quot;Spring MVC&quot;, &quot;click&quot; : 5 }, { &quot;title&quot; : &quot;Spring Security&quot;, &quot;click&quot; : 20 } ] } { &quot;name&quot; : &quot;ReactJS&quot;, &quot;articles&quot; : [ { &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;click&quot; : 30 }, { &quot;title&quot; : &quot;ReactJS Flux&quot; } ] } { &quot;name&quot; : &quot;NoSql&quot;, &quot;articles&quot; : [ { &quot;title&quot; : &quot;Redis&quot;, &quot;click&quot; : 0 }, { &quot;title&quot; : &quot;MongoDB&quot;, &quot;click&quot; : 25 } ] } { &quot;name&quot; : &quot;Docker&quot;, &quot;articles&quot; : [ ] }</code></pre></li><li><p><code>$group</code> : 按照特定的字段的值进行分组（非流式运算:必须等收到所有的文档之后，才能对文档进行处理）</p><pre><code class="lang-bash"> &gt; db.articles.count() 7 # 1. $sum # select count(*) as count from articles; &gt; db.articles.aggregate([     { $group:{_id:&quot;null&quot;,count:{$sum:1}} } ]) { &quot;_id&quot; : &quot;null&quot;, &quot;count&quot; : 7 } # select catalogueId as _id,count(*) as count as from articles group by catalogueId &gt; db.articles.aggregate([     { $group:{_id:&quot;$catalogueId&quot;,count:{$sum:1}} } ]) { &quot;_id&quot; : ObjectId(&quot;5b8e342212b995b45c17d5ec&quot;), &quot;count&quot; : 2 } { &quot;_id&quot; : ObjectId(&quot;5b8e342212b995b45c17d5eb&quot;), &quot;count&quot; : 2 } { &quot;_id&quot; : ObjectId(&quot;5b8e342212b995b45c17d5ea&quot;), &quot;count&quot; : 3 } # select author as _id, sum(click) as total_click from articles group by author &gt; db.articles.aggregate([     { $group:{_id:&quot;$author&quot;,total_click:{$sum:&quot;$click&quot;}} } ]) { &quot;_id&quot; : &quot;Lucy&quot;, &quot;total_click&quot; : 30 } { &quot;_id&quot; : &quot;Jack&quot;, &quot;total_click&quot; : 25 } { &quot;_id&quot; : &quot;Tom&quot;, &quot;total_click&quot; : 26 } # 2. $max/$min # select author as _id, max(click) as max_click from articles group by author &gt; db.articles.aggregate([     { $group:{_id:&quot;$author&quot;,max_click:{$max:&quot;$click&quot;}} } ])  { &quot;_id&quot; : &quot;Lucy&quot;, &quot;max_click&quot; : 30 } { &quot;_id&quot; : &quot;Jack&quot;, &quot;max_click&quot; : 25 } { &quot;_id&quot; : &quot;Tom&quot;, &quot;max_click&quot; : 20 } # 3. $avg # select author as _id, avg(click) as avg_click from articles group by author &gt; db.articles.aggregate([     { $group:{_id:&quot;$author&quot;,avg_click:{$avg:&quot;$click&quot;}} } ])  { &quot;_id&quot; : &quot;Lucy&quot;, &quot;avg_click&quot; : 30 } { &quot;_id&quot; : &quot;Jack&quot;, &quot;avg_click&quot; : 12.5 } { &quot;_id&quot; : &quot;Tom&quot;, &quot;avg_click&quot; : 8.666666666666666 } # 4. $first/$last &gt; db.articles.aggregate([     { $group:{_id:&quot;$author&quot;,click_list:{$first:&quot;$click&quot;}} } ])  { &quot;_id&quot; : &quot;Lucy&quot;, &quot;click_list&quot; : 30 } { &quot;_id&quot; : &quot;Jack&quot;, &quot;click_list&quot; : 0 } { &quot;_id&quot; : &quot;Tom&quot;, &quot;click_list&quot; : 1 } # 5. $push/$addToSet &gt; db.articles.aggregate([     { $group:{_id:&quot;$author&quot;,click_list:{$push:&quot;$click&quot;}} } ])  { &quot;_id&quot; : &quot;Lucy&quot;, &quot;click_list&quot; : [ 30 ] } { &quot;_id&quot; : &quot;Jack&quot;, &quot;click_list&quot; : [ 0, 25 ] } { &quot;_id&quot; : &quot;Tom&quot;, &quot;click_list&quot; : [ 1, 5, 20 ] }</code></pre></li><li><p><code>$match</code> 过滤（尽量放在前面，提高效率）</p><pre><code class="lang-bash"> # select _id,title,author from articles where click&gt;0 and click&lt;25 db.articles.aggregate([     { $match:{click:{$gt:0,$lt:25}} },     { $project:{&quot;_id&quot;:0,&quot;title&quot;:1,&quot;author&quot;:1,&quot;click&quot;:1}} ])  { &quot;title&quot; : &quot;Spring Basic&quot;, &quot;author&quot; : &quot;Tom&quot;, &quot;click&quot; : 1 } { &quot;title&quot; : &quot;Spring MVC&quot;, &quot;author&quot; : &quot;Tom&quot;, &quot;click&quot; : 5 } { &quot;title&quot; : &quot;Spring Security&quot;, &quot;author&quot; : &quot;Tom&quot;, &quot;click&quot; : 20 } # select author as _id,sum(click) as total_click from articles group by author having sum(click)&gt;0 and sum(click)&lt;30 db.articles.aggregate([     { $group:{_id:&quot;$author&quot;,total_click:{$sum:&quot;$click&quot;} } },     { $match:{total_click:{$gt:0,$lt:30}} } ])  { &quot;_id&quot; : &quot;Jack&quot;, &quot;total_click&quot; : 25 } { &quot;_id&quot; : &quot;Tom&quot;, &quot;total_click&quot; : 26 }</code></pre></li><li><p><code>$project</code>: 选择字段，重命名字段，派生字段    </p><pre><code class="lang-bash"> # 选择字段: field:1/0，表示选择/不选择 field；将无用的字段从pipeline中过滤掉，能够减少聚合操作对内存的消耗 &gt; db.articles.aggregate([     { $project:{&quot;_id&quot;:0,&quot;title&quot;:1,&quot;postData&quot;:1,&quot;click&quot;:1,&quot;tags&quot;:1} } ]) { &quot;title&quot; : &quot;Spring Basic&quot;, &quot;tags&quot; : [ &quot;java&quot;, &quot;spring&quot; ], &quot;click&quot; : 1 } { &quot;title&quot; : &quot;Spring MVC&quot;, &quot;tags&quot; : [ &quot;java&quot;, &quot;spring&quot;, &quot;mvc&quot; ], &quot;click&quot; : 5 } { &quot;title&quot; : &quot;Spring Security&quot;, &quot;tags&quot; : [ &quot;java&quot;, &quot;spring&quot;, &quot;security&quot; ], &quot;click&quot; : 20 } { &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;tags&quot; : [ &quot;front&quot;, &quot;reateJS&quot; ], &quot;click&quot; : 30 } { &quot;title&quot; : &quot;ReactJS Flux&quot;, &quot;tags&quot; : [ &quot;front&quot;, &quot;reateJS&quot; ] } { &quot;title&quot; : &quot;Redis&quot;, &quot;tags&quot; : [ &quot;nosql&quot;, &quot;redis&quot; ], &quot;click&quot; : 0 } { &quot;title&quot; : &quot;MongoDB&quot;, &quot;tags&quot; : [ &quot;nosql&quot;, &quot;mongodb&quot; ], &quot;click&quot; : 25 } # 重命名字段: 引用符$，格式是：&quot;$field&quot;，表示引用doc中 field 的值 &gt; db.articles.aggregate([     { $project:{_id:0,title:1,&quot;preClick&quot;:&quot;$click&quot;} } ]) { &quot;title&quot; : &quot;Spring Basic&quot;, &quot;preClick&quot; : 1 } { &quot;title&quot; : &quot;Spring MVC&quot;, &quot;preClick&quot; : 5 } { &quot;title&quot; : &quot;Spring Security&quot;, &quot;preClick&quot; : 20 } { &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;preClick&quot; : 30 } { &quot;title&quot; : &quot;ReactJS Flux&quot; } { &quot;title&quot; : &quot;Redis&quot;, &quot;preClick&quot; : 0 } { &quot;title&quot; : &quot;MongoDB&quot;, &quot;preClick&quot; : 25 } # 派生字段: 对字段进行计算，派生出一个新的字段 &gt; db.articles.aggregate([     { $project:{         &quot;title&quot;:1,         &quot;click&quot;:1,         &quot;result&quot;: { $or: [ { $gt: [ &quot;$click&quot;, 20 ] }, { $lt: [ &quot;$click&quot;, 100 ] } ] }       }      } ]) { &quot;_id&quot; : ObjectId(&quot;5be2b3347ec0ecb208b54816&quot;), &quot;title&quot; : &quot;Spring Basic&quot;, &quot;click&quot; : 1, &quot;result&quot; : true } { &quot;_id&quot; : ObjectId(&quot;5be2b3347ec0ecb208b54817&quot;), &quot;title&quot; : &quot;Spring MVC&quot;, &quot;click&quot; : 5, &quot;result&quot; : true } { &quot;_id&quot; : ObjectId(&quot;5be2b3347ec0ecb208b54818&quot;), &quot;title&quot; : &quot;Spring Security&quot;, &quot;click&quot; : 20, &quot;result&quot; : true } { &quot;_id&quot; : ObjectId(&quot;5be2b3347ec0ecb208b54819&quot;), &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;click&quot; : 30, &quot;result&quot; : true } { &quot;_id&quot; : ObjectId(&quot;5be2b3347ec0ecb208b5481a&quot;), &quot;title&quot; : &quot;ReactJS Flux&quot;, &quot;result&quot; : true } { &quot;_id&quot; : ObjectId(&quot;5be2b3347ec0ecb208b5481b&quot;), &quot;title&quot; : &quot;Redis&quot;, &quot;click&quot; : 0, &quot;result&quot; : true } { &quot;_id&quot; : ObjectId(&quot;5be2b3347ec0ecb208b5481c&quot;), &quot;title&quot; : &quot;MongoDB&quot;, &quot;click&quot; : 25, &quot;result&quot; : true } # 派生字段 &gt; db.articles.aggregate([     { $project:{         _id:0,         title:1,         click:1,         level: { $cond:{if:{$gte:[&quot;$click&quot;,20]},then: &quot;High&quot;,else: &quot;Low&quot;} }      }      } ]) { &quot;title&quot; : &quot;Spring Basic&quot;, &quot;click&quot; : 1, &quot;level&quot; : &quot;Low&quot; } { &quot;title&quot; : &quot;Spring MVC&quot;, &quot;click&quot; : 5, &quot;level&quot; : &quot;Low&quot; } { &quot;title&quot; : &quot;Spring Security&quot;, &quot;click&quot; : 20, &quot;level&quot; : &quot;High&quot; } { &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;click&quot; : 30, &quot;level&quot; : &quot;High&quot; } { &quot;title&quot; : &quot;ReactJS Flux&quot;, &quot;level&quot; : &quot;Low&quot; } { &quot;title&quot; : &quot;Redis&quot;, &quot;click&quot; : 0, &quot;level&quot; : &quot;Low&quot; } { &quot;title&quot; : &quot;MongoDB&quot;, &quot;click&quot; : 25, &quot;level&quot; : &quot;High&quot; }</code></pre></li><li><p><code>$limit</code>,<code>$skip</code>,<code>$sort</code></p><pre><code class="lang-bash"> &gt; db.articles.aggregate([     {$skip:2},     {$limit:3},     {$sort:{&quot;postDate&quot;:1}},     {$project:{&quot;_id&quot;:0,&quot;title&quot;:1,&quot;postDate&quot;:1}} ]) { &quot;title&quot; : &quot;Spring Security&quot;, &quot;postDate&quot; : &quot;2015-01-21&quot; } { &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;postDate&quot; : &quot;2015-02-01&quot; } { &quot;title&quot; : &quot;ReactJS Flux&quot;, &quot;postDate&quot; : &quot;2015-02-11&quot; } &gt; db.articles.aggregate([     {$sort:{&quot;postDate&quot;:1}},     {$limit:3},     {$skip:2},     {$project:{&quot;_id&quot;:0,&quot;title&quot;:1,&quot;postDate&quot;:1}} ]) { &quot;title&quot; : &quot;Spring Security&quot;, &quot;postDate&quot; : &quot;2015-01-21&quot; }</code></pre></li><li><p><code>$unwind</code>: 拆分数组字段</p><pre><code class="lang-bash"> &gt; db.articles.aggregate([     {$project:{&quot;_id&quot;:0,&quot;title&quot;:1,&quot;tags&quot;:1}},     {$unwind:&quot;$tags&quot;} ]) { &quot;title&quot; : &quot;Spring Basic&quot;, &quot;tags&quot; : &quot;java&quot; } { &quot;title&quot; : &quot;Spring Basic&quot;, &quot;tags&quot; : &quot;spring&quot; } { &quot;title&quot; : &quot;Spring MVC&quot;, &quot;tags&quot; : &quot;java&quot; } { &quot;title&quot; : &quot;Spring MVC&quot;, &quot;tags&quot; : &quot;spring&quot; } { &quot;title&quot; : &quot;Spring MVC&quot;, &quot;tags&quot; : &quot;mvc&quot; } { &quot;title&quot; : &quot;Spring Security&quot;, &quot;tags&quot; : &quot;java&quot; } { &quot;title&quot; : &quot;Spring Security&quot;, &quot;tags&quot; : &quot;spring&quot; } { &quot;title&quot; : &quot;Spring Security&quot;, &quot;tags&quot; : &quot;security&quot; } { &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;tags&quot; : &quot;front&quot; } { &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;tags&quot; : &quot;reateJS&quot; } { &quot;title&quot; : &quot;ReactJS Flux&quot;, &quot;tags&quot; : &quot;front&quot; } { &quot;title&quot; : &quot;ReactJS Flux&quot;, &quot;tags&quot; : &quot;reateJS&quot; } { &quot;title&quot; : &quot;Redis&quot;, &quot;tags&quot; : &quot;nosql&quot; } { &quot;title&quot; : &quot;Redis&quot;, &quot;tags&quot; : &quot;redis&quot; } { &quot;title&quot; : &quot;MongoDB&quot;, &quot;tags&quot; : &quot;nosql&quot; } { &quot;title&quot; : &quot;MongoDB&quot;, &quot;tags&quot; : &quot;mongodb&quot; }</code></pre><ul><li>参数数组字段为空或不存在时，待处理的文档将会被忽略，该文档将不会有任何输出</li><li>参数不是一个数组类型时，将会抛出异常</li></ul></li><li><p><code>$out</code>: 把执行的结果写入指定数据表(会先清空原数据)</p><pre><code class="lang-bash"> &gt; db.articles.aggregate([     { $group:{_id:&quot;$author&quot;,total_click:{$sum:&quot;$click&quot;}} },     { $out:&quot;author_click&quot; } ]) &gt; db.author_click.find() { &quot;_id&quot; : &quot;Lucy&quot;, &quot;total_click&quot; : 30 } { &quot;_id&quot; : &quot;Jack&quot;, &quot;total_click&quot; : 25 } { &quot;_id&quot; : &quot;Tom&quot;, &quot;total_click&quot; : 26 } &gt; db.articles.aggregate([     { $group:{_id:&quot;$author&quot;,total_click:{$sum:&quot;$click&quot;}} },     { $project:{&quot;_id&quot;:0}},     { $limit:2},     { $out:&quot;author_click&quot; } ]) &gt; db.author_click.find() { &quot;_id&quot; : ObjectId(&quot;5be3a0ec58072db74ca83569&quot;), &quot;total_click&quot; : 30 } { &quot;_id&quot; : ObjectId(&quot;5be3a0ec58072db74ca8356a&quot;), &quot;total_click&quot; : 25 }</code></pre></li><li><p>options:<code>explain</code> 返回aggregate各个阶段管道的执行计划信息</p><pre><code class="lang-bash"> &gt; db.articles.aggregate([     { $group:{_id:&quot;$author&quot;,click_list:{$push:&quot;$click&quot;}} } ])  { &quot;_id&quot; : &quot;Lucy&quot;, &quot;click_list&quot; : [ 30 ] } { &quot;_id&quot; : &quot;Jack&quot;, &quot;click_list&quot; : [ 0, 25 ] } { &quot;_id&quot; : &quot;Tom&quot;, &quot;click_list&quot; : [ 1, 5, 20 ] } &gt; db.articles.aggregate([     { $group:{_id:&quot;$author&quot;,click_list:{$push:&quot;$click&quot;}} } ],{explain:true}) {     &quot;stages&quot; : [             {                     &quot;$cursor&quot; : {                             &quot;query&quot; : {                             },                             &quot;fields&quot; : {                                     &quot;author&quot; : 1,                                     &quot;click&quot; : 1,                                     &quot;_id&quot; : 0                             },                             &quot;queryPlanner&quot; : {                                     &quot;plannerVersion&quot; : 1,                                     &quot;namespace&quot; : &quot;demo.articles&quot;,                                     &quot;indexFilterSet&quot; : false,                                     &quot;parsedQuery&quot; : {                                     },                                     &quot;winningPlan&quot; : {                                             &quot;stage&quot; : &quot;COLLSCAN&quot;,                                             &quot;direction&quot; : &quot;forward&quot;                                     },                                     &quot;rejectedPlans&quot; : [ ]                             }                     }             },             {                     &quot;$group&quot; : {                             &quot;_id&quot; : &quot;$author&quot;,                             &quot;click_list&quot; : {                                     &quot;$push&quot; : &quot;$click&quot;                             }                     }             }     ],     &quot;ok&quot; : 1 }</code></pre></li></ol><h3 id="header-28">Map-Reduce</h3><ul><li>是一种计算模型（能够在多台Server上并行执行），将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）</li><li>分为两个阶段:Map和Reduce；主要分为三步：Map，Shuffle，Reduce<ul><li>Map: 将操作映射到每条document，产生key和value。eg：Map一个document产生key value对：<code>{female,{count:1}}</code>,<code>{male,{count:1}}</code></li><li>Shuffle: 按照key进行分组，并将key相同的value组合成数组。eg：产生<code>(female:[{count:1},{count:1},...])</code>,<code>(male:[{count:1},{count:1},...])</code></li><li>Reduce: 把Value数组化简为单值(聚合运算统计)。eg：<code>(female:{count:20})</code>,<code>(male:{count:15})</code></li><li>注：Map和Reduce需要显式定义，shuffle由MongoDB来实现</li></ul></li></ul><p><img src="/2018/08/04/map-reduce.png" alt="map-reduce"></p><pre><code class="lang-javascript">db.collection.mapReduce(     &lt;map&gt;,                            // map 映射函数,生成键值对 (遍历 collection,调用emit(key, value))     &lt;reduce&gt;,                        // reduce 统计函数 (key-values -&gt; key-value,把values数组变成一个单一的值value)     {       out: &lt;collection&gt;,            // 存放统计结果 (不指定则使用临时集合,在客户端断开后自动删除)       query: &lt;document&gt;,            // 一个筛选条件，只有满足条件的文档才会调用map函数       sort: &lt;document&gt;,            // 发往map函数前给文档排序       limit: &lt;number&gt;,                // 发往map函数的文档数量的上限       finalize: &lt;function&gt;,       scope: &lt;document&gt;,       jsMode: &lt;boolean&gt;,       verbose: &lt;boolean&gt;,       bypassDocumentValidation: &lt;boolean&gt;     })</code></pre><p>示例：</p><pre><code class="lang-bash">&gt; db.articles.find({},{&quot;_id&quot;:0,&quot;title&quot;:1,&quot;author&quot;:1,&quot;click&quot;:1,&quot;tags&quot;:1}){ &quot;title&quot; : &quot;Spring Basic&quot;, &quot;author&quot; : &quot;Tom&quot;, &quot;tags&quot; : [ &quot;java&quot;, &quot;spring&quot; ], &quot;click&quot; : 1 }{ &quot;title&quot; : &quot;Spring MVC&quot;, &quot;author&quot; : &quot;Tom&quot;, &quot;tags&quot; : [ &quot;java&quot;, &quot;spring&quot;, &quot;mvc&quot; ], &quot;click&quot; : 5 }{ &quot;title&quot; : &quot;Spring Security&quot;, &quot;author&quot; : &quot;Tom&quot;, &quot;tags&quot; : [ &quot;java&quot;, &quot;spring&quot;, &quot;security&quot; ], &quot;click&quot; : 20 }{ &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;author&quot; : &quot;Lucy&quot;, &quot;tags&quot; : [ &quot;front&quot;, &quot;reateJS&quot; ], &quot;click&quot; : 30 }{ &quot;title&quot; : &quot;ReactJS Flux&quot;, &quot;author&quot; : &quot;Lucy&quot;, &quot;tags&quot; : [ &quot;front&quot;, &quot;reateJS&quot; ] }{ &quot;title&quot; : &quot;Redis&quot;, &quot;author&quot; : &quot;Jack&quot;, &quot;tags&quot; : [ &quot;nosql&quot;, &quot;redis&quot; ], &quot;click&quot; : 0 }{ &quot;title&quot; : &quot;MongoDB&quot;, &quot;author&quot; : &quot;Jack&quot;, &quot;tags&quot; : [ &quot;nosql&quot;, &quot;mongodb&quot; ], &quot;click&quot; : 25 }# 1. 各author的click大于0的文章总数&gt; db.articles.mapReduce(    function(){emit(this.author,1)},    function(key,values){return Array.sum(values)},    {query:{click:{$gt:0}},out: &quot;author_sum&quot;}){        &quot;result&quot; : &quot;author_sum&quot;,            // 储存结果的collection的名字        &quot;timeMillis&quot; : 122,                    // 执行花费的时间，毫秒为单位        &quot;counts&quot; : {                &quot;input&quot; : 5,                // 满足条件被发送到map函数的文档个数                &quot;emit&quot; : 5,                    // 在map函数中emit被调用的次数，也就是所有集合中的数据总量                &quot;reduce&quot; : 1,                // reduce函数调用次数                &quot;output&quot; : 3                // 结果集合中的文档个数        },        &quot;ok&quot; : 1                            // 是否成功，成功为1}&gt; db.author_sum.find(){ &quot;_id&quot; : &quot;Jack&quot;, &quot;value&quot; : 1 }{ &quot;_id&quot; : &quot;Lucy&quot;, &quot;value&quot; : 1 }{ &quot;_id&quot; : &quot;Tom&quot;, &quot;value&quot; : 3 }# 2. 各author文章的平均点击数&gt; db.articles.mapReduce(    function(){emit(this.author,{click:this.click||0,article:1})},    function(key,values){         reducedVal={sum_click:0,sum_article:0};        values.forEach(function(item){            reducedVal.sum_click+=item.click;            reducedVal.sum_article+=item.article;        })        return reducedVal.sum_click/reducedVal.sum_article;    },    {out:&quot;author_sum&quot;}){        &quot;result&quot; : &quot;author_sum&quot;,        &quot;timeMillis&quot; : 241,        &quot;counts&quot; : {                &quot;input&quot; : 7,                &quot;emit&quot; : 7,                &quot;reduce&quot; : 3,                &quot;output&quot; : 3        },        &quot;ok&quot; : 1}&gt; db.author_sum.find(){ &quot;_id&quot; : &quot;Jack&quot;, &quot;value&quot; : 12.5 }{ &quot;_id&quot; : &quot;Lucy&quot;, &quot;value&quot; : 15 }{ &quot;_id&quot; : &quot;Tom&quot;, &quot;value&quot; : 8.666666666666666 }</code></pre><h3 id="header-29">单目聚合操作</h3><p><img src="/2018/08/04/distinct.png" alt="distinct"></p><ol><li><p>count: <code>db.collection.count(query, options)</code></p><pre><code class="lang-bash"> &gt; db.articles.count() 7 &gt; db.articles.count({click:{$gt:10}}) 3 &gt; db.articles.count({click:{$gt:10},tags:{$size:2}}) 2 &gt; db.articles.find({click:{$gt:10},tags:{$size:2}}).count() 2</code></pre></li><li><p>distinct: <code>db.collection.distinct(field, query, options)</code></p><pre><code class="lang-bash"> &gt; db.articles.distinct(&quot;click&quot;) [ 1, 5, 20, 30, 0, 25 ] &gt; db.articles.distinct(&quot;tags&quot;) [&quot;java&quot;,&quot;spring&quot;,&quot;mvc&quot;,&quot;security&quot;,&quot;front&quot;,&quot;reateJS&quot;,&quot;nosql&quot;,&quot;redis&quot;,&quot;mongodb&quot;] &gt; db.articles.distinct(&quot;tags&quot;,{click:{$gt:20}}) [ &quot;front&quot;, &quot;reateJS&quot;, &quot;mongodb&quot;, &quot;nosql&quot; ]</code></pre></li></ol><h2 id="header-30">Security</h2><p>安全:</p><ul><li>物理隔离（最安全）</li><li>网络隔离</li><li>IP白名单隔离（防火墙配置等）</li><li>用户名密码鉴权</li></ul><p>开启权限认证:</p><ul><li>auth开启<pre><code class="lang-bash">  &gt; vim conf/mongod.conf  ...  auth = true</code></pre></li><li>keyfile开启</li></ul><ol><li><p>查看用户<code>db.getUsers()</code>，查看角色<code>db.getRoles()</code></p><pre><code class="lang-bash"> &gt; use admin switched to db admin &gt; db.getUsers() [     {             &quot;_id&quot; : &quot;admin.mongoadmin&quot;,             &quot;user&quot; : &quot;mongoadmin&quot;,             &quot;db&quot; : &quot;admin&quot;,             &quot;roles&quot; : [                     {                             &quot;role&quot; : &quot;root&quot;,                             &quot;db&quot; : &quot;admin&quot;                     }             ],             &quot;mechanisms&quot; : [                     &quot;SCRAM-SHA-1&quot;,                     &quot;SCRAM-SHA-256&quot;             ]     } ] &gt; db.getRoles() [ ]</code></pre></li><li><p>创建用户<code>db.createUser</code> (role内建类型：read,readWrite,dbAdmin,dbOwner,userAdmin)</p><pre><code class="lang-bash"> &gt; db.createUser({     user:&quot;cj&quot;,     pwd:&quot;123&quot;,     roles:[         {role:&quot;userAdmin&quot;,db:&quot;demo&quot;},         {role:&quot;read&quot;,db:&quot;local&quot;}     ] }) &gt; mongo localhost:12345 -u cj -p 123 &gt; use testdb &gt; show tables</code></pre></li><li><p>创建角色<code>db.createRole</code></p><pre><code class="lang-bash"> # 用户角色： # 数据库角色（read,readWrite,dbAdmin,dbOwner,userAdmin) # 集群角色（clusterAdmin,clusterManager,...） # 备份角色（backup,restore,...） # 其他特殊权限（DBAdminAnyDatabase,...） &gt; db.createRole({     role:&quot;appUser&quot;,     db:&quot;myApp&quot;     privileges:[         {             resource:{db:&quot;myApp&quot;,collection:&quot; &quot;},             actions:[&quot;find&quot;,&quot;createCollection&quot;,&quot;dbStates&quot;,&quot;collStats&quot;]         },         {             resource:{db:&quot;myApp&quot;,collection:&quot;logs&quot;},             actions:[&quot;insert&quot;]         },         {             resource:{db:&quot;myApp&quot;,collection:&quot;data&quot;},             actions:[&quot;insert&quot;,&quot;update&quot;,&quot;remove&quot;,&quot;compact&quot;]         },         {             resource:{db:&quot;myApp&quot;,collection:&quot;system.indexes&quot;},             actions:[&quot;find&quot;]         }     ],     roles:[] })</code></pre></li></ol><h2 id="header-31">复制集 &amp; 分片</h2><ol><li>复制集 Replica Set （纵向）: 基于领导（Leader-based）复制状态机 (关键：选举和数据复制)</li><li>分片 Sharding（横向）：将数据进行拆分，水平的分散到不同的服务器上；架构上：读写均衡，去中心化</li><li>分片与复制集集群对比<table class="table"><thead><tr><th style="text-align:left">-</th><th style="text-align:left">Shard</th><th style="text-align:left">Replication</th></tr></thead><tbody><tr><td style="text-align:left">实现意义</td><td style="text-align:left">提升并发性能，提高大量数据随机访问性能</td><td style="text-align:left">数据冗余，提升读性能</td></tr><tr><td style="text-align:left">架构上</td><td style="text-align:left">水平化</td><td style="text-align:left">中心化</td></tr><tr><td style="text-align:left">实现原理</td><td style="text-align:left">数据打散分布</td><td style="text-align:left">数据镜像</td></tr><tr><td style="text-align:left">维护成本</td><td style="text-align:left">相对较高</td><td style="text-align:left">相对容易</td></tr></tbody></table></li></ol><p><strong> More about Sharding </strong></p><ol><li><p>分片成员节点：<br> <img src="2018-08-04-MongoDB/sharding-nodes.png" alt="Sharding nodes"></p><ul><li><code>Shard节点</code>： 存储数据的节点（单个mongod或者副本集） <code>mongod --shardsvr --rpelSet</code></li><li><code>Config Server</code>：存储元数据，为mongos服务，将数据路由到Shard <code>mongod --configsvr</code></li><li><code>Query routers</code>: 查询路由节点，即<code>Mongos</code>节点，接入Client请求，根据路由规则转发给合适的shard或者shards <code>mongos --configdb &lt;configdb server&gt;</code></li></ul></li><li><p>概念：</p><ol><li>分片片键（Shard Key）：集合里面选个键，用该键的值作为数据拆分的依据,例如配置<code>sh.shardCollection(&quot;records.people&quot;, {user_id:&quot;hashed&quot;})</code></li><li>数据块（Chunk）：mongodb分片后，存储数据的单元块，默认大小为64M</li><li>拆分 （Split Chunk）：一个后台进程避免chunk增长的过大，当chunk尺寸超过指定的chunk size时，拆分此chunk（split后shard将会修改config server上这个chunk的metadata元信息）</li><li>平衡 （Balancing Chunks）：一个后台线程用于对chunks迁移以达到平衡，会周期性的检查分片是否存在不均衡，如果存在则会进行块的迁移（balancer均衡器运行在mongos上，注：balancer进行均衡的条件是块数量的多少，而不是块大小）</li><li>拆分－&gt;平衡过程：<br> <img src="/2018/08/04/shading-spliting.png" alt="Spliting"><br> <img src="/2018/08/04/shading-balancing.png" alt="Balancing"></li></ol></li><li><p>Sharding Strategy：</p><ul><li>Hashed Sharding（哈希切片) : 能将写入均衡分布到各个 shard</li><li>Ranged Sharding（范围切片）: 能很好的支持基于 shard key的范围查询</li><li>Tag aware Sharding</li><li>好的shard key：<ul><li>key分布足够离散 sufficient cardinality: 片键相同导致数据块不拆分，容易形成大的数据块，导致数据不均</li><li>写请求均匀分布 （evenly distributed write）: 例如单调递增的<code>_id</code>或者时间戳作为片键，会导致一直往最后一个复本集添加数据</li><li>尽量避免 scatter-gather 查询 （targeted read） </li></ul></li></ul></li><li><p>添加分片过程：</p><ol><li>连接到mongos</li><li>Add Shards</li><li>Enable Sharding</li><li>对一个Collection进行分片    </li></ol></li><li><p>示例：手动分片（减少自动平衡过程带来的IO等资源消耗）</p><ul><li><p>前提：充分了解数据，对数据进行预先划分</p><pre><code class="lang-bash"># 关闭自动平衡 auto balance    sh.stopBalancer()    # Currently enabled: no# 分片切割 spliting&gt; use admin&gt; db.runCommand({&quot;enablesharding&quot;:&quot;myapp&quot;})&gt; db.runCommand({&quot;shardcollection&quot;:&quot;myapp.users&quot;,&quot;key&quot;:{&quot;email&quot;:1}})for(var x=97;x&lt;97+26;x++){  for(var y=97;y&lt;97+26;y+=6){      var prefix=String.fromCharCode(x)+String.fromCharCode(y);      db.runCommand({split:&quot;myapp.users&quot;,middle:{email:prefix}})  }}# 手动移动分割块 balancingvar shServer=[  &quot;ShardServer 1&quot;,  &quot;ShardServer 2&quot;,  &quot;ShardServer 3&quot;,  &quot;ShardServer 4&quot;,  &quot;ShardServer 5&quot;]for(var x=97;x&lt;97+26;x++){  for(var y=97;y&lt;97+26;y+=6){      var prefix=String.fromCharCode(x)+String.fromCharCode(y);      db.adminCommand({moveChunk:&quot;myapp.users&quot;,find:{email:prefix},to:shServer[(y-97)/6]})  }}# 循环(y-97)/6的数值结果为0，6，12，18，24； shServer[0] -&gt; shServer[4]</code></pre></li></ul></li></ol><h2 id="header-32">MongoDB 4.0 新特性</h2><ol><li><p>多文档事务</p><ul><li>4.0: 单文档事务 -&gt; 跨文档事务</li><li>4.2: 复制集事务 -&gt; 分片集群事务</li></ul></li><li><p>聚合类型转换: 引入<code>$convert</code>聚合操作符来简化ETL（抽取，转化，加载）流程和负荷</p><ul><li>可结合:<pre><code class="lang-bash">  # 1. 类型转换  $toBool,$toDate,$toDecimal,$toDouble,$toInt,$toLong,$toObjectId,$toString  # 2. 日期操作转换  $dateToParts,$dateFromParts,$dateFromString  # 3. 修剪  $trim,$rtrim,$ltrim  {$trim:{input:&lt;expression&gt;}}  {$trim:{input:[&lt;expression&gt;],chars:&lt;string&gt;}}</code></pre></li><li>prepare test data:<pre><code class="lang-bash">  &gt; db.address.insert([      { street: &quot;Canal st&quot;, building: NumberDecimal(21), _id: 0},      { street: &quot;43rd st&quot;, building: &quot;229&quot;, _id: 1},      { street: &quot;Fulton st&quot;, building: &quot;31&quot;, _id: 2 },      { street: &quot;52nd st&quot;, building: &quot;11w&quot;, _id: 3},       { street: &quot;78th st&quot;, building: null, _id: 4},       { street: &quot;78th st&quot;,  _id: 5},       { street: &quot;Rector st&quot;, building: NumberInt(10), _id: 6,last_visited: {year: 2017, month: 10}}  ]);</code></pre></li><li><code>$convert</code>示例：<pre><code class="lang-bash">  &gt; db.address.aggregate( [    {      $addFields: {        building: {          $convert: {            input: &quot;$building&quot;,            to: &quot;int&quot;,            onError: 0,            onNull: -1          }        }      }    },    { $sort: {building: 1}}  ]);  { &quot;_id&quot; : 4, &quot;street&quot; : &quot;78th st&quot;, &quot;building&quot; : -1 }  { &quot;_id&quot; : 5, &quot;street&quot; : &quot;78th st&quot;, &quot;building&quot; : -1 }  { &quot;_id&quot; : 3, &quot;street&quot; : &quot;52nd st&quot;, &quot;building&quot; : 0 }  { &quot;_id&quot; : 6, &quot;street&quot; : &quot;Rector st&quot;, &quot;building&quot; : 10, &quot;last_visited&quot; : { &quot;year&quot; : 2017, &quot;month&quot; : 10 } }  { &quot;_id&quot; : 0, &quot;street&quot; : &quot;Canal st&quot;, &quot;building&quot; : 21 }  { &quot;_id&quot; : 2, &quot;street&quot; : &quot;Fulton st&quot;, &quot;building&quot; : 31 }  { &quot;_id&quot; : 1, &quot;street&quot; : &quot;43rd st&quot;, &quot;building&quot; : 229 }</code></pre></li><li><code>$dateFromParts</code>示例：<pre><code class="lang-bash">  # Add 15 months to month date field:  &gt; db.address.aggregate([    {      $addFields: {        next_visit: {            $convert:{              input: {                $dateFromParts: {                  year: &quot;$last_visited.year&quot;,                  month: {$add:[15, &quot;$last_visited.month&quot;]},                }},              to: &quot;date&quot;,              onNull: &quot;&quot;,              onError: &quot;&quot;          }        }      }    }  ]);  { &quot;_id&quot; : 0, &quot;street&quot; : &quot;Canal st&quot;, &quot;building&quot; : NumberDecimal(&quot;21.0000000000000&quot;), &quot;next_visit&quot; : &quot;&quot; }  { &quot;_id&quot; : 1, &quot;street&quot; : &quot;43rd st&quot;, &quot;building&quot; : &quot;229&quot;, &quot;next_visit&quot; : &quot;&quot; }  { &quot;_id&quot; : 2, &quot;street&quot; : &quot;Fulton st&quot;, &quot;building&quot; : &quot;31&quot;, &quot;next_visit&quot; : &quot;&quot; }  { &quot;_id&quot; : 3, &quot;street&quot; : &quot;52nd st&quot;, &quot;building&quot; : &quot;11w&quot;, &quot;next_visit&quot; : &quot;&quot; }  { &quot;_id&quot; : 4, &quot;street&quot; : &quot;78th st&quot;, &quot;building&quot; : null, &quot;next_visit&quot; : &quot;&quot; }  { &quot;_id&quot; : 5, &quot;street&quot; : &quot;78th st&quot;, &quot;next_visit&quot; : &quot;&quot; }  { &quot;_id&quot; : 6, &quot;street&quot; : &quot;Rector st&quot;, &quot;building&quot; : 10, &quot;last_visited&quot; : { &quot;year&quot; : 2017, &quot;month&quot; : 10 }, &quot;next_visit&quot; : ISODate(&quot;2019-01-01T00:00:00Z&quot;) }</code></pre></li><li><p><code>$trim</code>示例：</p><pre><code class="lang-bash">  # conversion error:  &gt; db.address.aggregate( [    {      $addFields: {         building: {$convert: { input: &quot;$building&quot;, to: &quot;int&quot;  }}  }    },    {$sort: {building: 1}}  ]);  Error: command failed: {      &quot;ok&quot; : 0,      &quot;errmsg&quot; : &quot;Failed to parse number &#39;11w&#39; in $convert with no onError value: Bad digit \&quot;w\&quot; while parsing 11w&quot;,      &quot;code&quot; : 241,      &quot;codeName&quot; : &quot;ConversionFailure&quot;  } : aggregate failed  # avoid conversion error: Using $trim expression with longer list of chars to remove:  &gt; db.address.aggregate( [    {$match: { building: {$type: &quot;string&quot;} }},    {      $addFields: {        building: {          $convert: {            input: {$trim: {              input: &quot;$building&quot;,              chars: &quot;abcdefghijklmnopqrstuvwxyz &quot;}},            to: &quot;int&quot;  }          }       }    },    {$sort: {building: 1}}  ]);  { &quot;_id&quot; : 3, &quot;street&quot; : &quot;52nd st&quot;, &quot;building&quot; : 11 }  { &quot;_id&quot; : 2, &quot;street&quot; : &quot;Fulton st&quot;, &quot;building&quot; : 31 }  { &quot;_id&quot; : 1, &quot;street&quot; : &quot;43rd st&quot;, &quot;building&quot; : 229 }</code></pre></li></ul></li><li><p>修改订阅扩展</p><ul><li>3.6 集合层面的修改订阅</li><li>4.0 数据库／集群层面的修改订阅(为修改事件返回clusterTime)</li></ul></li><li><p>后备节点读取: 阻塞 -&gt; 非阻塞性(引入快照机制)</p><ul><li>阻塞性后备节点：<br>  <img src="/2018/08/04/mongo4-block.png" alt="Block"> <img src="/2018/08/04/mongo4-block-rw.png" alt="Block Read and Write"><ul><li>读取：需等待批量数据复制写入操作完成才可</li><li>写入： 需等待数据读取操作完成，否则会导致一致性问题</li><li>形成了一个恶性循环</li></ul></li><li>非阻塞性后备节点:<br>  <img src="/2018/08/04/mongo4-unblock.png" alt="Unblock"> <img src="/2018/08/04/mongo4-unblock-rw.png" alt="UnBlock Read and Write"></li><li>改进优化了性能：<br>  <img src="/2018/08/04/mongo4-delay-cmp.png" alt="Delay Cmp"></li></ul></li></ol><h2 id="header-33">Application</h2><ul><li>Java: <code>mongodb-driver</code><ul><li>Refer <a href="http://www.runoob.com/mongodb/mongodb-java.html" target="_blank" rel="noopener">MongoDB Java</a></li><li>Demo <a href="https://github.com/sixDegree/java-mongo" target="_blank" rel="noopener">java-mongo</a></li></ul></li><li>NodeJS: <code>mongoose</code><ul><li>Refer <a href="https://mongoosejs.com/docs/guide.html" target="_blank" rel="noopener">mongoose</a></li><li>Demo <a href="https://github.com/sixDegree/node-mongo" target="_blank" rel="noopener">node-mongo</a></li></ul></li></ul><h2 id="header-34">Reference</h2><p><a href="http://www.mongoing.com/docs/index.html" target="_blank" rel="noopener">MongoDB 3.4 中文文档</a><br><a href="https://docs.mongodb.com/manual/" target="_blank" rel="noopener">MongoDB 4.0 Manual</a><br><a href="http://www.runoob.com/mongodb/mongodb-tutorial.html" target="_blank" rel="noopener">MongoDB 教程</a><br><a href="https://draveness.me/mongodb-wiredtiger" target="_blank" rel="noopener">『浅入浅出』MongoDB 和 WiredTiger</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;header-1&quot;&gt;Starter&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;文档型数据库。 一条记录就是一个文档（是一个数据结构），由字段和值对组成（与JSON对象类似）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="NoSql" scheme="http://sixdegree.github.io/tags/NoSql/"/>
    
  </entry>
  
  <entry>
    <title>Koa</title>
    <link href="http://sixdegree.github.io/2018/08/03/Koa.html"/>
    <id>http://sixdegree.github.io/2018/08/03/Koa.html</id>
    <published>2018-08-02T16:00:00.000Z</published>
    <updated>2018-10-26T12:33:58.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>module bundler</li><li>loader</li><li>plugin</li></ol><a id="more"></a><h2 id="header-1">Starter</h2><blockquote><p>Koa: next generation web framework for node.js</p></blockquote><p><a href="https://koajs.com" target="_blank" rel="noopener">官网</a></p><p>一个比expess更简洁轻量的nodeJS web框架 （requires node v7.6.0 or higher）<br>如今版本已更新到了koa2，性能更优异，还支持async/await（JS原生支持，本身是generator语法糖，实现了同步写异步，终结异步回调）</p><h3 id="header-2">Hello world</h3><ol><li><p>init:</p><pre><code class="lang-bash"> cd koa-demo npm init npm install koa -s</code></pre></li><li><p>app.js:</p><pre><code class="lang-javascript"> const Koa=require(&quot;koa&quot;); const app=new Koa(); const main=ctx=&gt;{    ctx.response.type=&quot;json&quot;;    ctx.response.body={     success:1,     msg:&quot;Hello world!&quot;    } } app.use(main); // app.listen(...) return an HTTP Server app.listen(3000,()=&gt;{   console.log(&#39;app started at port 3000...&#39;); });</code></pre></li><li><p>start http server:</p><pre><code class="lang-bash"> &gt; node app app started at port 3000...</code></pre></li><li><p>visit to verify:</p><pre><code class="lang-bash"> &gt; curl -i http://localhost:3000   % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                  Dload  Upload   Total   Spent    Left  Speed 100    34  100    34    0     0    435      0 --:--:-- --:--:-- --:--:--   548HTTP/1.1 200 OK Content-Type: application/json; charset=utf-8 Content-Length: 34 Date: Thu, 25 Oct 2018 02:44:39 GMT Connection: keep-alive {&quot;success&quot;:1,&quot;msg&quot;:&quot;Hello world!&quot;}</code></pre></li></ol><h3 id="header-3">API</h3><pre><code class="lang-javascript">const Koa=require(&quot;koa&quot;);const app=new Koa();</code></pre><ul><li><p><code>app.listen(...)</code>: 创建并返回一个http服务器</p><pre><code class="lang-javascript">  const http = require(&#39;http&#39;)  const Koa = require(&#39;koa&#39;)  const app = new Koa()  http.createServer(app.callback()).listen(3000)  // 等同于  const Koa = require(&#39;koa&#39;)  const app = new Koa()  app.listen(3000);</code></pre></li><li><code>app.callback()</code>：返回一个可被<code>http.createServer()</code> 接受的程序实例，可将此实例添加到Connect/Express应用中</li><li><code>app.use(function)</code>： 加载中间件</li><li><code>app.keys=</code>：设置cookie 密钥，eg：<code>app.keys = [&#39;im a newer secret&#39;, &#39;i like turtle&#39;];</code></li><li><p><code>app.context</code>: 是ctx的来源，可使用app.context添加额外的属性到ctx</p><pre><code class="lang-javascript">  // 从ctx添加一个数据库引用  add.context.db = db()  app.use(async (ctx)=&gt;{  console.log(ctx.db)  })</code></pre></li><li><code>app.on(eventName,function)</code>: 添加事件侦听器<pre><code class="lang-javascript">  // 默认情况下，所有错误输出到 stderr（ 若app.silent=true 或 err.status=404 或 err.expose=true，默认错误处理程序不会输出错误）  app.on(&#39;error&#39;, (err, ctx) =&gt;    log.error(&#39;server error&#39;, err, ctx)  );</code></pre></li><li><code>app.env</code>: 默认是 <code>NODE_ENV</code> 或 <code>development</code></li><li><code>app.proxy</code>: 设置为true时，porxy头部将被信任</li><li><code>app.subdomainOffset</code>: 设置<code>.subdomains</code>的偏移量</li></ul><h2 id="header-4">Middleware</h2><p>Koa 应用程序是一个包含一组中间件函数的对象，按照类似堆栈的方式组织和执行。</p><p>Middleware 实际就是一个函数，使用<code>use(function)</code>加载middleware，使用<code>next</code>进入下一个middleware。</p><h3 id="header-5">Express VS Koa</h3><p>Express Middleware： 顺序执行，从第一个中间件执行到最后一个中间件，发出响应<br><img src="/2018/08/03/express-middleware.jpg" alt="Express Middleware"></p><p>Koa Middleware： 洋葱模型，一层层的打开，再一层层的闭合，直到第一个中间件执行结束才发出响应<br><img src="/2018/08/03/koa-middleware.jpg" alt="Koa Middleware"></p><p>Express: <code>A-&gt;B-&gt;C-&gt;...-&gt;N</code></p><pre><code class="lang-javascript">// middleware Aapp.use(function(request,response,next){    //...    next();        // move to next middleware in the stack});// middle B// middle C// ...// middle Napp.use(function(request,response,next){    //...    response.send(&quot;done!&quot;);            // done!});</code></pre><p>Koa：<code>A-&gt;B-&gt;C-&gt;...-&gt;N-&gt;...-&gt;C-&gt;B-&gt;A</code></p><pre><code class="lang-javascript">// middleware Aapp.use((ctx,next)=&gt;{    console.log(&quot;A begin&quot;);    next();    console.log(&quot;A end&quot;);            // done!});// middle B// middle C// ...// middle Napp.use((ctx,next)=&gt;{    console.log(&quot;N begin&quot;);    next();    console.log(&quot;N end&quot;);})</code></pre><h3 id="header-6">异步中间件</h3><p>异步操作（比如读取数据库，文件等）</p><p>处理方式：</p><ol><li><p><code>callback</code>：回调函数（Express使用这种方式）；缺点：层层回调，若逻辑很复杂，可能会陷入回调地狱</p><pre><code class="lang-javascript"> fs.readFile(&#39;a.txt&#39;,function(err,data){     // do something     fs.readFile(&#39;b.txt&#39;,function(err,data){         //...     });     // do something });</code></pre></li><li><p><code>promise</code>: 用来传递异步操作流的对象；缺点：代码冗余，只是回调函数的改进</p><pre><code class="lang-javascript"> // 创造一个Promise实例 const promise = new Promise(function(resolve, reject) {   // ... some code   if (/* 异步操作成功 */){     resolve(value);   } else {     reject(error);   } }); // 后续处理 promise   .then(function(data) { //cb     // success   })   .then(function(data) { //cb     // success   })   .catch(function(err) {     // error   })   .finally(function(){     // no args,always exec   });</code></pre></li><li><p><code>generator/yield</code>: es6引入，以同步的方式来写异步编程；异步操作需要暂停的地方，都用yield语句注明；</p><pre><code class="lang-javascript"> function* gen(x){   try {     var y = yield x + 2;   } catch (e){     console.log(e);   }   return y; } var g = gen(1); //next:分阶段执行Generator函数 g.next()             // { value: 3, done: false } g.next(2)             // { value: 2, done: true } g.throw(&#39;出错了&#39;);    // 出错了</code></pre><pre><code class="lang-javascript"> // 引入co模块，用于 Generator 函数的自动执行，返回一个Promise对象 var co = require(&#39;co&#39;); var gen = function* () {   var f1 = yield readFile(&#39;/etc/fstab&#39;);   var f2 = yield readFile(&#39;/etc/shells&#39;);   console.log(f1.toString());   console.log(f2.toString()); }; co(gen).then(function (){   console.log(&#39;Generator 函数执行完成&#39;); });</code></pre></li><li><p><code>async/await</code>: es7引入，generator/yield的语法糖，语义更清晰，且javascript原生支持；注：await命令只能用在async函数之中，如果用在普通函数，就会报错</p><pre><code class="lang-javascript"> async function main() {   try {     const val1 = await firstStep();     const val2 = await secondStep(val1);     const val3 = await thirdStep(val1, val2);     console.log(&#39;Final: &#39;, val3);   }   catch (err) {     console.error(err);   } } main(); main() .then(v =&gt; console.log(v)) .catch(e =&gt; console.log(e)) ;</code></pre></li><li><p><code>generator/yield</code> vs. <code>async/await</code></p><table class="table"><thead><tr><th></th><th style="text-align:left">generator/yield</th><th style="text-align:left">async/await</th></tr></thead><tbody><tr><td>1</td><td style="text-align:left">执行必须靠执行器（eg：co模块–用于 Generator 函数的自动执行）</td><td style="text-align:left">async函数自带执行器</td></tr><tr><td>2</td><td style="text-align:left">co模块约定yield命令后面只能是 Thunk函数(自动执行 Generator 函数的一种方法)或 Promise 对象</td><td style="text-align:left">await后面可以是 Promise 对象和原始类型的值（这时等同于同步操作）</td></tr><tr><td>3</td><td style="text-align:left">Generator 函数的返回值是 Iterator 对象</td><td style="text-align:left">async函数返回值是 Promise对象（可以用then方法指定下一步的操作）</td></tr></tbody></table><ul><li>koa@1.x: 使用generator/yield语法<pre><code class="lang-javascript">  app.use(function *(next){      this.response.type=&#39;html&#39;;      this.response.body=yield fs.readFile(&#39;./demos/template.html&#39;, &#39;utf8&#39;);  });</code></pre></li><li>koa@2.x: 使用async/await语法<pre><code class="lang-javascript">  app.use((ctx,next)=&gt;{      ctx.response.type = &#39;html&#39;;      ctx.response.body = await fs.readFile(&#39;./demos/template.html&#39;, &#39;utf8&#39;);  });</code></pre></li></ul></li></ol><h2 id="header-7">Context</h2><p>Koa Context对象： 表示一次对话的上下文，每个请求会创建属于此请求的context对象，并在koa中间件中传递</p><ul><li>封装了node的request和response对象，通过加工这个对象，就可以控制返回给用户的内容。</li><li>对 Koa 内部一些常用的属性或者方法做了代理操作，使得我们可以直接通过这个context对象获取（eg：ctx.url与ctx.request.url等同）</li><li>约定了一个中间件的存储空间state，可以通过context对象的state存储一些数据，比如用户数据，版本信息等</li><li>注：<ul><li>koa@1.x: 使用this引用Context对象</li><li>koa@2.x: 使用ctx来访问Context对象</li></ul></li></ul><p>示例：</p><pre><code class="lang-javascript">const Koa = require(&#39;koa&#39;);const app = new Koa();app.use((ctx,next)=&gt;{    console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);    next();})app.use((ctx,next)=&gt;{    ctx.response.body = { data: &#39;Hello World&#39; };})app.use(async (ctx,next)=&gt;{    next();    ctx.response.type=&quot;json&quot;;});app.listen(3000);</code></pre><p><strong> API : </strong></p><ul><li>ctx.req: Node 的 request 对象</li><li>ctx.res: Node 的 response 对象，注：Koa 不支持直接调用底层res进行响应处理，请避免使用以下 node 属性：res.statusCode(),res.writeHead(),res.write(),res.end()</li><li>ctx.request: Koa 的 request 对象</li><li>ctx.response: Koa 的 response 对象</li><li>ctx.app: 应用实例引用</li><li>ctx.cookies.get(name, [options]): 获得 cookie 中名为 name 的值，options：<ul><li>signed: 所请求的cookie应该被签名</li></ul></li><li>ctx.cookies.set(name, value, [options]): 设置 cookie 中名为 name 的值，options：<ul><li>signed: 是否要做签名</li><li>expires: cookie 有效期时间</li><li>path: cookie 的路径，默认为 <code>/</code></li><li>domain: cookie 的域</li><li>secure: false 表示 cookie 通过 HTTP 协议发送，true 表示 cookie 通过 HTTPS 发送。</li><li>httpOnly: true 表示 cookie 只能通过 HTTP 协议发送</li></ul></li><li>ctx.throw(msg, [status]): 抛出包含 <code>.status</code> 属性的错误，默认为 500<pre><code class="lang-javascript">  ctx.throw(&#39;name required&#39;, 400)   //等价于：  var err = new Error(&#39;name required&#39;);  err.status = 400;  throw err;</code></pre></li><li><p>ctx.respond: 设为false，则表示绕过 Koa 的内置 response 处理，直接操作原生 res 对象</p></li><li><p><strong> 与Request等价的API: </strong></p><ul><li>ctx.header</li><li>ctx.method</li><li>ctx.method=</li><li>ctx.url</li><li>ctx.url=</li><li>ctx.originalUrl</li><li>ctx.path</li><li>ctx.path=</li><li>ctx.query</li><li>ctx.query=</li><li>ctx.querystring</li><li>ctx.querystring=</li><li>ctx.host</li><li>ctx.hostname</li><li>ctx.fresh</li><li>ctx.stale</li><li>ctx.socket</li><li>ctx.protocol</li><li>ctx.secure</li><li>ctx.ip</li><li>ctx.ips</li><li>ctx.subdomains</li><li>ctx.is()</li><li>ctx.accepts()</li><li>ctx.acceptsEncodings()</li><li>ctx.acceptsCharsets()</li><li>ctx.acceptsLanguages()</li><li>ctx.get()</li></ul></li><li><p><strong> Response等价的API: </strong></p><ul><li>ctx.body</li><li>ctx.body=</li><li>ctx.status</li><li>ctx.status=</li><li>ctx.length=</li><li>ctx.length</li><li>ctx.type=</li><li>ctx.type</li><li>ctx.headerSent</li><li>ctx.redirect()</li><li>ctx.attachment()</li><li>ctx.set()</li><li>ctx.remove()</li><li>ctx.lastModified=</li><li>ctx.etag=</li></ul></li></ul><h2 id="header-8">Exception</h2><h3 id="header-9">抛出错误</h3><pre><code class="lang-javascript">const main = ctx =&gt; {  ctx.response.status = 404;  ctx.response.body = &#39;Page Not Found&#39;;};</code></pre><pre><code class="lang-javascript">const main = ctx =&gt; {  ctx.throw(&#39;Page Not Found&#39;,404); // ctx.throw(404)};</code></pre><h3 id="header-10">监听错误</h3><pre><code class="lang-javascript">app.on(&#39;error&#39;,function(err){    console.log(&#39;logging error &#39;, err.message);    console.log(err);});</code></pre><h3 id="header-11">处理错误</h3><p>在最外层添加一个中间件，使用<code>try...catch</code>捕获错误</p><pre><code class="lang-javascript">app.use(async (ctx, next) =&gt; {  try {    await next();  } catch (err) {    ctx.response.status = err.statusCode || err.status || 500;    ctx.response.body = {      message: err.message    };    ctx.app.emit(&#39;error&#39;, err, ctx);    // 调用ctx.app.emit()，手动释放error事件，才能让监听函数生效  }});app.use(ctx =&gt; {  ctx.throw(500);});</code></pre><h2 id="header-12">常用第三方插件</h2><h3 id="header-13">static</h3><pre><code class="lang-javascript">const path=require(&#39;path&#39;);const static = require(&#39;koa-static&#39;);app.use(static(path.resolve(__dirname, &quot;./public&quot;)));</code></pre><h3 id="header-14">body</h3><p>koa-body模块可以用来从请求的数据体里面提取键值对（方便处理表单，上传文件：ctx.request.files）</p><pre><code class="lang-javascript">const KoaBody = require(&#39;koa-body&#39;);app.use(KoaBody());    app.use(async(ctx,next)=&gt;{    console.log(&quot;request body:&quot;);    console.log(ctx.request.body);    if (!body.name)         ctx.throw(400, &#39;.name required&#39;);    await next();});</code></pre><h3 id="header-15">Router</h3><p>app.js:</p><pre><code class="lang-javascript">const Router=require(&quot;koa-router&quot;);const router=new Router();var catalogueController=require(&quot;./controller/catalogueController&quot;);router.get(&#39;/catalogues&#39;,catalogueController.list);router.get(&#39;/catalogues/:id&#39;,catalogueController.get);router.put(&#39;/catalogues/:id&#39;,catalogueController.update);router.post(&#39;/catalogues&#39;,catalogueController.create);router.delete(&#39;/catalogues/:id&#39;,catalogueController.delete);app.use(router.routes());app.use(router.allowedMethods());</code></pre><p>./controller/catalogueController.js:</p><pre><code class="lang-javascript">module.exports={  list:async (ctx,next)=&gt;{      ...  },  get:async (ctx,next)=&gt;{    let id=ctx.params.id;      ...  },  update:async (ctx,next)=&gt;{    let id=ctx.params.id;    let catalogue=ctx.request.body;    ...  }  ...}</code></pre><h3 id="header-16">Session</h3><pre><code class="lang-javascript">const session=require(&#39;koa-session2&#39;);app.keys=[&#39;a secret key&#39;];    // if set signed:true,need setting the .keys.app.use(session({    key:&quot;SESSIONID&quot;,    signed:true,        // SESSIONID.sig,need to set app.keys,作用：给cookie加上一个sha256的签名,防止cookie被篡改    maxAge:86400000,    // cookie expire after maxAge ms: 1 day = 24h*60m*60s*1000=86400,000ms}));const logger=async (ctx,next)=&gt;{  let path=ctx.request.path;  console.log(&quot;log:&quot;+ctx.request.method+&quot; &quot;+path+&quot;,&quot;+ctx.request.url);  if(ctx.session){        console.log(&quot;loginUser&quot;,ctx.session.loginUser);      console.log(&quot;cookie&quot;,ctx.request.header.cookie);    //ctx.cookies    }  await next();}app.use(logger);app.use(async(ctx,next)=&gt;{    // get: ctx.session.xxx    // set: ctx.session.Xxx=xxx    // remove: delete ctx.session.Xxx    ...})</code></pre><p>扩展：使用MongoDB/Redis等存储Session (具体参看下节)</p><h2 id="header-17">示例</h2><h3 id="header-18">Koa</h3><pre><code class="lang-javascript">const Koa=require(&quot;koa&quot;);const app=new Koa();const errorHandler=async(ctx,next)=&gt;{    try{        await next();    }catch(e){        console.log(&quot;catch exception&quot;);        ctx.response.type=&quot;json&quot;;        ctx.response.body={            success:0,            status: e.statusCode || e.status || 500,            message: e.message        }    }}const prefixHandler=async(ctx,next)=&gt;{    console.log(&quot;prefix Handler...&quot;+ctx.request.path);    if(ctx.request.path==&#39;/error&#39;)        ctx.throw(&quot;go to error!&quot;);    await next();}const postHandler=async(ctx,next)=&gt;{    await next();    console.log(&quot;post Handler...&quot;+ctx.request.path);    ctx.response.type=&quot;json&quot;;    ctx.set(&quot;micro-test&quot;,true);        // set header}const fs = require(&#39;fs&#39;);const main=async(ctx,next)=&gt;{    console.log(&quot;main&quot;)    let data = await fs.readFileSync(&#39;./public/1.txt&#39;,&#39;utf8&#39;);    console.log(&quot;readed:&quot;+data);    ctx.response.body={        success:1,        data:data    }}app.use(errorHandler);app.use(prefixHandler);app.use(postHandler);app.use(main);app.listen(3000,()=&gt;{  console.log(&#39;app started at port 3000...&#39;);});</code></pre><ol><li><p>测试成功情况：</p><pre><code class="lang-bash"> &gt; curl -i http://localhost:3000/1 HTTP/1.1 200 OK Content-Type: application/json; charset=utf-8 micro-test: true Content-Length: 35 Date: Sun, 09 Sep 2018 16:07:48 GMT Connection: keep-alive {&quot;success&quot;:1,&quot;data&quot;:&quot;Static File!&quot;} # server console: prefix Handler.../1 main readed:Static File! post Handler.../1</code></pre></li><li><p>测试异常情况：</p><pre><code class="lang-bash"> &gt; curl -i http://localhost:3000/error HTTP/1.1 200 OK Content-Type: application/json; charset=utf-8 Content-Length: 51 Date: Sun, 09 Sep 2018 16:09:19 GMT Connection: keep-alive {&quot;success&quot;:0,&quot;status&quot;:500,&quot;message&quot;:&quot;go to error!&quot;} # server console: prefix Handler.../error catch exception */</code></pre></li></ol><h3 id="header-19">async/await</h3><ol><li><p>计时器函数执行顺序：</p><pre><code class="lang-javascript"> function sleep(time){     console.log(&quot;sleep func start&quot;)                        // 1     setTimeout(()=&gt;{         console.log(&quot;sleep wakeup after &quot;+time+&quot; !&quot;)    // 3 [ execute after sleep `${time} ms` ]     },time);     console.log(&quot;sleep func end&quot;)                        // 2 }</code></pre></li><li><p>Promise函数（+timeout函数）执行顺序：</p><pre><code class="lang-javascript"> function promiseFunc(timeout){     console.log(&quot;a1. build promise instance&quot;);            // 1     let inst=new Promise((resolve,reject)=&gt;{                             console.log(&quot;b1. start promise instance func&quot;)    // 2         setTimeout(()=&gt;{                                     console.log(&quot;promise wakeup&quot;)                         resolve(&quot;promise resolved after &quot;+timeout);    // 5 &lt;pending&gt; -&gt; &lt;resolved&gt;                 },timeout);             console.log(&quot;b2. end promise instance func&quot;)    // 3     });     console.log(&quot;a2. return promise instance&quot;);                     return inst;                                        // 4 }</code></pre></li><li><p>async函数使用await和不使用await：</p><pre><code class="lang-javascript"> async function asyncFunc(timeout){     console.log(&quot;async 1-&gt;2&quot;)     let msg=await promiseFunc(timeout);    // 1      console.log(&quot;await result:&quot;+msg);    // 2 [ 1-&gt;2 `blocked ${timeout} ms`, get resolved data ]     console.log(&quot;async 3-&gt;4&quot;)     sleep(timeout-2000);                // 3      return msg;                            // 4  [ 3-&gt;4 no block,return a promise instance ]  }</code></pre></li><li><p>async函数调用async函数：</p><pre><code class="lang-javascript"> async function test1(timeout){     console.log(&quot;test timeout:&quot;+timeout);     console.log(&quot;1-&gt;2&quot;)     let result=asyncFunc(timeout);        // 1     console.log(result);                // 2 [ 1 -&gt; 2 no block,get a promise instance]     console.log(&quot;3-&gt;4&quot;)     let msg=await result;                // 3      console.log(msg);                    // 4 [ 3 -&gt; 4 blocked `${timeout} ms`, get resolved data ] };</code></pre></li><li><p>async/await+Promise 多条异步：顺序trigger，reject同throw error）</p><pre><code class="lang-javascript"> function promiseFunc2(code){     console.log(&quot;a1. build promise instance&quot;);            // 1     let inst=new Promise((resolve,reject)=&gt;{                             console.log(&quot;b1. start promise instance func&quot;)             if(code==1)                                         resolve(code+&quot; resolve!&quot;);            // 2 &lt;pending&gt; -&gt; &lt;fulfilled&gt;             else if(code==0)             reject(code+&quot; reject!&quot;);            // 2 &lt;peinding&gt; -&gt; &lt;rejected&gt;          else if(code==-1)             throw new Error(code+&quot; error!&quot;);    // 2 exception         else{                                    // 2 reject(e) == throw new Error(xxx);             try {                 throw new Error(`${code} error! [same with code -1 error!]`);             } catch(e) {                 reject(e);             }         }         console.log(&quot;b2. end promise instance func&quot;)     });     console.log(&quot;a2. return promise instance&quot;);            // 3                     return inst;         } async function test2(code){     console.log(&quot;test code:&quot;+code);     try{         let msg=await promiseFunc2(code);         console.log(&quot;get return: &quot;+msg);     }catch(e){         console.log(&quot;get error: &quot;+(e.message||e));     } } //exec test: test2(1); test2(0); test2(-1); test2(-2); /* test code:1 a1. build promise instance b1. start promise instance func b2. end promise instance func a2. return promise instance test code:0 a1. build promise instance b1. start promise instance func b2. end promise instance func a2. return promise instance test code:-1 a1. build promise instance b1. start promise instance func a2. return promise instance test code:-2 a1. build promise instance b1. start promise instance func b2. end promise instance func a2. return promise instance get return: 1 resolve! get error: 0 reject! get error: -1 error! get error: -2 error! [same with code -1 error!] */</code></pre></li></ol><h3 id="header-20">Mongoose</h3><ol><li><p>MongoDB Data Model: catalogues(name,description,meta:createTime,updateTime,updator)</p><pre><code class="lang-bash"> &gt; db.catalogues.insert([ {name:&quot;Spring&quot;,description:&quot;spring framework&quot;,meta:{createTime:new Date(),updateTime:new Date(),updator:&quot;Tom&quot;}}, {name:&quot;ReactJS&quot;,description:&quot;reactJS front framework&quot;,meta:{createTime:new Date(),updateTime:new Date(),updator:&quot;Tom&quot;}}, {name:&quot;NoSql&quot;,description:&quot;not only sql databases&quot;,meta:{createTime:new Date(),updateTime:new Date(),updator:&quot;Tom&quot;}} ]);</code></pre></li><li><p>mongoTest.js</p><pre><code class="lang-javascript"> const mongoose =require(&quot;mongoose&quot;); mongoose.connect(&#39;mongodb://cj:123456@localhost:27017/demo?authSource=admin&#39;,{ useNewUrlParser: true}); mongoose.set(&#39;useCreateIndex&#39;,true); let catalogueSchema=mongoose.Schema({     name:{type:String,required:true,unique:true},     description:{type:String},     meta:{       createTime:{type:Date,default:Date.now},       updateTime:{type:Date,default:Date.now},       updator:{type:String}     } },{versionKey: false}); // Pre and post save() hooks are not executed on update(), findOneAndUpdate() catalogueSchema.pre(&#39;save&#39;,function(next){   console.log(&#39;pre save:&#39;+this.isNew);   if(this.isNew)     this.meta.createTime=this.meta.updateTime=Date.now();   else     this.meta.updateTime=Date.now();   next(); }); let catalogueDao=mongoose.model(&#39;catalogues&#39;,catalogueSchema); /* Operation */ async function list(){     let catalogueList= await catalogueDao.find({},{meta:0});     return catalogueList; }; async function get(id){     let catalogue=await catalogueDao.findOne({_id:id});     return catalogue; } async function create(catalogue){     let result=await catalogueDao.create(catalogue);     console.log(&quot;create:&quot;);     console.log(result);     return result; } async function udpateCatalogue(id,catalogue){   let result=await catalogueDao.updateOne({_id:id}     ,{$set:{name:catalogue.name,description:catalogue.description       ,&quot;meta.updateTime&quot;:new Date(),&quot;meta.updator&quot;:catalogue.updator}},{new:true});     return result; } async function deleteCatalogue(id){     let result=await catalogueDao.deleteOne({_id:id});     return result; } // test async function test(){   console.log(&quot;start test&quot;);   let catalogue={name:&quot;Docker&quot;,description:&quot;Build, Ship, and Run Any App, Anywhere&quot;};   let newCatalogue= await create(catalogue);   let id=newCatalogue._id;   console.log(&quot;list:&quot;)   let catalogueList=await list();   console.log(catalogueList);   console.log(`update ${id}:`);   let catalogueChange={name:&quot;Docker Feature&quot;,     description:&quot;Container:Build, Ship, and Run Any App, Anywhere&quot;,     updator:&quot;anomy&quot;   };   let result=await udpateCatalogue(id,catalogueChange);   console.log(result);   console.log(`get ${id}:`)   result=await get(id);   console.log(result);   console.log(`delete ${id}:`)   result=await deleteCatalogue(newCatalogue._id);   console.log(result);   console.log(&quot;end test&quot;);   mongoose.disconnect();   console.log(&quot;finish!&quot;); } // clear same records in mongodb first // db.catalogues.remove({name:{$regex:&quot;Docker*&quot;}}) test();</code></pre></li></ol><h3 id="header-21">koa-session2+mongo</h3><p>store session on mongodb</p><ol><li><p>app.js</p><pre><code class="lang-javascript"> const session=require(&#39;koa-session2&#39;); const MongoStore=require(&#39;./util/mongoStore&#39;); const mongoose =require(&quot;mongoose&quot;); mongoose.connect(&#39;mongodb://cj:123456@localhost:27017/demo?authSource=admin&#39;   ,{ useNewUrlParser: true}); mongoose.set(&#39;useCreateIndex&#39;,true); app.keys=[&#39;a secret key&#39;];    // if set signed:true,need setting the .keys. app.use(session({     key:&quot;SESSIONID&quot;,     //signed:true,        // SESSIONID.sig,need to set .keys,作用：给cookie加上一个sha256的签名,防止cookie被篡改     maxAge:86400000,    // cookie expire after maxAge ms: 1 day = 24h*60m*60s*1000=86400,000ms     store: new MongoStore({         collection:&quot;sessions&quot;,         connection:mongoose,         expireAfterSeconds:30    // mongo TTL expireAfterSeconds ( unit:s )     }) })); ... app.use(async(ctx,next)=&gt;{     /*         login: do get/set session             get session: ctx.session.Xxx , eg: ctx.session.loginUser             set session: ctx.session.Xxx=xxx , eg: ctx.session.loginUser={username:result.username,roles:result.roles};         logout: do remove session             delete ctx.session.Xxx , eg: delete ctx.session.loginUser;     */      ... })</code></pre></li><li><p>mongoStore.js</p><pre><code class="lang-javascript"> const mongoose = require(&#39;mongoose&#39;); const { Store } = require(&quot;koa-session2&quot;); class MongoStore extends Store {   constructor({connection=mongoose,collection=&#39;sessions&#39;,expireAfterSeconds=86400000}={}){     super();     let storeSchema=new connection.Schema({       _id:String,       data:Object,       updatedAt: {         default: new Date(),         expires: expireAfterSeconds, // 1 day: 86400 s = 60s*60m*24h =&gt; expireAfterSeconds         type: Date       }     })     this.modelDao=connection.model(collection,storeSchema);   }   async get(sid,ctx){     console.log(&quot;get mongo session:&quot;+sid);     let result= await this.modelDao.findOne({_id:sid});     console.log(result);     return result?result.data:null;   }   async set(session, { sid =  this.getID(24), maxAge = 86400000 } = {}, ctx) {     console.log(&quot;set mongo session:&quot;+sid+&quot;,cookie maxAge:&quot;+maxAge);       try {           let record={_id:sid,data:session,updatedAt:new Date()};           console.log(record);           await this.modelDao.updateOne({_id:sid}, record, { upsert: true, safe: true });       } catch (e) {         console.log(&quot;set mongo session fail:&quot;);         console.log(e);       }       return sid;   }   async destroy(sid){     console.log(&quot;destroy mongo session:&quot;+sid);     return await this.modelDao.deleteOne({_id:sid});   } } module.exports = MongoStore; session stored in mongodb:</code></pre></li><li><p>Session Stored on MongoDB:</p><pre><code class="lang-bash"> &gt; db.sessions.find().pretty() {     &quot;_id&quot; : &quot;53094f8db3e399e17616a4d910676c58b6cde92f3b9435be&quot;,     &quot;__v&quot; : 0,     &quot;data&quot; : {         &quot;loginUser&quot; : {             &quot;username&quot; : &quot;admin&quot;,             &quot;roles&quot; : [                 &quot;admin&quot;             ]         }     },     &quot;updatedAt&quot; : ISODate(&quot;2018-09-09T09:40:40.277Z&quot;) }</code></pre><pre><code class="lang-bash"> &gt; db.sessions.getIndexes() [   {     &quot;v&quot; : 2,     &quot;key&quot; : {       &quot;_id&quot; : 1     },     &quot;name&quot; : &quot;_id_&quot;,     &quot;ns&quot; : &quot;demo.sessions&quot;   },   {     &quot;v&quot; : 2,     &quot;key&quot; : {       &quot;updatedAt&quot; : 1     },     &quot;name&quot; : &quot;updatedAt_1&quot;,     &quot;ns&quot; : &quot;demo.sessions&quot;,     &quot;expireAfterSeconds&quot; : 30,     &quot;background&quot; : true   } ]</code></pre></li></ol><p>Verify:</p><ol><li><p>login</p><pre><code class="lang-bash"> &gt; curl -i -c cookie.txt -d &quot;username=admin&amp;password=123&quot; http://localhost:3000/login HTTP/1.1 200 OK Content-Type: application/json; charset=utf-8 Set-Cookie: SESSIONID=8cbe57db55bb6c944df99ec9a10481a431c41e5ba1400a4a; path=/; expires=Wed, 12 Sep 2018 16:29:57 GMT; httponly Set-Cookie: SESSIONID.sig=TsESPv34Ny1rOA9jimTrlybpHDE; path=/; expires=Wed, 12 Sep 2018 16:29:57 GMT; httponly Content-Length: 59 Date: Tue, 11 Sep 2018 16:29:57 GMT Connection: keep-alive {&quot;success&quot;:1,&quot;data&quot;:{&quot;username&quot;:&quot;admin&quot;,&quot;roles&quot;:[&quot;admin&quot;]}}</code></pre></li><li><p>logout</p><pre><code class="lang-bash"> &gt; curl -i -b cookie.txt -X POST http://localhost:3000/logout HTTP/1.1 200 OK Content-Type: application/json; charset=utf-8 Set-Cookie: SESSIONID=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT; httponly Content-Length: 13 Date: Tue, 11 Sep 2018 16:00:55 GMT Connection: keep-alive {&quot;success&quot;:1}</code></pre></li></ol><h3 id="header-22">Privilege Filter</h3><ol><li><p>MongoDB data Model: privileges(path,method,roles)</p><pre><code class="lang-bash"> &gt; db.privileges.insert([ {path:&quot;/catalogues&quot;,method:&quot;GET&quot;,roles:[]}, {path:&quot;/catalogues/:id&quot;,method:&quot;GET&quot;}, {path:&quot;/catalogues/:id&quot;,method:&quot;PUT&quot;,roles:[&quot;admin&quot;]}, {path:&quot;/catalogues/:id&quot;,method:&quot;DELETE&quot;,roles:[&quot;admin&quot;]}, {path:&quot;/catalogues&quot;,method:&quot;POST&quot;,roles:[&quot;admin&quot;]}, {path:&quot;/articles&quot;,method:&quot;GET&quot;}, {path:&quot;/articles/:id&quot;,method:&quot;GET&quot;}, {path:&quot;/articles/:id&quot;,method:&quot;PUT&quot;,roles:[&quot;user&quot;]}, {path:&quot;/articles/:id&quot;,method:&quot;DELETE&quot;,roles:[&quot;user&quot;,&quot;admin&quot;]}, {path:&quot;/articles&quot;,method:&quot;POST&quot;,roles:[&quot;user&quot;]}, {path:&quot;/login&quot;,method:&quot;POST&quot;}, {path:&quot;/register&quot;,method:&quot;POST&quot;}, {path:&quot;/logout&quot;,method:&quot;POST&quot;}, ]);</code></pre></li><li><p>app.js:</p><pre><code class="lang-javascript"> const PrivilegeStore=require(&#39;./util/PrivilegeStore&#39;); let privilegeStore=new PrivilegeStore(); const privilegeFilter=async (ctx,next)=&gt;{     /*     Note:         1. ctx.request.path: /catalogues/1 ; ctx.request.url: /catalogues/1?x=1         2. roles: get from ctx.session.loginUser,eg: {username:&quot;Tom&quot;,roles:[&quot;user&quot;]}         3. url-pattern:             let pattern=new UrlPattern(&#39;/catalogues/:id&#39;);             console.log(pattern.match(&#39;/catalogues&#39;));            //null             console.log(pattern.match(&#39;/catalogues/1&#39;));        //{id:&#39;1&#39;}             console.log(pattern.match(&#39;/catalogues/1/2&#39;));        //null             console.log(pattern.match(&#39;/catalogues/1?x=3&#39;));    //null             console.log(pattern.match(&#39;catalogues&#39;));            //null     */     let reqItem={path:ctx.request.path,method:ctx.request.method         ,roles:(ctx.session &amp;&amp; ctx.session.loginUser)?ctx.session.loginUser.roles||[]:[]};     let privileges = await privilegeStore.privileges;     let matched = privileges.find((item)=&gt;{         return privilegeStore.verify(item,reqItem);     });     console.log(&quot;pass priv:&quot;+matched);     if(matched)       await next();     else       ctx.throw(401); } app.use(privilegeFilter);</code></pre></li><li><p>PrivilegeStore.js:</p><pre><code class="lang-javascript"> const mongoose = require(&#39;mongoose&#39;); const UrlPattern=require(&#39;url-pattern&#39;); class PrivilegeStore{   constructor({connection=mongoose,collection=&#39;privileges&#39;}={}){     let storeSchema=this.initSchema();     this.privilegeDao=connection.model(collection,storeSchema);     this.privileges=this.loadPrivileges();   }   initSchema(){     let privilegeSchema=mongoose.Schema({         path:{type:String,required:true},         method:{type:String,required:true},         roles:{type:Array},         meta:{           createTime:{type:Date,default:Date.now},           updateTime:{type:Date,default:Date.now},           updator:{type:String}         }     });     privilegeSchema.pre(&#39;save&#39;,function(next){       if(this.isNew)         this.meta.createTime=this.meta.updateTime=Date.now();       else         this.meta.updateTime=Date.now();       next();     });     return privilegeSchema;   }   async loadPrivileges(){     let result=await this.privilegeDao.find({},{_id:0,meta:0});     result.map((item,index,arr)=&gt;{        item.pattern=new UrlPattern(item.path);        return item;     });     console.log(result);     return result;   }   async refresh(){     this.privileges=this.loadPrivileges();   }   verify(item,reqItem){     // console.log(item);     if(item.method!=reqItem.method)       return false;     let pattern = item.pattern;     if(!pattern){       console.log(&quot;init pattern&quot;);       pattern=new UrlPattern(item.path);     }     let match=pattern.match(reqItem.path);     if(match==null){       // console.log(&quot;path not match&quot;);       return false;     }     if(!item.roles || item.roles.length==0){       console.log(&quot;guest pass&quot;);       return true;     }     if(item.roles.find((n)=&gt;reqItem.roles.includes(n))){       console.log(&quot;auth pass&quot;);       return true;     }     return false;    } } module.exports = PrivilegeStore;</code></pre></li></ol><h2 id="header-23">Reference</h2><p><a href="https://github.com/sixDegree/node-mongo" target="_blank" rel="noopener">my demo</a></p><p>Blog:</p><ul><li><a href="http://www.ruanyifeng.com/blog/2017/08/koa.html" target="_blank" rel="noopener">ruanyf/koa</a> | <a href="https://github.com/ruanyf/koa-demos.git" target="_blank" rel="noopener">ruanyf/koa demo</a></li><li><a href="https://www.jianshu.com/p/f59594b90500" target="_blank" rel="noopener">如何使用koa2+es6/7打造高质量Restful API</a></li><li><a href="https://www.jianshu.com/p/d3afa36aa17a" target="_blank" rel="noopener">koa2入门笔记</a></li><li><a href="https://www.jianshu.com/p/6b816c609669" target="_blank" rel="noopener">koa2从起步到填坑</a></li><li><a href="https://www.jianshu.com/p/f8cfb82b4dad" target="_blank" rel="noopener">koa2 async和await 实战详解</a></li><li><a href="https://segmentfault.com/a/1190000013039187" target="_blank" rel="noopener">koa-session学习笔记</a></li><li><a href="https://segmentfault.com/a/1190000012412299" target="_blank" rel="noopener">从koa-session中间件源码学习cookie与session</a></li><li><a href="https://mongoosejs.com/docs/guide.html" target="_blank" rel="noopener">Mongoose</a></li><li><a href="https://www.jianshu.com/p/554a5bf67b31" target="_blank" rel="noopener">mongoose使用之查询篇</a></li><li><a href="https://www.jianshu.com/p/265ff15bca7a" target="_blank" rel="noopener">Mongoose初使用总结</a></li><li><a href="https://www.jianshu.com/p/dcdd116600fe" target="_blank" rel="noopener">koa2+mongodb搭建简易nodejs后台接口服务</a></li></ul><p>Useful npm:</p><ul><li><a href="https://www.npmjs.com/package/koa-session2" target="_blank" rel="noopener">koa session2</a></li><li><a href="https://www.npmjs.com/package/route-parser" target="_blank" rel="noopener">route-parser</a></li><li><a href="https://www.npmjs.com/package/path-parser" target="_blank" rel="noopener">path-parser</a></li><li><a href="https://www.npmjs.com/package/url-pattern" target="_blank" rel="noopener">url-pattern</a></li></ul>]]></content>
    
    <summary type="html">
    
      a Web framework for node.js (simpler then express)
    
    </summary>
    
    
      <category term="Node" scheme="http://sixdegree.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>Babel &amp; Browserify</title>
    <link href="http://sixdegree.github.io/2018/08/02/Babel-Browserify.html"/>
    <id>http://sixdegree.github.io/2018/08/02/Babel-Browserify.html</id>
    <published>2018-08-01T16:00:00.000Z</published>
    <updated>2018-10-26T12:33:58.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Babel</li><li>Browserify</li></ol><a id="more"></a><h2 id="header-1">Babel 转码器</h2><p><a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a></p><blockquote><p>Babel is a JavaScript compiler ( Put in next-gen JavaScript, Get browser-compatible JavaScript out)</p></blockquote><p>一种转码器，将ES6代码转换为ES5代码，从而在现有环境执行</p><p>eg：用 ES6 编写程序，特性还没有得到广泛支持，用Babel将其转换为ES5标准的代码，就能在现有的JavaScript环境执行了</p><p>转码前</p><pre><code class="lang-javascript">input.map(item =&gt; item + 1);</code></pre><p>转码后</p><pre><code class="lang-javascript">input.map(function (item) {  return item + 1;});</code></pre><h3 id="header-2">配置执行</h3><p><strong> .babelrc</strong></p><p>Babel的配置文件，用来设置转码规则和插件，存放在项目的根目录下。使用Babel的第一步，就是配置这个文件</p><ol><li><p>基本格式：</p><pre><code class="lang-json"> {   &quot;presets&quot;: [],   &quot;plugins&quot;: [] }</code></pre></li><li><p>说明：</p><ul><li><code>presents</code>字段用来设定转码规则，按需下载安装和配置</li><li>官方提供的规则集:<ul><li>ES2015转码规则: babel-preset-es2015</li><li>react转码规则: babel-preset-react</li><li>ES7不同阶段语法提案的转码规则（共有4个阶段），任选一个：<ul><li>babel-preset-stage-0</li><li>babel-preset-stage-1</li><li>babel-preset-stage-2</li><li>babel-preset-stage-3</li></ul></li></ul></li></ul></li><li><p>Demo:</p><ul><li>安装转码规则集：<pre><code class="lang-bash">  npm install --save-dev babel-preset-es2015 babel-preset-react babel-preset-stage-2</code></pre></li><li>配置.babelrc：<pre><code class="lang-json">  {      &quot;presets&quot;: [        &quot;es2015&quot;,        &quot;react&quot;,        &quot;stage-2&quot;      ]  }</code></pre></li></ul></li></ol><p><strong> babel-cli </strong></p><p>用于命令行转码</p><ol><li><p>安装</p><pre><code class="lang-bash"> npm install --global babel-cli</code></pre></li><li><p>使用</p><pre><code class="lang-bash"> # 转码结果输出到标准输出 $ babel example.js # 转码结果写入一个文件 ( --out-file 或 -o 参数指定输出文件 ) $ babel example.js -o compiled.js # 整个目录转码 ( --out-dir 或 -d 参数指定输出目录 ) $ babel src -d lib # -s 参数生成source map文件 $ babel src -d lib -s</code></pre></li><li><p>注：若要支持不同项目使用不同版本的Babel，可将babel-cli安装在项目之中，再配置package.json</p><ul><li>安装：<pre><code class="lang-bash">  $ npm install --save-dev babel-cli</code></pre></li><li>package.json配置：<pre><code>  {    // ...    &quot;devDependencies&quot;: {      &quot;babel-cli&quot;: &quot;^6.0.0&quot;    },    &quot;scripts&quot;: {      &quot;build&quot;: &quot;babel src -d lib&quot;    },  }</code></pre></li><li>执行转码<pre><code class="lang-bash">  $ npm run build</code></pre></li></ul></li></ol><h3 id="header-3">钩子</h3><p><strong> babel-polyfill </strong></p><p>Babel默认只转换新的JavaScript句法，而不转换新的API（如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法，eg：Object.assign）详细清单可以查看<code>babel-plugin-transform-runtime</code>模块的<a href="https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-runtime/src/definitions.js" target="_blank" rel="noopener">definitions.js</a>文件<br>eg：<br>ES6在Array对象上新增了Array.from方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。</p><p>安装：</p><pre><code class="lang-bash">npm install --save babel-polyfill</code></pre><p>在脚本头部导入:</p><pre><code class="lang-javascript">import &#39;babel-polyfill&#39;;    // 或者 require(&#39;babel-polyfill&#39;);</code></pre><p><strong> babel-register </strong></p><p>改写require命令，为它加上一个钩子。此后，每当使用<code>require</code>加载<code>.js</code>、<code>.jsx</code>、<code>.es</code>和<code>.es6</code>后缀名的文件，就会先用Babel进行转码</p><p>注: </p><ul><li>只会对<code>require</code>命令加载的文件转码，不会对当前文件转码</li><li>它是实时转码，所以只适合在开发环境使用</li></ul><p>Demo:</p><pre><code class="lang-bash">$ npm install --save-dev babel-register</code></pre><pre><code class="lang-javascript">require(&quot;babel-register&quot;);        // 使用时，必须首先加载babel-registerrequire(&quot;./index.js&quot;);            // 然后，就不需要手动对index.js转码了</code></pre><h3 id="header-4">代码调用Babel API</h3><p>引入babel-core</p><ol><li><p>安装：</p><pre><code class="lang-bash"> $ npm install babel-core --save</code></pre></li><li><p>API调用:</p><pre><code class="lang-javascript"> var babel = require(&#39;babel-core&#39;); // 字符串转码 babel.transform(&#39;code();&#39;, options); // 文件转码（异步） babel.transformFile(&#39;filename.js&#39;, options, function(err, result) {   result; }); // 文件转码（同步） babel.transformFileSync(&#39;filename.js&#39;, options); // Babel AST转码 babel.transformFromAst(ast, code, options);</code></pre><ul><li>transform方法说明：<ul><li>参数：<ul><li>参数一：一个字符串，表示需要转换的ES6代码</li><li>参数二：配置对象options，可以参看<a href="http://babeljs.io/docs/usage/options/" target="_blank" rel="noopener">官方文档</a></li></ul></li><li>返回对象：<code>{ code, map, ast }</code></li></ul></li></ul></li><li><p>Demo:</p><pre><code class="lang-javascript"> var es6Code = &#39;let x = n =&gt; n + 1&#39;; var es5Code = require(&#39;babel-core&#39;)   .transform(es6Code, {     presets: [&#39;es2015&#39;]   })   .code;        // &#39;&quot;use strict&quot;;\n\nvar x = function x(n) {\n  return n + 1;\n};&#39;</code></pre></li></ol><h3 id="header-5">执行环境</h3><ol><li><p><strong> REPL环境：</strong> 可使用babel-cli工具自带的<code>babel-node</code>命令，会提供一个支持ES6的REPL环境 ( 支持Node的REPL环境的所有功能，可直接运行ES6代码 )</p><ul><li>Demo1: 直接执行babel-node就进入PEPL环境<pre><code class="lang-bash">  $ babel-node  &gt; (x =&gt; x * 2)(1)  2</code></pre></li><li>Demo2：执行ES6脚本文件 (注：脚本本身不做任何转码处理)<pre><code class="lang-bash">  $ babel-node es6.js  2</code></pre></li></ul></li><li><p><strong> 浏览器环境：</strong> 使用转换器，直接在浏览器运行</p><ul><li>使用Babel提供的转换器脚本<code>browser.js</code>，直接在浏览器运行（注：Babel 6.0开始，不再直接提供浏览器版本，而是要用构建工具构建出来；可使用Babel 5.x）<pre><code class="lang-html">  &lt;script type=&quot;text/javascript&quot; src=&quot;bower_components/babel/browser.min.js&quot;&gt;&lt;/script&gt;  &lt;script type=&quot;text/babel&quot;&gt;      // write your ES6 code here  &lt;/script&gt;</code></pre></li><li>使用<code>babel-standalone</code>模块提供的浏览器版本，直接在浏览器运行<pre><code class="lang-html">  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.4.4/babel.min.js&quot;&gt;&lt;/script&gt;  &lt;script type=&quot;text/babel&quot;&gt;      // Your ES6 code  &lt;/script&gt;</code></pre></li><li>注：网页中实时将ES6代码转为ES5，对性能会有影响，生产环境最好加载已经转码完成的脚本</li></ul></li><li><p><strong> 浏览器环境：</strong> 先将代码打包转码成浏览器可使用的脚本在加载</p><ul><li><p>使用Browserify（配合Babel，需安装babelify模块）</p><pre><code class="lang-bash">  # 安装babelify模块  $ npm install --save-dev babelify babel-preset-es2015  # 执行转换：将ES6脚本script.js，转为bundle.js，然后浏览器直接加载bundle.js即可  $ browserify script.js -o bundle.js -t [ babelify --presets [ es2015 ] ]</code></pre></li><li>使用webpack（babel-loader），配置webpack.config.js，执行webpack<pre><code class="lang-javascript">  module.exports = {    entry: &quot;./src/a.js&quot;,    output: {        path: __dirname+&quot;/dist&quot;,        filename: &quot;a.js&quot;        publicPath:&quot;/dist&quot;    },    resolve: {        extensions: [&#39;&#39;,&#39;.js&#39;]    },    module: {        loaders: [            { test: /\.js$/, loader: &quot;babel&quot;,query:{presets:[&#39;latest&#39;]} }    //babel参数，例如presets，也可以在.babelrc或package.json中指定        ]    }  };</code></pre></li><li>在线转换：Babel提供一个<a href="https://babeljs.io/repl/" target="_blank" rel="noopener">REPL在线编译器</a>，可以在线将ES6代码转为ES5代码。转换后的代码，可以直接作为ES5代码插入网页运行</li></ul></li></ol><h2 id="header-6">Browserify</h2><p><a href="http://browserify.org/" target="_blank" rel="noopener">Browserify</a></p><blockquote><p>Browserify lets you require(‘modules’) in the browser by bundling up all of your dependencies</p></blockquote><p>让服务器端的CommonJS格式的模块可以运行在浏览器端（Browserify编译时，会将脚本所依赖的模块一起编译进去，即可以将多个模块合并成一个文件）</p><p>Demo:</p><ol><li>安装<pre><code class="lang-bash"> npm install -g browserify</code></pre></li><li>编写一个服务器端脚本a.js,代码中uniq模块是CommonJS格式，无法在浏览器中运行<pre><code class="lang-javascript"> var uniq = require(&#39;uniq&#39;); var nums = [ 5, 2, 1, 3, 2, 5, 4, 2, 0, 1 ]; console.log(uniq(nums));</code></pre></li><li>通过Browserify将上面代码编译为浏览器脚本<pre><code class="lang-javascript"> browserify a.js &gt; bundle.js</code></pre></li><li>生成的bundle.js可以直接插入网页<pre><code class="lang-html">&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</code></pre></li></ol><h2 id="header-7">Reference</h2><p><a href="http://www.ruanyifeng.com/blog/2014/09/package-management.html" target="_blank" rel="noopener">阮一峰/前端模块管理器简介</a></p><p><a href="http://www.ruanyifeng.com/blog/2016/01/babel.html" target="_blank" rel="noopener">阮一峰/Babel 入门教程</a></p>]]></content>
    
    <summary type="html">
    
      Build and Transform Tool
    
    </summary>
    
    
      <category term="Node" scheme="http://sixdegree.github.io/tags/Node/"/>
    
  </entry>
  
</feed>
