<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SixDegree</title>
  
  <subtitle>host by chenjin</subtitle>
  <link href="//atom.xml" rel="self"/>
  
  <link href="http://sixdegree.github.io/"/>
  <updated>2019-03-09T08:44:28.000Z</updated>
  <id>http://sixdegree.github.io/</id>
  
  <author>
    <name>Chen Jin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot Redis</title>
    <link href="http://sixdegree.github.io/2019/01/06/Redis.html"/>
    <id>http://sixdegree.github.io/2019/01/06/Redis.html</id>
    <published>2019-01-05T16:00:00.000Z</published>
    <updated>2019-03-09T08:44:28.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>SpringBoot Redis + Demo</li><li>应用：Session持久化：NoSession方案,SpringSession方案</li><li>方案：NoSession示例</li><li>方案：SpringSession示例</li></ol><a id="more"></a><h2 id="header-1">SpringBoot Redis</h2><ol><li><p>Redis 特性：高性能的key-value数据库</p><ul><li>支持数据的持久化，可将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用</li><li>支持String，Hash,list,Set,ZSet等数据结构的存储</li><li>支持数据的备份（master-slave）</li><li>支持分布式集群，横向扩展</li></ul></li><li><p>Spring: 封装了RedisTemplate对象来支持对redis的各种操作</p><ul><li><code>RedisTemplate&lt;K,V&gt;</code>: 默认采用JDK的序列化策略</li><li><code>StringRedisTemplate extends RedisTemplate&lt;String, String&gt;</code> : 默认采用String的序列化策略</li><li>RedisTemplate中定义了对5种数据结构操作:<ul><li>redisTemplate.opsForValue() 操作字符串</li><li>redisTemplate.opsForHash() 操作hash</li><li>redisTemplate.opsForList() 操作list</li><li>redisTemplate.opsForSet() 操作set</li><li>redisTemplate.opsForZSet() 操作有序set</li></ul></li></ul></li><li><p>SpringBoot:自动化装配</p><ul><li><p><code>org.springframework.boot.autoconfigure.data.redis.RedisProperties</code></p><pre><code class="lang-java">  @ConfigurationProperties(prefix = &quot;spring.redis&quot;)  public class RedisProperties {      private int database = 0;      private String url;      private String host = &quot;localhost&quot;;      private String password;      private int port = 6379;      private boolean ssl;      private Duration timeout;      private Sentinel sentinel;      private Cluster cluster;      private final Jedis jedis = new Jedis();      private final Lettuce lettuce = new Lettuce();      // getter &amp; setter ...      public static class Pool {          private int maxIdle = 8;          private int minIdle = 0;          private int maxActive = 8;          private Duration maxWait = Duration.ofMillis(-1);          //getter &amp; setter ...      }      public static class Cluster {          private List&lt;String&gt; nodes;            //Comma-separated list of &quot;host:port&quot; pairs          private Integer maxRedirects;          //getter &amp; setter ...      }      public static class Sentinel {          private String master;          private List&lt;String&gt; nodes;          //getter &amp; setter ...      }      public static class Jedis {          private Pool pool;          //getter &amp; setter ...      }      public static class Lettuce {          private Duration shutdownTimeout = Duration.ofMillis(100);          private Pool pool;          //getter &amp; setter ...      }  }</code></pre></li><li><code>org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration</code><pre><code class="lang-java">  @Configuration  @ConditionalOnClass(RedisOperations.class)  @EnableConfigurationProperties(RedisProperties.class)  @Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class })  public class RedisAutoConfiguration {      @Bean      @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)      public RedisTemplate&lt;Object, Object&gt; redisTemplate(              RedisConnectionFactory redisConnectionFactory) throws UnknownHostException {          RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();          template.setConnectionFactory(redisConnectionFactory);          return template;      }      @Bean      @ConditionalOnMissingBean      public StringRedisTemplate stringRedisTemplate(              RedisConnectionFactory redisConnectionFactory) throws UnknownHostException {          StringRedisTemplate template = new StringRedisTemplate();          template.setConnectionFactory(redisConnectionFactory);          return template;      }  }</code></pre></li></ul></li><li><p>数据同步,eg: redis和mysql间的数据的同步</p><ul><li>Read: <ul><li>Read from redis -&gt; Exist -&gt; get Data</li><li>Read from redis -&gt; None -&gt; Read mysql -&gt; write to redis</li></ul></li><li>Write: <ul><li>Write to mysql -&gt; Success -&gt; Write to Redis</li></ul></li></ul></li></ol><h3 id="header-2">Demo</h3><ol><li><p>pom.xml</p><pre><code class="lang-xml"> &lt;!-- SpringBoot --&gt; &lt;dependency&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Springboot redis --&gt; &lt;dependency&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt;</code></pre></li><li><p>resources/application.yml</p><pre><code> spring:   redis:     host: localhost     port: 6379     password: 123456     timeout: 30000     jedis:       pool:         max-active: 8         max-wait: 1         max-idle: 8         min-idle: 0</code></pre></li><li><p>RedisConfig</p><pre><code class="lang-java"> @Configuration public class RedisConfig {     @Bean     @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)        // create and inject when no bean which named `redisTemplate`     public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory){         RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();         template.setConnectionFactory(redisConnectionFactory);         // set serializer for key: use `RedisSerializer&lt;String&gt;`         RedisSerializer&lt;String&gt; stringSerializer = new StringRedisSerializer();         template.setKeySerializer(stringSerializer);         template.setHashKeySerializer(stringSerializer);         // set serializer for value: use `Jackson2JsonRedisSerializer&lt;Object&gt;`         Jackson2JsonRedisSerializer&lt;Object&gt;    jsonSerializer = new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class);         ObjectMapper objectMapper = initObjectMapper();         jsonSerializer.setObjectMapper(objectMapper);         template.setValueSerializer(jsonSerializer);         template.setHashValueSerializer(jsonSerializer);         return template;     }     private ObjectMapper initObjectMapper(){         ObjectMapper objectMapper = new ObjectMapper();         //去除掉对getter和setter的依赖,ObjectMapper将通过反射机制直接操作Java对象上的字段         objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);         // DefaultTyping:          // 指定什么样的类型输入会被使用 ( eg: `NON_FINAL`表示对所有非final类型或者非final类型元素对象持久化)         // 这样Json序列化/反序列化不需要知道具体子类的类型，只需要根据父类以及类别标识就能准确判断子类类型         // 注：会存储类型信息（为了能准确的反序列多态类型的数据）         objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);         // disable Feature:         // `DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES` (Json -&gt; Object): 忽略json字符串中不识别的属性         // `SerializationFeature.FAIL_ON_EMPTY_BEANS` (Object -&gt; Json) 忽略无法转换的对象 “No serializer found for class com.xxx.xxx”         objectMapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);          objectMapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);         // Serialization (Object -&gt; Json):          // `NON_EMPTY`只序列化非空属性         //objectMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);         return objectMapper;     } }</code></pre></li><li><p>RedisService</p><pre><code class="lang-java"> @Service public class RedisService {     // @Autowired     // private StringRedisTemplate redisTemplate;     //  inject base on bean name     // @Resource             // private RedisTemplate&lt;String, Object&gt; redisTemplate;     // inject base on the bean type     @Autowired     private RedisTemplate&lt;String, Object&gt; redisTemplate;     public Object get(String key) {         return redisTemplate.opsForValue().get(key);     }     public void set(String key, Object value) {         redisTemplate.opsForValue().set(key, value);     }     public void set(String key,Object value,int timeout){         redisTemplate.opsForValue().set(key, value,timeout,TimeUnit.SECONDS);     }     public Boolean delete(String key){         return redisTemplate.delete(key);     }     public void expire(String key,int timeout){         redisTemplate.expire(key, timeout, TimeUnit.SECONDS);     } }</code></pre></li></ol><h2 id="header-3">应用：Session 持久化</h2><ul><li>Session在服务端保存用户会话状态（如：用户登录信息等） </li><li>在程序重启、多进程运行、负载均衡、跨域等情况时，会出现Session丢失或多进程、多个负载站点间状态不能共享的情况</li><li>解决方案：将Session持久化存储以共享 （ Redis 是一个高性能的<code>key-value</code>数据库，可用来存储<code>Session</code>），eg:<ul><li><code>NoSession</code>(服务端自己生成一个序列码代替Session作为标识)</li><li><code>SpringSession</code>(对每一个请求request进行封装，后续取到的不是HttpSession而是可持久化的SpringSession)</li></ul></li></ul><h3 id="header-4">方案：NoSession</h3><p>Scenarios:</p><ol><li><p>One App, Multiple Clients Login,only latest login valid:</p><ul><li>Login Process:<ul><li>Client1: login -&gt; success</li><li>Client2: login -&gt; success &amp; expire Client1 login</li></ul></li><li>Visit controlled resources:<ul><li>Client1: 401 Unauthorized -&gt; please login</li><li>Client2: success</li></ul></li><li>Logout Process:<ul><li>Client1: logout -&gt; invalid token-&gt; success</li><li>Client2: logout -&gt; valid token -&gt; success</li></ul></li><li>Implement:<ul><li>使用Redis维护保存用户登陆信息:<ul><li><code>&lt;prefix&gt;:&lt;token&gt;</code>:<code>&lt;user&gt;</code> &amp; expireTime</li><li><code>&lt;prefix&gt;:&lt;user.id&gt;</code>:<code>&lt;token&gt;</code> &amp; expireTime</li></ul></li><li>HttpHeader中带有token:<ul><li><code>&lt;token&gt;</code></li></ul></li><li>login:<ul><li>delete the two redis key-values (for invaliding other clients login)</li><li>generate new <code>&lt;token&gt;</code></li><li>set the two redis key-values</li><li>set <code>&lt;token&gt;</code> to Http Response</li></ul></li><li>logout:<ul><li>get <code>token1</code> from http header</li><li>get <code>user.id</code> from redis key-value <code>&lt;prefix&gt;:&lt;token1&gt;</code>:<code>&lt;user&gt;</code></li><li>get <code>token2</code> from redis key-value <code>&lt;prefix&gt;:&lt;user.id&gt;</code>:<code>&lt;token2&gt;</code></li><li>can’t get <code>user.id</code> || can’t get <code>token2</code> -&gt; valid -&gt; success</li><li>compare <code>token1</code> &amp; <code>token2</code><ul><li>match -&gt; valid -&gt; delete the two redis key-values -&gt; success</li><li>unmatch -&gt; invalid -&gt; fail</li></ul></li></ul></li><li>getAuthentication<ul><li>get <code>user</code> from redis key-value <code>&lt;prefix&gt;:&lt;token&gt;</code>:<code>&lt;user&gt;</code> (get <code>token</code> from http header) </li></ul></li></ul></li></ul></li><li><p>One AuthService,Multiple other Services call AuthService(seperate auth process)</p><ul><li>AuthService API:<ul><li>login</li><li>logout</li><li>getAuthentication</li></ul></li><li>Service1 -&gt; AuthService</li><li>Service2 -&gt; AuthService</li><li>Implement:<ul><li>使用Redis维护保存用户登陆信息: (note: different services use different <code>&lt;prefix&gt;</code>)<ul><li><code>&lt;prefix&gt;:&lt;token&gt;</code>:<code>&lt;user&gt;</code> &amp; expireTime </li></ul></li><li>HttpHeader中带有token:<ul><li><code>&lt;token&gt;</code></li></ul></li><li>login: <ul><li>generate new <code>token</code></li><li>set redis key-value <code>&lt;prefix&gt;:&lt;token&gt;</code>:<code>&lt;user&gt;</code></li><li>set <code>&lt;token&gt;</code> to HttpResponse</li></ul></li><li>logout: <ul><li>delete redis key-value <code>&lt;prefix&gt;:&lt;token&gt;</code>:<code>&lt;user&gt;</code> (get <code>token</code> from http header)</li></ul></li><li>getAuthentication: <ul><li>get <code>user</code> from redis key-value <code>&lt;prefix&gt;:&lt;token&gt;</code>:<code>&lt;user&gt;</code> (get <code>token</code> from http header)</li></ul></li></ul></li></ul></li></ol><h3 id="header-5">方案：SpringSession</h3><p>Refer to <a href="https://docs.spring.io/spring-session/docs/current/reference/html5/guides/boot-redis.html" target="_blank" rel="noopener">Spring Session - Spring Boot</a></p><p>spring-session</p><ul><li>spring旗下的一个项目, 把servlet容器实现的HttpSession替换为spring-session的HttpSession</li><li>核心组件：<code>SessionRepositoryFilter</code> 拦截Web请求,确保随后调用<code>javax.servlet.http.HttpServletRequest</code>的<code>getSession()</code>，会返回Spring Session的HttpSession实例，而不是应用服务器默认的<code>HttpSession</code><ul><li>HttpSessionIdResolver: resolveSessionIds，expireSession</li><li>SessionRepository: createSession,save,findById,deleteById</li><li>@Override doFilterInternal(HttpServletRequest request,HttpServletResponse response, FilterChain filterChain)<ul><li>SessionRepositoryRequestWrapper (getSession -&gt; return HttpSessionWrapper)</li><li>SessionRepositoryResponseWrapper    </li></ul></li></ul></li><li>使用Redis存储的SpringSession(默认使用前缀：<code>spring:session</code>),对于每一个session都会创建3组数据,eg:<ul><li><code>spring:session:sessions:[sessionId]</code>: hash结构,存储springsession的主要内容:<ul><li>sessionAttr:[sessionId]  存储session信息（eg：实体类的序列化数据）</li><li>creationTime</li><li>maxInactiveInterval</li><li>lastAccessedTime</li></ul></li><li><code>spring:session:sessions:expires:[sessionId]</code>：string结构，value为空,ttl倒计时过期</li><li><code>spring:session:expirations:[expireTime]</code>：set结构<ul><li>expires:[sessionId] 一个会话一条</li><li>redis的ttl删除key是一个异步行为且是一个低优先级的行为，可能会导致session不被清除，于是引入了expirations这个key，来主动进行session的过期行为判断</li></ul></li></ul></li><li>Process：<ul><li>通过request的<code>getSession(boolean create)</code> 方法获取<code>session</code></li><li>根据sessionId 读取 <code>spring:session:sessions:[sessionId]</code> 的值</li></ul></li><li>Scenarios:<ul><li>One App,Multiple Clients Login =&gt; seperated,all success</li><li>One AuthService,Multiple other Services call AuthService =&gt; seperated,all successs</li><li>One App,Multiple ports (Nginx/Apache+Tomcat) =&gt; depends on session async strategy</li></ul></li></ul><h2 id="header-6">方案：NoSession 示例</h2><h3 id="header-7">Dependency</h3><p>pom.xml</p><pre><code class="lang-xml">&lt;!-- SpringBoot --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- Redis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- for StringUtils --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;    &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- for MD5 --&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-codec&lt;/groupId&gt;    &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h3 id="header-8">Config</h3><ol><li><p>resources/application.yml</p><pre><code class="lang-yml"> server:       port: 8080       servlet:         context-path: /micro-auth spring:   redis:     host: localhost     port: 6379     password: 123456     timeout: 30000     jedis:       pool:         max-active: 8         max-wait: 1         max-idle: 8         min-idle: 0 # for authController         auth:   usersessionHeader: usersession   principalHeader: micro-auth   expireTime: 180</code></pre></li><li><p>RedisConfig</p><pre><code class="lang-java"> @Configuration public class RedisConfig {     @Bean     public RedisTemplate&lt;Object,Object&gt; jsonRedisTemplate(RedisConnectionFactory redisConnectionFactory){         RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;Object,Object&gt;();         template.setConnectionFactory(redisConnectionFactory);         RedisSerializer&lt;String&gt; stringSerializer = new StringRedisSerializer();         template.setKeySerializer(stringSerializer);         template.setHashKeySerializer(stringSerializer);         Jackson2JsonRedisSerializer&lt;Object&gt;    jsonSerializer = initJsonSerializer();         template.setValueSerializer(jsonSerializer);         template.setHashValueSerializer(jsonSerializer);         template.afterPropertiesSet();         System.out.println(&quot;Create Customer JsonRedisTemplate-----&quot;);         return template;     }     private Jackson2JsonRedisSerializer&lt;Object&gt; initJsonSerializer(){         Jackson2JsonRedisSerializer&lt;Object&gt;    jsonSerializer = new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class);         ObjectMapper objectMapper = initObjectMapper();         jsonSerializer.setObjectMapper(objectMapper);         return jsonSerializer;     }     private ObjectMapper initObjectMapper(){         ObjectMapper objectMapper = new ObjectMapper();         objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);         objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);         objectMapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);          objectMapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);         //objectMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);         return objectMapper;     } }</code></pre></li></ol><h3 id="header-9">RedisService</h3><pre><code class="lang-java">@Servicepublic class RedisService {            @Autowired    private RedisTemplate&lt;Object, Object&gt; jsonRedisTemplate;    public Object get(String key) {        return jsonRedisTemplate.opsForValue().get(key);    }        public void set(String key, Object value) {        jsonRedisTemplate.opsForValue().set(key, value);    }    public void set(String key,Object value,int timeout){        jsonRedisTemplate.opsForValue().set(key, value,timeout,TimeUnit.SECONDS);    }    public Boolean delete(String key){        return jsonRedisTemplate.delete(key);    }    public void expire(String key,int timeout){        jsonRedisTemplate.expire(key, timeout, TimeUnit.SECONDS);    }}</code></pre><h3 id="header-10">AuthController</h3><pre><code class="lang-java">@RestControllerpublic class AuthController {    @Value(&quot;${auth.principalHeader}&quot;)    private String principalHeader;    @Value(&quot;${auth.expireTime}&quot;)    private int expireTime;    @Autowired    private RedisService redisService;    @Autowired    private UserService userService;    @GetMapping(&quot;/&quot;)    public Object index(){        return ResponseEntity.ok(&quot;This is micro-authService!&quot;);    }    @PostMapping(&quot;/login&quot;)    public Object login(@RequestBody User loginUser,            @RequestHeader(name=&quot;${auth.usersessionHeader}&quot;) String sessionKey,             @RequestHeader(name=&quot;${auth.principalHeader}&quot;,required=false) String principle,            HttpServletResponse response){        // db: verify         if(loginUser==null || StringUtils.isAnyBlank(loginUser.getName(),loginUser.getPassword()))            return MicroResponse.InvalidRequest;        // check principle        if(principle!=null){            User user=(User)this.redisService.get(sessionKey+&quot;:&quot;+principle);            if(user!=null                     &amp;&amp; loginUser.getName().equals(user.getName())                     &amp;&amp; MD5Utils.getMD5Str(loginUser.getPassword()).equals(user.getPassword())){                this.redisService.expire(sessionKey+&quot;:&quot;+principle, expireTime);                this.redisService.expire(sessionKey+&quot;:&quot;+user.getId(), expireTime);                response.setHeader(principalHeader, principle);                return MicroResponse.success(&quot;login success&quot;);            }        }        // check name &amp; password        User user=userService.findByNameAndPassword(loginUser);        if(user==null)            return MicroResponse.AuthenticationFail;        // delete other clients login        String oldToken = (String)this.redisService.get(sessionKey+&quot;:&quot;+user.getId());        if(user!=null)            this.redisService.delete(sessionKey+&quot;:&quot;+oldToken);        this.redisService.delete(sessionKey+&quot;:&quot;+user.getId());        // set new        String token = UUID.randomUUID().toString();        this.redisService.set(sessionKey+&quot;:&quot;+token,user,expireTime);        this.redisService.set(sessionKey+&quot;:&quot;+user.getId(),token,expireTime);        response.setHeader(principalHeader, token);        return MicroResponse.success(&quot;login success&quot;);    }    @GetMapping(&quot;/logout&quot;)    public Object logout(@RequestHeader(name=&quot;${auth.principalHeader}&quot;) String principle,@RequestHeader(name=&quot;${auth.usersessionHeader}&quot;) String sessionKey){        User user=(User)this.redisService.get(sessionKey+&quot;:&quot;+principle);        if(user==null)            return MicroResponse.success(&quot;logout success&quot;);        String token=(String)this.redisService.get(sessionKey+&quot;:&quot;+user.getId());        if(token==null)            return MicroResponse.success(&quot;logout success&quot;);        if(principle.equals(token)){            this.redisService.delete(sessionKey+&quot;:&quot;+user.getId());            this.redisService.delete(sessionKey+&quot;:&quot;+token);            return MicroResponse.success(&quot;logout success&quot;);        }        return MicroResponse.fail(&quot;logout fail&quot;);    }    @GetMapping(&quot;/authentication&quot;)    public Object getAuthentication(@RequestHeader(name=&quot;${auth.principalHeader}&quot;) String principle,@RequestHeader(name=&quot;${auth.usersessionHeader}&quot;) String sessionKey){        return MicroResponse.success(redisService.get(sessionKey+&quot;:&quot;+principle));    }    @PostMapping(&quot;/regist&quot;)    public Object regist(@RequestBody User user){        if(user==null || StringUtils.isAnyBlank(user.getName(),user.getPassword()))            return MicroResponse.InvalidRequest;        boolean result=userService.save(user);        return new MicroResponse(result,result?1:0,user);    }}// catch error!@RestControllerpublic class AuthErrorController implements ErrorController{    @Override    public String getErrorPath() {        return &quot;/error&quot;;    }    @RequestMapping(value=&quot;/error&quot;)    public Object onError(HttpServletResponse rs,Exception ex){       HttpStatus status=HttpStatus.resolve(rs.getStatus());       if(status!=null)           return new MicroResponse(false,rs.getStatus(),status.getReasonPhrase());       else           return MicroResponse.fail(ex.getMessage());    }}</code></pre><h3 id="header-11">Service &amp; Repository &amp; Entity</h3><p>Service: UserService</p><pre><code class="lang-java">@Servicepublic class UserService {    @Autowired    private UserRepository userRepository;    public User findByNameAndPassword (User user){        Optional&lt;User&gt; result= this.userRepository.findByNameAndPassword(user.getName(),user.getPassword());        if(result.isPresent())            return result.get();        return null;    }    public boolean save(User user){        return this.userRepository.save(user);    }}</code></pre><p>Repository: UserRepository</p><pre><code class="lang-java">@Repositorypublic class UserRepository {    //private final ConcurrentMap&lt;Integer,User&gt; users = new ConcurrentHashMap&lt;Integer,User&gt;();    private final ConcurrentMap&lt;String,User&gt; users=new ConcurrentHashMap&lt;String,User&gt;();    private final static AtomicInteger idGenerator = new AtomicInteger();    @PostConstruct    public void init(){        users.put(&quot;admin&quot;, new User(idGenerator.incrementAndGet(),&quot;admin&quot;,MD5Utils.getMD5Str(&quot;admin123&quot;)));    }    public boolean save(User user){        Integer id = idGenerator.incrementAndGet();        user.setId(id);        user.setPassword(MD5Utils.getMD5Str(user.getPassword()));        return users.put(user.getName(),user)==null;    }    public Collection&lt;User&gt; list(){        return users.values();    }    public Optional&lt;User&gt; findByNameAndPassword(String name,String password){        User user=users.get(name);        if(user!=null &amp;&amp; user.getPassword().equals(MD5Utils.getMD5Str(password)))            return Optional.of(user);        return Optional.empty();    }    public boolean existsByName(String name){        return users.containsKey(name);    }}</code></pre><p>Entity: User</p><pre><code class="lang-java">public class User implements Serializable{    private static final long serialVersionUID = -4198480470411674996L;    private Integer id;    private String name;    private String password;    public User(){}    public User(Integer id,String name,String password){        this.id=id;        this.name=name;        this.password=password;    }    @JsonIgnore    public String getPassword() {        return password;    }    @JsonProperty    public void setPassword(String password) {        this.password = password;    }    /* other getter &amp; setter ... */}</code></pre><h3 id="header-12">Utils: MD5Utils &amp; MicroResponse</h3><pre><code class="lang-java">public class MD5Utils {     public static String getMD5Str(String strValue) {        try {            MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);            String newstr = Base64.encodeBase64String(md5.digest(strValue.getBytes()));            return newstr;        } catch (NoSuchAlgorithmException e) {            //e.printStackTrace();            System.out.println(e.getMessage());        }        return strValue;    }}</code></pre><pre><code class="lang-java">public class MicroResponse {    public static final MicroResponse OK=new MicroResponse(true,1,null);    public static final MicroResponse AuthenticationFail=new MicroResponse(false,2, &quot;Authentication Fail&quot;);    public static final MicroResponse UnAuthorized=new MicroResponse(false,3, &quot;Not Authorized&quot;);    public static final MicroResponse InvalidRequest=new MicroResponse(false,4,&quot;Invalid Request&quot;);    public static final MicroResponse Existed=new MicroResponse(false,5,&quot;Already Existed&quot;);    public static final MicroResponse NotExist=new MicroResponse(false,6,&quot;Not Exist&quot;);    public static MicroResponse success(Object data){        return new MicroResponse(true,1,data);    }    public static MicroResponse fail(Object data){        return new MicroResponse(false,0,data);    }    private boolean success;    private Integer code;    private Object data;    public MicroResponse(boolean success, Integer code, Object data) {        super();        this.success = success;        this.code = code;        this.data = data;    }    /* getter &amp; setter ...  */}</code></pre><h3 id="header-13">Run and Visit</h3><ol><li><p>main</p><pre><code class="lang-java"> @SpringBootApplication public class AuthServiceApplication {     public static void main(String[] args) {         SpringApplication.run(AuthServiceApplication.class, args);     } }</code></pre></li><li><p>Visit: <code>http://localhost:8080/micro-auth</code></p><ul><li>POST <code>/regist</code><ul><li>body: <code>{&quot;name&quot;:&quot;Tom&quot;,&quot;password&quot;:&quot;123123&quot;}</code></li></ul></li><li>POST <code>/login</code><ul><li>header: <code>usersession:xx</code></li><li>body: <code>{&quot;name&quot;:&quot;Tom&quot;,&quot;password&quot;:&quot;123123&quot;}</code></li></ul></li><li>GET     <code>/logout</code><ul><li>header: <code>usersession:xx</code>,<code>micro-auth:xxxxxxxxxxxxxx</code></li></ul></li><li>GET <code>/authentication</code><ul><li>header: <code>usersession:xx</code>,<code>micro-auth:xxxxxxxxxxxxxx</code></li></ul></li></ul></li></ol><h3 id="header-14">Verify</h3><ol><li><p>POST <code>/regist</code></p><pre><code class="lang-bash"> &gt; curl -i -H &quot;Content-Type: application/json&quot; -H &quot;usersession:s1&quot; -X POST -d &#39;{&quot;name&quot;:&quot;Tom&quot;,&quot;password&quot;:&quot;123123&quot;}&#39; http://localhost:8080/micro-auth/regist HTTP/1.1 200 Content-Type: application/json;charset=UTF-8 Transfer-Encoding: chunked Date: Thu, 07 Feb 2019 05:38:22 GMT {&quot;success&quot;:true,&quot;code&quot;:1,&quot;data&quot;:{&quot;id&quot;:2,&quot;name&quot;:&quot;Tom&quot;}}</code></pre></li><li><p>POST <code>/login</code></p><pre><code class="lang-bash"> &gt; curl -i -H &quot;Content-Type: application/json&quot; -H &quot;usersession:s1&quot; -X POST -d &#39;{&quot;name&quot;:&quot;Tom&quot;,&quot;password&quot;:&quot;123123&quot;}&#39; http://localhost:8080/micro-auth/login HTTP/1.1 200 micro-auth: 1d0fa647-9dbe-410a-8d9c-0e1c973a98e2 Content-Type: application/json;charset=UTF-8 Transfer-Encoding: chunked Date: Thu, 07 Feb 2019 05:39:33 GMT {&quot;success&quot;:true,&quot;code&quot;:1,&quot;data&quot;:&quot;login success&quot;} # check redis: redis:6379&gt; keys * 1) &quot;s1:2&quot; 2) &quot;s1:1d0fa647-9dbe-410a-8d9c-0e1c973a98e2&quot; redis:6379&gt; get s1:2 &quot;\&quot;1d0fa647-9dbe-410a-8d9c-0e1c973a98e2\&quot;&quot; redis:6379&gt; get s1:1d0fa647-9dbe-410a-8d9c-0e1c973a98e2 &quot;[\&quot;com.cj.auth.entity.User\&quot;,{\&quot;id\&quot;:2,\&quot;name\&quot;:\&quot;Tom\&quot;,\&quot;password\&quot;:\&quot;Qpf0SxOVUjUkWySXOZ16kw==\&quot;}]&quot; redis:6379&gt; ttl s1:2 (integer) 100 redis:6379&gt; ttl s1:1d0fa647-9dbe-410a-8d9c-0e1c973a98e2 (integer) 99</code></pre></li><li><p>GET <code>/authentication</code></p><pre><code class="lang-bash"> &gt; curl -i -H &quot;micro-auth:1d0fa647-9dbe-410a-8d9c-0e1c973a98e2&quot; -H &quot;usersession:s1&quot; -X GET http://localhost:8080/micro-auth/authentication HTTP/1.1 200 Content-Type: application/json;charset=UTF-8 Transfer-Encoding: chunked Date: Thu, 07 Feb 2019 05:40:49 GMT {&quot;success&quot;:true,&quot;code&quot;:1,&quot;data&quot;:{&quot;id&quot;:2,&quot;name&quot;:&quot;Tom&quot;}}</code></pre></li><li><p>GET <code>/logout</code></p><pre><code class="lang-bash"> &gt; curl -i -H &quot;micro-auth: 1d0fa647-9dbe-410a-8d9c-0e1c973a98e2&quot; -H &quot;usersession:s1&quot; -X GET http://localhost:8080/micro-auth/logout HTTP/1.1 200 Content-Type: application/json;charset=UTF-8 Transfer-Encoding: chunked Date: Thu, 07 Feb 2019 05:04:30 GMT {&quot;success&quot;:true,&quot;code&quot;:1,&quot;data&quot;:&quot;logout success&quot;} # check redis: redis:6379&gt; keys * (empty list or set)</code></pre></li></ol><h3 id="header-15">Client: call AuthService</h3><p>使用RestTemplate方式call发布的AuthService ( 注：也可考虑使用Dobbo等其他RPC方式，AuthService发布方式也需要改变)：</p><ul><li><p>resources/application.yml</p><pre><code>  server:    port: 9080    servlet:      context-path: /micro-service1  auth:      url: http://localhost:8080/micro-auth      principalHeader: micro-auth      usersessionHeader: usersession      usersessionKey: s1</code></pre></li><li><p>Controller</p><pre><code class="lang-java">  @RestController  @RequestMapping(&quot;/auth&quot;)  public class Service1Controller {      @Autowired      private AuthCallService authCallService;      @PostMapping(&quot;/login&quot;)      public Object login(@RequestBody User loginUser){          // ...      }      @PostMapping(&quot;/logout&quot;)      public Object logout(){          // ...      }      @GetMapping(&quot;/authentication&quot;)      public Object getAuthentication(@RequestHeader(name=&quot;${auth.principalHeader}&quot;,required=false) String principle){          return AuthCallService.getAuthentication(principle);      }  }</code></pre></li><li><p>AuthCallService</p><pre><code class="lang-java">  @Service  public class AuthCallService {      @Value(&quot;${auth.url}&quot;)      private String authURL;      @Value(&quot;${auth.principalHeader}&quot;)      private String principalHeader;      @Value(&quot;${auth.usersessionHeader}&quot;)      private String usersessionHeader;      @Value(&quot;${auth.usersessionKey}&quot;)      private String usersessionKey;      @Autowired      private RestTemplate restTemplate;      public Object login(){          //...      }      public Object logout(){          //...      }      public Object getAuthentication(String principle){          HttpHeaders headers = new HttpHeaders();           headers.set(principalHeader,principle);           headers.set(usersessionHeader,usersessionKey);           headers.setContentType(MediaType.APPLICATION_JSON);          HttpEntity&lt;String&gt; entity=new HttpEntity&lt;String&gt;(null,headers);          HttpEntity&lt;Map&gt; response=restTemplate.exchange(authURL+&quot;/authentication&quot;,HttpMethod.GET,entity,Map.class);          return response.getBody();      }  }</code></pre></li><li><p>main </p><pre><code class="lang-java">  @SpringBootApplication  public class ServiceApplication {      public static void main(String[] args) {          SpringApplication.run(ServiceApplication.class, args);      }  }</code></pre></li><li><p>Visit: <code>http://localhost:9080/micro-service1</code></p><ul><li><code>/login</code></li><li><code>/logout</code></li><li><code>/getAuthentication</code></li></ul></li></ul><h3 id="header-16">Client：简化测试版</h3><pre><code class="lang-java">@RunWith(SpringRunner.class)@SpringBootTest(webEnvironment=SpringBootTest.WebEnvironment.RANDOM_PORT)public class ServiceCallAuthNoSessionTest {    @Autowired    private TestRestTemplate restTemplate;    private String authURL=&quot;http://localhost:8080/micro-auth&quot;;    private String principalHeader=&quot;micro-auth&quot;;    private String usersessionHeader=&quot;usersession&quot;;    private String usersessionKey=&quot;s1&quot;;    String principle=&quot;a37377ec-dc92-41f8-95af-4d0a494f3eb8&quot;;    @Test    public void callTest(){        //getAuthentication        callGetAuthentication();        // login        callLoginTest();        // callGetAuthentication        callGetAuthentication();        // logout        callLogoutTest();        // getAuthentication        callGetAuthentication();    }    @Test    public void callLoginTest(){        System.out.println(&quot;call login...&quot;);        HttpHeaders headers = new HttpHeaders();         headers.set(usersessionHeader,usersessionKey);         headers.setContentType(MediaType.APPLICATION_JSON);        Map&lt;String,String&gt; userMap=new HashMap&lt;String,String&gt;();        userMap.put(&quot;name&quot;, &quot;Tom&quot;);        userMap.put(&quot;password&quot;, &quot;123123&quot;);        HttpEntity&lt;Map&gt; entity=new HttpEntity&lt;Map&gt;(userMap,headers);        HttpEntity&lt;Map&gt; response=restTemplate.exchange(authURL+&quot;/login&quot;,HttpMethod.POST,entity,Map.class);        System.out.println(response);        principle=(String)response.getHeaders().getFirst(principalHeader);        System.out.println(&quot;token:&quot;+principle);    }    @Test    public void callLogoutTest(){        System.out.println(&quot;call logout...&quot;);        HttpHeaders headers = new HttpHeaders();         headers.set(principalHeader,principle);         headers.set(usersessionHeader,usersessionKey);         headers.setContentType(MediaType.APPLICATION_JSON);        HttpEntity&lt;String&gt; entity=new HttpEntity&lt;String&gt;(null,headers);        HttpEntity&lt;String&gt; response=restTemplate.exchange(authURL+&quot;/logout&quot;,HttpMethod.GET,entity,String.class);        System.out.println(response);    }    @Test    public void callGetAuthentication(){        System.out.println(&quot;call getAuthentication...&quot;);        HttpHeaders headers = new HttpHeaders();         headers.set(principalHeader,principle);         headers.set(usersessionHeader,usersessionKey);         headers.setContentType(MediaType.APPLICATION_JSON);        HttpEntity&lt;String&gt; entity=new HttpEntity&lt;String&gt;(null,headers);        HttpEntity&lt;Map&gt; response=restTemplate.exchange(authURL+&quot;/authentication&quot;,HttpMethod.GET,entity,Map.class);        System.out.println(response);    }}</code></pre><p>Run Junit Test: callTest</p><pre><code>call getAuthentication...&lt;200,{success=true, code=1, data=null},{Content-Type=[application/json;charset=UTF-8], Transfer-Encoding=[chunked], Date=[Thu, 07 Feb 2019 06:37:22 GMT]}&gt;call login...&lt;200,{success=true, code=1, data=login success},{micro-auth=[80d89cb8-f8e3-4b6c-8344-06d9e3a88d41], Content-Type=[application/json;charset=UTF-8], Transfer-Encoding=[chunked], Date=[Thu, 07 Feb 2019 06:37:22 GMT]}&gt;token:80d89cb8-f8e3-4b6c-8344-06d9e3a88d41call getAuthentication...&lt;200,{success=true, code=1, data={id=2, name=Tom}},{Content-Type=[application/json;charset=UTF-8], Transfer-Encoding=[chunked], Date=[Thu, 07 Feb 2019 06:37:22 GMT]}&gt;call logout...&lt;200,{&quot;success&quot;:true,&quot;code&quot;:1,&quot;data&quot;:&quot;logout success&quot;},{Content-Type=[application/json;charset=UTF-8], Transfer-Encoding=[chunked], Date=[Thu, 07 Feb 2019 06:37:22 GMT]}&gt;call getAuthentication...&lt;200,{success=true, code=1, data=null},{Content-Type=[application/json;charset=UTF-8], Transfer-Encoding=[chunked], Date=[Thu, 07 Feb 2019 06:37:22 GMT]}&gt;</code></pre><h2 id="header-17">方案：SpringSession 示例</h2><h3 id="header-18">Dependency</h3><p>pom.xml</p><pre><code class="lang-xml">&lt;!-- SpringBoot --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- Springboot redis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- Spring Session --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;    &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h3 id="header-19">Config</h3><ol><li><p>resources/application.yml</p><pre><code> server:   port: 8080   servlet:     context-path: /micro-auth       spring:   redis:     host: localhost     port: 6379     password: 123456     timeout: 30000     jedis:       pool:         max-active: 8         max-wait: 1         max-idle: 8         min-idle: 0       #  session: #    store-type: redis   #     timeout: 180   #    redis: #      namespace: sps        # default prefix is `spring:session` #      flush-mode: on-save</code></pre></li><li><p>RedisConfig (使用<code>@EnableRedisHttpSession</code>或在application.yml中配置<code>spring.session</code>)</p><pre><code class="lang-java"> @Configuration @EnableRedisHttpSession(maxInactiveIntervalInSeconds = 180,     redisFlushMode=RedisFlushMode.ON_SAVE,     redisNamespace=&quot;sps&quot;) public class RedisConfig { }</code></pre></li></ol><h3 id="header-20">Controller</h3><p>AuthSessionController</p><pre><code class="lang-java">@RestController@RequestMapping(&quot;/session&quot;)public class AuthSessionController {    @Autowired    private UserService userService;    @GetMapping(&quot;/&quot;)    public Object index(){        return ResponseEntity.ok(&quot;This is micro-authService using springsession!&quot;);    }    @PostMapping(&quot;/login&quot;)    public Object login(@RequestBody User loginUser,HttpServletRequest request){        if(loginUser==null || StringUtils.isAnyBlank(loginUser.getName(),loginUser.getPassword()))            return MicroResponse.InvalidRequest;        // check name &amp; password        User user=userService.findByNameAndPassword(loginUser);        if(user==null)            return MicroResponse.AuthenticationFail;        HttpSession session=request.getSession();        session.setAttribute(session.getId(), user);        System.out.println(session.getId());        return MicroResponse.success(user);    }    @GetMapping(&quot;/logout&quot;)    public Object logout(HttpServletRequest request){        HttpSession session=request.getSession(false);        if(session!=null){            session.removeAttribute(session.getId());            System.out.println(session.getId());        }else            System.out.println(&quot;logout: session is null&quot;);        return MicroResponse.OK;    }    @GetMapping(&quot;/authentication&quot;)    public Object getAuthentication(HttpServletRequest request /*HttpSession session*/){        HttpSession session=request.getSession(false);        if(session!=null){            System.out.println(session.getId());            return MicroResponse.success(session.getAttribute(session.getId()));        }        System.out.println(&quot;getAuthentication: session is null&quot;);        return MicroResponse.success(null);    }}</code></pre><h3 id="header-21">Service &amp; Repository &amp; Entity</h3><p>UserService &amp; UserRepository &amp; User &amp; MicroResponse 均同上</p><h3 id="header-22">Run</h3><ol><li><p>main</p><pre><code class="lang-java"> @SpringBootApplication public class AuthServiceApplication {     public static void main(String[] args) {         SpringApplication.run(AuthServiceApplication.class, args);     } }</code></pre></li><li><p>Visit: <code>http://localhost:8080/micro-auth/session</code></p><ul><li>POST <code>/login</code><ul><li>body: <code>{&quot;name&quot;:&quot;Tom&quot;,&quot;password&quot;:&quot;123123&quot;}</code></li></ul></li><li>GET <code>/logout</code></li><li>GET <code>/authentication</code></li></ul></li></ol><h3 id="header-23">Verify</h3><ol><li><p>clear redis records</p><pre><code class="lang-bash"> redis:6379&gt; FLUSHALL OK redis:6379&gt; keys * (empty list or set)</code></pre></li><li><p>POST <code>/login</code></p><pre><code class="lang-bash"> &gt; curl -c cookie.txt -i -H &quot;Content-Type:application/json&quot; -X POST -d &#39;{&quot;name&quot;: &quot;admin&quot;, &quot;password&quot;:&quot;admin123&quot;}&#39; http://localhost:8080/micro-auth/session/login HTTP/1.1 200 Set-Cookie: SESSION=ODY1NDBhZDUtYzNmNy00NTg4LTg4ZjYtMDMxZWVlYzE2YTBm; Path=/micro-auth/; HttpOnly Content-Type: application/json;charset=UTF-8 Transfer-Encoding: chunked Date: Thu, 07 Feb 2019 15:17:57 GMT {&quot;success&quot;:true,&quot;code&quot;:1,&quot;data&quot;:{&quot;id&quot;:1,&quot;name&quot;:&quot;admin&quot;}} # check redis: redis:6379&gt; keys * 1) &quot;sps:sessions:86540ad5-c3f7-4588-88f6-031eeec16a0f&quot; 2) &quot;sps:sessions:expires:86540ad5-c3f7-4588-88f6-031eeec16a0f&quot; 3) &quot;sps:expirations:1549552860000&quot; redis:6379&gt; hgetall sps:sessions:36a41b20-a02e-4685-b359-a2b9b0aec2b1 1) &quot;creationTime&quot; 2) &quot;\xac\xed\x00\x05sr\x00\x0ejava.lang.Long;\x8b\xe4\x90\xcc\x8f#\xdf\x02\x00\x01J\x00\x05valuexr\x00\x10java.lang.Number\x86\xac\x95\x1d\x0b\x94\xe0\x8b\x02\x00\x00xp\x00\x00\x01h\xc8ef &quot; 3) &quot;maxInactiveInterval&quot; 4) &quot;\xac\xed\x00\x05sr\x00\x11java.lang.Integer\x12\xe2\xa0\xa4\xf7\x81\x878\x02\x00\x01I\x00\x05valuexr\x00\x10java.lang.Number\x86\xac\x95\x1d\x0b\x94\xe0\x8b\x02\x00\x00xp\x00\x00\x00\xb4&quot; 5) &quot;sessionAttr:36a41b20-a02e-4685-b359-a2b9b0aec2b1&quot; 6) &quot;\xac\xed\x00\x05sr\x00\x17com.cj.auth.entity.User\xc5\xbc\x00A\xb4\xb2z\x8c\x02\x00\x03L\x00\x02idt\x00\x13Ljava/lang/Integer;L\x00\x04namet\x00\x12Ljava/lang/String;L\x00\bpasswordq\x00~\x00\x02xpsr\x00\x11java.lang.Integer\x12\xe2\xa0\xa4\xf7\x81\x878\x02\x00\x01I\x00\x05valuexr\x00\x10java.lang.Number\x86\xac\x95\x1d\x0b\x94\xe0\x8b\x02\x00\x00xp\x00\x00\x00\x01t\x00\x05admint\x00\x18AZICOnu9cyUFFvBp3xi1AA==&quot; 7) &quot;lastAccessedTime&quot; 8) &quot;\xac\xed\x00\x05sr\x00\x0ejava.lang.Long;\x8b\xe4\x90\xcc\x8f#\xdf\x02\x00\x01J\x00\x05valuexr\x00\x10java.lang.Number\x86\xac\x95\x1d\x0b\x94\xe0\x8b\x02\x00\x00xp\x00\x00\x01h\xc8ef &quot;</code></pre></li><li><p>GET <code>/authentication</code></p><pre><code class="lang-bash"> &gt; curl -b cookie.txt -i -H &quot;Content-Type:application/json&quot; -X GET http://localhost:8080/micro-auth/session/authentication</code></pre></li><li><p>GET <code>/logout</code></p><pre><code class="lang-bash"> &gt; curl -b cookie.txt -i -H &quot;Content-Type:application/json&quot; -X GET http://localhost:8080/micro-auth/session/logout</code></pre></li></ol><h3 id="header-24">扩展：使用json方式序列化对象到Redis</h3><p>使用Jackson2JsonRedisSerializer解析Redis Value值</p><pre><code class="lang-java">@Configuration@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 180,    redisFlushMode=RedisFlushMode.ON_SAVE,    redisNamespace=&quot;sps&quot;)public class RedisConfig {    /* @Bean RedisTemplate&lt;Object,Object&gt; jsonRedisTemplate : 同上面NoSession示例 */    /* SessionRepository:      * 定义了创建、保存、删除以及检索session的方法     * (将Session实例真正保存到数据存储的逻辑是在这个接口的实现中编码完成的)     *      * RedisOperationsSessionRepository implements SessionRepository:     * 会在Redis中创建、存储和删除session     *      * {@link RedisHttpSessionConfiguration}     */    /* Method1: */    //    @SuppressWarnings(&quot;unchecked&quot;)    //    @Bean    //    public SessionRepository&lt;?&gt; sessionRepository( @Qualifier(&quot;jsonRedisTemplate&quot;) RedisOperations&lt;Object, Object&gt; redisTemplate){    //        RedisOperationsSessionRepository sessionRepository =  new RedisOperationsSessionRepository(redisTemplate);    //        // sessionRepository.setDefaultSerializer(initJsonSerializer());    //        sessionRepository.setDefaultSerializer((RedisSerializer&lt;Object&gt;) redisTemplate.getValueSerializer());    //        sessionRepository.setDefaultMaxInactiveInterval(180);    //        sessionRepository.setRedisKeyNamespace(&quot;sps&quot;);    //        sessionRepository.setRedisFlushMode(RedisFlushMode.ON_SAVE);    //        System.out.println(&quot;Create Customer RedisOperationsSessionRepository --- &quot;);    //        return sessionRepository;    //    }    /* Method2 - Recomend */    @Bean    public RedisSerializer&lt;Object&gt; springSessionDefaultRedisSerializer(@Qualifier(&quot;jsonRedisTemplate&quot;) RedisOperations&lt;Object, Object&gt; redisTemplate){        return (RedisSerializer&lt;Object&gt;)redisTemplate.getValueSerializer();    }}</code></pre><h3 id="header-25">Verify again</h3><ol><li><p>POST <code>/login</code></p><pre><code class="lang-bash"> &gt; curl -c cookie.txt -i -H &quot;Content-Type:application/json&quot; -X POST -d &#39;{&quot;name&quot;: &quot;admin&quot;, &quot;password&quot;:&quot;admin123&quot;}&#39; http://localhost:8080/micro-auth/session/login HTTP/1.1 200 Set-Cookie: SESSION=MzAxZWJkNjMtOWYzMy00NWJiLWFhZjMtMGM0ZjJlMzIyYWM1; Path=/micro-auth/; HttpOnly Content-Type: application/json;charset=UTF-8 Transfer-Encoding: chunked Date: Thu, 07 Feb 2019 16:27:43 GMT {&quot;success&quot;:true,&quot;code&quot;:1,&quot;data&quot;:{&quot;id&quot;:1,&quot;name&quot;:&quot;admin&quot;}} # check redis: redis:6379&gt; keys * 1) &quot;sps:sessions:293d00d7-359f-4b82-87be-bbbe1fc64c8d&quot; 2) &quot;sps:sessions:expires:293d00d7-359f-4b82-87be-bbbe1fc64c8d&quot; 3) &quot;sps:expirations:1549558500000&quot; redis:6379&gt; hgetall sps:sessions:293d00d7-359f-4b82-87be-bbbe1fc64c8d 1) &quot;creationTime&quot; 2) &quot;1549558319123&quot; 3) &quot;maxInactiveInterval&quot; 4) &quot;180&quot; 5) &quot;sessionAttr:293d00d7-359f-4b82-87be-bbbe1fc64c8d&quot; 6) &quot;[\&quot;com.cj.auth.entity.User\&quot;,{\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;admin\&quot;,\&quot;password\&quot;:\&quot;AZICOnu9cyUFFvBp3xi1AA==\&quot;}]&quot; 7) &quot;lastAccessedTime&quot; 8) &quot;1549558319123&quot; redis:6379&gt; ttl sps:sessions:expires:293d00d7-359f-4b82-87be-bbbe1fc64c8d (integer) 158 redis:6379&gt; smembers sps:expirations:1549558500000 1) &quot;\&quot;expires:293d00d7-359f-4b82-87be-bbbe1fc64c8d\&quot;&quot; # check cookie &gt; cat cookie.txt # Netscape HTTP Cookie File # http://curl.haxx.se/docs/http-cookies.html # This file was generated by libcurl! Edit at your own risk. HttpOnly_localhost    FALSE    /micro-auth/    FALSE    0    SESSION    MzAxZWJkNjMtOWYzMy00NWJiLWFhZjMtMGM0ZjJlMzIyYWM1</code></pre></li><li><p>GET <code>/authentication</code></p><pre><code class="lang-bash"> &gt; curl -b cookie.txt -i -H &quot;Content-Type:application/json&quot; -X GET http://localhost:8080/micro-auth/session/authentication HTTP/1.1 200 Content-Type: application/json;charset=UTF-8 Transfer-Encoding: chunked Date: Thu, 07 Feb 2019 16:27:48 GMT {&quot;success&quot;:true,&quot;code&quot;:1,&quot;data&quot;:{&quot;id&quot;:1,&quot;name&quot;:&quot;admin&quot;}} # check redis: redis:6379&gt; keys * 1) &quot;sps:expirations:1549558560000&quot;        # new 2) &quot;sps:sessions:293d00d7-359f-4b82-87be-bbbe1fc64c8d&quot; 3) &quot;sps:sessions:expires:293d00d7-359f-4b82-87be-bbbe1fc64c8d&quot; redis:6379&gt; hgetall sps:sessions:293d00d7-359f-4b82-87be-bbbe1fc64c8d 1) &quot;creationTime&quot; 2) &quot;1549558319123&quot; 3) &quot;maxInactiveInterval&quot; 4) &quot;180&quot; 5) &quot;sessionAttr:293d00d7-359f-4b82-87be-bbbe1fc64c8d&quot; 6) &quot;[\&quot;com.cj.auth.entity.User\&quot;,{\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;admin\&quot;,\&quot;password\&quot;:\&quot;AZICOnu9cyUFFvBp3xi1AA==\&quot;}]&quot; 7) &quot;lastAccessedTime&quot; 8) &quot;1549558358599&quot;                        # changed redis:6379&gt; ttl sps:sessions:expires:293d00d7-359f-4b82-87be-bbbe1fc64c8d (integer) 166                            # changed</code></pre></li><li><p>GET <code>/logout</code></p><pre><code class="lang-bash"> &gt; curl -b cookie.txt -i -H &quot;Content-Type:application/json&quot; -X GET http://localhost:8080/micro-auth/session/logout HTTP/1.1 200 Content-Type: application/json;charset=UTF-8 Transfer-Encoding: chunked Date: Thu, 07 Feb 2019 16:28:38 GMT {&quot;success&quot;:true,&quot;code&quot;:1,&quot;data&quot;:null} # check redis: redis:6379&gt; keys * 1) &quot;sps:sessions:293d00d7-359f-4b82-87be-bbbe1fc64c8d&quot; 2) &quot;sps:expirations:1549558680000&quot;                                # new 3) &quot;sps:sessions:expires:293d00d7-359f-4b82-87be-bbbe1fc64c8d&quot; redis:6379&gt; hgetall sps:sessions:293d00d7-359f-4b82-87be-bbbe1fc64c8d 1) &quot;creationTime&quot; 2) &quot;1549558319123&quot; 3) &quot;maxInactiveInterval&quot; 4) &quot;180&quot; 5) &quot;sessionAttr:293d00d7-359f-4b82-87be-bbbe1fc64c8d&quot; 6) &quot;&quot;                                    # removed 7) &quot;lastAccessedTime&quot; 8) &quot;1549558447429&quot;                        # changed redis:6379&gt; ttl sps:sessions:expires:293d00d7-359f-4b82-87be-bbbe1fc64c8d (integer) 151</code></pre></li><li><p>GET <code>/authentication</code></p><pre><code class="lang-bash"> &gt; curl -b cookie.txt -i -H &quot;Content-Type:application/json&quot; -X GET http://localhost:8080/micro-auth/session/authentication HTTP/1.1 200 Content-Type: application/json;charset=UTF-8 Transfer-Encoding: chunked Date: Thu, 07 Feb 2019 16:29:58 GMT {&quot;success&quot;:true,&quot;code&quot;:1,&quot;data&quot;:null} # check redis: redis:6379&gt; keys * 1) &quot;sps:sessions:301ebd63-9f33-45bb-aaf3-0c4f2e322ac5&quot; redis:6379&gt; keys * (empty list or set)</code></pre></li></ol><h3 id="header-26">Client：简化测试版</h3><pre><code class="lang-java">@RunWith(SpringRunner.class)@SpringBootTest(webEnvironment=SpringBootTest.WebEnvironment.RANDOM_PORT)public class ServiceCallAuthNoSessionTest {    @Autowired    private TestRestTemplate restTemplate;    private String authURL=&quot;http://localhost:8080/micro-auth/session&quot;;    private String cookie=&quot;&quot;;    private String name=&quot;admin&quot;;    private String password=&quot;admin123&quot;;    @Test    public void callTest(){        //getAuthentication        callGetAuthentication();        // login        callLoginTest();        // callGetAuthentication        callGetAuthentication();        // logout        callLogoutTest();        // getAuthentication        callGetAuthentication();    }    @Test    public void callLoginTest(){        System.out.println(&quot;call login...&quot;);        HttpHeaders headers = new HttpHeaders();         headers.setContentType(MediaType.APPLICATION_JSON);        Map&lt;String,String&gt; userMap=new HashMap&lt;String,String&gt;();        userMap.put(&quot;name&quot;, name);        userMap.put(&quot;password&quot;, password);        HttpEntity&lt;Map&gt; entity=new HttpEntity&lt;Map&gt;(userMap,headers);        HttpEntity&lt;Map&gt; response=restTemplate.exchange(authURL+&quot;/login&quot;,HttpMethod.POST,entity,Map.class);        System.out.println(response);        cookie=(String)response.getHeaders().getFirst(HttpHeaders.SET_COOKIE);        System.out.println(&quot;cookie:&quot;+cookie);    }    @Test    public void callLogoutTest(){        System.out.println(&quot;call logout...&quot;);        HttpHeaders headers = new HttpHeaders();         headers.set(HttpHeaders.COOKIE,cookie);         headers.setContentType(MediaType.APPLICATION_JSON);        HttpEntity&lt;String&gt; entity=new HttpEntity&lt;String&gt;(null,headers);        HttpEntity&lt;String&gt; response=restTemplate.exchange(authURL+&quot;/logout&quot;,HttpMethod.GET,entity,String.class);        System.out.println(response);    }    @Test    public void callGetAuthentication(){        System.out.println(&quot;call getAuthentication...&quot;);        HttpHeaders headers = new HttpHeaders();         headers.set(HttpHeaders.COOKIE,cookie);         headers.setContentType(MediaType.APPLICATION_JSON);        HttpEntity&lt;String&gt; entity=new HttpEntity&lt;String&gt;(null,headers);        HttpEntity&lt;Map&gt; response=restTemplate.exchange(authURL+&quot;/authentication&quot;,HttpMethod.GET,entity,Map.class);        System.out.println(response);    }}</code></pre><p>Run Junit Test: callTest</p><pre><code>call getAuthentication...&lt;200,{success=true, code=1, data=null},{Set-Cookie=[SESSION=ZmM1NDQ1M2EtZTU4ZC00NTNmLWI5ODEtNWQ0YmUyODI3MmE0; Path=/micro-auth/; HttpOnly], Content-Type=[application/json;charset=UTF-8], Transfer-Encoding=[chunked], Date=[Sat, 09 Feb 2019 07:02:26 GMT]}&gt;call login...&lt;200,{success=true, code=1, data={id=1, name=admin}},{Set-Cookie=[SESSION=ZmYxNDJiNTctNGU5Ny00MzFjLWFkMWYtNzkwMTJlMmUzZjIy; Path=/micro-auth/; HttpOnly], Content-Type=[application/json;charset=UTF-8], Transfer-Encoding=[chunked], Date=[Sat, 09 Feb 2019 07:02:26 GMT]}&gt;cookie:SESSION=ZmYxNDJiNTctNGU5Ny00MzFjLWFkMWYtNzkwMTJlMmUzZjIy; Path=/micro-auth/; HttpOnlycall getAuthentication...&lt;200,{success=true, code=1, data={id=1, name=admin}},{Content-Type=[application/json;charset=UTF-8], Transfer-Encoding=[chunked], Date=[Sat, 09 Feb 2019 07:02:26 GMT]}&gt;call logout...&lt;200,{&quot;success&quot;:true,&quot;code&quot;:1,&quot;data&quot;:null},{Content-Type=[application/json;charset=UTF-8], Transfer-Encoding=[chunked], Date=[Sat, 09 Feb 2019 07:02:26 GMT]}&gt;call getAuthentication...&lt;200,{success=true, code=1, data=null},{Content-Type=[application/json;charset=UTF-8], Transfer-Encoding=[chunked], Date=[Sat, 09 Feb 2019 07:02:26 GMT]}&gt;</code></pre><h2 id="header-27">Reference</h2><p><a href="https://github.com/sixDegree/micro-demo" target="_blank" rel="noopener">My demo: auth-demo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;SpringBoot Redis + Demo&lt;/li&gt;
&lt;li&gt;应用：Session持久化：NoSession方案,SpringSession方案&lt;/li&gt;
&lt;li&gt;方案：NoSession示例&lt;/li&gt;
&lt;li&gt;方案：SpringSession示例&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="MicroService" scheme="http://sixdegree.github.io/tags/MicroService/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件 RabbitMQ</title>
    <link href="http://sixdegree.github.io/2019/01/05/Rabbitmq.html"/>
    <id>http://sixdegree.github.io/2019/01/05/Rabbitmq.html</id>
    <published>2019-01-04T16:00:00.000Z</published>
    <updated>2019-03-09T09:51:54.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>AMQP: Advanced Message Queuing Protocol</li><li>RabbitMQ: Producer -&gt; VirtualHost(Exchange -&gt; Binding:routingKey,headers,all,… -&gt; Queue) -&gt; Consumer</li><li>使用Docker安装RabbitMQ</li><li>Demo: Direct/Topic/Headers/Fanout Exchange</li><li>Demo: Exchange object</li><li>Demo: Reliability send</li></ol><a id="more"></a><h2 id="header-1">Start</h2><p><a href="http://www.rabbitmq.com" target="_blank" rel="noopener">官网</a><br><a href="http://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">Quick Start</a></p><h3 id="header-2">AMQP</h3><ul><li>Advanced Message Queuing Protocol 高级消息队列协议</li><li>是一个进程间传递异步消息的网络协议</li><li>是应用层协议的一个开放标准，为面向消息的中间件设计(主要用于组件之间的解耦)</li><li>AMQP协议模型: pic</li></ul><h3 id="header-3">RabbitMQ</h3><ul><li>实现系统之间的双向解耦（eg: 当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层,存储转发这些消息)</li><li>基于AMQP协议实现的的消息中间件（一个开源的消息代理和队列服务器，用来通过普通协议在完全不同的应用之间共享数据）</li><li>底层使用Erlang语言编写，支持多种客户端</li><li>开源，高性能，稳定（集群模式丰富，表达式配置，HA模式，镜像队列模型）</li><li>能与SpringAMQP完美整合，API丰富</li></ul><p><strong> 注: </strong></p><ul><li>队列服务, 会有三个概念： 发消息者、队列、收消息者</li><li>RabbitMQ 在这个基本概念之上, 多了层抽象：在发消息者和队列之间, 加入了交换器 (Exchange)</li><li>这样发消息者和队列就没有直接联系, 转而变成发消息者把消息给交换器, 交换器根据调度策略再把消息再给队列</li></ul><p><strong> 核心概念: </strong></p><ul><li><p>Message: </p><ul><li>消息(Properties+Body)，Server和应用程序之间传送的数据</li><li>Properties: 可对消息进行修饰，比如消息的优先级，延迟等高级特性</li><li>Body: 消息体内容</li></ul></li><li><p>队列 Queue: </p><ul><li>Message Queue 消息队列，保存消息并将它们转发给消费者</li></ul></li><li><p>交换机 Exchange: </p><ul><li>接收消息并且转发到绑定的队列</li><li>根据路由键 Routing key(一个路由规则,用<code>.</code>分隔)将消息转发到绑定的队列</li><li>注: <ul><li>交换机不存储消息(如果没有 Queue Binding to Exchange, 它会直接丢弃掉 Producer 发送过来的消息) </li><li>在启用ack模式后，交换机找不到队列会返回错误</li></ul></li><li>交换机有四种类型:<ul><li>Direct(默认)：根据routingKey全文匹配寻找匹配的队列</li><li>Topic：与direct类似, 只是routingKey匹配上支持通配符：<code>*</code> 只能向后多匹配一层路径 ; <code>#</code> 可以向后匹配多层路径</li><li>Headers：根据请求消息中设置的header attribute参数类型（一组键值对）匹配队列（和routingKey没有关系）</li><li>Fanout：广播模式，转发消息到所有绑定队列（和routingKey没有关系）</li></ul></li></ul></li><li><p>绑定 Binding: </p><ul><li>Exchange和Queue之间的虚拟连接（多对多）</li><li>binding中可以包含Routing key</li></ul></li><li><p>虚拟主机 Virtual host: </p><ul><li>用于进行逻辑隔离，最上层的消息路由</li><li>一个Virtual host里面可以有若干个Exchange和Queue，但名称需不同</li><li>每一个RabbitMQ服务器都有一个默认的虚拟主机<code>/</code></li><li>用户只能在虚拟主机的粒度进行权限控制（eg: 要禁止A组访问B组的交换机/队列/绑定，须为A和B分别创建一个虚拟主机）</li></ul></li><li><p>服务端 Server: </p><ul><li>又称Broker，接受Client的连接，实现AMQP实体服务</li></ul></li><li><p>连接 Connection: </p><ul><li>应用程序与Broker的网络连接</li></ul></li><li><p>Channel: </p><ul><li>网络信道，消息读写的通道</li><li>Client可建立多个Channel，每个Channel代表一个会话任务</li><li>几乎所有的操作都在Channel中进行</li></ul></li></ul><p><img src="/2019/01/05/rabbitmq.png" alt="rabitmq">    </p><p><img src="/2019/01/05/rabbitmq-process.png" alt="rabitmq"></p><p><img src="/2019/01/05/rabbitmq-message.png" alt="rabitmq"></p><h3 id="header-4">搭建环境（安装RabbitMQ）</h3><p>使用Docker安装RabbitMQ</p><p><a href="https://docs.docker.com/samples/library/rabbitmq/" target="_blank" rel="noopener">docker rabbitmq</a><br><a href="https://hub.docker.com/_/rabbitmq" target="_blank" rel="noopener">docker hub</a></p><ol><li><p>pull rabbitmq image</p><pre><code class="lang-bash"> $ docker pull rabbitmq:3.7.8-management</code></pre></li><li><p>rabbitmq server container</p><pre><code class="lang-bash"> # simplest: # http://container-ip:15672 # guest/guest # docker run -d --hostname my-rabbit --name micro-rabbit rabbitmq:3.7.8-management # $ docker run -d --name micro-rabbit -p 5672:5672 -p 15672:15672 -v `pwd`/rabbitmq:/var/lib/rabbitmq --hostname myRabbit -e RABBITMQ_DEFAULT_VHOST=my_vhost -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin RABBITMQ_ERLANG_COOKIE=&#39;cj&#39; rabbitmq:3.7.8-management $ docker run -d --name micro-rabbit -p 5672:5672 -p 15672:15672 --hostname myRabbit -e RABBITMQ_DEFAULT_VHOST=my_vhost -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -e RABBITMQ_ERLANG_COOKIE=&#39;cj&#39; rabbitmq:3.7.8-management $ docker logs micro-rabbit # visit: # http://localhost:15672/ # admin/admin $ docker exec -it micro-rabbit bash root@myRabbit:/# rabbitmq-plugins list root@myRabbit:/# rabbitmq-plugins enable rabbitmq_management root@myRabbit:/# rabbitmq-server</code></pre></li><li><p>rabbitmq client container</p><pre><code class="lang-bash"> $ docker run -it --rm --link micro-rabbit:myRabbit --name rabbit-client -e RABBITMQ_ERLANG_COOKIE=&#39;cj&#39; rabbitmq:3.7.8-management bash root@f2a2d3d27c75:/# rabbitmqctl -n rabbit@myRabbit list_users Listing users ... admin   [administrator] $ docker run -it --rm --link micro-rabbit:myRabbit --name rabbit-client -e RABBITMQ_ERLANG_COOKIE=&#39;cj&#39; -e RABBITMQ_NODENAME=rabbit@myRabbit rabbitmq:3.7.8-management bash root@3863ca585892:/# rabbitmqctl list_users Listing users ... admin    [administrator]</code></pre></li></ol><h2 id="header-5">Demo</h2><h3 id="header-6">dependency &amp; config</h3><ol><li><p>pom.xml</p><pre><code class="lang-xml"> &lt;dependency&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt;</code></pre></li><li><p>application.yml</p><pre><code> server:   port: 8080   servlet:     context-path: /rabbit-demo spring:   rabbitmq:     addresses: localhost:5672     username: admin     password: admin     virtual-host: my_vhost     connection-timeout: 15000     # add below for consumer:     listener:       simple:         acknowledge-mode: manual         prefetch: 1         concurrency: 5         max-concurrency: 10</code></pre></li></ol><h3 id="header-7">Direct Exchange</h3><ul><li>默认Exxchange，根据<code>routingKey</code>全文匹配寻找匹配的队列 </li><li><code>Producer -&gt; Exchange -&gt; (routingKey) -&gt; Queue -&gt; Consumer</code></li><li>Demo case:<ul><li>Bean:<ul><li>queue(direct.s1)</li><li>queue(direct.s2)</li></ul></li><li>Default binding:<ul><li>defaultExchange -&gt; routingKey:<code>direct.s1</code> -&gt; queue(direct.s1)</li><li>defaultExchange -&gt; routingKey:<code>direct.s2</code> -&gt; queue(direct.s2)</li></ul></li><li>Send to defaultExchange:<ul><li>msg with routingKey: <code>direct.s1,direct.s1.user</code> -&gt; <code>consume queue(direct.s1): direct.s1</code></li><li>msg with routingKey: <code>direct.s2,direct.s2.user.role</code> -&gt; <code>consume queue(direct.s2): direct.s2</code></li></ul></li></ul></li></ul><pre><code class="lang-java">@SpringBootApplication@Configurationpublic class DirectExchangeDemoApp {    public static final String RoutingKey_S1=&quot;direct.s1&quot;;    public static final String RoutingKey_S2=&quot;direct.s2&quot;;    public static void main( String[] args ) throws IOException{        ConfigurableApplicationContext ctx = SpringApplication.run(DirectExchangeDemoApp.class, args);        QueueSender sender=ctx.getBean(QueueSender.class);        sender.send(DirectExchangeDemoApp.RoutingKey_S1,&quot;Hello world &quot;+System.currentTimeMillis());        sender.send(DirectExchangeDemoApp.RoutingKey_S1+&quot;.user&quot;,&quot;Hello world &quot;+System.currentTimeMillis());        sender.send(DirectExchangeDemoApp.RoutingKey_S2,&quot;Hello world &quot;+System.currentTimeMillis());        sender.send(DirectExchangeDemoApp.RoutingKey_S2+&quot;.user.role&quot;,&quot;Hello world &quot;+System.currentTimeMillis());    }    // config    @Bean    public Queue s1Queue() {        return new Queue(DirectExchangeDemoApp.RoutingKey_S1);        //配置一个routingKey为direct.s1的消息队列    }    @Bean    public Queue s2Queue() {        return new Queue(DirectExchangeDemoApp.RoutingKey_S2);    }    // sender    @Component    public class QueueSender {        @Autowired        private AmqpTemplate rabbitTemplate;        public void send(String routingKey,String msg){            System.out.println(&quot;send &quot;+routingKey+&quot; : &quot;+msg);            rabbitTemplate.convertAndSend(routingKey, msg);        }    }    // receiver    @Component    @RabbitListener(queues = {DirectExchangeDemoApp.RoutingKey_S1,DirectExchangeDemoApp.RoutingKey_S2})    public class QueueReceiver {        @RabbitHandler        public void receive(@Payload String msg,@Headers Map&lt;String,Object&gt; headers,Channel channel)                 throws IOException {            System.out.println(&quot;consume queue(&quot;+headers.get(AmqpHeaders.CONSUMER_QUEUE)+&quot;)&quot;                    +&quot; routingKey(&quot;+headers.get(AmqpHeaders.RECEIVED_ROUTING_KEY)+&quot;)&quot;                    +&quot; msg:&quot;+msg);            ;            Long deliveryTag=(Long)headers.get(AmqpHeaders.DELIVERY_TAG);            channel.basicAck(deliveryTag, false);        }    }}</code></pre><h3 id="header-8">Topic Exchange</h3><ul><li>与<code>direct exchange</code>类似, 只是<code>routing_key</code>匹配上支持通配符：<code>*</code> 只能向后多匹配一层路径 ; <code>#</code> 可以向后匹配多层路径 </li><li><code>Producer -&gt; Exchange -&gt; (routingKey) -&gt; Queue -&gt; Consumer</code></li><li>Demo Case:<ul><li>Bean:<ul><li>queue(topic.s1),queue(topic.s2),queue(123)</li><li>topicExchange</li><li>binding:<ul><li>topicExchange -&gt; routingKey: <code>topic.s1.*</code> -&gt; queue(topic.s1) </li><li>topicExchange -&gt; routingKey: <code>topic.s2.#</code> -&gt; queue(topic.s2)</li></ul></li></ul></li><li>Default binding:<ul><li>defaultExchange -&gt; routingKey: <code>123</code> -&gt; queue(123)</li></ul></li><li>Send to topicExchange:<ul><li>msg with routingKey: <code>123</code>    -&gt; <code>no consume</code></li><li>msg with routingKey: <code>topic.s1,topic.s1.user,topic.s1.user.role</code> -&gt; <code>consume queue(topic.s1) routingKey(topic.s1.user)</code></li><li>msg with routingKey: <code>topic.s2,topic.s2.user,topic.s2.user.role</code> -&gt; <code>consume queue(topic.s2): all</code></li></ul></li></ul></li></ul><pre><code class="lang-java">@SpringBootApplicationpublic class TopicExchangeDemoApp {    public static void main( String[] args ) throws IOException, InterruptedException{        ConfigurableApplicationContext ctx = SpringApplication.run(TopicExchangeDemoApp.class, args);        QueueSender sender=ctx.getBean(QueueSender.class);        String routingKey=TopicExchangeConfig.RoutingKey_S2; // &quot;123&quot;,TopicExchangeConfig.RoutingKey_S1/S2        sender.send(routingKey,&quot;Hello world &quot;+System.currentTimeMillis());        sender.send(routingKey+&quot;.user&quot;,&quot;Hello World &quot;+System.currentTimeMillis());        sender.send(routingKey+&quot;.user.role&quot;,&quot;Hello World &quot;+System.currentTimeMillis());    }    // config    @Configuration    public class TopicExchangeConfig{        public final static String RoutingKey_S1=&quot;topic.s1&quot;;        public final static String RoutingKey_S2=&quot;topic.s2&quot;;        public final static String Exchange_Name=&quot;topicExchange&quot;;        // Queue        @Bean        public Queue s1Queue(){            return new Queue(RoutingKey_S1);        }        @Bean        public Queue s2Queue(){            return new Queue(RoutingKey_S2);        }        @Bean        public Queue testQueue() {            return new Queue(&quot;123&quot;);        }        // Exchange        @Bean        public TopicExchange exchange(){            return new TopicExchange(Exchange_Name);        }        // Binding        @Bean        public Binding bindingS1QueueAndExchange(Queue s1Queue, TopicExchange exchange){            return BindingBuilder.bind(s1Queue).to(exchange).with(RoutingKey_S1+&quot;.*&quot;);        }        @Bean        public Binding bingS2QueueAndExchange(Queue s2Queue,TopicExchange exchange){            return BindingBuilder.bind(s2Queue).to(exchange).with(RoutingKey_S2+&quot;.#&quot;);        }    }    // sender    @Component    public class QueueSender{        @Autowired        private AmqpTemplate rabbitTemplate;        public void send(String routingKey,String msg){            System.out.println(&quot;send routingKey(&quot;+routingKey+&quot;) :&quot;+msg);            rabbitTemplate.convertAndSend(TopicExchangeConfig.Exchange_Name, routingKey, msg);        }    }    // receiver    @Component    public class QueueReceiver{        @RabbitHandler        @RabbitListener(queues = {TopicExchangeConfig.RoutingKey_S1,TopicExchangeConfig.RoutingKey_S2,&quot;123&quot;})        public void receive(@Payload String msg,@Headers Map&lt;String,Object&gt; headers,Channel channel)                 throws IOException {            System.out.println(&quot;consume queue(&quot;+headers.get(AmqpHeaders.CONSUMER_QUEUE)+&quot;)&quot;                    +&quot; routingKey(&quot;+headers.get(AmqpHeaders.RECEIVED_ROUTING_KEY)+&quot;)&quot;                    +&quot; msg:&quot;+msg);            ;            Long deliveryTag=(Long)headers.get(AmqpHeaders.DELIVERY_TAG);            channel.basicAck(deliveryTag, false);        }    }}</code></pre><h3 id="header-9">Headers Exchange</h3><ul><li>根据请求消息中设置的header attribute参数类型（一组键值对）匹配队列（和routingKey没有关系）</li><li><code>Producer -&gt; Exchange -&gt; (headers) -&gt; Queue -&gt; Consumer</code></li><li>Demo case:<ul><li>Bean:<ul><li>queue(headers.s1),queueu(headers.s2),queue(123)</li><li>headersExchange</li><li>binding: <ul><li>headersExchange -&gt; <code>headers(&quot;from&quot;:&quot;Tom&quot; &amp;&amp; &quot;to&quot;:&quot;Lucy&quot;)</code> -&gt; queue(headers.s1)</li><li>headersExchange -&gt; <code>headers(&quot;from&quot;:&quot;Tom&quot; || &quot;to&quot;:&quot;Lucy&quot;)</code> -&gt; queue(headers.s2)</li></ul></li></ul></li><li>default Exchange:<ul><li>defaultExchange -&gt; routingKey:<code>123</code> -&gt; queue(123)</li></ul></li><li>Send to HeadersExchange with routingKey:123,headers.s1,headers.s1.user<ul><li>msg with <code>headers(&quot;from&quot;:&quot;Tom&quot; &amp;&amp; &quot;to&quot;:&quot;Lucy&quot;)</code> -&gt; <code>consume queue(headers.s1) &amp; queue(headers.s2)</code></li><li>msg with <code>headers(&quot;from&quot;:&quot;Tom&quot; ||&quot;to&quot;:&quot;Lucy&quot;)</code>  -&gt; <code>consume queue(headers.s2)</code></li><li>msg with <code>headers( !&quot;from&quot;:&quot;Tom&quot; &amp;&amp; ! &quot;from&quot;:&quot;Tom&quot;)</code> -&gt; <code>no consume</code></li></ul></li></ul></li></ul><pre><code class="lang-java">@SpringBootApplicationpublic class HeadersExchangeDemoApp {    public static void main( String[] args ) throws IOException, InterruptedException{        ConfigurableApplicationContext ctx = SpringApplication.run(HeadersExchangeDemoApp.class, args);        QueueSender sender=ctx.getBean(QueueSender.class);        Map&lt;String,Object&gt; headers=new HashMap&lt;String,Object&gt;();        //case1: send to s1,s1.user,s1.user.role =&gt; s1 &amp; s2 receive !        headers.put(&quot;from&quot;, &quot;Tom&quot;);        headers.put(&quot;to&quot;, &quot;Lucy&quot;);        headers.put(&quot;cc&quot;, &quot;Susan&quot;);//        //case2.1: send to s1,s1.user,s1.user.role =&gt; s1 no receive &amp; s2 receive !//        headers.put(&quot;from&quot;, &quot;Tom&quot;);//        headers.put(&quot;to&quot;, &quot;Lucy2&quot;);//        //case2.2: send to s1,s1.user,s1.user.role =&gt; s1 no receive &amp; s2 receive !//        headers.put(&quot;from&quot;, &quot;Tom&quot;);        //case3: send to s1,s1.user,s1.user.role =&gt; s1 &amp; s2 no receive !//        headers.put(&quot;from&quot;, &quot;Tom1&quot;);//        headers.put(&quot;to&quot;, &quot;Lucy1&quot;);        String routingKey=&quot;123&quot;;    // HeadersExchangeConfig.RoutingKey_S1        sender.send(routingKey,&quot;Hello world &quot;+System.currentTimeMillis(),headers);        sender.send(routingKey+&quot;.user&quot;,&quot;Hello World &quot;+System.currentTimeMillis(),headers);        sender.send(routingKey+&quot;.user.role&quot;,&quot;Hello World &quot;+System.currentTimeMillis(),headers);    }    // config    @Configuration    public class HeadersExchangeConfig{        public static final String RoutingKey_S1=&quot;headers.s1&quot;;        public static final String RoutingKey_S2=&quot;headers.s2&quot;;        public static final String Exchange_Name=&quot;headersExchange&quot;;        // queue        @Bean        public Queue s1Queue() {            return new Queue(RoutingKey_S1);        }        @Bean        public Queue s2Queue() {            return new Queue(RoutingKey_S2);        }        @Bean        public Queue testQueue() {            return new Queue(&quot;123&quot;);        }        // exchange        @Bean        public HeadersExchange exchange() {            return new HeadersExchange(Exchange_Name);        }         // binding        @Bean        public Binding bindS1QueueAndExchange(Queue s1Queue,HeadersExchange exchange) {            Map&lt;String,Object&gt; headerMap=new HashMap&lt;String,Object&gt;();            headerMap.put(&quot;from&quot;, &quot;Tom&quot;);            headerMap.put(&quot;to&quot;, &quot;Lucy&quot;);            return BindingBuilder.bind(s1Queue).to(exchange).whereAll(headerMap).match();        }        @Bean        public Binding bindS2QueueAndExchange(Queue s2Queue,HeadersExchange exchange) {            Map&lt;String,Object&gt; headerMap=new HashMap&lt;String,Object&gt;();            headerMap.put(&quot;from&quot;, &quot;Tom&quot;);            headerMap.put(&quot;to&quot;, &quot;Lucy&quot;);            return BindingBuilder.bind(s2Queue).to(exchange).whereAny(headerMap).match();        }    }    // sender    @Component    public class QueueSender{         @Autowired         private AmqpTemplate rabbitTemplate;         public void send(String routingKey,String msg,Map&lt;String,Object&gt; headers){            Message message = MessageBuilder.withBody(msg.getBytes()).copyHeaders(headers).build();            System.out.println(&quot;send routingKey(&quot;+routingKey+&quot;) :&quot;+(new String(message.getBody()))+&quot; &quot;+message.getMessageProperties());            rabbitTemplate.convertAndSend(HeadersExchangeConfig.Exchange_Name, routingKey, message);        }    }    // receiver    @Component    public class QueueReceiver{        @RabbitHandler        @RabbitListener(queues = {HeadersExchangeConfig.RoutingKey_S1,HeadersExchangeConfig.RoutingKey_S2,&quot;123&quot;})        public void receive(@Payload byte[] msg,@Headers Map&lt;String,Object&gt; headers,Channel channel)                 throws IOException {            System.out.println(&quot;consume queue(&quot;+headers.get(AmqpHeaders.CONSUMER_QUEUE)+&quot;)&quot;                    +&quot; routingKey(&quot;+headers.get(AmqpHeaders.RECEIVED_ROUTING_KEY)+&quot;)&quot;                    +&quot; msg: &quot;+(new String(msg))                    +&quot;, headers:&quot;+headers);            Long deliveryTag=(Long)headers.get(AmqpHeaders.DELIVERY_TAG);            channel.basicAck(deliveryTag, false);        }    }}</code></pre><h3 id="header-10">Fanout Exchange</h3><ul><li>广播模式，转发消息到所有绑定队列（和routingKey没有关系）</li><li><code>Producer -&gt; Exchange -&gt; (all) -&gt; Queue -&gt; Consumer</code></li><li>Demo Case:<ul><li>Bean:<ul><li>queue(fanout.s1),queue(fanout.s2),queue(123)</li><li>fanoutExchange</li><li>binding: FanoutExchange -&gt; all -&gt; queue(fanout.s1) &amp; queue(fanout.s2)</li></ul></li><li>Default binding:<ul><li>defaultExchange -&gt; routingKey: 123 -&gt; queue(123)</li></ul></li><li>Send to FanoutExchange with routingKey:<code>123,fanout.s1,fanout.s1.user,...</code> -&gt; <code>consume queue(fanout.s1) &amp; queue(fanout.s2)</code></li></ul></li></ul><pre><code class="lang-java">@SpringBootApplicationpublic class FanoutExchangeDemoApp {    public static void main( String[] args ) throws IOException, InterruptedException{        ConfigurableApplicationContext ctx = SpringApplication.run(FanoutExchangeDemoApp.class, args);        QueueSender sender=ctx.getBean(QueueSender.class);        String routingKey=&quot;123&quot;;    // FanoutExchangeConfig.RoutingKey_S1;        sender.send(routingKey,&quot;Hello world S1 &quot;+System.currentTimeMillis());        sender.send(routingKey+&quot;.user&quot;,&quot;Hello World S1.User &quot;+System.currentTimeMillis());        sender.send(routingKey+&quot;.user.role&quot;,&quot;Hello World S1.User.Role &quot;+System.currentTimeMillis());    }    // config    @Configuration    public class FanoutExchangeConfig{        public final static String RoutingKey_S1=&quot;fanout.s1&quot;;        public final static String RoutingKey_S2=&quot;fanout.s2&quot;;        public final static String Exchange_Name=&quot;fanoutExchange&quot;;        // Queue        @Bean        public Queue s1Queue(){            return new Queue(RoutingKey_S1);        }        @Bean        public Queue s2Queue(){            return new Queue(RoutingKey_S2);        }        @Bean        public Queue testQueue() {            return new Queue(&quot;123&quot;);        }        // Exchange        @Bean        public FanoutExchange exchange(){            return new FanoutExchange(Exchange_Name);        }        // Binding        @Bean        public Binding bindingS1QueueAndExchange(Queue s1Queue, FanoutExchange exchange){            return BindingBuilder.bind(s1Queue).to(exchange);        }        @Bean        public Binding bingS2QueueAndExchange(Queue s2Queue,FanoutExchange exchange){            return BindingBuilder.bind(s2Queue).to(exchange);        }    }    // sender    @Component    public class QueueSender{        @Autowired        private AmqpTemplate rabbitTemplate;        public void send(String routingKey,String msg){            System.out.println(&quot;send routingKey(&quot;+routingKey+&quot;) :&quot;+msg);            rabbitTemplate.convertAndSend(FanoutExchangeConfig.Exchange_Name, routingKey, msg);        }    }    // receiver    @Component    public class QueueReceiver{        @RabbitHandler        @RabbitListener(queues = {FanoutExchangeConfig.RoutingKey_S1,FanoutExchangeConfig.RoutingKey_S2,&quot;123&quot;})        public void receive(@Payload String msg,@Headers Map&lt;String,Object&gt; headers,Channel channel)                 throws IOException {            System.out.println(&quot;consume queue(&quot;+headers.get(AmqpHeaders.CONSUMER_QUEUE)+&quot;)&quot;                    +&quot; routingKey(&quot;+headers.get(AmqpHeaders.RECEIVED_ROUTING_KEY)+&quot;)&quot;                    +&quot; msg:&quot;+msg);            ;            Long deliveryTag=(Long)headers.get(AmqpHeaders.DELIVERY_TAG);            channel.basicAck(deliveryTag, false);        }    }}</code></pre><h2 id="header-11">扩展：传输对象</h2><h3 id="header-12">配置(Optional)</h3><p>rabbitmq-management界面setting (visit <code>http://localhost:15672</code>)</p><ul><li>Queues<ul><li>Add Queue,eg: <code>order-queue</code></li></ul></li><li>Exchanges <ul><li>Add Exchange,eg: <code>order-exchange</code> (type:<code>topic</code>)</li><li>Add Binding,eg: <code>order-queue</code> (routingKey: <code>order.#</code>)</li></ul></li></ul><h3 id="header-13">Producer</h3><ol><li><p>pom.xml</p><pre><code class="lang-xml"> &lt;dependency&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;     &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt;</code></pre></li><li><p>application.yml</p><pre><code> server:   port: 8080   servlet:     context-path: /rabbit-producer spring:   rabbitmq:     addresses: localhost:5672     username: admin     password: admin     virtual-host: my_vhost     connection-timeout: 15000     # for confirmCallback:     publisher-confirms: true</code></pre></li><li><p>Entity: Order(id,msgId,name)</p></li><li><p>Sender</p><pre><code class="lang-java"> package com.cj.rabbit.producer; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.amqp.rabbit.support.CorrelationData; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import com.cj.rabbit.entity.Order; @Component public class OrderSender {     @Autowired     private RabbitTemplate rabbitTemplate;     public void send(Order order) throws Exception{         CorrelationData correlationData=new CorrelationData();         correlationData.setId(order.getMsgId());         rabbitTemplate.convertAndSend(&quot;order-exchange&quot;,    // exchange             &quot;order.abcd&quot;,     // routingkey             order,            // 消息内容             correlationData // 消息唯一Id             );     } }</code></pre></li><li><p>main</p><pre><code class="lang-java"> @SpringBootApplication public class App {     public static void main( String[] args ){         SpringApplication.run(App.class, args);     } }</code></pre></li><li><p>Test</p><pre><code class="lang-java"> @RunWith(SpringRunner.class) @SpringBootTest public class AppTest{     @Autowired     private OrderSender orderSender;     @Test     public void testOrderSend() throws Exception{         Order order=new Order();         order.setId(&quot;201901070002&quot;);         order.setName(&quot;Test Order2&quot;);         order.setMsgId(System.currentTimeMillis()+&quot;$&quot;+UUID.randomUUID().toString());         orderSender.send(order);     } }</code></pre></li></ol><h3 id="header-14">Consumer</h3><ol><li><p>pom.xml</p><pre><code class="lang-xml"> &lt;dependency&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;     &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt;</code></pre></li><li><p>application.xml</p><pre><code> server:   port: 8090   servlet:     context-path: /rabbit-consumer spring:   rabbitmq:     addresses: localhost:5672     username: admin     password: admin     virtual-host: my_vhost     connection-timeout: 15000     # add below for consumer listener config:     listener:       simple:         acknowledge-mode: manual         prefetch: 1         concurrency: 5         max-concurrency: 10</code></pre></li><li><p>Entity: Order(id,msgId,name)</p></li><li><p>Receiver</p><pre><code class="lang-java"> package com.cj.rabbit.consumer; import java.util.Map; import org.springframework.amqp.rabbit.annotation.Exchange; import org.springframework.amqp.rabbit.annotation.Queue; import org.springframework.amqp.rabbit.annotation.QueueBinding; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.amqp.support.AmqpHeaders; import org.springframework.messaging.handler.annotation.Headers; import org.springframework.messaging.handler.annotation.Payload; import org.springframework.stereotype.Component; import com.cj.rabbit.entity.Order; import com.rabbitmq.client.Channel; @Component public class OrderReceiver {     @RabbitListener(     // Queue,Exchange,Binding 不存在的会自动创建         bindings=@QueueBinding(             value=@Queue(value=&quot;order-queue&quot;,durable=&quot;true&quot;),             exchange=@Exchange(name=&quot;order-exchange&quot;,durable=&quot;true&quot;,type=&quot;topic&quot;),             key=&quot;order.#&quot;         )     )     @RabbitHandler     public void onOrderMessage(@Payload Order order,@Headers Map&lt;String,Object&gt; headers,Channel channel)          throws Exception{         System.err.println(&quot;Received Message&quot;);         System.err.println(&quot;order Id:&quot;+order.getId());         // 手工签收：         Long deliveryTag=(Long)headers.get(AmqpHeaders.DELIVERY_TAG);         channel.basicAck(deliveryTag,false); // 给MQ主动回送一个信息，说明已签收     } }</code></pre></li><li><p>main</p><pre><code class="lang-java"> @SpringBootApplication public class App {     public static void main( String[] args ){         SpringApplication.run(App.class, args);     } }</code></pre></li></ol><h2 id="header-15">扩展：可靠性投递</h2><p><img src="/2019/01/05/reliable-sending.png" alt="Reliable Sending"></p><h3 id="header-16">Summary</h3><ul><li><p>Entity (implements Serializable):</p><ul><li>Order:<ul><li>Long id: <code>System.currentTimeMillis()</code></li><li>String msgId: <code>System.currentTimeMillis()+&quot;$&quot;+UUID.randomUUID().toString()</code></li><li>String name</li></ul></li><li>TransportLog: <ul><li>String msgId: <code>order.getMsgId()</code></li><li>String content: <code>JSON.toJSONString(order)</code></li><li>String status: <code>Sending</code>,<code>Success</code>,<code>Fail</code></li><li>Integer retryCount (&lt;=3)</li><li>Date nextTime: now+10s</li><li>Date createTime: now</li><li>Date updateTime</li></ul></li></ul></li><li><p>Service: TransportLogService:</p><ul><li>list(): list all</li><li>listRetry(): list records that status==”Sending” &amp;&amp; nextTime before now</li><li>changeStatus(msgId,status)</li><li>addRetryCount(msgId): retryCount++ &amp;&amp; nextTime=now+10s</li><li>create(msgId,content): status=<code>Sending</code>,retryCount=0,nextTime=now+10s</li><li>save(transportLog)</li></ul></li><li><p>OrderQueueSender: </p><ul><li>confirmCallback: if ack then do <code>transportLogService.changeStatus(correlationData.getId(),&quot;Success&quot;)</code></li><li>send: <code>rabbitTemplate.convertAndSend(Order_Exchange,routingKey,order,new CorrelationData(order.getMsgId()))</code></li><li>application.xml:<code>spring.rabbitmq.publisher-confirms=true</code> </li></ul></li><li><p>OrderQueueReceiver:</p><ul><li><code>@RabbitListener</code> &amp;&amp; <code>@RabbitHandler</code> &amp;&amp; <code>channel.basicAck((Long)headers.get(AmqpHeaders.DELIVERY_TAG),false);</code></li></ul></li><li><p>ScheduleTask: RetryMessageTasker</p><ul><li>@Scheduled(initialDelay=3000,fixedDelay=1000) reSend()<ul><li>transportLogService.listRetry()</li><li>transportLog.getRetryCount()&gt;=3 -&gt; stop retry sending,change status to <code>Fail</code></li><li>transportLog.getRetryCount()<3 -=""> addRetryCount &amp;&amp; orderQueueSender.send</3></li></ul></li></ul></li><li><p>TaskSchedulerConfig implements <code>SchedulingConfigurer</code> : spring默认创建一个单线程池，这里通过taskRegistrar设置一个自定义线程池</p><ul><li><code>@Configuration</code> &amp;&amp; <code>@EnableScheduling</code></li><li><code>@override configureTasks(ScheduledTaskRegistrar taskRegistrar)</code></li><li><code>Executors.newScheduledThreadPool(100)</code></li></ul></li></ul><h3 id="header-17">Dependency</h3><p>pom.xml</p><pre><code class="lang-xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.56&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="header-18">Config</h3><p>application.yml</p><pre><code>server:  port: 8080  servlet:    context-path: /rabbit-demospring:  rabbitmq:    addresses: localhost:5672    username: admin    password: admin    virtual-host: my_vhost    connection-timeout: 15000    # for confirmCallback:    publisher-confirms: true    # add below for consumer:    listener:      simple:        acknowledge-mode: manual        prefetch: 1        concurrency: 5        max-concurrency: 10</code></pre><h3 id="header-19">Code</h3><pre><code class="lang-java">@SpringBootApplicationpublic class SendConfirmDemoApp {    public static void main( String[] args ) throws IOException, InterruptedException{        ConfigurableApplicationContext ctx = SpringApplication.run(SendConfirmDemoApp.class, args);        OrderQueueSender sender=ctx.getBean(OrderQueueSender.class);        TransportLogService transportLogService=ctx.getBean(TransportLogService.class);        // prepare testing transportLog records        Order order = null;        for(int i=0;i&lt;=4;i++) {            order=new Order();            order.setId(System.currentTimeMillis());            order.setMsgId(&quot;0&quot;+i+&quot;-&quot;+order.getId()+&quot;$&quot;+UUID.randomUUID().toString());            order.setName(&quot;TestSending0&quot;+i);            transportLogService.create(order.getMsgId(), JSON.toJSONString(order),&quot;Sending&quot;,i,10);        }        for(int i=5;i&lt;=8;i++) {            order=new Order();            order.setId(System.currentTimeMillis());            order.setMsgId(&quot;0&quot;+i+&quot;-&quot;+order.getId()+&quot;$&quot;+UUID.randomUUID().toString());            order.setName(&quot;TestSuccess0&quot;+i);            transportLogService.create(order.getMsgId(), JSON.toJSONString(order),&quot;Success&quot;,i-5,10);        }        order=new Order();        order.setId(System.currentTimeMillis());        order.setMsgId(&quot;09&quot;+&quot;-&quot;+order.getId()+&quot;$&quot;+UUID.randomUUID().toString());        order.setName(&quot;TestFail09&quot;);        transportLogService.create(order.getMsgId(), JSON.toJSONString(order),&quot;Fail&quot;,0,10);        // send        String routingKey=&quot;order.123&quot;;        order = new Order();        order.setId(System.currentTimeMillis());        order.setMsgId(order.getId()+&quot;$&quot;+UUID.randomUUID().toString());        order.setName(&quot;Hello&quot;);        transportLogService.create(order.getMsgId(), JSON.toJSONString(order));        sender.send(routingKey,order);    }    public static final String Order_Exchange=&quot;order-exchange&quot;;    public static final String Order_Queue=&quot;order-queue&quot;;    public static final String Order_RoutingKey=&quot;order.#&quot;;    public static final String Order_RoutingKey_Prefix=&quot;order.&quot;;    // sender    @Component    public class OrderQueueSender{        @Autowired        private RabbitTemplate rabbitTemplate;        /*public void send(String routingKey,Order order){            System.out.println(&quot;send order :&quot;+order);            rabbitTemplate.convertAndSend(Order_Exchange,routingKey,order,new CorrelationData(order.getMsgId()));        }*/        @Autowired        private TransportLogService transportLogService;        private final ConfirmCallback confirmCallback=new RabbitTemplate.ConfirmCallback(){            @Override            public void confirm(CorrelationData correlationData,boolean ack,String cause){                System.out.println(&quot;confirm correlationData:&quot;+correlationData+&quot;, ack:&quot;+ack+&quot;, cause:&quot;+cause);                if(ack)                    transportLogService.changeStatus(correlationData.getId(),&quot;Success&quot;);                else                    System.err.println(&quot;confirm error:&quot;+cause);            }        };        public void send(String routingKey,Order order){            System.out.println(&quot;send order :&quot;+order);            rabbitTemplate.setConfirmCallback(confirmCallback);            rabbitTemplate.convertAndSend(Order_Exchange,routingKey,order,new CorrelationData(order.getMsgId()));        }    }    // receiver    @Component    public class OrderQueueReceiver {        @RabbitHandler        @RabbitListener(            bindings=@QueueBinding(                value=@Queue(name=Order_Queue,durable=&quot;true&quot;),                exchange=@Exchange(name=Order_Exchange,durable=&quot;true&quot;,type=&quot;topic&quot;),                key=Order_RoutingKey            )        )//        @RabbitListener(queues = {Order_Queue})        public void onOrderMessage(@Payload Order order,@Headers Map&lt;String,Object&gt; headers,Channel channel)             throws Exception{            System.out.println(&quot;consume queue(&quot;+headers.get(AmqpHeaders.CONSUMER_QUEUE)+&quot;)&quot;                    +&quot; routingKey(&quot;+headers.get(AmqpHeaders.RECEIVED_ROUTING_KEY)+&quot;)&quot;                    +&quot; order:&quot;+order);            ;            // 手工签收：            Long deliveryTag=(Long)headers.get(AmqpHeaders.DELIVERY_TAG);            channel.basicAck(deliveryTag,false); // 给MQ主动回送一个信息，说明已签收        }    }    // schedule Task    @Component    public class RetryMessageTasker {        @Autowired        private OrderQueueSender orderQueueSender;        @Autowired        private TransportLogService transportLogService;        @Scheduled(initialDelay=3000,fixedDelay=1000)        public void reSend(){            System.out.println(&quot;trigger reSend()&quot;);            List&lt;TransportLog&gt; list=transportLogService.listRetry();    // status=&#39;Sending&#39; and nextTime&lt;=sysdate()            list.forEach(transportLog-&gt;{                System.out.println(transportLog);                String msgId= transportLog.getMsgId();                Integer retryCount=transportLog.getRetryCount();                if(transportLog.getRetryCount()&gt;=3){                    System.out.println(&quot;Fail &quot;+retryCount+&quot; times:&quot;+msgId);                    transportLogService.changeStatus(msgId,&quot;Fail&quot;);        // stop retry sending                }else{                    System.out.println(&quot;Retry &quot;+(retryCount+1)+&quot; times:&quot;+msgId);                    transportLogService.addRetryCount(msgId);                    Order reSendOrder=JSON.parseObject(transportLog.getContent(),Order.class);                    orderQueueSender.send(Order_RoutingKey_Prefix+retryCount,reSendOrder);                }            });        }        @Scheduled(initialDelay=1000*10,fixedDelay=5*1000)        public void listTransportLogs() {            System.out.println(&quot;trigger listTransportLogs()&quot;);            List&lt;TransportLog&gt; list=transportLogService.list();            for(TransportLog log:list)                System.out.println(log);        }    }    // schedule: spring默认会创建一个单线程池,通过taskRegistrar设置自定义线程池    @Configuration    @EnableScheduling    public class TaskSchedulerConfig implements SchedulingConfigurer{        @Override        public void configureTasks(ScheduledTaskRegistrar taskRegistrar){            taskRegistrar.setScheduler(taskScheduler());        }        @Bean(destroyMethod=&quot;shutdown&quot;)        public Executor taskScheduler(){            return Executors.newScheduledThreadPool(100);        }    }    // entity: Order    public static class Order implements Serializable {        private static final long serialVersionUID = -698577629696435935L;        private Long id;        private String name;        private String msgId;        /* getter &amp; setter &amp; toString */    }    // entity: TransportLog    public static class TransportLog implements Serializable{        private static final long serialVersionUID = 4330091676523447230L;        private String msgId;        private String content;        private String status;        private Integer retryCount;        private Date nextTime;        private Date createTime;        private Date updateTime;        /* getter &amp; setter &amp; toString */    }    // service: TransportLogService    @Component    public class TransportLogService{        private final ConcurrentMap&lt;String,TransportLog&gt; data = new ConcurrentHashMap&lt;String,TransportLog&gt;();        public List&lt;TransportLog&gt; list(){            return new ArrayList&lt;TransportLog&gt;(data.values());        }        public List&lt;TransportLog&gt; listRetry(){            Date now = new Date();            List&lt;TransportLog&gt; list=new ArrayList&lt;TransportLog&gt;();            for(String key:data.keySet()) {                TransportLog transportLog=data.get(key);                if(&quot;Sending&quot;==transportLog.getStatus() &amp;&amp; transportLog.getNextTime().before(now))                    list.add(transportLog);            }            return list;        }        public TransportLog changeStatus(String msgId,String status){            TransportLog transportLog=data.get(msgId);            if(transportLog==null)                return null;            transportLog.setStatus(status);            transportLog.setUpdateTime(new Date());            data.replace(msgId, transportLog);            return transportLog;        }        public TransportLog addRetryCount(String msgId) {            TransportLog transportLog=data.get(msgId);            if(transportLog==null)                return null;            Date now=new Date();            Calendar c=Calendar.getInstance();            c.setTime(now);            c.add(Calendar.SECOND, 10);            Integer retryCount=transportLog.getRetryCount()==null?0:transportLog.getRetryCount();            transportLog.setRetryCount(retryCount+1);            transportLog.setNextTime(c.getTime());            transportLog.setUpdateTime(now);            data.replace(msgId, transportLog);            return transportLog;        }        public TransportLog create(String msgId,String content) {            return create(msgId,content,&quot;Sending&quot;,0,10);        }        // for test:        public TransportLog create(String msgId,String content,String initialStatus,Integer intialRetryCount,Integer intervalSeconds){            Date now=new Date();            Calendar c=Calendar.getInstance();            c.setTime(now);            c.add(Calendar.SECOND, intervalSeconds);            TransportLog transportLog=new TransportLog();            transportLog.setMsgId(msgId);            transportLog.setContent(content);            transportLog.setStatus(initialStatus);            transportLog.setRetryCount(intialRetryCount);            transportLog.setNextTime(c.getTime());            transportLog.setCreateTime(now);            transportLog.setUpdateTime(now);            data.putIfAbsent(msgId, transportLog);            return transportLog;        }    }}</code></pre><h2 id="header-20">Reference</h2><ul><li><a href="https://github.com/sixDegree/micro-demo" target="_blank" rel="noopener">My demo: rabbit-demo</a></li><li><a href="https://blog.csdn.net/weixin_37641832/article/details/83270778" target="_blank" rel="noopener">深入理解AMQP协议</a></li><li><a href="https://www.cnblogs.com/dwlsxj/p/RabbitMQ.html" target="_blank" rel="noopener">RabbitMQ基础知识</a></li><li><a href="https://blog.csdn.net/hellozpc/article/details/81436980" target="_blank" rel="noopener">RabbitMQ教程</a></li><li><a href="https://www.cnblogs.com/ityouknow/p/6120544.html" target="_blank" rel="noopener">RabbitMQ详解</a></li><li><a href="https://www.cnblogs.com/skychenjiajun/p/9037324.html" target="_blank" rel="noopener">springboot集成rabbitmq</a></li><li><a href="https://www.cnblogs.com/skychenjiajun/p/9057379.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">springboot集成schedule</a>    </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;AMQP: Advanced Message Queuing Protocol&lt;/li&gt;
&lt;li&gt;RabbitMQ: Producer -&amp;gt; VirtualHost(Exchange -&amp;gt; Binding:routingKey,headers,all,… -&amp;gt; Queue) -&amp;gt; Consumer&lt;/li&gt;
&lt;li&gt;使用Docker安装RabbitMQ&lt;/li&gt;
&lt;li&gt;Demo: Direct/Topic/Headers/Fanout Exchange&lt;/li&gt;
&lt;li&gt;Demo: Exchange object&lt;/li&gt;
&lt;li&gt;Demo: Reliability send&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="MicroService" scheme="http://sixdegree.github.io/tags/MicroService/"/>
    
  </entry>
  
  <entry>
    <title>RPC:Dubbo</title>
    <link href="http://sixdegree.github.io/2019/01/04/Dubbo.html"/>
    <id>http://sixdegree.github.io/2019/01/04/Dubbo.html</id>
    <published>2019-01-03T16:00:00.000Z</published>
    <updated>2019-03-09T08:04:57.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>RPC 远程过程调用<ul><li>四个核心组建(Client,Server,Client Stub,Server Stub)</li><li>框架选择的关注点(I/O,线程,序列化,多语言,服务治理)</li><li>流行框架（Dubbo,Motan,Thrift,Grpc)</li></ul></li><li>Dubbo: Provider,Consumer,Registry,Monitor,Container</li><li>HelloWorld</li><li>Demo(with SpringBoot)</li></ol><a id="more"></a><h2 id="header-1">Start</h2><h3 id="header-2">RPC</h3><p>Remote Procedure Call 远程过程调用</p><ul><li>主要是基于TCP/IP协议，长连接，四个核心的组件：<code>Client</code>,<code>Server</code>,<code>Client Stub</code>，<code>Server Stub</code></li><li>选择RPC框架时的关注点：<ul><li><code>I/O</code>: 同步／异步，长／短连接</li><li>线程调度模型: 单／多线程，线程池，线程调度算法的性能</li><li>序列化方式: 可读 (eg: xml,json),二进制(eg: fastjson，jdk自带的序列化）</li><li>多语言支持</li><li>服务治理（服务发现，监控）</li></ul></li><li>流行的RPC框架：<ul><li><code>Dubbo</code>（阿里）／ <code>Dubbox</code>（当当）: 基于Java开发，只支持Java的客户端和服务端</li><li><code>Motan</code> （新浪）: 基于Java开发</li><li><code>Thrift</code>（Facebook －&gt; Apache）: 跨语言的RPC框架，无服务治理</li><li><code>Grpc</code> （谷歌): 基于HTTP2.0协议（基于二进制的HTTP协议升级版本），跨语言的RPC框架（应用主要面向移动端）</li></ul></li><li>各RPC框架对比：<br><img src="/2019/01/04/rpc.png" alt="RPC"></li></ul><h3 id="header-3">Dubbo</h3><ul><li>一款分布式服务框架</li><li>高性能和透明化的RPC远程服务调用方案</li><li>SOA服务治理方案</li><li>提供了三大核心能力：<ul><li>面向接口的远程方法调用</li><li>智能容错和负载均衡</li><li>服务自动注册和发现</li></ul></li><li>基于Java开发，只支持Java的客户端和服务端</li><li>可以和Spring框架无缝集成</li></ul><p><img src="/2019/01/04/dubbo.png" alt="Dubbo 架构"></p><ul><li>角色：<ul><li>Provider: 暴露服务的服务提供方</li><li>Consumer: 调用远程服务的服务消费方</li><li>Registry: 服务注册与发现的注册中心</li><li>Monitor: 统计服务的调用次数和调用时间的监控中心</li><li>Container: 服务运行容器</li></ul></li><li>调用关系<ul><li>Container负责启动，加载，运行Provider</li><li>Provider 启动时向注册中心注册自己提供的服务</li><li>Consumer 启动时向注册中心订阅自己所需的服务</li><li>Registry 返回服务提供者地址列表给Consumer (如果有变更，Registry将基于长连接推送变更数据给Consumer)</li><li>Consumer 从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用</li><li>Provider &amp; Consumer 在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到 Monitor</li></ul></li><li>注：<ul><li>Provider &amp; Consumer &amp; Registory 之间使用的是长连接</li><li>Provier &amp; Consumer 之间使用非阻塞IO（NIO）通讯</li><li>Dubbo支持的注册中心有: Multicast,Zookeeper,Redis,Simple，下面的示例均使用Zookeeper</li></ul></li></ul><p><a href="http://dubbo.apache.org/en-us/docs/user/quick-start.html" target="_blank" rel="noopener">Dubbo Quick Start</a> | <a href="https://github.com/sixDegree/dubbo-demo.git" target="_blank" rel="noopener">dubbo-demo</a></p><h2 id="header-4">HelloWorld</h2><h3 id="header-5">dependency</h3><p>pom.xml</p><pre><code class="lang-xml">&lt;!-- Dubbo (include spring)--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;dubbo&lt;/artifactId&gt;    &lt;version&gt;2.6.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Curator (include zookeeper) --&gt;&lt;!-- Note: need to change zookeeper version,the beta version zookeeper has issues --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;    &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;    &lt;version&gt;4.0.1&lt;/version&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;             &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;             &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;    &lt;version&gt;3.4.6&lt;/version&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;              &lt;groupId&gt;org.slf4j&lt;/groupId&gt;              &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;        &lt;/exclusion&gt;        &lt;exclusion&gt;             &lt;groupId&gt;org.slf4j&lt;/groupId&gt;             &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- Junit --&gt;&lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="header-6">Provider</h3><ul><li><p>resources/demo-provider.xml</p><pre><code class="lang-xml">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot;         xmlns=&quot;http://www.springframework.org/schema/beans&quot;         xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd         http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt;      &lt;dubbo:application name=&quot;demoProvider&quot;/&gt;      &lt;dubbo:registry address=&quot;zookeeper://localhost:2181&quot;/&gt;      &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt;      &lt;dubbo:service interface=&quot;com.cj.dubbo.service.DemoService&quot; ref=&quot;demoService&quot;/&gt;      &lt;bean id=&quot;demoService&quot; class=&quot;com.cj.dubbo.service.DemoServiceImpl&quot;/&gt;  &lt;/beans&gt;</code></pre></li><li><p>Service interface</p><pre><code class="lang-java">package com.cj.dubbo.service;public interface DemoService {   String sayHello(String name);}</code></pre></li><li><p>Service Impl</p><pre><code class="lang-java">package com.cj.dubbo.service;public class DemoServiceImpl implements DemoService {  @Override  public String sayHello(String name) {      return &quot;Hello &quot;+name;  }}</code></pre></li></ul><h3 id="header-7">Consumer</h3><ul><li><p>resources/demo-consumer.xml</p><pre><code class="lang-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot;     xmlns=&quot;http://www.springframework.org/schema/beans&quot;     xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd     http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt;  &lt;dubbo:application name=&quot;demoConsumer&quot;/&gt;  &lt;dubbo:registry address=&quot;zookeeper://192.168.99.100:2181&quot;/&gt;  &lt;dubbo:reference id=&quot;demoService&quot; check=&quot;false&quot; interface=&quot;com.cj.dubbo.service.DemoService&quot;/&gt;&lt;/beans&gt;</code></pre></li><li><p>Service interface</p><pre><code class="lang-java">package com.cj.dubbo.service;public interface DemoService {   String sayHello(String name);}</code></pre></li></ul><h3 id="header-8">Test</h3><pre><code class="lang-java">package com.cj.dubbo;import java.io.IOException;import org.junit.Test;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.cj.dubbo.consumer.HelloConsumerService;import com.cj.dubbo.service.DemoService;import com.cj.dubbo.service.HelloService;public class DemoDubboTest {    @Test    public void runDemoProvider() throws IOException {        System.setProperty(&quot;java.net.preferIPv4Stack&quot;, &quot;true&quot;);        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{&quot;demo-provider.xml&quot;});        context.start();        System.out.println(&quot;Provider started.&quot;);        System.in.read(); // press any key to exit    }    @Test    public void runDemoConsumer() {        // System.setProperty(&quot;java.net.preferIPv4Stack&quot;, &quot;true&quot;);        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{&quot;demo-consumer.xml&quot;});        context.start();        DemoService demoService = (DemoService) context.getBean(&quot;demoService&quot;); // obtain proxy object for remote invocation        String hello = demoService.sayHello(&quot;world&quot;); // execute remote invocation        System.out.println(hello); // show the result    }}</code></pre><p>Check zookeeper</p><pre><code class="lang-bash">[zk: zk01:2181(CONNECTED) 9] ls /dubbo[com.cj.dubbo.service.DemoService][zk: zk01:2181(CONNECTED) 10] ls /dubbo/com.cj.dubbo.service.DemoService[consumers, configurators, routers, providers]</code></pre><h2 id="header-9">Demo</h2><h3 id="header-10">Provider (SpringBoot)</h3><ol><li><p>pom.xml</p><pre><code class="lang-xml"> &lt;!-- springboot --&gt; &lt;dependency&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;     &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- springboot dubbo --&gt; &lt;!-- &lt;dependency&gt;     &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt;     &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;     &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; --&gt; &lt;!-- Dubbo (include spring) --&gt; &lt;dependency&gt;     &lt;groupId&gt;com.alibaba&lt;/groupId&gt;     &lt;artifactId&gt;dubbo&lt;/artifactId&gt;     &lt;version&gt;2.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Curator (include zookeeper) --&gt; &lt;!-- Note: need to change zookeeper version,the beta version zookeeper has issues --&gt; &lt;dependency&gt;     &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;     &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;     &lt;version&gt;4.0.1&lt;/version&gt;     &lt;exclusions&gt;         &lt;exclusion&gt;              &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;              &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;         &lt;/exclusion&gt;     &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;     &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;     &lt;version&gt;3.4.6&lt;/version&gt;     &lt;exclusions&gt;         &lt;exclusion&gt;               &lt;groupId&gt;org.slf4j&lt;/groupId&gt;               &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;         &lt;/exclusion&gt;         &lt;exclusion&gt;              &lt;groupId&gt;org.slf4j&lt;/groupId&gt;              &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;         &lt;/exclusion&gt;     &lt;/exclusions&gt; &lt;/dependency&gt;</code></pre></li><li><p>Configure</p><ul><li>resources/log4j.properties<pre><code>  ###set log levels###  log4j.rootLogger=warn, stdout  ###output to the console###  log4j.appender.stdout=org.apache.log4j.ConsoleAppender  log4j.appender.stdout.Target=System.out  log4j.appender.stdout.layout=org.apache.log4j.PatternLayout  log4j.appender.stdout.layout.ConversionPattern=[%d{dd/MM/yy hh:mm:ss:sss z}] %t %5p %c{2}: %m%n</code></pre></li><li><p>resources/provider.xml</p><pre><code class="lang-xml">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot;         xmlns=&quot;http://www.springframework.org/schema/beans&quot;         xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd         http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt;      &lt;dubbo:application name=&quot;helloProvider&quot;/&gt;      &lt;dubbo:registry address=&quot;zookeeper://localhost:2181&quot;/&gt;      &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20881&quot;/&gt;      &lt;dubbo:service interface=&quot;com.cj.dubbo.service.HelloService&quot;  ref=&quot;helloService&quot;/&gt;  &lt;/beans&gt;</code></pre></li><li><p>Config: import the <code>provider.xml</code></p><pre><code class="lang-java">  package com.cj.dubbo.config;  import org.springframework.context.annotation.Configuration;  import org.springframework.context.annotation.ImportResource;  @Configuration  @ImportResource(locations={&quot;classpath:provider.xml&quot;})  public class ProviderConfig {  }</code></pre></li></ul></li><li><p>Service</p><ul><li>interface<pre><code class="lang-java">  package com.cj.dubbo.service;  public interface HelloService {      public String sayHello(String name);  }</code></pre></li><li><p>implement</p><pre><code class="lang-java">  package com.cj.dubbo.provider;  import org.springframework.stereotype.Component;  import com.cj.dubbo.service.HelloService;  @Component(&quot;helloService&quot;)  public class HelloServiceImpl implements HelloService {      @Override      public String sayHello(String name) {          return &quot;Hello, &quot; + name + &quot; (from Spring Boot)&quot;;      }  }</code></pre></li></ul></li><li><p>Start</p><pre><code class="lang-java"> package com.cj.dubbo; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class HelloProviderApplication {     public static void main(String[] args) {         SpringApplication.run(HelloProviderApplication.class,args);         System.out.println(&quot;Start Application&quot;);     } }</code></pre></li></ol><h3 id="header-11">Consumer (Spring)</h3><ol><li><p>pom.xml</p><pre><code class="lang-xml"> &lt;!-- Curator(include Zookeeper) --&gt; &lt;dependency&gt;     &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;     &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;     &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Dubbo (include Spring) --&gt; &lt;dependency&gt;     &lt;groupId&gt;com.alibaba&lt;/groupId&gt;     &lt;artifactId&gt;dubbo&lt;/artifactId&gt;     &lt;version&gt;2.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Junit --&gt; &lt;dependency&gt;     &lt;groupId&gt;junit&lt;/groupId&gt;     &lt;artifactId&gt;junit&lt;/artifactId&gt;     &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;</code></pre></li><li><p>Configure: resource/hello-consumer.xml</p><pre><code class="lang-xml"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot;        xmlns=&quot;http://www.springframework.org/schema/beans&quot;        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt;     &lt;dubbo:application name=&quot;helloConsumer&quot;/&gt;     &lt;dubbo:registry address=&quot;zookeeper://localhost:2181&quot;/&gt;     &lt;dubbo:reference id=&quot;helloService&quot; check=&quot;false&quot;  interface=&quot;com.cj.dubbo.service.HelloService&quot;/&gt;     &lt;bean id=&quot;helloConsumerService&quot; class=&quot;com.cj.dubbo.consumer.HelloConsumerService&quot;&gt;         &lt;property name=&quot;helloService&quot; ref=&quot;helloService&quot;/&gt;     &lt;/bean&gt; &lt;/beans&gt;</code></pre></li><li><p>Service</p><ul><li>interface (same with Provider service interface)<pre><code class="lang-java">  package com.cj.dubbo.service;  public interface HelloService {      public String sayHello(String name);  }</code></pre></li><li><p>Call the provided Service</p><pre><code class="lang-java">  package com.cj.dubbo.consumer;  import com.cj.dubbo.service.HelloService;  public class HelloConsumerService {      private HelloService helloService;      public HelloService getHelloService() {          return helloService;      }      public void setHelloService(HelloService helloService) {          this.helloService = helloService;      }      public void printSay(String name) {          if(helloService==null)              System.out.println(&quot;Can&#39;t get helloService!&quot;);          System.out.println(helloService.sayHello(name));      }  }</code></pre></li></ul></li><li><p>Test</p><pre><code class="lang-java"> public class DemoDubboTest {     @Test     public void runHelloConsumer() {         // System.setProperty(&quot;java.net.preferIPv4Stack&quot;, &quot;true&quot;);         ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{&quot;hello-consumer.xml&quot;});         context.start();         HelloService helloService = (HelloService) context.getBean(&quot;helloService&quot;); // obtain proxy object for remote invocation         String hello=helloService.sayHello(&quot;Girl&quot;); // execute remote invocation         System.out.println(hello);                    // show the result         System.out.println(&quot;---- Consume HelloService ----&quot;);         HelloConsumerService consumer=context.getBean(HelloConsumerService.class);         consumer.printSay(&quot;Boy&quot;);     } }</code></pre></li><li><p>Check zookeeper</p><pre><code class="lang-bash"> [zk: zk01:2181(CONNECTED) 9] ls /dubbo [com.cj.dubbo.service.DemoService, com.cj.dubbo.service.HelloService] [zk: zk01:2181(CONNECTED) 18] ls /dubbo/com.cj.dubbo.service.HelloService       [consumers, configurators, routers, providers] [zk: zk01:2181(CONNECTED) 19] ls /dubbo/com.cj.dubbo.service.HelloService/providers [dubbo%3A%2F%2F192.168.31.78%3A20881%2Fcom.cj.dubbo.service.HelloService%3Fanyhost%3Dtrue%26application%3DhelloProvider%26dubbo%3D2.6.2%26generic%3Dfalse%26interface%3Dcom.cj.dubbo.service.HelloService%26methods%3DsayHello%26pid%3D1359%26side%3Dprovider%26timestamp%3D1549812635667] [zk: zk01:2181(CONNECTED) 20] ls /dubbo/com.cj.dubbo.service.HelloService/consumers []</code></pre></li></ol><h2 id="header-12">Reference</h2><p><a href="https://github.com/sixDegree/micro-demo" target="_blank" rel="noopener">My demo: dubbo-demo</a></p><p><a href="https://www.cnblogs.com/chenliangcl/p/7402367.html" target="_blank" rel="noopener">什么是Dubbo</a></p><p><a href="https://blog.csdn.net/sanyuedexuanlv/article/details/80352124" target="_blank" rel="noopener">dubbo的详细介绍</a></p><p><a href="https://blog.csdn.net/uniqueweimeijun/article/details/79896551" target="_blank" rel="noopener">dubbo从入门到精通</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;RPC 远程过程调用&lt;ul&gt;
&lt;li&gt;四个核心组建(Client,Server,Client Stub,Server Stub)&lt;/li&gt;
&lt;li&gt;框架选择的关注点(I/O,线程,序列化,多语言,服务治理)&lt;/li&gt;
&lt;li&gt;流行框架（Dubbo,Motan,Thrift,Grpc)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Dubbo: Provider,Consumer,Registry,Monitor,Container&lt;/li&gt;
&lt;li&gt;HelloWorld&lt;/li&gt;
&lt;li&gt;Demo(with SpringBoot)&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="MicroService" scheme="http://sixdegree.github.io/tags/MicroService/"/>
    
  </entry>
  
  <entry>
    <title>一致性服务 Zookeeper(CuratorFramework)</title>
    <link href="http://sixdegree.github.io/2019/01/03/Zookeeper.html"/>
    <id>http://sixdegree.github.io/2019/01/03/Zookeeper.html</id>
    <published>2019-01-02T16:00:00.000Z</published>
    <updated>2019-03-09T10:02:08.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>dependency: curator-recipes</li><li>Start／Close: CuratorFrameworkFactory.builder()…build(), start(),close()</li><li>CRUD: create(),getData(),setData(),delete(),checkExists(),getChildren()</li><li>Watch: usingWatcher(watcher),NodeCache,PathChildrenCache,TreeCache</li><li>ACL: schema:id:permission, new ACL(perms,id),.aclProvider(aclProvider),.authorization(authInfoList),.withACL(aclList),get/setACL()</li><li>一个应用示例：Client端监控文件增删，实现文件从Server端到Client端的同步</li></ol><a id="more"></a><h2 id="header-1">CuratorFramework</h2><h3 id="header-2">Summary</h3><ol><li><p>dependency: curator-recipes (included zookeeper)</p><pre><code class="lang-xml"> &lt;dependency&gt;     &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;     &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;     &lt;version&gt;4.0.1&lt;/version&gt;     &lt;exclusions&gt;         &lt;exclusion&gt;              &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;              &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;         &lt;/exclusion&gt;     &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;     &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;     &lt;version&gt;3.4.6&lt;/version&gt;     &lt;!-- &lt;exclusions&gt;         &lt;exclusion&gt;               &lt;groupId&gt;org.slf4j&lt;/groupId&gt;               &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;         &lt;/exclusion&gt;         &lt;exclusion&gt;              &lt;groupId&gt;org.slf4j&lt;/groupId&gt;              &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;         &lt;/exclusion&gt;     &lt;/exclusions&gt; --&gt; &lt;/dependency&gt;</code></pre><ul><li>Change zookeeper version ( beta version may have issues.)</li></ul></li><li><p><code>CuratorFramework zkClient = CuratorFrameworkFactory.builder()...build()</code>, key properties:</p><ul><li>connectString 服务器列表，格式host1:port1,host2:port2</li><li>namespace 命名空间</li><li>retryPolicy 重试策略,内建有四种重试策略,也可以自行实现RetryPolicy接口(eg: <code>ExponentialBackoffRetry(3000, 3)</code>)</li><li>sessionTimeoutMs 会话超时时间，单位毫秒，默认60000ms</li><li>connectionTimeoutMs 连接创建超时时间，单位毫秒，默认60000ms</li></ul></li><li><p><code>zkClient.start()</code>,<code>zkClient.close()</code></p></li><li><p>CRUD</p><ul><li>Create: <code>create()</code><ul><li>creatingParentContainersIfNeeded() 自动递归创建所有所需的父节点</li><li>withMode(CreateMode.xxx) 指定创建模式<ul><li>CreateMode.PERSISTENT 持久化 (default)</li><li>CreateMode.PERSISTENT_SEQUENTIAL 持久化并且带序列号</li><li>CreateMode.EPHEMERAL 临时</li><li>CreateMode.EPHEMERAL_SEQUENTIAL 临时并且带序列号</li></ul></li><li>withACL(Ids.xxx) <ul><li>Ids.OPEN_ACL_UNSAFE (default)</li><li>Ids.CREATOR_ALL_ACL</li><li>Ids.READ_ACL_UNSAFE</li><li>Ids.ANYONE_ID_UNSAFE</li><li>Ids.AUTH_IDS</li></ul></li><li>eg:<ul><li><code>String createdPath=zkClient.create().creatingParentsIfNeeded().forPath(path,dataBytes)</code></li><li><code>String createdPath=zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).withACL(Ids.OPEN_ACL_UNSAFE).forPath(path,dataBytes)</code></li></ul></li></ul></li><li>Read: <code>getData()</code><ul><li>不存在则抛出<code>NoNodeException</code></li><li>返回值是<code>byte[]</code></li><li><code>storingStatIn(stat)</code> 获取到该节点的stat</li><li>eg:<ul><li><code>byte[] data=zkClient.getData().forPath(path)</code></li><li><code>byte[] data=zkClient.getData().storingStatIn(stat).forPath(path)</code> </li></ul></li></ul></li><li>Update: <code>setData()</code> <ul><li>不存在则抛出<code>NoNodeException</code></li><li>返回一个<code>Stat</code>实例</li><li><code>withVersion(num)</code> 强制指定版本进行更新</li><li>eg:<ul><li><code>Stat stat=zkClient.setData().forPath(path,dataBytes)</code></li><li><code>Stat stat=zkClient.setData().withVersion(0).forPath(path,dataBytes)</code> (Version不匹配则抛出<code>BadVersionException</code>)</li></ul></li></ul></li><li>Delete: <code>delete()</code><ul><li>不存在则抛出<code>NoNodeException</code></li><li>只能删除叶子节点</li><li><code>guaranteed()</code> 保障措施, 如果删除失败，那么在后端还是继续会删除，直到成功</li><li><code>deletingChildrenIfNeeded()</code>     递归删除其所有的子节点</li><li><code>withVersion(num)</code> 强制指定版本进行删除</li><li>eg:<ul><li><code>zkClient.delete().guaranteed().deletingChildrenIfNeeded().withVersion(12).forPath(path)</code>  </li></ul></li></ul></li><li>More: <ul><li><code>checkExists()</code> 检查节点是否存在，不存在则返回为<code>null</code>，eg:<ul><li><code>Stat stat=zkClient.checkExists().forPath(path)</code></li><li><code>client.checkExists().creatingParentContainersIfNeeded().forPath(path)</code></li></ul></li><li><code>getChildren()</code> 获取某个节点的所有子节点路径,eg:<ul><li><code>List&lt;String&gt; childrenPathList=zkClient.getChildren().forPath(zkPath)</code></li></ul></li></ul></li></ul></li><li><p>Watch</p><ul><li><p><code>usingWatcher(watcher)</code>: </p><ul><li>Target: 监听当前节点，对子节点无效!</li><li>Times: 只触发一次，监听完毕后就销毁</li><li>Watcher: <code>interface CuratorWatcher</code><pre><code class="lang-java">  public interface CuratorWatcher{      public void process(WatchedEvent event) throws Exception;    // event.getPath(),getType(),getState(),...  }</code></pre></li><li>Usage:<ul><li><code>getData().usingWatcher(watcher).forPath(watchPath)</code><ul><li>监听节点(watchPath)需存在，否则报<code>NoNodeException</code></li><li>可监听到的EventType: <code>NodeDeleted</code>,<code>NodeDataChanged</code></li></ul></li><li><code>checkExists().usingWatcher(watcher).forPath(watchPath)</code><ul><li>监听节点(watchPath)可不存在</li><li>可监听到的EventType: <code>NodeCreated</code>,<code>NodeDeleted</code>,<code>NodeDataChanged</code></li></ul></li></ul></li></ul></li><li><p><code>NodeCache</code>: </p><ul><li>Target: 监听当前节点，对子节点无效！</li><li>Times: 一次注册，n次监听 (监听节点可不存在)</li><li>Listener: <code>interface NodeCacheListener</code><pre><code class="lang-java">  public interface NodeCacheListener{      public void nodeChanged() throws Exception;  }</code></pre></li><li>Usage: <pre><code class="lang-java">  NodeCache nodeCache = new NodeCache(zkClient, watchPath);  nodeCache.getListenable().addListener(new NodeCacheListener() {      @Override      public void nodeChanged() throws Exception {          // ChildData data=nodeCache.getCurrentData();     ChildData#getPath(),getData(),getStat() -- get watchPath node information      }  });  nodeCache.start(true);                         // 启动（buildInitial: true/false）, 注：启动不会触发watcher  ChildData data=nodeCache.getCurrentData();    // get watchPath node information</code></pre></li></ul></li><li><p><code>PathChildrenCache</code>: </p><ul><li>Target: 监听节点的一级子节点的CUD，注：<ul><li>监听节点不会触发watcher，监听节点可不存在</li><li>若监听节点删除，则监听失效，子节点的变化将不会触发watcher</li></ul></li><li>Times: 一次注册，n次监听</li><li>Listener: <code>interface PathChildrenCacheListener</code><pre><code class="lang-java">  public interface PathChildrenCacheListener{       public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception;  }</code></pre></li><li><p>Usage:</p><pre><code class="lang-java">  PathChildrenCache pathChildrenCache=new PathChildrenCache(zkClient, watchPath, true);    // cacheData:true/false (true则Client能够获取到节点数据内容)  pathChildrenCache.getListenable().addListener(new PathChildrenCacheListener() {      @Override      public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {          // event.getType()            // Type.CHILD_ADDED,CHILD_UPDATED,CHILD_REMOVED,CONNECTION_SUSPENDED,CONNECTION_RECONNECTED,CONNECTION_LOST,INITIALIZED          // event.getData()            // ChildData, ChildData#getPath,getData,getStat    -- 获取触发Event的节点信息          // event.getInitialData()    // List&lt;ChildData&gt;     -- get initial data when triggered Type.INITIALIZED                      }  });  pathChildrenCache.start(StartMode.BUILD_INITIAL_CACHE);                        // 启动  // StartMode 为初始的cache设置暖场方式  // StartMode.NORMAL                        异步初始化(default mode), Note: initial not trigger watcher  // StartMode.POST_INITIALIZED_EVENT        异步初始化, Cache初始化数据后发送一个PathChildrenCacheEvent.Type#INITIALIZED事件  // StartMode.BUILD_INITIAL_CACHE        同步初始化, start方法返回之前调用rebuild(), Note: initial not trigger watcher  List&lt;ChildData&gt; childDataList= pathChildrenCache.getCurrentData();            //  get watch node (watchPath&#39;s child nodes) information</code></pre></li></ul></li><li><code>TreeCache</code>: <ul><li>Target: 监听节点和该节点的所有子节点 （创建时可设置<code>maxDepth</code>）</li><li>Times: 一次注册，n次监听</li><li>Listener: <code>interface TreeCacheListener</code><pre><code class="lang-java">  public interface TreeCacheListener{      public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception;  }</code></pre></li><li>Usage:<pre><code class="lang-java">  TreeCache treeCache=new TreeCache(zkClient, watchPath,false);        // cacheData：true/false  treeCache.getListenable().addListener(new TreeCacheListener() {      @Override      public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception {          // event.getType()        Type.NODE_ADDED,NODE_UPDATED,NODE_REMOVED,CONNECTION_SUSPENDED,CONNECTION_RECONNECTED,CONNECTION_LOST,INITIALIZED          // event.getData()         ChildData,ChildData#getPath,getData,getStat -- 获取触发Event的节点信息      }  });  treeCache.start();                                                            // 启动  ChildData childData=treeCache.getCurrentData(watchPath);                    // get watch node (watchPath node) information  Map&lt;String,ChildData&gt; childMap=treeCache.getCurrentChildren(watchPath);        // get watch node (watchPath&#39;s child nodes) information</code></pre></li></ul></li></ul></li><li><p>ACL 权限控制</p><ul><li>使用：<code>schema</code>:<code>id</code>:<code>permission</code> 来标识<ul><li><code>schema</code>:<code>id</code><ul><li><code>schema</code>: 权限模式(鉴权的策略)</li><li><code>id</code>: 授权对象,即权限赋予的用户或者一个实体<table class="table"><thead><tr><th style="text-align:left">schema</th><th style="text-align:left">id</th></tr></thead><tbody><tr><td style="text-align:left">world</td><td style="text-align:left">只有一个ID：<code>anyone</code> (任何人都拥有所有权限)</td></tr><tr><td style="text-align:left">ip</td><td style="text-align:left">ip地址或ip段</td></tr><tr><td style="text-align:left">auth</td><td style="text-align:left">“”, 使用已添加认证的用户认证,eg: <code>digest:username:password</code></td></tr><tr><td style="text-align:left">digest</td><td style="text-align:left"><code>用户名:加密密码</code> 通常是<code>username:BASE64(SHA-1(username:password))</code></td></tr></tbody></table></li></ul></li><li><code>permission</code>: 权限<ul><li>CREATE :     c     可以创建子节点</li><li>DELETE :     d     可以删除子节点（仅下一级节点）</li><li>READ :     r     可以读取节点数据及显示子节点列表</li><li>WRITE :     w     可以设置节点数据</li><li>ADMIN :    a     可以设置节点访问控制列表权限</li></ul></li></ul></li><li><p>特性：</p><ul><li>ZooKeeper的权限控制是基于每个znode节点的，需要对每个节点设置权限</li><li>每个znode支持设置多种权限控制方案和多个权限</li><li>子节点不会继承父节点的权限，客户端无权访问某节点，但可能可以访问它的子节点</li></ul></li><li><p>cmd示例：</p><ul><li>world<pre><code class="lang-bash">  # setAcl &lt;path&gt; world:anyone:&lt;permission&gt;  $ setAcl /node1 world:anyone:cdrwa  $ getAcl /node1</code></pre></li><li>ip<pre><code class="lang-bash">  # setAcl &lt;path&gt; ip:&lt;ip&gt;:&lt;permission&gt;  $ setAcl /node2 ip:192.168.100.1:cdrwa  $ getAcl /node2</code></pre></li><li>auth<pre><code class="lang-bash">  # addauth digest &lt;user&gt;:&lt;password&gt;                 # 添加认证用户  # setAcl &lt;path&gt; auth:&lt;user&gt;:&lt;permission&gt;         # 设置ACL  $ addauth digest tom:123456  $ setAcl /node3 auth:tom:cdrwa</code></pre></li><li>digest<pre><code class="lang-bash">  # echo -n &lt;user&gt;:&lt;password&gt; | openssl dgst -binary -sha1 | openssl base64   # password：经SHA1及BASE64处理的密文  # setAcl &lt;path&gt; digest:&lt;user&gt;:&lt;password&gt;:&lt;permission&gt;  $ echo -n tom:123456 | openssl dgst -binary -sha1 | openssl base64  3YvKnq60bERLJOlabQFeB1f+/n0=  $ setAcl /node4 digest:tom:3YvKnq60bERLJOlabQFeB1f+/n0=:cdrwa</code></pre></li></ul></li><li><p>Curator    </p><ul><li><p><code>new ACL(perms,id)</code></p><ul><li>parameter1: <code>Perms.xxx</code><ul><li>Perms.ADMIN    – 可以修改节点权限(setAcl)</li><li>Perms.READ    – 可读取节点（ls,get）</li><li>Perms.WRITE    – 可修改节点内容 (set)</li><li>Perms.CREATE – 可创建节点 (create)</li><li>Perms.DELETE – 可删除节点 (delete)</li></ul></li><li>parameter2: <code>new org.apache.zookeeper.data.Id(String schema,String id)</code></li><li>eg: <pre><code class="lang-java">  Id id1=new Id(&quot;digest&quot;,DigestAuthenticationProvider.generateDigest(&quot;id01:12345&quot;));  ACL aclRW=new ACL(Perms.READ|Perms.WRITE,id1);</code></pre></li><li>Util: <code>org.apache.zookeeper.ZooDefs.Ids</code> 提供一些常用的Id和ACL实例<ul><li><code>ANYONE_ID_UNSAFE = new Id(&quot;world&quot;, &quot;anyone&quot;)</code></li><li><code>AUTH_IDS = new Id(&quot;auth&quot;, &quot;&quot;)</code></li><li><code>OPEN_ACL_UNSAFE = new ArrayList&lt;ACL&gt;(Collections.singletonList(new ACL(Perms.ALL, ANYONE_ID_UNSAFE)))</code></li><li><code>CREATOR_ALL_ACL = new ArrayList&lt;ACL&gt;(Collections.singletonList(new ACL(Perms.ALL, AUTH_IDS)))</code></li><li><code>READ_ACL_UNSAFE = new ArrayList&lt;ACL&gt;(Collections.singletonList(new ACL(Perms.READ, ANYONE_ID_UNSAFE)))</code></li></ul></li></ul></li><li><p><code>aclProvider(aclProvider)</code> same as zkClient cmd <code>setAcl path acl</code> </p><pre><code class="lang-java">  public interface ACLProvider{      public List&lt;ACL&gt; getDefaultAcl();      public List&lt;ACL&gt; getAclForPath(String path);  }</code></pre><ul><li><code>aclProvider(new DefaultACLProvider())</code> default,使用ZooDefs.Ids.OPEN_ACL_UNSAFE</li><li><code>aclProvider(new ACLProvider(){ ... })</code> override getDefaultAcl,getAclForPath    </li></ul></li><li><code>authorization(authInfoList)</code>    : same as zkClient cmd <code>addauth sechema auth</code> ( eg: addauth digest id02:12345 )<ul><li><code>new AuthInfo(String scheme, byte[] auth)</code></li><li>eg: <code>new AuthInfo(&quot;digest&quot;, &quot;id01:12345&quot;.getBytes())</code></li></ul></li><li><code>withACL()</code>: same as zkClient cmd <code>setAcl path acl</code> <ul><li><code>setACL().withACL(aclList).forPath(path)</code></li><li><code>create().withACL(aclList).forPath(path)</code></li></ul></li><li>Note:<ul><li><code>setACL()</code> 需要Admin权限 (Perms.ADMIN)</li><li><code>getACL()</code> 无需认权限证</li></ul></li></ul></li></ul></li></ol><h3 id="header-3">Demo: Start</h3><pre><code class="lang-java">public class CuratorTest {    public static String connectString=&quot;127.0.0.1:2181&quot;;    public static String namespace=&quot;micro&quot;;    public static String zkPath=&quot;/test&quot;;    private CuratorFramework zkClient=null;    @Before    public void init(){        RetryPolicy retryPolicy = new ExponentialBackoffRetry(3000, 3);        zkClient=CuratorFrameworkFactory.builder()                .connectString(connectString)                .retryPolicy(retryPolicy)                .sessionTimeoutMs(100000)                .connectionTimeoutMs(100000)                .namespace(namespace)                .build();        zkClient.start();        CuratorFrameworkState state=zkClient.getState();        System.out.println(&quot;Init zkClient :&quot;+state.name());    }    @After    public void close(){        if(zkClient!=null){            zkClient.close();            CuratorFrameworkState state=zkClient.getState();            System.out.println(&quot;Close zkClient :&quot;+state.name());        }    }    /*....*/}</code></pre><h3 id="header-4">Demo: CRUD</h3><ol><li><p>Create</p><ul><li><p><code>create().creatingParentsIfNeeded().forPath(path,data)</code></p><pre><code class="lang-java">  @Test  public void createTest() throws Exception{      String result=zkClient.create()              .creatingParentsIfNeeded()              .withMode(CreateMode.PERSISTENT)    //default: PERSISTENT              .withACL(Ids.OPEN_ACL_UNSAFE)        //default: Ids.OPEN_ACL_UNSAFE              .forPath(zkPath+&quot;/a&quot;,&quot;aaa&quot;.getBytes())              ;      System.out.println(&quot;create: &quot;+result);    // print created path  }  @Test  public void createChildrenTest() throws Exception {      zkClient.create().creatingParentsIfNeeded().forPath(zkPath+&quot;/a/01/02&quot;);  }</code></pre></li><li><p><code>checkExists().forPath(path)</code></p><pre><code class="lang-java">  @Test  public void checkExistTest() throws Exception{      Stat stat=zkClient.checkExists().forPath(zkPath+&quot;/a&quot;);      System.out.println(stat);      // 如果不存在则为空      stat=zkClient.checkExists().forPath(zkPath+&quot;/aa&quot;);    //null      System.out.println(stat);  }</code></pre></li></ul></li><li><p>Read</p><ul><li><p><code>getData().forPath(path)</code></p><pre><code class="lang-java">  @Test  public void getDataTest() throws Exception{      byte[] data=zkClient.getData().forPath(zkPath+&quot;/a&quot;);      System.out.println(new String(data));      // NoNodeException      data=zkClient.getData().forPath(zkPath+&quot;/aa&quot;);      if(data!=null)          System.out.println(new String(data));  }</code></pre></li><li><p><code>getData().storingStatIn(stat).forPath(path)</code></p><pre><code class="lang-java">  @Test  public void getStatTest() throws Exception{      Stat stat = new Stat();      byte[] data=zkClient.getData().storingStatIn(stat).forPath(zkPath+&quot;/a&quot;);      if(data!=null){          System.out.println(&quot;data: &quot;+new String(data));          System.out.println(&quot;version: &quot;+stat.getVersion());      }      //NoNodeException      data=zkClient.getData().storingStatIn(stat).forPath(zkPath+&quot;/aa&quot;);          if(data!=null){          System.out.println(&quot;data: &quot;+new String(data));          System.out.println(&quot;version: &quot;+stat.getVersion());      }  }</code></pre></li><li><code>getChildren().forPath(path)</code><pre><code class="lang-java">  @Test  public void getChildrenTest() throws Exception{      List&lt;String&gt; children=zkClient.getChildren().forPath(zkPath);      for(String child:children){          byte[] data=zkClient.getData().forPath(zkPath+&quot;/&quot;+child);    // note: need add parentPath          System.out.println(child+&quot;:&quot;+new String(data));      }  }</code></pre></li></ul></li><li><p>Update    </p><ul><li><p><code>setData().forPath(path,data)</code></p><pre><code class="lang-java">  @Test  public void updateTest() throws Exception{      Stat stat=zkClient.setData().forPath(zkPath+&quot;/a&quot;,&quot;aaa-aaa&quot;.getBytes());      System.out.println(stat.getVersion());      byte[] data=zkClient.getData().forPath(zkPath+&quot;/a&quot;);      System.out.println(new String(data));      //BadVersionException      stat=zkClient.setData().withVersion(0).forPath(zkPath+&quot;/a&quot;,&quot;aaa-bbb&quot;.getBytes());          System.out.println(stat.getVersion());      //NoNodeException      //zkClient.setData().forPath(zkPath+&quot;/a/01&quot;,&quot;a01&quot;.getBytes());  }</code></pre></li></ul></li><li><p>Delete</p><ul><li><p><code>delete().guaranteed().deletingChildrenIfNeeded().forPath(path)</code></p><pre><code class="lang-java">  @Test  public void deleteTest() throws Exception{      zkClient.delete()          .guaranteed()                    // 如果删除失败，那么在后端还是继续会删除，直到成功          .deletingChildrenIfNeeded()        // 如果有子节点，就删除          .forPath(zkPath+&quot;/a/01&quot;);      Stat stat=zkClient.checkExists().forPath(zkPath+&quot;/a/01&quot;);      System.out.println(zkPath+&quot;/a/01 :&quot;+(stat!=null?&quot;Exist&quot;:&quot;NotExist&quot;));      stat=zkClient.checkExists().forPath(zkPath+&quot;/a/01/02&quot;);      System.out.println(zkPath+&quot;/a/01/02 :&quot;+(stat!=null?&quot;Exist&quot;:&quot;NotExist&quot;));      // NoNodeException      zkClient.delete().guaranteed().deletingChildrenIfNeeded().forPath(zkPath+&quot;/aa&quot;);      }</code></pre></li></ul></li></ol><h3 id="header-5">Demo: Watch</h3><ol><li><p><code>usingWatcher</code>: 监听只会触发一次，监听完毕后就销毁,且对子节点无效！(<code>getData()</code>,<code>checkExists()</code> 方法可追加 Watcher)</p><ul><li><p><code>getData().usingWatcher(new CuratorWatcher(){ ... } ).forPath(watchPath)</code>: 只监听该节点的变化（可监听到 <code>NodeDeleted</code>,<code>NodeDataChanged</code>)，监听节点(watchPath)需存在，不然会报<code>NoNodeException</code></p><pre><code class="lang-java">  @Test  public void usingWatcherTest() throws Exception{      Stat stat=zkClient.checkExists().forPath(zkPath+&quot;/b&quot;);      if(stat==null)          zkClient.create().creatingParentContainersIfNeeded().forPath(zkPath+&quot;/b&quot;,&quot;bbb&quot;.getBytes());      zkClient.getData().usingWatcher(new CuratorWatcher() {          @Override          public void process(WatchedEvent event) throws Exception {              System.out.println(&quot;Path:&quot;+event.getPath());              System.out.println(&quot;Type:&quot;+event.getType());              System.out.println(&quot;State:&quot;+event.getState());              if(!event.getType().equals(EventType.NodeDeleted)){                  byte[] data=zkClient.getData().forPath(event.getPath());                  if(data!=null)                      System.out.println(&quot;Data:&quot;+new String(data));              }          }      }).forPath(zkPath+&quot;/b&quot;);      // case 1: node data change -- only trigger once      // first time - trigger event: NodeDataChanged      // zkClient.setData().forPath(zkPath+&quot;/b&quot;,&quot;bbb-bbb&quot;.getBytes());      // second time - no watcher trigger      // zkClient.setData().forPath(zkPath+&quot;/b&quot;,&quot;bbb-ccc&quot;.getBytes());          // case 2: create children -- no trigger      // zkClient.create().creatingParentsIfNeeded().forPath(zkPath+&quot;/b/01/02&quot;,&quot;Hello&quot;.getBytes());      // case 3: update children data -- no trigger      // zkClient.setData().forPath(zkPath+&quot;/b/01&quot;,&quot;b01&quot;.getBytes());      // case 4: delete children -- no trigger      // zkClient.delete().deletingChildrenIfNeeded().forPath(zkPath+&quot;/b/01/02&quot;);      // case 5: delete node -- trigger event: NodeDeleted      zkClient.delete().deletingChildrenIfNeeded().forPath(zkPath+&quot;/b&quot;);      Thread.sleep(10000);  }</code></pre></li><li><p><code>checkExists().usingWatcher(new CuratorWatcher(){ ... } ).forPath(watchPath)</code>: 只监听该节点的变化（可监听到 <code>NodeCreated</code>,<code>NodeDeleted</code>,<code>NodeDataChanged</code>)，监听节点(watchPath)可不存在</p><pre><code class="lang-java">  @Test  public void usingWatcher2Test() throws Exception{      // Stat stat=zkClient.checkExists().forPath(zkPath+&quot;/b&quot;);      // if(stat==null)      //         zkClient.create().creatingParentContainersIfNeeded().forPath(zkPath+&quot;/b&quot;,&quot;bbb&quot;.getBytes());      zkClient.checkExists().usingWatcher(new CuratorWatcher() {          @Override          public void process(WatchedEvent event) throws Exception {              System.out.println(&quot;Path:&quot;+event.getPath());              System.out.println(&quot;Type:&quot;+event.getType());              System.out.println(&quot;State:&quot;+event.getState());              if(!event.getType().equals(EventType.NodeDeleted)){                  byte[] data=zkClient.getData().forPath(event.getPath());                  if(data!=null)                      System.out.println(&quot;Data:&quot;+new String(data));              }          }      }).forPath(zkPath+&quot;/b&quot;);      // case 1: node data change      // first time - trigger event:NodeDataChanged      // zkClient.setData().forPath(zkPath+&quot;/b&quot;,&quot;bbb-bbb&quot;.getBytes());      // second time - no watcher trigger      // zkClient.setData().forPath(zkPath+&quot;/b&quot;,&quot;bbb-ccc&quot;.getBytes());          // case 2: create children -- no trigger      // zkClient.create().creatingParentsIfNeeded().forPath(zkPath+&quot;/b/01/02&quot;,&quot;Hello&quot;.getBytes());      // case 3: update children data -- no trigger      // zkClient.setData().forPath(zkPath+&quot;/b/01&quot;,&quot;b01&quot;.getBytes());      // case 4: delete children -- no trigger      // zkClient.delete().deletingChildrenIfNeeded().forPath(zkPath+&quot;/b/01/02&quot;);      // case 5: delete node -- trigger event: NodeDeleted      // zkClient.delete().deletingChildrenIfNeeded().forPath(zkPath+&quot;/b&quot;);      // case 6: create node -- trigger event: NodeCreated      zkClient.create().creatingParentContainersIfNeeded().forPath(zkPath+&quot;/b&quot;,&quot;bbb&quot;.getBytes());      Thread.sleep(10000);  }</code></pre></li></ul></li><li><p><code>NodeCache</code>: 一次注册，n次监听 – 监听当前节点，对子节点无效！（监听节点可不存在）</p><pre><code class="lang-java">@Testpublic void nodeCacheWatchTest() throws Exception{ String watchPath=zkPath+&quot;/c&quot;; if(zkClient.checkExists().forPath(watchPath)==null)     zkClient.create().creatingParentContainersIfNeeded().forPath(watchPath,&quot;ccc&quot;.getBytes()); NodeCache nodeCache = new NodeCache(zkClient, watchPath); System.out.println(&quot;Add Listener...&quot;); nodeCache.getListenable().addListener(new NodeCacheListener() {     @Override     public void nodeChanged() throws Exception {         System.out.println(&quot;Trigger Watcher...&quot;);         ChildData data=nodeCache.getCurrentData();         if(data!=null){             System.out.println(data.getPath());             System.out.println(new String(data.getData()));             System.out.println(data.getStat().getVersion());         }else {             System.out.println(&quot;Empty!&quot;);         }     } }); // start -- 注意：不管是否cacheData，启动不会触发watcher // nodeCache.start();        // 不cache节点数据 nodeCache.start(true);    // cache节点数据  // check initial data ChildData data=nodeCache.getCurrentData(); if(data!=null){     System.out.println(&quot;节点初始化数据为：&quot;);     System.out.println(data.getPath());     System.out.println(new String(data.getData()));     System.out.println(data.getStat().getVersion()); }else {     System.out.println(&quot;节点初始化数据为空！&quot;); } System.out.println(&quot;Begin Case 1 : watchPath -- trigger watcher&quot;); // node data change -- always trigger event:NodeDataChanged zkClient.setData().forPath(watchPath,&quot;ccc-ccc&quot;.getBytes()); Thread.sleep(2000); zkClient.setData().forPath(watchPath,&quot;ccc-ddd&quot;.getBytes());     // delete node -- trigger event: NodeDeleted zkClient.delete().deletingChildrenIfNeeded().forPath(watchPath); // create node -- trigger event: NodeCreated zkClient.create().creatingParentContainersIfNeeded().forPath(watchPath,&quot;ccc&quot;.getBytes()); Thread.sleep(2000); System.out.println(&quot;Begin Case 2 : children -- no trigger&quot;); // create children zkClient.create().creatingParentsIfNeeded().forPath(watchPath+&quot;/01/02&quot;,&quot;Hello&quot;.getBytes()); // update children data zkClient.setData().forPath(watchPath+&quot;/01&quot;,&quot;c01&quot;.getBytes()); // delete children zkClient.delete().deletingChildrenIfNeeded().forPath(watchPath+&quot;/01/02&quot;); Thread.sleep(10000); if(nodeCache!=null)     nodeCache.close();}</code></pre></li><li><p><code>PathChildrenCache</code>: 监听节点的一级子节点的CUD (Note: 监听节点不会触发watcher，监听节点可不存在; 若监听节点删除，则监听失效，子节点的变化将不会触发watcher )</p><pre><code class="lang-java"> @Test public void pathChildenCacheWatchTest() throws Exception{     String watchPath=zkPath+&quot;/d&quot;;     if(zkClient.checkExists().forPath(watchPath)==null){         zkClient.create().creatingParentContainersIfNeeded().forPath(watchPath,&quot;ddd&quot;.getBytes());     }     if(zkClient.checkExists().forPath(watchPath+&quot;/0&quot;)==null){         zkClient.create().creatingParentContainersIfNeeded().forPath(watchPath+&quot;/0&quot;,&quot;00&quot;.getBytes());     }     // cacheData:true/false     PathChildrenCache childCache=new PathChildrenCache(zkClient, watchPath, true);     System.out.println(&quot;Add Listener...&quot;);     childCache.getListenable().addListener(new PathChildrenCacheListener() {         @Override         public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {             System.out.println(event.getType());             ChildData child=event.getData();             if(child!=null)                 System.out.println(child.getPath()+&quot;:&quot;+new String(child.getData())+&quot;,version:&quot;+child.getStat().getVersion());             if(event.getType().equals(Type.INITIALIZED)){                 System.out.println(&quot;watcher到的节点初始化信息：&quot;);                 List&lt;ChildData&gt; childDataList=event.getInitialData();                 for(ChildData c:childDataList){                     System.out.println(c.getPath()+&quot;:&quot;+new String(c.getData())+&quot;,version:&quot;+c.getStat().getVersion());                 }             }         }     });     System.out.println(&quot;Start Cache: &quot;);     // childCache.start();                                    //default: StartMode.NORMAL,异步初始化     -- initial data not trigger watcher     // childCache.start(StartMode.POST_INITIALIZED_EVENT);     // 异步初始化 -- initial trigger watcher: Type.INITIALIZED     childCache.start(StartMode.BUILD_INITIAL_CACHE);        // 同步初始化 -- initial not trigger watcher     // Thread.sleep(2000);     List&lt;ChildData&gt; childDataList= childCache.getCurrentData();     System.out.println(&quot;start 节点初始化信息：&quot;);     for(ChildData child:childDataList){         System.out.println(child.getPath()+&quot;:&quot;+new String(child.getData())+&quot;,version:&quot;+child.getStat().getVersion());     }     System.out.println(&quot;Begin Case 1 : watchPath -- no trigger&quot;);     // node data change     // zkClient.setData().forPath(watchPath,&quot;ddd-ddd&quot;.getBytes());     // delete node    -- Note: 会导致watcher失效     // zkClient.delete().deletingChildrenIfNeeded().forPath(watchPath);     // create node     // zkClient.create().creatingParentContainersIfNeeded().forPath(watchPath,&quot;ddd&quot;.getBytes());     // Thread.sleep(2000);     System.out.println(&quot;Begin Case 2 : children -- trigger&quot;);     // create children -- trigger CHILD_ADDED -- Note: on trigger &quot;/01&quot; CHILD_ADD, won&#39;t trigger &quot;/01/02&quot; CHILD     zkClient.create().creatingParentsIfNeeded().forPath(watchPath+&quot;/01/02&quot;,&quot;Hello&quot;.getBytes());     // update children data -- trigger CHILD_UPDATED     zkClient.setData().forPath(watchPath+&quot;/01&quot;,&quot;d01&quot;.getBytes());     // delete children -- trigger CHILD_REMOVED     zkClient.delete().deletingChildrenIfNeeded().forPath(watchPath+&quot;/01&quot;);     Thread.sleep(10000);     if(childCache!=null)         childCache.close(); }</code></pre></li><li><p><code>TreeCache</code>: 监听节点和该节点的所有子节点 （创建时可设置<code>maxDepth</code>）</p><pre><code class="lang-java"> @Test public void treeCacheWatchTest() throws Exception{     String watchPath=zkPath+&quot;/e&quot;;     if(zkClient.checkExists().forPath(watchPath)==null){         zkClient.create().creatingParentContainersIfNeeded().forPath(watchPath,&quot;eee&quot;.getBytes());     }     if(zkClient.checkExists().forPath(watchPath+&quot;/0&quot;)==null){         zkClient.create().creatingParentContainersIfNeeded().forPath(watchPath+&quot;/0&quot;,&quot;00&quot;.getBytes());     }     System.out.println(&quot;Add Listener...&quot;);     TreeCache treeCache=new TreeCache(zkClient, watchPath);        // default：not cacheData,initial data will trigger watcher: NODE_ADDED     treeCache.getListenable().addListener(new TreeCacheListener() {         @Override         public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception {             System.out.println(&quot;Watch:&quot;);             System.out.println(event.getType());             ChildData childData=event.getData();             if(childData!=null)                 System.out.println(childData.getPath()+&quot;:&quot;+new String(childData.getData())+&quot;,version:&quot;+childData.getStat().getVersion());         }     });     treeCache.start();     System.out.println(&quot;Initial Data...&quot;);     ChildData childData=treeCache.getCurrentData(watchPath);     if(childData!=null)         System.out.println(&quot;Current:&quot;+childData.getPath()+&quot;:&quot;+new String(childData.getData())+&quot;,version:&quot;+childData.getStat().getVersion());     Map&lt;String,ChildData&gt; childMap=treeCache.getCurrentChildren(watchPath);     if(childMap!=null){         for(String key:childMap.keySet()){             System.out.println(&quot;Child:&quot;+key+&quot;:&quot;+childMap.get(key));         }     }     System.out.println(&quot;Begin case 1 : watchPath -- trigger&quot;);     // node data change -- trigger NODE_UPDATED     zkClient.setData().forPath(watchPath,&quot;eee-eee&quot;.getBytes());     // delete node    -- trigger NODE_REMOVED 2 times for path &#39;/test/e/0&#39;,&#39;/test/e&#39;     zkClient.delete().deletingChildrenIfNeeded().forPath(watchPath);     // create node -- trigger NODE_ADDED     zkClient.create().creatingParentContainersIfNeeded().forPath(watchPath,&quot;eee&quot;.getBytes());     Thread.sleep(2000);     System.out.println(&quot;Begin Case 2 : children -- trigger&quot;);     // create children -- trigger NODE_ADDED 2 times for path: &#39;/test/e/01&#39;,&#39;/test/e/01/02&#39;     zkClient.create().creatingParentsIfNeeded().forPath(watchPath+&quot;/01/02&quot;,&quot;Hello&quot;.getBytes());     // update children data -- trigger NODE_UPDATED     zkClient.setData().forPath(watchPath+&quot;/01&quot;,&quot;d01&quot;.getBytes());     // delete children -- trigger NODE_REMOVED 2 times for path: &#39;/test/e/01/02&#39;,&#39;/test/e/01&#39;     zkClient.delete().deletingChildrenIfNeeded().forPath(watchPath+&quot;/01&quot;);     Thread.sleep(10000);     if(treeCache!=null)         treeCache.close(); }</code></pre></li></ol><h3 id="header-6">Demo: ACL</h3><ol><li><p>init</p><pre><code class="lang-java"> public class CuratorAclTest {     public static String connectString=&quot;127.0.0.1:2181&quot;;     public static String namespace=&quot;micro&quot;;     public static String zkPath=&quot;/bb&quot;;     private CuratorFramework zkClient=null;     private ACL aclAdmin=null;     private ACL aclRW=null;     private ACL aclCD=null;     /*      * Perms.ADMIN    -- 可以修改节点权限(setAcl)      * Perms.READ    -- 可读取节点（ls,get）      * Perms.WRITE    -- 可修改节点内容 (set)      * Perms.CREATE -- 可创建节点 (create)      * Persm.DELETE -- 可删除节点 (delete)      */     @Before     public void init() throws NoSuchAlgorithmException{         Id id0=new Id(&quot;digest&quot;,DigestAuthenticationProvider.generateDigest(&quot;id00:admin&quot;));         Id id1=new Id(&quot;digest&quot;,DigestAuthenticationProvider.generateDigest(&quot;id01:12345&quot;));         Id id2=new Id(&quot;digest&quot;,DigestAuthenticationProvider.generateDigest(&quot;id02:12345&quot;));         aclAdmin=new ACL(Perms.ADMIN, id0);         aclRW=new ACL(Perms.READ|Perms.WRITE,id1);         aclCD=new ACL(Perms.CREATE|Perms.DELETE,id2);     }     @After     public void close(){         if(zkClient!=null){             zkClient.close();                     CuratorFrameworkState state=zkClient.getState();             System.out.println(&quot;Close zkClient :&quot;+state.name());         }     }     /*  ... */ }</code></pre></li><li><p>ACL</p><ul><li><p><code>aclProvider</code>/<code>setACL</code>: same as zkClient cmd <code>setAcl path acl</code></p><pre><code class="lang-java">      @Test  public void aclProviderTest() throws Exception{      RetryPolicy retryPolicy = new ExponentialBackoffRetry(3000, 3);      zkClient=CuratorFrameworkFactory.builder()              //.aclProvider(new DefaultACLProvider())    // default              .aclProvider(new ACLProvider() {    // Note: 在节点创建时触发调用，为新建的节点设置权限                  @Override                  public List&lt;ACL&gt; getDefaultAcl() {                      System.out.println(&quot;setting default acl...&quot;);                      return ZooDefs.Ids.OPEN_ACL_UNSAFE;                  }                  @Override                  public List&lt;ACL&gt; getAclForPath(String path) {                      System.out.println(&quot;setting acl...&quot;);                      // 为zkPath节点和其以下的所有子节点设置acl                      if(path.startsWith(&quot;/&quot;+namespace+zkPath)){    // note: namespace+zkPath                          System.out.println(&quot;setting aclAdmin,aclRW,aclCD...&quot;);                          return Arrays.asList(aclAdmin,aclRW,aclCD);                      }                      else                          return ZooDefs.Ids.OPEN_ACL_UNSAFE;                  }              })              .connectString(connectString)              .retryPolicy(retryPolicy)              .sessionTimeoutMs(100000)              .connectionTimeoutMs(100000)              .namespace(namespace)              .build();      zkClient.start();      CuratorFrameworkState state=zkClient.getState();      System.out.println(&quot;Init zkClient :&quot;+state.name());      // case 1 -- Create -zkPath --&gt; Success      aclCreateTest();      // case 2 -- Read and Write -zkPath    --&gt; NoAuthException!!      // aclReadWriteTest();      // case 3 -- Delete -zkPath --&gt; NoAuthException!!      aclDeleteTest();      // case 4 -- Create -zkPath --&gt; Success      aclCreateTest();      System.out.println(&quot;child case...&quot;);      // case 5 -- Delete and Create -zkPath child --&gt; NoAuthException!!      // aclDeleteChildTest();      // aclCreateChildTest();      // case 6 -- Read and Write -zkPath child    --&gt; NoAuthException!!      // aclReadWriteChildTest();  }</code></pre></li><li><p>authorization:  same as zkClient cmd <code>addauth sechema auth</code> ( eg: addauth digest id02:12345 )</p><pre><code class="lang-java">  @Test  public void authorizationTest() throws Exception{      List&lt;AuthInfo&gt; authInfos = new ArrayList&lt;AuthInfo&gt;();      authInfos.add(new AuthInfo(&quot;digest&quot;, &quot;id00:admin&quot;.getBytes()));    // admin：修改权限认证      // authInfos.add(new AuthInfo(&quot;digest&quot;, &quot;id01:12345&quot;.getBytes()));    // rw:读写节点认证      authInfos.add(new AuthInfo(&quot;digest&quot;, &quot;id02:12345&quot;.getBytes()));    // cr:增删节点认证      RetryPolicy retryPolicy = new ExponentialBackoffRetry(3000, 3);      zkClient=CuratorFrameworkFactory.builder()              // Note:               // 不设置aclProvider，等同.aclProvider(new DefaultACLProvider())，即使用ZooDefs.Ids.OPEN_ACL_UNSAFE              // 对于新创建的节点，acl为ZooDefs.Ids.OPEN_ACL_UNSAFE              // .authorization(authInfos)    // 附上访问权限信息AuthInfo，用于访问节点认证              .connectString(connectString)              .retryPolicy(retryPolicy)              .sessionTimeoutMs(100000)              .connectionTimeoutMs(100000)              .namespace(namespace)              .build();      zkClient.start();      CuratorFrameworkState state=zkClient.getState();      System.out.println(&quot;Init zkClient :&quot;+state.name());      //get acl -- 无需权限      getACLTest();      // set acl -zkPath       // --&gt; 拥有admin权限认证时才可      setACLTest();      // getChildACLTest();      // case 1: read &amp; write -zkPath      // --&gt; 需拥有rw权限      aclReadWriteTest();      // case 2: create -zkPath child          // --&gt; 需拥有c权限才可创建，新创建的节点未设置acl，则使用默认acl{world,anyone}      aclCreateChildTest();      // case 3: read &amp; write -zkPath child      aclReadWriteChildTest();      // case 4: delete -zkPath child      aclDeleteChildTest();      // case 4: delete -zkPath      // --&gt; 需拥有d权限才可删除      aclDeleteTest();  }</code></pre></li></ul></li><li><p>Set/Get ACL</p><ul><li><p>getACL (无需认权限证)</p><pre><code class="lang-java">  public void getACLTest() throws Exception{      if(zkClient.checkExists().forPath(zkPath)==null){          System.out.println(zkPath+&quot; not exist!&quot;);          return;      }      System.out.println(&quot;list acl:&quot;);      List&lt;ACL&gt; aclList=zkClient.getACL().forPath(zkPath);      for(ACL acl:aclList)          System.out.println(acl);  }  public void getChildACLTest() throws Exception{      System.out.println(&quot;list child acl:&quot;);      List&lt;String&gt; childList=zkClient.getChildren().forPath(zkPath);      for(String child:childList){          List&lt;ACL&gt; aclList=zkClient.getACL().forPath(zkPath+&quot;/&quot;+child);          System.out.println(child+&quot; acl: &quot;);          for(ACL acl:aclList)              System.out.println(&quot;\t&quot;+acl);      }  }</code></pre></li><li>setACL<pre><code class="lang-java">  public void setACLTest() throws Exception{      if(zkClient.checkExists().forPath(zkPath)!=null){          System.out.println(&quot;Set ACL&quot;);          Stat stat=zkClient.setACL().withACL(Arrays.asList(aclAdmin,aclRW,aclCD)).forPath(zkPath);          System.out.println(stat.getVersion());      }else{          System.out.println(&quot;Create and Set ACL&quot;);          zkClient.create().creatingParentsIfNeeded().withACL(Arrays.asList(aclAdmin,aclRW,aclCD)).forPath(zkPath,&quot;access test&quot;.getBytes());      }      getACLTest();  }</code></pre></li></ul></li><li><p>CRUD : call to test</p><pre><code class="lang-java"> /* Current Path */ public void aclReadWriteTest() throws Exception{     System.out.println(&quot;aclReadWriteTest....&quot;);     if(zkClient.checkExists().forPath(zkPath)==null){         System.out.println(zkPath+&quot; not exist!&quot;);         return;     }     //read     System.out.println(&quot;read...&quot;+zkPath);     byte[] data=zkClient.getData().forPath(zkPath);     if(data!=null)         System.out.println(new String(data));     //write     System.out.println(&quot;write...&quot;+zkPath);     Stat stat=zkClient.setData().forPath(zkPath,&quot;access test-acl&quot;.getBytes());     System.out.println(stat.getVersion()); } public void aclCreateTest() throws Exception{     System.out.println(&quot;acl create test...&quot;);     if(zkClient.checkExists().forPath(zkPath)!=null){         System.out.println(zkPath+&quot; already exist!&quot;);     }else{         //create         System.out.println(&quot;create...&quot;+zkPath);         zkClient.create().creatingParentsIfNeeded().forPath(zkPath,&quot;access test-new&quot;.getBytes());     }     //print acl     System.out.println(&quot;list acl...&quot;+zkPath);     List&lt;ACL&gt; aclList=zkClient.getACL().forPath(zkPath);     for(ACL acl:aclList){         System.out.println(acl);     } } public void aclDeleteTest() throws Exception{     System.out.println(&quot;aclDeleteTest....&quot;);     if(zkClient.checkExists().forPath(zkPath)==null){         System.out.println(zkPath+&quot; not exist!&quot;);     }else{         //delete         System.out.println(&quot;delete...&quot;+zkPath);         zkClient.delete().deletingChildrenIfNeeded().forPath(zkPath);     } } /* Children CRUD */ public void aclReadWriteChildTest() throws Exception{     System.out.println(&quot;aclReadWriteChildTest....&quot;);     String accessPath=zkPath+&quot;/a&quot;;     //read     System.out.println(&quot;read...&quot;+accessPath);     byte[] data=zkClient.getData().forPath(accessPath);     if(data!=null)         System.out.println(new String(data));     //write     System.out.println(&quot;write...&quot;+accessPath);     Stat stat=zkClient.setData().forPath(accessPath,&quot;aaa-acl&quot;.getBytes());     System.out.println(stat.getVersion()); } public void aclCreateChildTest() throws Exception{     System.out.println(&quot;aclCreateChildTest....&quot;);     String accessPath=zkPath+&quot;/a&quot;;     if(zkClient.checkExists().forPath(accessPath)!=null){         System.out.println(accessPath+&quot; already exist!&quot;);     }else{         //create         System.out.println(&quot;create...&quot;+accessPath);         zkClient.create().creatingParentsIfNeeded().forPath(accessPath,&quot;aaa-new&quot;.getBytes());     }     //print acl     System.out.println(&quot;list acl...&quot;+accessPath);     List&lt;ACL&gt; aclList=zkClient.getACL().forPath(accessPath);     for(ACL acl:aclList){         System.out.println(acl);     } } public void aclDeleteChildTest() throws Exception{     System.out.println(&quot;aclDeleteChildTest....&quot;);     String accessPath=zkPath+&quot;/a&quot;;     if(zkClient.checkExists().forPath(accessPath)==null){         System.out.println(accessPath+&quot; not exist!&quot;);     }else{         //delete         System.out.println(&quot;delete...&quot;+accessPath);         zkClient.delete().deletingChildrenIfNeeded().forPath(accessPath);     } }</code></pre></li></ol><h2 id="header-7">一个应用示例</h2><p>Client端监控文件增删，实现文件从Server端到Client端的同步</p><!-- ![sync-files](2019-01-03-Zookeeper/sync-files.png) --><h3 id="header-8">Summary</h3><p>Two Parts:</p><ul><li>Part 1: FileServer -&gt; CRUD files</li><li><p>Part 2: ClientUser -&gt; Auto download from FileServer / delete local file depends on the files updates on FileServer.</p></li><li><p>admin(<code>/admin</code>): FileServer</p><ul><li>upload file: POST <code>/images</code> -&gt; upload(MultipartFile photo)<ul><li>save file with name <code>{image.id}.{image.type}</code> on local fileLocation </li><li>save file information on DB</li><li>add zk node: <code>/{image.id}_{PERSISTENT_SEQUENTIAL}</code>: <code>ADD:{image.id}:{image.type}:{image.originalName}</code></li></ul></li><li>delete file: DEL <code>images/{id}</code> -&gt; delete(id)<ul><li>delete file information on DB</li><li>add zk node: <code>/{image.id}_{PERSISTENT_SEQUENTIAL}</code>: <code>DEL:{image.id}:{image.type}:{image.originalName}</code></li></ul></li><li>list all files information: GET <code>/images</code> -&gt; list()</li><li>get file information by id: GET <code>/images/{id}</code> -&gt; get(id)</li><li>config:<ul><li>fileLocation: <code>/Users/cj/space/java/admin-uploads</code></li><li>zk<ul><li>server: 127.0.0.1:2181</li><li>namespace: demo</li></ul></li></ul></li></ul></li><li><p>user(<code>/user</code>): Client User</p><ul><li>get local file: GET <code>/images/{filename}</code> -&gt; get(filename)</li><li>zk listen <code>/</code>:<code>CHILD_ADDED</code>: <ul><li><code>ADD:{filename}:{extension}:{originalName}</code> -&gt; download file from fileServer to local,then del this child node</li><li><code>DEL:{filename}:{extension}:{originalName}</code> -&gt; delete local file,then del this child node</li></ul></li><li>config:<ul><li>local fileLocation <code>/Users/cj/space/java/user-downloads</code></li><li>remote fileServer <code>http://localhost:8080/zookeeper-demo/admin/images</code></li><li>zk<ul><li>server: 127.0.0.1:2181</li><li>namespace: demo</li></ul></li></ul></li></ul></li><li><p>verify:</p><pre><code class="lang-bash">  # upload: POST /admin/images  $ curl -i -F &#39;photo=@/Users/cj/Pictures/design/极光2.jpg&#39; -X POST http://localhost:8080/zookeeper-demo/admin/images   # list: GET /admin/images  $ curl -i -H &quot;Content-Type: application/json&quot; http://localhost:8080/zookeeper-demo/admin/images  # get: GET /admin/images/{id}  $ curl -i -H &quot;Content-Type: application/json&quot; http://localhost:8080/zookeeper-demo/admin/images/1d0fa647-9dbe-410a-8d9c-0e1c973a98e2  # delete: DELETE /admin/images/{id}  $ curl -i -H &quot;Content-Type: application/json&quot; -X DELETE http://localhost:8080/zookeeper-demo/admin/images/1d0fa647-9dbe-410a-8d9c-0e1c973a98e2  # visit:   # /user/images/1d0fa647-9dbe-410a-8d9c-0e1c973a98e2.jpg  # More (for test)  # /light.jpg  # /admin/images  # /admin/images/test1/虫洞.gif  # /admin/images/test2/极光1.jpg</code></pre></li></ul><h3 id="header-9">Dependencies</h3><p>pom.xml</p><pre><code class="lang-xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- Curator (include zookeeper) --&gt;&lt;!-- Note: need to change zookeeper version,the beta version zookeeper has issues --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;    &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;    &lt;version&gt;4.0.1&lt;/version&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;             &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;             &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;    &lt;version&gt;3.4.6&lt;/version&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;              &lt;groupId&gt;org.slf4j&lt;/groupId&gt;              &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;        &lt;/exclusion&gt;        &lt;exclusion&gt;             &lt;groupId&gt;org.slf4j&lt;/groupId&gt;             &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- FileUpload --&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;    &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-io&lt;/groupId&gt;    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;    &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="header-10">Admin(FileServer)</h3><ol><li><p>application.yml</p><pre><code> server:   port: 8080   servlet:     context-path: /zookeeper-demo zk:   server: 127.0.0.1:2181   namespace: demo admin:   fileLocation: /Users/cj/space/java/admin-uploads</code></pre></li><li><p>ImageAdminController</p><pre><code class="lang-java">@RestController@RequestMapping(&quot;/admin/images&quot;)public class ImageAdminController { @Value(&quot;${admin.fileLocation}&quot;) private String fileLocation; @Autowired private ImageService imageService; @Resource(name=&quot;zkService&quot;) private ZkCuratorService zkService; @PostMapping public Object upload(@RequestParam(value=&quot;photo&quot;) MultipartFile photo) throws Exception{     System.out.println(&quot;Name:&quot;+photo.getName());                            // photo     System.out.println(&quot;OriginalFilename:&quot;+photo.getOriginalFilename());    // 极光2.jpg     System.out.println(&quot;Size:&quot;+photo.getSize());                            // 186316     System.out.println(&quot;ContentType:&quot;+photo.getContentType());                // image/jpeg     Image image=new Image(UUID.randomUUID().toString(),             photo.getOriginalFilename(),&quot;Active&quot;);     String destFilePath=this.fileLocation+&quot;/&quot;+image.getId()+&quot;.&quot;+image.getType();     System.out.println(&quot;dest:&quot;+destFilePath);     FileUtils.copyToFile(photo.getInputStream(), new File(destFilePath));     boolean result=this.imageService.save(image);     // zookeeper     String data=&quot;ADD:&quot;+image.getId()+&quot;:&quot;+image.getType()+&quot;:&quot;+image.getOriginalName();     String zkPath=zkService.create(&quot;/&quot;+image.getId(), data.getBytes());     System.out.println(&quot;create zkPath(for ADD):&quot;+zkPath);     return ResponseEntity.ok(result); } @DeleteMapping(&quot;/{id}&quot;) public Object delete(@PathVariable(&quot;id&quot;) String id) throws Exception{     Image image=this.imageService.delete(id);     // zookeeper     if(image!=null){         String data=&quot;DEL:&quot;+image.getId()+&quot;:&quot;+image.getType()+&quot;:&quot;+image.getOriginalName();         String zkPath=zkService.create(&quot;/&quot;+image.getId(), data.getBytes());         System.out.println(&quot;create zkPath(for DEL):&quot;+zkPath);     }     return ResponseEntity.ok(image!=null); } @GetMapping public Object list(){     return ResponseEntity.ok(this.imageService.list()); } @GetMapping(&quot;/{id}&quot;) public Object get(@PathVariable(&quot;id&quot;)String id) throws IOException{     Image image=this.imageService.get(id);     if(image==null || !&quot;Active&quot;.equals(image.getStatus())              || StringUtils.isEmpty(image.getType()) || &quot;Unknow&quot;.equals(image.getType()))         return ResponseEntity.ok(&quot;Not Available!&quot;);     FileInputStream in=new FileInputStream(this.fileLocation+&quot;/&quot;+image.getId()+&quot;.&quot;+image.getType());     return ResponseEntity.ok()             .contentType(MediaType.IMAGE_JPEG)             .contentType(MediaType.IMAGE_PNG)             .contentType(MediaType.IMAGE_GIF)             .body(IOUtils.toByteArray(in)); } /* ------ For Test: -------- */ @GetMapping(value=&quot;/test1/{name}&quot;         ,produces={MediaType.IMAGE_JPEG_VALUE,MediaType.IMAGE_PNG_VALUE,MediaType.IMAGE_GIF_VALUE}) public Object getImageByName1(@PathVariable(&quot;name&quot;) String filename) throws IOException{     String filePath=&quot;/Users/cj/Pictures/design&quot;;     FileInputStream in = new FileInputStream(filePath+&quot;/&quot;+filename);     return IOUtils.toByteArray(in);    // or ResponseEntity.ok(IOUtils.toByteArray(in)); } @GetMapping(value=&quot;/test2/{name}&quot;) public Object getImageByName2(@PathVariable(&quot;name&quot;) String filename) throws IOException{     String filePath=&quot;/Users/cj/Pictures/design&quot;;     FileInputStream in = new FileInputStream(filePath+&quot;/&quot;+filename);     return ResponseEntity.ok()             .contentType(MediaType.IMAGE_JPEG)             .contentType(MediaType.IMAGE_PNG)             .contentType(MediaType.IMAGE_GIF)             .body(IOUtils.toByteArray(in)); } @PostConstruct private void init() throws Exception{     System.out.println(&quot;init:&quot;+this.fileLocation);     FileUtils.forceMkdir(new File(this.fileLocation));     String id=&quot;1d0fa647-9dbe-410a-8d9c-0e1c973a98e2&quot;;     Image image=new Image(id,&quot;light.jpg&quot;,&quot;Active&quot;);     FileUtils.copyFile(new File(&quot;/Users/cj/Pictures/design/极光1.jpg&quot;), new File(this.fileLocation+&quot;/&quot;+id+&quot;.jpg&quot;));     this.imageService.save(image);     // zookeeper     String data=&quot;ADD:&quot;+image.getId()+&quot;:&quot;+image.getType()+&quot;:&quot;+image.getOriginalName();     String zkPath=zkService.create(&quot;/&quot;+image.getId(), data.getBytes());     System.out.println(&quot;create zkPath(for ADD):&quot;+zkPath); } @PreDestroy private void clear() throws Exception{     FileUtils.cleanDirectory(new File(this.fileLocation));     // zookeeper     zkService.delete(&quot;/&quot;); }}</code></pre></li><li><p>main</p><pre><code class="lang-java">@SpringBootApplication@Configurationpublic class App { public static void main( String[] args ){     SpringApplication.run(App.class, args); } @Bean(name=&quot;zkService&quot;) public ZkCuratorService zkService(){     return new ZkCuratorService(); }}</code></pre></li></ol><h3 id="header-11">User(ClientUser)</h3><ol><li><p>application.yml</p><pre><code> server:   port: 8090   servlet:     context-path: /zookeeper-demo zk:   server: 127.0.0.1:2181   namespace: demo user:   fileLocation: /Users/cj/space/java/user-downloads   fileServer: http://localhost:8080/zookeeper-demo/admin/images</code></pre></li><li><p>ImageUserController</p><pre><code class="lang-java">@RestController@RequestMapping(&quot;/user/images&quot;)public class ImageUserController { @Value(&quot;${user.fileLocation}&quot;) private String fileLocation; @Value(&quot;${user.fileServer}&quot;) private String fileServer; @Resource(name=&quot;zkClientService&quot;)//    @Resource(name=&quot;zkService&quot;) private ZkCuratorService zkService; @GetMapping(&quot;/{filename}&quot;) public Object get(@PathVariable(&quot;filename&quot;) String filename) throws IOException{     FileInputStream in=new FileInputStream(this.fileLocation+&quot;/&quot;+filename);     return ResponseEntity.ok()             .contentType(MediaType.IMAGE_JPEG)             .contentType(MediaType.IMAGE_PNG)             .contentType(MediaType.IMAGE_GIF)             .body(IOUtils.toByteArray(in)); } @PostConstruct public void init() throws Exception{     PathChildrenCacheListener listener=new PathChildrenCacheListener(){         @Override         public void childEvent(CuratorFramework client, PathChildrenCacheEvent event)                  throws Exception {             System.out.println(&quot;Get Event:&quot;+event.getType());             if(event.getType().equals(PathChildrenCacheEvent.Type.CHILD_ADDED)){                 ChildData child=event.getData();                 if(child==null)                     return;                 String data=new String(child.getData());                 String array[]=data.split(&quot;:&quot;);                 String filename= array[1]+&quot;.&quot;+array[2];                 System.out.println(child.getPath()+&quot;:&quot;+data);                 if(&quot;ADD&quot;.equals(array[0])){                     try{                         Thread.sleep(3000);        // ! for test and connect refused exception                         FileUtils.copyURLToFile(new URL(fileServer+&quot;/&quot;+filename)                                 , new File(fileLocation+&quot;/&quot;+filename));                         zkService.delete(child.getPath());                     }catch(ConnectException ex){                         System.out.println(ex.getMessage());                     }                 }else if(&quot;DEL&quot;.equals(array[0])){                     try{                         FileUtils.forceDelete(new File(fileLocation+&quot;/&quot;+filename));                     }catch(FileNotFoundException ex){                         System.out.println(&quot;not exist:&quot;+fileLocation+&quot;/&quot;+filename);                     }                     zkService.delete(child.getPath());                 }             }         }     };     zkService.addPathChildrenWatcher(&quot;/&quot;, true, listener); } @PreDestroy public void clear() throws Exception{     FileUtils.cleanDirectory(new File(this.fileLocation));     // zookeeper     zkService.delete(&quot;/&quot;); }}</code></pre></li><li><p>main</p><pre><code class="lang-java">@SpringBootApplication@Configurationpublic class App { public static void main( String[] args ){     SpringApplication.run(App.class, args); } @Bean(name=&quot;zkClientService&quot;) public ZkCuratorService zkClientService(){     return new ZkCuratorService(); }}</code></pre></li></ol><h3 id="header-12">Common: Service &amp; Entity</h3><ol><li><p>ImageService</p><pre><code class="lang-java">@Servicepublic class ImageService { private final ConcurrentMap&lt;String,Image&gt; images=new ConcurrentHashMap&lt;String,Image&gt;(); public boolean save(Image image){     return images.put(image.getId(),image)==null; } public Image delete(String id){     Image image=images.get(id);     if(image==null)         return null;     image.setStatus(&quot;InActive&quot;);     images.replace(id, image);     return image; } public Image get(String id){     return images.get(id); } public Collection&lt;Image&gt; list(){     return images.values(); }   }</code></pre></li><li><p>ZkCuratorService</p><pre><code class="lang-java">public class ZkCuratorService { private CuratorFramework zkClient; @Value(&quot;${zk.server}&quot;) private String connectString; @Value(&quot;${zk.namespace}&quot;) private String namespace; private PathChildrenCache childCache; public CuratorFramework getZkClient() {     return zkClient; } public void setZkClient(CuratorFramework zkClient) {     this.zkClient = zkClient; } @PostConstruct public void init(){     System.out.println(&quot;ZK Service init&quot;);     RetryPolicy retryPolicy = new ExponentialBackoffRetry(3000, 3);     zkClient=CuratorFrameworkFactory.builder()             .connectString(connectString)             .retryPolicy(retryPolicy)             .sessionTimeoutMs(10000)             .connectionTimeoutMs(10000)             .namespace(namespace)             .build();     zkClient.start(); } @PreDestroy public void close(){     if(zkClient!=null)         zkClient.close(); } public void addPathChildrenWatcher(String watchPath,boolean createIfNotExist,PathChildrenCacheListener listener) throws Exception{     if(createIfNotExist){         if(zkClient.checkExists().forPath(watchPath)==null){             zkClient.create().creatingParentContainersIfNeeded().forPath(watchPath);         }     }     childCache = new PathChildrenCache(zkClient, watchPath, true);     System.out.println(&quot;Add Listener...&quot;);     childCache.getListenable().addListener(listener);     System.out.println(&quot;Start Cache...&quot;);     childCache.start(StartMode.POST_INITIALIZED_EVENT);     // 异步初始化 -- initial trigger watcher: Type.INITIALIZED } public String create(String path,byte[] data) throws Exception{     return zkClient.create()             .creatingParentsIfNeeded()             .withMode(CreateMode.PERSISTENT_SEQUENTIAL)             .forPath(path,data); } public void delete(String path) throws Exception{     zkClient.delete().guaranteed().deletingChildrenIfNeeded().forPath(path); } public Stat update(String path,byte[] data) throws Exception{     return zkClient.setData().forPath(path,data); } public Stat checkExists(String path) throws Exception{     return zkClient.checkExists().forPath(path); }}</code></pre></li><li><p>Entity: Image</p><pre><code class="lang-java">public class Image { private String id; private String originalName; private String type; private String status; public Image(){} public Image(String id,String originalName,String status){     this.id=id;     this.originalName=originalName;     this.status=status;     int pos=originalName.lastIndexOf(&quot;.&quot;);     this.type=(pos!=-1?originalName.substring(pos+1):&quot;Unknow&quot;); } /* getter &amp; setter .... */}</code></pre></li></ol><h2 id="header-13">Reference</h2><p><a href="https://github.com/sixDegree/micro-demo" target="_blank" rel="noopener">My demo: zookeeper-demo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;dependency: curator-recipes&lt;/li&gt;
&lt;li&gt;Start／Close: CuratorFrameworkFactory.builder()…build(), start(),close()&lt;/li&gt;
&lt;li&gt;CRUD: create(),getData(),setData(),delete(),checkExists(),getChildren()&lt;/li&gt;
&lt;li&gt;Watch: usingWatcher(watcher),NodeCache,PathChildrenCache,TreeCache&lt;/li&gt;
&lt;li&gt;ACL: schema:id:permission, new ACL(perms,id),.aclProvider(aclProvider),.authorization(authInfoList),.withACL(aclList),get/setACL()&lt;/li&gt;
&lt;li&gt;一个应用示例：Client端监控文件增删，实现文件从Server端到Client端的同步&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="MicroService" scheme="http://sixdegree.github.io/tags/MicroService/"/>
    
  </entry>
  
  <entry>
    <title>智能路由 Zuul</title>
    <link href="http://sixdegree.github.io/2019/01/02/Zuul.html"/>
    <id>http://sixdegree.github.io/2019/01/02/Zuul.html</id>
    <published>2019-01-01T16:00:00.000Z</published>
    <updated>2019-03-09T08:04:39.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>dependency: spring-cloud-starter-netflix-zuul</li><li>@EnableZuulProxy(included: @EnableDiscoveryClient, @EnableCircuitBreaker)</li><li>ZuulFilter @Override shouldFilter(),filterType(), filterOrder(),run()</li><li>配置zuul.routes.xxx: path,url/service-id</li><li>通过Eureka中已经注册的服务名,调用服务（使用service-id)</li></ol><a id="more"></a><h2 id="header-1">Start</h2><ul><li>是Netflix开源的微服务网关组件(路由转发 + 过滤器)</li><li>可以和Eureka、Ribbon、Hystrix等组件配合使用，提供动态路由，监控，弹性，安全等的边缘服务</li><li>其核心是一些列的Filters，用来实现对外服务的控制，其作用可以类比Servlet框架的Filter，或者AOP，根据执行时期分为以下几类:<ul><li>PRE：在请求被路由之前调用</li><li>ROUTING：将请求路由到微服务</li><li>POST：在路由到微服务以后执行</li><li>ERROR：在其他阶段发生错误时执行该过滤器</li></ul></li><li>Zuul可实现对内/对外路由，内部服务互相调用还可通过Eureka进行服务发现和调用<ul><li>通过URL映射来实现路由有局限性(例如每增加一个服务就需要配置一条内容；服务本身被调度到其他节点Zuul无法感知）</li><li>利用Eureka注册服务，配置Zuul从Eureka Server获取服务的地址并且基于所有服务的实例进行轮询/熔断/重试更好</li><li>在实现微服务架构时，服务名与服务实例地址的关系在eureka server中已经存在了,只需要将Zuul注册到eureka即可</li><li>注：对于使用<code>service-id</code>的路由，Zuul会以均衡负载（Ribbon）的方式访问服务</li></ul></li><li>路由规则：<ul><li>URL(path,url,prefix,strip-prefix)</li><li>Service(path,service-id,prefix,strip-prefix)</li><li><code>strip-prefix</code>: 是否过滤掉前缀（true则过滤掉）<ul><li>eg: <code>path: /myusers/**</code>，默认时转发到服务的请求是<code>/**</code>，如果<code>stripPrefix</code>为<code>false</code>，则转发的请求是<code>/myusers/**</code></li></ul></li><li><code>prefix</code>: 对path增加一个前缀，可加在全局zuul下，也可加在某个路由规则下面</li><li><code>service-id</code>: 服务名，服务发现中的服务</li><li><code>ignored-services</code>: 注意匹配了忽略的列表, 但却明确的配置在路由列表中的路由不会被忽略</li></ul></li><li>路由熔断: 可以通过写自定义的fallback方法，并且将其指定给某个route,来实现该route访问出问题的熔断处理<pre><code class="lang-java">  public interface FallbackProvider {      // 告诉 Zuul 它是负责哪个 route 定义的熔断      public String getRoute();                                                      // 告诉 Zuul 断路出现时，它会提供一个什么返回值来处理请求      ClientHttpResponse fallbackResponse(String route, Throwable cause);          }</code></pre></li><li>在Spring Cloud体系中，Spring Cloud Zuul就是提供负载均衡、反向代理、权限认证的一个<code>API gateway</code></li><li>Note: <code>API Gateway</code> 是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过这一层，作用<ul><li>简化客户端调用复杂度</li><li>数据裁剪以及聚合</li><li>多渠道支持 （针对不同的渠道和客户端提供不同的API Gateway,eg: BFF Backend for front-end）</li></ul></li></ul><p><img src="/2019/01/02/zuul-filter.png" alt="Filters"></p><p><img src="/2019/01/02/zuul-simple.jpg" alt="Simple"></p><p><img src="/2019/01/02/zuul-case.png" alt="高可用"></p><h2 id="header-2">Demo</h2><h3 id="header-3">Starter</h3><ol><li><p>pom.xml</p><pre><code class="lang-xml"> &lt;properties&gt;     &lt;spring-cloud.version&gt;Finchley.RELEASE&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt;     &lt;dependencies&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;             &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;             &lt;version&gt;${spring-cloud.version}&lt;/version&gt;             &lt;type&gt;pom&lt;/type&gt;             &lt;scope&gt;import&lt;/scope&gt;         &lt;/dependency&gt;     &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;         &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;     &lt;/dependency&gt; &lt;/dependencies&gt;</code></pre></li><li><p>resources/application.yml</p><pre><code> server:   port: 8888   servlet:     context-path: /zuul-demo spring:   application:     name: zuul-demo zuul:   routes:     baidu:       path: /baidu/**       url: http://www.baidu.com     csdn:       path: /csdn/**       url: https://www.csdn.net/</code></pre></li><li><p>main</p><pre><code class="lang-java"> @EnableZuulProxy     // include: @EnableDiscoveryClient, @EnableCircuitBreaker @SpringBootApplication public class MicroZuulApplication {     public static void main(String[] args) {         SpringApplication.run(MicroZuulApplication.class, args);     } }</code></pre></li><li><p>Visit: <code>http://localhost:8888/zuul-demo</code></p><ul><li><code>/baidu</code></li><li><code>/csdn</code></li></ul></li></ol><h3 id="header-4">Filter</h3><ol><li><p>Filter Definition</p><pre><code class="lang-java"> public class MyFilter extends ZuulFilter {     private static Logger log = LoggerFactory.getLogger(MyFilter.class);     @Override     public boolean shouldFilter() {         return true;     }     @Override     public Object run() throws ZuulException {         RequestContext ctx = RequestContext.getCurrentContext();          HttpServletRequest request = ctx.getRequest();          log.info(String.format(&quot;%s -- %s&quot;, request.getMethod(), request.getRequestURL().toString()));          String token = request.getParameter(&quot;token&quot;);// 获取请求的参数          if (token!=null &amp;&amp; token.length()&gt;0) {              ctx.setSendZuulResponse(true); //对请求进行路由              ctx.setResponseStatusCode(200);              ctx.set(&quot;success&quot;, true);          } else {              ctx.setSendZuulResponse(false); //不对其进行路由              ctx.setResponseStatusCode(400);              ctx.setResponseBody(&quot;token is empty&quot;);              ctx.set(&quot;success&quot;, false);          }         return null;     }     @Override     public String filterType() {         //Zuul内置的filter类型有四种，pre, route，post，error，分别代表请求处理前，处理时，处理后和出错后         return &quot;pre&quot;;     }     @Override     public int filterOrder() {         //指定了该过滤器执行的顺序         return 1;     } }</code></pre></li><li><p>Inject Filter Bean</p><pre><code class="lang-java"> @EnableZuulProxy @SpringBootApplication public class MicroZuulApplication {     public static void main(String[] args) {         SpringApplication.run(MicroZuulApplication.class, args);     }     // inject Filter     @Bean      public MyFilter myFilter() {          return new MyFilter();      } }</code></pre></li><li><p>Visit: <code>http://localhost:8888/zuul-demo</code></p><ul><li><code>/baidu</code></li><li><code>/baidu?token=123</code></li></ul></li></ol><h3 id="header-5">Service</h3><p>这里通过Eureka中已经注册的服务名,调用服务</p><ol><li><p>Prepare <a href="https://github.com/sixDegree/micro-demo" target="_blank" rel="noopener">Eureka</a></p><ul><li>Eureka Server(eureka-server): <code>http://localhost:8761/eureka-server</code> </li><li>Eureka Client(eureka-client): <code>http://localhost:8080/eureka-client</code> (<code>/</code>,<code>/say</code>,<code>/actuator</code>)</li></ul></li><li><p>pom.xml: 添加<code>spring-cloud-starter-netflix-eureka-client</code></p><pre><code class="lang-xml"> &lt;properties&gt;     &lt;spring-cloud.version&gt;Finchley.RELEASE&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt;     &lt;dependencies&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;             &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;             &lt;version&gt;${spring-cloud.version}&lt;/version&gt;             &lt;type&gt;pom&lt;/type&gt;             &lt;scope&gt;import&lt;/scope&gt;         &lt;/dependency&gt;     &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;         &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;         &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;     &lt;/dependency&gt; &lt;/dependencies&gt;</code></pre></li><li><p>resource/application.xml</p><pre><code> server:   port: 8888   servlet:     context-path: /zuul-demo spring:   application:     name: zuul-demo # 注册到eureka服务中心 eureka:   client:     service-url:       defaultZone: http://localhost:8761/eureka-server/eureka  zuul:   routes:     baidu:       path: /baidu/**     csdn:       path: /csdn/**       url: https://www.csdn.net/     eurekaServer:       path: /eurekaServer/**       url: http://localhost:8761/eureka-server/     serviceTest1:    # http://localhost:8888/zuul-demo/eureka-client/say       path: /eureka-client/**       service-id: eureka-client       strip-prefix: false        serviceTest2:    # http://localhost:8888/zuul-demo/ec/eureka-client/say       path: /ec/**       service-id: eureka-client</code></pre></li><li><p>FallbackProvider: 熔断处理，eg： 未发现eureka-client service，则会调用此处理</p><pre><code class="lang-java"> public class MyFallbackProvider implements FallbackProvider{     @Override     public String getRoute() {         return &quot;*&quot;;     }     @Override     public ClientHttpResponse fallbackResponse(String route, Throwable cause) {          return new ClientHttpResponse() {                 @Override                 public HttpStatus getStatusCode() throws IOException {                     return HttpStatus.OK;                 }                 @Override                 public int getRawStatusCode() throws IOException {                     return 200;                 }                 @Override                 public String getStatusText() throws IOException {                     return &quot;OK&quot;;                 }                 @Override                 public void close() {                 }                 @Override                 public InputStream getBody() throws IOException {                     return new ByteArrayInputStream(&quot;This is my fallback response&quot;.getBytes());                 }                 @Override                 public HttpHeaders getHeaders() {                     HttpHeaders headers = new HttpHeaders();                     headers.setContentType(MediaType.APPLICATION_JSON);                     return headers;                 }             };     } }</code></pre></li><li><p>main</p><pre><code class="lang-java"> @EnableZuulProxy @SpringBootApplication public class MicroZuulApplication {     public static void main(String[] args) {         SpringApplication.run(MicroGatewayApplication.class, args);     }     @Bean     public MyFallbackProvider myFallbackProvider() {         return new MyFallbackProvider();     } /* service route 映射规则修改    eg： service: erueka-client =&gt; route: eureka/client */ //    @Bean //    public PatternServiceRouteMapper serviceRouteMapper() { //        // servicePatterh,routePattern //        return new PatternServiceRouteMapper( //            &quot;(?&lt;servicename&gt;^.+)-(?&lt;contextPath&gt;v.+$)&quot;, //            &quot;${servicename}/${contextPath}&quot;); //    } }</code></pre></li><li><p>Visit: <code>http://localhost:8888/zuul-demo</code></p><ul><li><code>/eureka-client/</code>,<code>/eureka-client/say</code>,<code>/eureka-client/actuator</code></li><li><code>/ec/eureka-client/</code>, <code>/ec/eureka-client/say</code>,<code>/ec//eureka-client/actuator</code></li><li><code>/eurekaServer/</code></li><li>关闭eureka-client后再访问，会出发路由熔断机制，返回<code>This is my fallback response</code></li></ul></li></ol><h2 id="header-6">Reference</h2><p><a href="https://github.com/sixDegree/micro-demo" target="_blank" rel="noopener">My demo: zuul-demo</a></p><p><a href="https://www.cnblogs.com/lexiaofei/p/7080257.html" target="_blank" rel="noopener">zuul入门（1）zuul 的概念和原理</a></p><p><a href="https://cloud.spring.io/spring-cloud-netflix/2.0.x/single/spring-cloud-netflix.html" target="_blank" rel="noopener">Spring Cloud Netflix</a></p><p><a href="https://blog.csdn.net/zhanglh046/article/details/78651993/" target="_blank" rel="noopener">使用Zuul构建API Gateway</a></p><p><a href="https://blog.csdn.net/chenqipc/article/details/53322830/" target="_blank" rel="noopener">Zuul:智能路由和过滤</a></p><p><a href="https://www.imooc.com/article/44600" target="_blank" rel="noopener">路由网关—zuul</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;dependency: spring-cloud-starter-netflix-zuul&lt;/li&gt;
&lt;li&gt;@EnableZuulProxy(included: @EnableDiscoveryClient, @EnableCircuitBreaker)&lt;/li&gt;
&lt;li&gt;ZuulFilter @Override shouldFilter(),filterType(), filterOrder(),run()&lt;/li&gt;
&lt;li&gt;配置zuul.routes.xxx: path,url/service-id&lt;/li&gt;
&lt;li&gt;通过Eureka中已经注册的服务名,调用服务（使用service-id)&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="MicroService" scheme="http://sixdegree.github.io/tags/MicroService/"/>
    
  </entry>
  
</feed>
