<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SixDegree</title>
  
  <subtitle>host by chenjin</subtitle>
  <link href="//atom.xml" rel="self"/>
  
  <link href="http://sixdegree.github.io/"/>
  <updated>2018-10-26T12:33:58.000Z</updated>
  <id>http://sixdegree.github.io/</id>
  
  <author>
    <name>Chen Jin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES6</title>
    <link href="http://sixdegree.github.io/2018/10/15/ES6.html"/>
    <id>http://sixdegree.github.io/2018/10/15/ES6.html</id>
    <published>2018-10-14T16:00:00.000Z</published>
    <updated>2018-10-26T12:33:58.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>变量，作用域，Symbol</li><li>Object，Function，Array，Set，Map</li><li>解构赋值，扩展运算符，箭头函数</li><li>代理器Proxy，修饰器Decorator，遍历器Iterator</li><li>类，模块</li></ol><a id="more"></a><blockquote><p>参阅 <a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="noopener">阮一峰 ECMAScript 6 入门</a> ，作一个归纳整理吧。。。</p></blockquote><p>ES6 : 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等,而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。</p><p>ES6 的第一个版本在 2015 年 6 月发布，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）</p><h2 id="header-1">声明变量</h2><ul><li>var （ES5）</li><li>function （ES5）</li><li>let</li><li>const</li><li>class</li><li>import</li></ul><p><strong> var/let/const: </strong></p><ul><li><p>scope:</p><pre><code class="lang-js">  {    var a = 1;    let b = 10;    const c = 20;  }  a               // 1  b              // ReferenceError: b is not defined.  c              // ReferenceError: c is not defined.</code></pre></li><li><code>var</code> : 声明的变量在全局范围内都有效；会发生”变量提升“现象（即变量可以在声明之前使用，值为undefined）<pre><code class="lang-js">  var a = [];  for (var i = 0; i &lt; 10; i++) {    a[i] = function () {      console.log(i);    };  }  a[6]();                     // 10</code></pre></li><li><code>let</code> : 声明的变量只在所在的代码块内有效（局部有效）；声明的变量一定要在声明后使用，否则报错（“暂时性死区”）<pre><code class="lang-js">  var a = [];  for (let i = 0; i &lt; 10; i++) {    a[i] = function () {      console.log(i);    };  }  a[6]();                     // 6</code></pre></li><li><code>const</code> : 声明一个只读的常量；与let相同，只在声明所在的块级作用域内有效，同样存在暂时性死区<ul><li>ES5 常量写法：<pre><code class="lang-js">  Object.defineProperty(window,&quot;PI&quot;,{      value:3.1415926,      writable:false  });  console.log(window.PI);</code></pre></li><li>ES6 常量写法（使用const）<pre><code class="lang-js">  const PI = 3.1415;  PI                                           // 3.1415  PI = 3;                                      // TypeError: Assignment to constant variable.</code></pre></li><li>scope:<pre><code class="lang-js">  const foo;                                // SyntaxError: Missing initializer in const declaration  if (true) {    const MAX = 5;    MAX                                      // 5  }  MAX                                        // Uncaught ReferenceError: MAX is not defined</code></pre></li></ul></li><li><p>注：</p><ul><li><code>const</code>实际上保证的是变量指向的内存地址中保存的数据不得改动</li><li><p>所以对于简单类型的数据（例如：数值、字符串、布尔值）可以保证只读，但对于复合类型的数据就无法保证了</p><pre><code class="lang-js">  const foo = {};  foo.prop = 123;              // 成功  foo = {};                    // TypeError: &quot;foo&quot; is read-only  const a = [];  a.push(&#39;Hello&#39;);             //  成功  a.length = 0;                //  成功  a = [&#39;Dave&#39;];                // 报错</code></pre></li><li>在<code>let</code>和<code>const</code>之间，建议优先使用<code>const</code>，尤其是在全局环境，不应该设置变量，只应设置常量</li></ul></li></ul><h2 id="header-2">块级作用域 <code>{}</code></h2><ol><li><p>可代替闭包</p><ul><li>ES5 闭包（执行函数表达式 IIFE）写法：<pre><code class="lang-js">  (function () {    var tmp = ...;    ...  }());</code></pre></li><li>ES6 块级作用域写法：<pre><code class="lang-js">  {    let tmp = ...;    ...  }</code></pre></li></ul></li><li><p>声明的函数在不同环境下可能会有差异，建议使用函数表达式，而不是函数声明语句</p><ul><li>使用函数声明语句 – 不推荐，不同环境下会有差异：<pre><code class="lang-js">  {    let a = &#39;secret&#39;;    function f() {return a;}  }</code></pre><ul><li>浏览器环境： 函数声明类似于var（即会提升到全局作用域和函数作用域的头部）</li><li>其他环境：函数声明类似于let （对作用域之外没有影响）</li></ul></li><li>使用函数表达式方式(推荐方式)<pre><code class="lang-js">  {    let a = &#39;secret&#39;;    let f = function () {return a;};  }</code></pre></li></ul></li></ol><h2 id="header-3">顶层对象 <code>global</code></h2><p>为同一段代码能够在各种环境，都能取到顶层对象，引入global<br>注：</p><ul><li>浏览器中顶层对象： windows，self</li><li>Node中顶层对象： global</li><li>一般通用方法是使用this，但有局限性</li></ul><p><strong> 示例：</strong></p><ol><li><p>全局变量与顶层对象</p><ul><li>ES5中，全局变量与顶层对象等价<pre><code class="lang-js">  var a = 1;  window.a                 // 1  -- Node 的 REPL 环境，可以写成 global.a，或者用通用方法this.a</code></pre></li><li>ES6中，全局变量与顶层对象不等价<pre><code class="lang-js">  let a = 1;  window.a                 // undefined</code></pre></li></ul></li><li><p>使用垫片库system.global取到global</p><pre><code class="lang-js"> // CommonJS 的写法 var global = require(&#39;system.global&#39;)(); // ES6 模块的写法 import getGlobal from &#39;system.global&#39;; const global = getGlobal();</code></pre></li></ol><h2 id="header-4">扩展运算符 <code>...</code></h2><p><code>...变量</code> ： 将剩余传入的参数值，存入一个数组变量中<br><code>...对象</code> ： 拷贝对象的可遍历属性给一个新对象</p><p><strong> 示例：</strong> </p><ol><li><p>function rest 参数</p><pre><code class="lang-js"> function add(...values) {   let sum = 0;   for (let val of values) {     sum += val;   }   return sum; } add(2, 5, 3)                 // 10</code></pre><ul><li>注：rest参数只能是最后一个参数，否则会报错<br>（ES5 使用arguments对象，类似数组，但非数组，可使用Array.prototype.slice.call(arguments)转换为数组）</li></ul></li><li><p>解构赋值</p><pre><code class="lang-js"> let [head, ...tail] = [1, 2, 3, 4]; head             // 1 tail             // [2, 3, 4]</code></pre></li><li><p>拷贝对象的可遍历属性，同<code>Object.assign</code></p><pre><code class="lang-js"> let aClone = { ...a };                                  // 等同 let aClone = Object.assign({}, a); let abClone = { ...a, ...b };                           // 等同 let abClone = Object.assign({}, a, b); let aWithOverrides = { ...a, x: 1, y: 2 };        let aWithOverrides = { ...a, ...{ x: 1, y: 2 } }; let x = 1, y = 2, aWithOverrides = { ...a, x, y }; // 以上都等同 let aWithOverrides = Object.assign({}, a, { x: 1, y: 2 });</code></pre><ul><li>注： 扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行<pre><code class="lang-js">  let obj={      a:1,      get x(){         throw new Error(&#39;get x error!&#39;);      }  }  let c={...obj};    //  get x error!</code></pre></li></ul></li></ol><h2 id="header-5">解构赋值 (Destructuring)</h2><p>从等式右边的对象中提取值，赋给左边对应变量:</p><ul><li>模式匹配：只要等号两边的模式相同，左边的变量就会被赋予对应的值</li><li>类型转换：若等号右边的值不是对象或数组，就先将其转为对象</li><li>浅拷贝：解构赋值的拷贝都是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本</li><li>注：<ul><li><code>undefined</code>/<code>null</code>: 无法转为对象，对它们进行解构赋值，会报错</li><li><code>...</code>：扩展运算符的解构赋值(<code>...a</code>)，只能读取对象自身的属性</li></ul></li></ul><p>eg：</p><pre><code class="lang-js">let a = 1;let b = 2;// 可合并成：let [a, b] = [1, 2];a    // 1b    // 2</code></pre><h3 id="header-6">解构数组赋值</h3><p>右边数据结构具有 Iterator 接口，即可用数组形式解构赋值，否则报错</p><p><strong> 示例：</strong></p><ol><li><p>完全解构</p><pre><code class="lang-js"> let [foo, [[bar], baz]] = [1, [[2], 3]]; foo                 // 1 bar                 // 2 baz                 // 3 let [x, , y] = [1, 2, 3]; x                     // 1 y                     // 3 let [head, ...tail] = [1, 2, 3, 4]; head                 // 1 tail                 // [2, 3, 4]</code></pre></li><li><p>不完全解构</p><pre><code class="lang-js"> let [a, [b], d] = [1, [2, 3], 4]; a // 1 b // 2 d // 4 let [x, y, ...z] = [&#39;a&#39;]; x                     // &quot;a&quot; y                     // undefined z                     // []</code></pre></li><li><p>解构不成功</p><pre><code class="lang-js"> let [foo] = []; foo                // undefined //报错 let [foo] = 1; let [foo] = false; let [foo] = {}; let [foo] = null;</code></pre></li><li>对数组进行对象属性的解构，使用：属性名表达式<pre><code class="lang-js"> let arr = [1, 2, 3]; let {0 : first, [arr.length - 1] : last} = arr; first                 // 1 last                 // 3</code></pre></li></ol><h3 id="header-7">解构对象赋值</h3><p>对象的属性没有次序，变量须与属性同名或给变量指定对应属性，才能取到正确的值<br>（解构数组赋值：是按照数组顺序位置给对应变量赋值的）</p><p><strong> 示例：</strong></p><ol><li><p>单层结构对象</p><pre><code class="lang-js"> let { foo, bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; foo                 // &quot;aaa&quot; bar                 // &quot;bbb&quot; let { x } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; x                    // undefined let { foo: x } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; }; x                    // aaa</code></pre></li><li><p>嵌套结构的对象</p><pre><code class="lang-js"> let obj = {   p: [ &#39;Hello&#39;,{ y: &#39;World&#39; }] }; let { p: [x, { y }] } = obj;  // 这时p是模式，不是变量，不会被赋值 x                             // &quot;Hello&quot; y                             // &quot;World&quot; let { p, p: [x, { y }] } = obj; p                             // [&quot;Hello&quot;, {y: &quot;World&quot;}] x                             // &quot;Hello&quot; y                             // &quot;World&quot; // 嵌套对象，若子对象所在的父属性不存在，会报错 let {foo: {bar}} = {baz: &#39;baz&#39;};        // 报错，因为foo不存在</code></pre></li></ol><h3 id="header-8">解构函数参数赋值</h3><pre><code class="lang-js">function add([x, y]){  return x + y;}add([1, 2]);                                    // 3</code></pre><p>函数<code>add</code>的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量<code>x</code>和<code>y</code></p><pre><code class="lang-js">[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);        // [ 3, 7 ]</code></pre><h3 id="header-9">解构基础类型赋值</h3><p>会先转为对象</p><p><strong> 示例：</strong></p><ol><li><p>字符串</p><pre><code class="lang-js"> const [a, b, c, d, e] = &#39;hello&#39;; a                 // &quot;h&quot; b                 // &quot;e&quot; let {length : len} = &#39;hello&#39;; len                 // 5</code></pre></li><li>数值<pre><code class="lang-js"> let {toString: s} = 123; s === Number.prototype.toString         // true</code></pre></li><li>布尔值<pre><code class="lang-js"> let {toString: s} = true; s === Boolean.prototype.toString         // true</code></pre></li><li><code>undefined</code>，<code>null</code>: 无法转换为对象，解构报错<pre><code class="lang-js"> let { prop: x } = undefined;             // TypeError let { prop: y } = null;                  // TypeError</code></pre></li></ol><h3 id="header-10">指定默认值</h3><p><code>undefined</code>会触发使用默认值</p><p><strong> 示例：</strong></p><ol><li><p>数组</p><pre><code class="lang-js"> let [x, y = &#39;b&#39;] = [&#39;a&#39;];         // x=&#39;a&#39;, y=&#39;b&#39; // 默认值可以是一个表达式，表达式是惰性求值的，即只有在用到的时候，才会求值 function f() {   console.log(&#39;aaa&#39;); } let [x = f()] = [1];                // x 能取到值，所以函数f根本不会执行 // 默认值可以引用解构赋值的其他变量，但该变量必须已经声明 let [x = 1, y = x] = [];         // x=1; y=1 let [x = 1, y = x] = [2];        // x=2; y=2 let [x = 1, y = x] = [1, 2];     // x=1; y=2 let [x = y, y = 1] = [];         // ReferenceError: y is not defined -- 因为x用y做默认值时，y还没有声明</code></pre></li><li><p>对象</p><pre><code class="lang-js"> // 注：默认值生效的条件是，对象的属性值严格等于（===）undefined var {x, y = 5} = {x: 1}; x                     // 1 y                     // 5 var {x: y = 3} = {}; y                     // 3 var {x = 3} = {x: null}; x                     // null</code></pre></li><li><p>函数</p><pre><code class="lang-js"> function move({x = 0, y = 0} = {}) {        // 为变量x，y指定默认值   return [x, y]; } move({x: 3, y: 8});         // [3, 8] move({x: 3});               // [3, 0] move({});                   // [0, 0] move();                     // [0, 0] function move({x, y} = { x: 0, y: 0 }) {        // 为函数参数对象整体指定默认值，而不是为变量x和y指定默认值   return [x, y];， } move({x: 3, y: 8});         // [3, 8] move({x: 3});               // [3, undefined] move({});                   // [undefined, undefined] move();                     // [0, 0]</code></pre></li></ol><h3 id="header-11">应用示例</h3><ol><li><p>交换变量的值</p><pre><code class="lang-js"> let x = 1; let y = 2; [x, y] = [y, x];        // x=2,y=1</code></pre></li><li><p>合并数组</p><pre><code class="lang-js"> // ES5 var params=[&#39;hello&#39;,true,7]; var other=[1,2].concat(params); console.log(other); // ES6 // 利用扩展运算符合并数组 var params=[&#39;hello&#39;,true,7]; var other=[1,2,...params]; console.log(other);</code></pre></li><li><p>函数返回多个值: 函数返回多个值，只能将它们放在数组或对象里，通过解构赋值，取出这些值很方便</p><pre><code class="lang-js"> function example() {   return [1, 2, 3]; } let [a, b, c] = example();</code></pre></li><li><p>函数参数的定义：方便地将一组参数与变量名对应起来</p><pre><code class="lang-js"> // 参数是一组有次序的值 function f([x, y, z]) {      ...  } f([1, 2, 3]); // 参数是一组无次序的值 function f({x, y, z}) {      ...  } f({z: 3, y: 2, x: 1});</code></pre></li><li><p>提取 JSON 数据</p><pre><code class="lang-js"> let jsonData = {   id: 42,   status: &quot;OK&quot;,   data: [867, 5309] }; let { id, status, data: number } = jsonData; console.log(id, status, number);        // 42, &quot;OK&quot;, [867, 5309]</code></pre></li><li><p>遍历 Map 结构 ：任何部署了 Iterator 接口的对象，都可以用for…of循环遍历</p><pre><code class="lang-js"> const map = new Map(); map.set(&#39;first&#39;, &#39;hello&#39;); map.set(&#39;second&#39;, &#39;world&#39;); for (let [key, value] of map) {   console.log(key + &quot; is &quot; + value); } // first is hello // second is world // 只获取键名 for (let [key] of map) { ...} // 只获取键值 for (let [,value] of map) { ...}</code></pre></li><li><p>import模块的部分项</p><pre><code class="lang-js"> const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);</code></pre></li></ol><p>注： 圆括号</p><pre><code class="lang-js">// 错误let x;{x} = {x: 1};  // SyntaxError: syntax error  因为{x}会被当成一个代码块// 正确let x;({x} = {x: 1});</code></pre><h2 id="header-12">Iterator 遍历器</h2><p>提供一种统一的遍历接口，供<code>for...of</code>（或<code>while</code>）消费（循环遍历）</p><ul><li><p>本质：创建一个指针对象，通过<code>next</code>方法移动指针，指向遍历对象的成员，返回成员信息</p></li><li><p>属性：</p><ul><li><code>value</code> : 当前成员的值</li><li><code>done</code> : 布尔值，表示遍历是否结束</li></ul></li><li><p>方法：</p><ul><li><code>next</code> ：指针跳到下一个成员（遍历器必需部署此方法）</li><li><code>return</code> : 循环遍历中提前退出（出错，break）时触发调用 （可选部署）<ul><li>注：必须返回一个对象</li><li>使用场景：一个对象在完成遍历前，需要清理或释放资源</li></ul></li><li><code>throw</code> : 主要配合 Generator 函数使用（可选部署）</li></ul></li><li><p>可遍历性（iterable）：</p><ul><li>部署了Iterator 接口的数据结构，此数据结构即是“可遍历的”</li><li><p><code>Symbol.iterator</code>属性：当前数据结构默认的遍历器生成函数（即<code>Iterator</code>接口），执行这个函数，就会返回一个遍历器对象</p><pre><code class="lang-js">  let arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];  let iter = arr[Symbol.iterator]();  iter.next() // { value: &#39;a&#39;, done: false }  iter.next() // { value: &#39;b&#39;, done: false }  iter.next() // { value: &#39;c&#39;, done: false }  iter.next() // { value: undefined, done: true }</code></pre></li></ul></li><li><p>原生具备<code>Iterator</code>接口的数据结构：</p><ul><li>Array/TypedArray</li><li>Set/Map</li><li>String</li><li>function的arguments对象</li><li>Dom NodeList</li><li>Generator对象</li></ul></li><li><p>遍历操作：</p><ul><li><code>for...of</code> 循环<ul><li>循环读取键值(value)</li><li>遍历所有数据结构的统一的方法</li><li>内部调用的是数据结构的<code>Symbol.iterator</code>方法，可以与<code>break</code>，<code>continue</code>，<code>return</code>配合使用（<code>forEach</code>不行）</li></ul></li><li><code>for...in</code> 循环<ul><li>循环读取键名(key)，</li><li>任意顺序，不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键</li><li>主要是为遍历对象而设计</li></ul></li><li><p>示例:</p><ul><li><p>遍历数组</p><pre><code class="lang-js">  let arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];  arr.foo = &#39;hello&#39;;  // for...in循环读取键名(key)，注意：数组的key为数字，但循环键名为字符串  for (let i in arr) {    console.log(i);     // &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;  }  // for...of循环读取键值(value)，注意：数组的遍历器接口只返回具有数字索引的属性  for (let i of arr) {    console.log(i);     // a,b,c -- 不会返回数组arr的foo属性  }</code></pre></li><li><p>遍历对象</p><pre><code class="lang-js">  // 对于普通的对象，for...of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用  let es6 = {    edition: 6,    committee: &quot;TC39&quot;,    standard: &quot;ECMA-262&quot;  };  for (let e of es6) {    console.log(e);        // TypeError: es6[Symbol.iterator] is not a function  }  // for...in可以遍历普通对象  for (let e in es6) {    console.log(e);        // edition,committee,standard  }</code></pre></li></ul></li></ul></li></ul><h2 id="header-13">Proxy 代理器</h2><p>用于修改某些操作的默认行为，相当于在目标对象之前架设一层“拦截”,对外界的访问进行过滤和改写</p><h3 id="header-14">Proxy 对象</h3><p><strong> 构造Proxy实例对象：</strong></p><ul><li><p>方式一：<code>var proxy = new Proxy(target, handler);</code></p><pre><code class="lang-js">  var person = {    name: &quot;张三&quot;  };  var proxy = new Proxy(person, {    get: function(target, property) {      if (property in target) {        return target[property];      } else {        throw new ReferenceError(&quot;Property \&quot;&quot; + property + &quot;\&quot; does not exist.&quot;);      }    }  });  proxy.name // &quot;张三&quot;  proxy.age // 抛出一个错误</code></pre></li><li><p>方式二：<code>let {proxy,revoke}=Proxy.revocable(target,handler);</code> : 生成一个可取消的 Proxy 实例</p><ul><li>Proxy.revocable方法返回一个对象</li><li>该对象的proxy属性是Proxy实例</li><li><p>该对象的revoke属性是一个函数，可以取消Proxy实例</p><pre><code class="lang-js">let target = {};let handler = {};let {proxy, revoke} = Proxy.revocable(target, handler);proxy.foo = 123;proxy.foo // 123revoke();proxy.foo // TypeError: Revoked</code></pre></li></ul></li><li><p>参数说明：</p><ul><li><code>target</code>：所要拦截的目标对象</li><li><code>handler</code>：对象，用于定制拦截行为，若为空对象{}，则没有任何拦截效果，访问proxy对象等同于访问target对象</li></ul></li><li><p>注：Proxy代理后，目标对象内部的<code>this</code>会指向Proxy代理对象</p><pre><code class="lang-js">  const target = {    m: function () {      console.log(this === proxy);    }  };  const handler = {};  const proxy = new Proxy(target, handler);  target.m() // false  proxy.m()  // true</code></pre></li></ul><p><strong> Proxy 支持的拦截操作：</strong></p><ul><li>对象属性<ul><li><code>get(target,propKey,receiver)</code> : 拦截对象属性的读取,eg: <code>proxy.foo,proxy[&#39;foo&#39;]</code></li><li><code>set(target,propKey,value,receiver)</code> : 拦截对象属性的设置,eg: <code>proxy.foo=v,proxy[&#39;foo&#39;]=v</code></li><li><code>has(target,propKey)</code> : propKey in proxy</li><li><code>deleteProperty(target,propKey)</code>: delete proxy[propKey]</li></ul></li><li>函数调用<ul><li><code>apply(target,ctx,args)</code>: 拦截 Proxy 实例作为函数调用的操作,eg: <code>proxy(...args)</code>,<code>proxy.call(ctx,...args)</code>,<code>proxy.apply(...)</code></li><li><code>construct(target,args)</code>: 拦截 Proxy 实例作为构造函数调用的操作,eg: <code>new proxy(...args)</code></li></ul></li><li>属性描述对象<ul><li><code>defineProperty(target,propKey,propDesc)</code>: 拦截添加新属性,eg: <code>Object.defineProperty(proxy, propKey, propDesc)</code>,<code>Object.defineProperties(proxy, propDescs)</code></li><li><code>ownKeys(target)</code>: 拦截对象自身属性的读取操作, eg: <code>Object.getOwnPropertyNames</code>,<code>Object.getOwnPropertySymbols</code>,<code>Object.keys</code>,<code>for...in</code></li><li><code>getOwnPropertyDescriptor(target,propKey)</code>: 拦截获取属性描述对象, eg: <code>Object.getOwnPropertyDescriptor(proxy, propKey)</code></li></ul></li><li>对象原型<ul><li><code>getPropertyOf(target)</code>: 拦截获取对象原型, eg: <code>Object.getPrototypeOf(proxy)</code>,<code>instanceof</code></li><li><code>setPropertyOf(target,proto)</code>: 拦截设置对象原型, eg: <code>Object.setPrototypeOf(proxy, proto)</code></li></ul></li><li>对象扩展<ul><li><code>isExtensible(target)</code>: Object.isExtensible(proxy)</li><li><code>preventExtensions(target)</code>: Object.preventExtensions(proxy)</li></ul></li></ul><p><strong> 应用示例：</strong></p><ol><li><p>Proxy对象作为普通函数调用 VS 作为构造函数调用</p><pre><code class="lang-js"> var handler = {   get: function(target, name) {     if (name === &#39;prototype&#39;) {       return Object.prototype;     }     return &#39;Hello, &#39; + name;   },   apply: function(target, thisBinding, args) {     return args[0];   },   construct: function(target, args) {     return {value: args[1]};   } }; var fproxy = new Proxy(function(x, y) {   return x + y; }, handler); fproxy(1, 2) // 1 new fproxy(1, 2) // {value: 2} fproxy.prototype === Object.prototype // true fproxy.foo === &quot;Hello, foo&quot; // true</code></pre></li><li><p>私有变量</p><ul><li><p>ES3 写法</p><pre><code class="lang-js">  var Person=function(){      var data={          name:&#39;Tom&#39;,          sex:&#39;male&#39;,          age:15      }      this.get=function(key){          return data[key];      }      this.set=function(key,value){          if(key!==&#39;sex&#39;)              data[key]=value;      }  }  var person=new Person();  person.set(&#39;name&#39;,&#39;Jack&#39;);  person.set(&#39;sex&#39;,&#39;female&#39;);  console.table({      name: person.get(&#39;name&#39;),      sex: person.get(&#39;sex&#39;),      age: person.get(&#39;age&#39;)  }); // Jack,male,15</code></pre></li><li>ES5 写法<pre><code class="lang-js">  var Person={      name:&#39;Tom&#39;,      age: 15  }  Object.defineProperty(Person,&#39;sex&#39;,{      writable:false,      value:&#39;male&#39;  })  Person.name=&#39;Jack&#39;;  console.table({      name: Person.name,      age: Person.age,      sex: Person.sex  }); // Jack,male,15  Person.sex=&#39;female&#39;;    // will throw exception</code></pre></li><li><p>ES6</p><pre><code class="lang-js">  let Person={      name:&#39;Tom&#39;,      sex:&#39;male&#39;,      age:15  };  let person=new Proxy(Person,{      get(target,key){          return target[key]      }      set(target,key){          if(key!==&#39;sex&#39;)              target[key]=value;      }  });  person.set(&#39;name&#39;,&#39;Jack&#39;);  console.table({      name: person.get(&#39;name&#39;),      sex: person.get(&#39;sex&#39;),      age: person.get(&#39;age&#39;)  }); // Jack,male,15  person.set(&#39;sex&#39;,&#39;female&#39;);    // will throw exception</code></pre></li></ul></li></ol><h3 id="header-15">Reflect 对象</h3><ol><li><p>将Object的一些方法放到Reflect上，使用Reflect代替Object的一些方法，例如：</p><ul><li><p>defineProperty方法</p><pre><code class="lang-js">  // 老写法  try {    Object.defineProperty(target, property, attributes);    // success  } catch (e) {    // failure  }  // 新写法  if (Reflect.defineProperty(target, property, attributes)) {    // success  } else {    // failure  }</code></pre></li><li><p>判断对象是否有某属性</p><pre><code class="lang-js">  // 老写法  &#39;assign&#39; in Object // true  // 新写法  Reflect.has(Object, &#39;assign&#39;) // true</code></pre></li><li><p>方法调用</p><pre><code class="lang-js">  // 老写法  Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1  // 新写法  Reflect.apply(Math.floor, undefined, [1.75]) // 1</code></pre></li></ul></li><li><p>与Proxy对象的方法一一对应，可通过Reflect获取对象原有的默认行为，例如：</p><pre><code class="lang-js"> var loggedObj = new Proxy(obj, {   get(target, name) {     console.log(&#39;get&#39;, target, name);     return Reflect.get(target, name);   },   deleteProperty(target, name) {     console.log(&#39;delete&#39; + name);     return Reflect.deleteProperty(target, name);   },   has(target, name) {     console.log(&#39;has&#39; + name);     return Reflect.has(target, name);   } });</code></pre></li></ol><h2 id="header-16">对象 <code>Object</code></h2><h3 id="header-17">对象属性</h3><p><strong> <code>Descriptor</code>属性描述对象：</strong> 对象的每个属性都有一个描述对象，用来控制该属性的行为</p><ul><li><p>数据属性描述对象包含：</p><ul><li>value</li><li>writable</li><li>enumerable</li><li>configurable</li></ul></li><li><p>获取对象自身属性（非继承属性）的描述对象</p><ul><li>Object.getOwnPropertyDescriptor</li><li>Object.getOwnPropertyDescriptors</li><li>Reflect.getOwnPropertyDescriptors</li></ul></li><li><p>某属性的描述对象的enumerable：可枚举性，若为false，即不可枚举，则一下操作会忽略该属性</p><ul><li>for…in循环</li><li>Object.keys()</li><li>JSON.stringify()</li><li>Object.assign()</li><li>注：<ul><li>以上操作除了<code>for...in</code>会包含继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性</li><li>ES6 规定，所有 Class 的原型的方法都是不可枚举的</li></ul></li></ul></li></ul><p><strong> <code>__prop__</code>属性 </strong>（前后各两个下划线）： 等于<code>Object.prototype.__proto__</code>，即一个对象的<code>__prop__</code>属性值就是对象的原型</p><ul><li>操作对象的prototype对象（原型对象）的方法：<ul><li>Object.setPrototypeOf(object, prototype); </li><li>Object.getPrototypeOf(object); </li><li>Object.create(…) </li></ul></li></ul><p><strong> 获取对象自身属性的操作 </strong>（即不包括继承属性）:</p><ul><li>可枚举属性（无Symbol）：Object.keys(obj) – ES2017 引入了Object.values,Object.entries，作为遍历一个对象的补充手段，供for…of循环使用</li><li>可枚举和不可枚举属性（无Symbol）：Object.getOwnPropertyNames(obj) </li><li>Symbol属性：Object.getOwnPropertySymbols(obj) </li><li>所有（可枚举，不可枚举，Symbol）：Reflect.ownKeys(obj) </li></ul><p><strong> 示例：</strong></p><ol><li><p>Descriptor 属性描述对象</p><pre><code class="lang-js"> const obj = {   foo: 123,   get bar() { return &#39;abc&#39; } }; Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;) Object.getOwnPropertyDescriptors(obj) // descriptor对象 // { foo: //    { value: 123, //      writable: true, //      enumerable: true,         // 可枚举性 //      configurable: true //     }, //   bar: //    { get: [Function: get bar], //      set: undefined, //      enumerable: true, //      configurable: true }  // }</code></pre></li><li><p>读取/遍历对象</p><pre><code class="lang-js"> let obj = { a: 1, b: 2, c: 3 }; Object.keys(obj)                                            // [&#39;a&#39;, &#39;b&#39;] Object.values(obj)                                         //  [1,2,3] Object.entries(obj)                                        // [ [&#39;a&#39;, 1], [&#39;b&#39;, 2],[&#39;c&#39;,3] ] for (let [key, value] of entries(obj)) {   console.log([key, value]);                                // [&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3] } const map = new Map(Object.entries(obj));    // Map {a: 1, b: 2, c: 3}</code></pre></li></ol><h3 id="header-18">对象比较</h3><ul><li><code>==</code> 相等运算符：自动转换数据类型</li><li><code>===</code> 严格相等运算符：NaN不等于自身，+0与-0相等</li><li><code>Object.is</code> 同值相等：比较两个值是否严格相等，与<code>===</code>相比，<code>NaN</code>等于自身，<code>+0</code>与<code>-0</code>不等</li></ul><pre><code class="lang-js">+0 === -0                 //trueNaN === NaN                 // falseObject.is(+0, -0)         // falseObject.is(NaN, NaN)        // trueObject.is(&#39;foo&#39;, &#39;foo&#39;)    // trueObject.is({}, {})          // false</code></pre><h3 id="header-19">对象拷贝</h3><p><strong> 浅拷贝：</strong> 只能进行值的复制，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用</p><ol><li><p><code>Object.assign(target,src1,src2,...)</code> : 拷贝可被枚举的自有属性到目标对象（浅拷贝，同名属性替换， 取值函数求值后再复制）</p><pre><code class="lang-js"> // 浅拷贝，同名属性替换 const target = { a: 1, b: 1,d:{e:&#39;hello&#39;,f:&#39;world&#39;} }; const source1 = { b: 2, c: 2 }; const source2 = { c: 3,d:{g:&#39;say&#39;} }; Object.assign(target, source1, source2);                // {a:1, b:2, c:3,d:{g:&#39;say&#39;}}</code></pre><ul><li>参数注意点：<ul><li>只有一个参数，即只有<code>target</code>，则返回<code>target</code>（不是对象会先转换成对象返回）</li><li>传入不是对象的参数，会先转成对象（eg：字符串可转换为字符数组，数组视为属性名为 0、1、2 的对象）</li><li>传入无法转成对象的参数（eg: undefined,null，数值，布尔值）：<ul><li>作为第一个参数（即target）会报错；</li><li>不是第一个参数（即source），会跳过</li></ul></li></ul></li><li>只拷贝属性值，不会拷贝它背后的赋值方法或取值方法，取值函数求值后再复制值<pre><code class="lang-js">  // 不会复制取值函数,会用取值函数求值后再复制  const source = {    get foo() { return 1 }  };  Object.assign({}, source)                                        // { foo: 1 }</code></pre></li><li><p>使用<code>Object.getOwnPropertyDescriptors方法</code>配合<code>Object.defineProperties方法</code>添加描述对象，可实现正确拷贝</p><pre><code class="lang-js">// 配合Object.defineProperties方法添加描述对象const source = {set foo(value) {  console.log(value);}};const target = {};Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));Object.getOwnPropertyDescriptor(target, &#39;foo&#39;);// {//   get: undefined,//   set: [Function: set foo],//   enumerable: true,//   configurable: true//}</code></pre></li></ul></li><li><p><code>Object.create(proto [, propertyDescriptors ])</code> ：创建一个新对象，对象继承到<code>__proto__</code>属性上</p><pre><code class="lang-js"> const person = {   isHuman: false,   printIntroduction: function () {     console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);   } }; const me = Object.create(person); me.name = &quot;Matthew&quot;;             // &quot;name&quot; is a property set on &quot;me&quot;, but not on &quot;person&quot; me.isHuman = true;               // inherited properties can be overwritten me.printIntroduction();          // &quot;My name is Matthew. Am I human? true&quot;</code></pre><ul><li><code>proto</code>：新创建对象的原型对象，可为null</li><li><p><code>propertyDescriptors</code>：可选项，新对象属性的描述对象（其自身定义的属性，不是其原型链上的属性）</p><pre><code class="lang-js">  let o = Object.create({}, { p: { value: 42 } })   // 创建一个以空对象为原型,拥有一个属性p的对象   // 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的  // p的属性描述对象的enumerable默认是false, 改成true，Object.values就会返回属性p的值  Object.values(obj)     // []  o.p                    // 42  o.p = 20               // 失败  o.__proto__            // Object {}  o.__proto__.p          // undefined</code></pre><pre><code class="lang-js">  var o = Object.create(Object.prototype, {  foo: {                                    // foo会成为所创建对象的数据属性       writable:true,      configurable:true,      value: &quot;hello&quot;    },  bar: {                                    // bar会成为所创建对象的访问器属性        configurable: false,                // false，下面set,get方法不起作用      get: function() { return 10 },      set: function(value) {        console.log(&quot;Setting `o.bar` to&quot;, value);      }    }  });  console.log(o);                         // {foo:&#39;hello&#39;}</code></pre></li></ul></li><li><p><code>Object.create()</code>,<code>new Object()</code>,<code>{}</code> 区别</p><pre><code class="lang-js"> // test1,test2,test3的__proto 一样 var test1 = {}; var test2 = new Object(); var test3 = Object.create(Object.prototype); // 创建一个原型为null的对象，test4.__proto__为undefined， 没有继承原型属性和方法，不同于test1，2，3 var test4 = Object.create(null); var test = Object.create({x:123,y:345}); console.log(test);                                               //{} console.log(test.x);                                            //123 console.log(test.__proto__.x);                            //123 console.log(test.__proto__.x === test.x);          //true var test1 = new Object({x:123,y:345}); console.log(test1);                                              //{x:123,y:345} console.log(test1.x);                                            //123 console.log(test1.__proto__.x);                            //undefined console.log(test1.__proto__.x === test1.x);        //false var test2 = {x:123,y:345}; console.log(test2);                                                 //{x:123,y:345}; console.log(test2.x);                                                //123 console.log(test2.__proto__.x);                                //undefined console.log(test2.__proto__.x === test2.x);            //false</code></pre></li></ol><p><strong> 综合示例：</strong> 克隆一个对象（包括对象原型的属性，浅拷贝）</p><pre><code class="lang-js">// 写法一，注：__proto__属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三const clone1 = {  __proto__: Object.getPrototypeOf(obj),  ...obj};// 写法二const clone2 = Object.assign(  Object.create(Object.getPrototypeOf(obj)),  obj);// 写法三const clone3 = Object.create(  Object.getPrototypeOf(obj),  Object.getOwnPropertyDescriptors(obj));</code></pre><h3 id="header-20">super对象</h3><p>指向当前对象的原型对象</p><p><strong> 示例：</strong></p><ol><li><p>调用当前对象原型对象的属性</p><pre><code class="lang-js"> const proto = { foo: &#39;hello&#39;}; const obj = {   foo: &#39;world&#39;,   find() {     return super.foo;                                        // 引用了原型对象proto的foo属性，同 Object.getPrototypeOf(this).foo   } }; Object.setPrototypeOf(obj, proto); obj.find()                                                         // &quot;hello&quot;</code></pre></li><li><p>调用当前对象原型对象的方法</p><pre><code class="lang-js"> const proto = {   x: &#39;hello&#39;,   foo() {     console.log(this.x);   }, }; const obj = {   x: &#39;world&#39;,   foo() {     super.foo();                                                    // 同 Object.getPrototypeOf(this).foo.call(this)，this绑定的是当前obj   } } Object.setPrototypeOf(obj, proto); obj.foo()                                                             // &quot;world&quot;</code></pre></li><li><p><strong> 注：</strong> 只能用在对象的方法中（注：方法为简写方式才可以让 JavaScript 引擎确认，定义的是对象的方法）</p><ul><li>super用在属性里面，报错<pre><code class="lang-js">  const obj = {    foo: super.foo  }</code></pre></li><li><p>super用在一个函数里面，然后赋值给foo属性,报错</p><pre><code class="lang-js">  // 错  const obj = {    foo: () =&gt; super.foo  }  // 错  const obj = {    foo: function () {      return super.foo    }  }</code></pre></li></ul></li></ol><h2 id="header-21">函数 <code>function</code></h2><h3 id="header-22">name属性</h3><p>返回函数的函数名</p><pre><code class="lang-js">function foo() {}foo.name                                     // &quot;foo&quot;const a = function baz() {};a.name                                       // &quot;baz&quot;</code></pre><p><strong> 注：</strong></p><ul><li>匿名函数: ES5返回空字符串，ES6返回赋给的变量名<pre><code class="lang-js">  var f = function () {};  f.name                                  // ES5 &quot;&quot;； ES6 &quot;f&quot;</code></pre></li><li>Function构造函数返回的函数实例: anonymous<pre><code class="lang-js">  (new Function).name                      // &quot;anonymous&quot;</code></pre></li><li><p>bind返回的函数: name属性值会加上<code>bound</code>前缀</p><pre><code class="lang-js">  function foo() {};  foo.bind({}).name                         // &quot;bound foo&quot;  (function(){}).bind({}).name            // &quot;bound &quot;</code></pre></li></ul><h3 id="header-23">函数参数</h3><ol><li><p>通过解构赋值设置参数</p><pre><code class="lang-js"> function add([x, y]){                        // 参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y   return x + y; } add([1, 2]);                                // 3 [[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);    // [ 3, 7 ]</code></pre></li><li><p>处理可变参数: 使用rest参数<code>...参数名</code>（类似ES5的arguments）</p><pre><code class="lang-js"> function add(...values) {    // values同ES5 Array.prototype.slice.call(arguments);   let sum = 0;   for (let val of values) {     sum += val;   }   return sum; } add(2, 5, 3)                 // 10</code></pre></li></ol><h3 id="header-24">参数默认值</h3><ul><li><p>直接写在参数定义的后面</p><pre><code class="lang-js">  function log(x, y = &#39;World&#39;) {    console.log(x, y);  }  log(&#39;Hello&#39;)              // Hello World  log(&#39;Hello&#39;, &#39;China&#39;)     // Hello China</code></pre></li><li><p>可以使用表达式/函数（惰性求值）</p><pre><code class="lang-js">  let x = 99;  function foo(p = x + 1) {    console.log(p);  }  foo()             // 100  x = 100;  foo()             // 101</code></pre></li><li><p>使用解构赋值设置默认值</p><pre><code class="lang-js">  /* 1. 为函数参数对象整体指定默认值，eg: 为{x,y}对象整体指定默认值，而不是为变量x和y指定默认值 */  function m2({x, y} = { x: 0, y: 0 }) {    return [x, y];  }  m2()                    // [0,0]  m2({})                  // [undefined,undefined]  m2({x: 3})              // [3, undefined]  m2({x:3,y:8})           // [3, 8]  /* 2. 为函数某个具体参数指定默认值，eg：为变量y指定默认值 */  function foo({x, y = 5} = {}) {    console.log(x, y);  }  foo()                     // undefined 5  foo({})                   // undefined 5  foo({x:3})                // 3 5  foo({x:3,y:8})            // 3 8</code></pre></li><li><p>注：指定了默认值后，函数的length属性将失真，会返回没有指定默认值的参数个数</p><pre><code class="lang-js">  // 函数的length属性: 函数预期传入的参数个数  (function(...args) {}).length                 // 0  (function (a) {}).length                      // 1  // 设置默认参数后，函数的length属性将失真：  (function (a, b, c = 5) {}).length             // 2  (function (a, b = 1, c) {}).length             // 1    -- 默认值以后的参数也不计数</code></pre></li></ul><p><strong> 应用示例：</strong></p><ol><li>利用参数默认值，指定某一个参数不得省略，若省略就抛出一个错误<pre><code class="lang-js"> function throwIfMissing() {   throw new Error(&#39;Missing parameter&#39;); } function foo(mustBeProvided = throwIfMissing()) {   return mustBeProvided; } foo()        // Error: Missing parameter</code></pre></li><li>利用参数默认值，指定某一个参数是可以省略的(将参数默认值设为undefined)<pre><code class="lang-js"> function foo(optional = undefined) {      //··· }</code></pre></li></ol><h3 id="header-25">函数绑定运算符 <code>::</code></h3><p>用来取代call、apply、bind调用</p><ul><li><p><code>对象::函数</code> : 会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面</p><pre><code class="lang-js">  bar.bind(foo);        // ES5  foo::bar;             // ES6  bar.apply(foo, arguments);        // ES5  foo::bar(...arguments);           // ES6</code></pre></li><li><code>::对象.方法</code> ：等于将该方法绑定在该对象上面<pre><code class="lang-js">  var log = console.log.bind(console);    // ES5  let log = ::console.log;                // ES6， 同 let log = console::console.log;</code></pre></li><li>若双冒号运算符的运算结果，还是一个对象，可采用链式写法</li></ul><h3 id="header-26">箭头函数 arrow-function</h3><p>简化函数编写形式</p><pre><code class="lang-js">// ES3,ES5function a(){    exp}// ES6// 只有一个参数，可省略&quot;()&quot;// 表达式直接作为返回值时，可省略&quot;{}&quot;(arg)=&gt;{    exp}</code></pre><p><strong> 示例：</strong></p><pre><code class="lang-js">var f = function () { return 5 };                          // ES5var f = () =&gt; 5;                                          // ES6var sum = function(num1, num2) { return num1 + num2;};    // ES5var sum = (num1, num2) =&gt; num1 + num2;                    // ES6[1,2,3,4,5].map(function(v){ return v+1; });              // ES5[1,2,3,4,5].map(v=&gt;v+1);                                  // ES6//无返回let fn = () =&gt; void doesNotReturn();//返回一个对象（为防止语法歧义报错，用圆括号包起来）let getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; });//使用rest参数const headAndTail = (head, ...tail) =&gt; [head, tail];headAndTail(1, 2, 3, 4, 5)        // [1,[2,3,4,5]]</code></pre><p><strong> 限制：</strong></p><ul><li>不能用作构造函数（即不能用new）</li><li>不能使用arguments对象，用rest参数代替</li><li>不能用作Generator函数（即不能使用yield）</li></ul><p><strong> <code>this</code>对象: </strong> 在箭头函数中，this对象的指向是固定的，为定义时所在的对象，不是使用时所在的对象</p><ul><li>实际上：箭头函数没有自己的 <code>this</code>、<code>arguments</code>、<code>super</code>、<code>new.target</code>，只能引用外层代码块的对应变量</li><li>因为没有自己的<code>this</code>（使用外层代码块的<code>this</code>），所以不能用作构造函数，也不能使用<code>call</code>，<code>apply</code>，<code>bind</code>这些方法去改变<code>this</code>的指向</li></ul><p><strong> 示例：</strong></p><ol><li><p>ES3,ES5 原始写法 : this 指向的是该函数被调用的对象</p><pre><code class="lang-js"> var factory=function(){     this.a=&#39;a&#39;;     this.b=&#39;b&#39;;     this.c={         a:&#39;a+&#39;,         b:function(){             return this.a;         }     } } console.log(new factory().c.b());            // a+     -- this指向c</code></pre></li><li><p>ES6 箭头函数 : this 指向的是定义时this的指向</p><pre><code class="lang-js"> var factory=function(){      this.a=&#39;a&#39;;      this.b=&#39;b&#39;;      this.c={         a: &#39;a+&#39;,         b: ()=&gt;{             return this.a;         }     } } console.log(new factory().c.b());    // a    -- 同外层代码this，指向factory</code></pre></li><li><p>箭头函数转成 ES5写法（注意this）</p><pre><code class="lang-js"> // ES6 箭头函数 function foo() {   setTimeout(() =&gt; {     console.log(&#39;id:&#39;, this.id);            // this -- foo   }, 100); } // ES5 原始写法 function foo() {   var _this = this;   setTimeout(function () {     console.log(&#39;id:&#39;, _this.id);   }, 100); }</code></pre></li></ol><h3 id="header-27">优化：尾调用，尾递归</h3><p><strong> 尾调用：</strong> 函数的最后一步是返回调用另一个函数</p><pre><code class="lang-js">function f(x){  return g(x);}function f(x) {  if (x &gt; 0) {    return m(x)  }  return n(x);}</code></pre><p>由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，直接用内层函数的调用帧取代外层函数的调用帧即可<br>注：</p><ul><li>ES6支持尾调用优化，且只在严格模式下开启</li><li>只有不再用到外层函数的内部变量才可取代</li><li><p>例：以下三种情况，都不属于尾调用</p><pre><code class="lang-js">  function f(x){    let y = g(x);    return y;                // 因为调用后还有赋值操作  }  function f(x){    return g(x) + 1;    // 因为调用后还有操作  }  function f(x){    g(x);                    // 函数最后一步为 return undefined；  }</code></pre></li></ul><p><strong> 尾递归：</strong> 尾调用自身</p><p>函数调用自身，因为调用栈太多，容易发生“栈溢出”错误（stack overflow）；<br>而尾递归，由于只存在一个调用帧，所以不会发生“栈溢出”错误</p><p>应用示例：</p><ol><li>计算n的阶乘: <code>n!</code><ul><li>非尾递归实现: 最多需要保存n个调用记录，复杂度 O(n) <pre><code class="lang-js">  function factorial(n) {    if (n === 1) return 1;    return n * factorial(n - 1);  }  factorial(5)             // 120</code></pre></li><li>尾递归实现（将所有用到的内部中间变量改写成函数的参数）: 只保留一个调用记录，复杂度 O(1)<pre><code class="lang-js">  function factorial(n, total=1) {    if (n === 1) return total;    return factorial(n - 1, n * total);  }  factorial(5, 1)             // 120</code></pre></li></ul></li><li><p>Fibonacci 数列</p><ul><li><p>非尾递归的 Fibonacci 数列实现</p><pre><code class="lang-js">  function Fibonacci (n) {    if ( n &lt;= 1 ) {          return 1      };    return Fibonacci(n - 1) + Fibonacci(n - 2);  }  Fibonacci(10)               // 89  Fibonacci(100)             // 堆栈溢出  Fibonacci(500)             // 堆栈溢出</code></pre></li><li><p>尾递归优化过的 Fibonacci 数列实现</p><pre><code class="lang-js">  function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {    if( n &lt;= 1 ) {          return ac2      };    return Fibonacci2 (n - 1, ac2, ac1 + ac2);  }  Fibonacci2(100)             // 573147844013817200000  Fibonacci2(1000)           // 7.0330367711422765e+208  Fibonacci2(10000)         // Infinity</code></pre></li></ul></li></ol><p><strong> 注：</strong><br>尾递归优化只在严格模式下生效，正常模式下可采用“循环”换掉“递归”的方式进行优化</p><h2 id="header-28">Symbol</h2><ol><li>ES6新增的原始数据类型，类似于字符串的数据类型 （Javascript其他原始数据类型有：undefined，null，Boolean，String，Number，Object）</li><li><strong> 表示独一无二的值 </strong>（例如：可以用来保证对象的属性名是独一无二的）</li><li>通过<code>Symbol()</code>函数生成，可以接受一个字符串作为参数，表示对Symbol实例的描述</li><li>注：不能使用<code>new</code>，基本上，它是一种类似于字符串的数据类型</li></ol><pre><code class="lang-js">let s = Symbol(); typeof s                                // &quot;symbol&quot;let s1 = Symbol(&#39;foo&#39;);s1                                     // Symbol(foo)s1.toString()                         // &quot;Symbol(foo)&quot;  //相同参数的Symbol函数的返回值是不相等let s2 = Symbol(&#39;foo&#39;);s1 === s2                             // false// 用于对象属性let mySymbol = Symbol();let a = {  [mySymbol]: &#39;Hello!&#39;};a[mySymbol]                         // &quot;Hello!&quot;</code></pre><h2 id="header-29">Set/WeakSet</h2><h3 id="header-30">Set</h3><ul><li>类似于数组，但是成员的值都是唯一，可枚举（<code>Array.from</code>方法可以将 Set 结构转为数组）</li><li>可以接受一个具有 iterable 接口的数据结构作为参数（例如数组），用来初始化</li><li>内部使用同值相等判断两个值是否相同（比严格相等<code>===</code>，多了NaN和0的比较)，注：两个对象总是不相等的</li><li>属性：<ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是Set函数。</li><li><code>Set.prototype.size</code>：返回Set实例的成员总数。</li></ul></li><li>方法（操作）：<ul><li>add(value)</li><li>delete(value)</li><li>has(value)</li><li>clear()</li></ul></li><li>方法（遍历）：<ul><li>keys()</li><li>values()</li><li>entries()</li><li>forEach()        </li></ul></li></ul><p><strong> 示例：</strong></p><ol><li><p>无参构造使用Set</p><pre><code class="lang-js"> let s= new Set(); s.add(1).add(2).add(2); s.size                                       // 2 s.has(1)                                     // true s.has(2)                                     // true s.has(3)                                     // false s.delete(2); s.has(2)                                     // false</code></pre></li><li><p>可枚举对象作为参数构造</p><pre><code class="lang-js"> const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]); items.size                                     // 5 const s = new Set(); [2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x)); // 去除数组的重复成员 [...new Set(array)]</code></pre></li><li><p>遍历</p><pre><code class="lang-js"> let s2= new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]); s2.keys()                    // [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;] s2.values()                  // [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;] s2.entries()                 // [ [&#39;red&#39;,&#39;red&#39;], [&#39;green&#39;,&#39;green&#39;], [&#39;blue&#39;,&#39;blue&#39;] ] // for...of循环遍历 for (let x of s2) {          // 默认遍历器生成函数就是它的values方法   console.log(x); } // red // green // blue // forEach循环遍历 s2.forEach((value, key) =&gt; console.log(key + &#39; : &#39; + value)) // red:red // green:green // blue:blue</code></pre><ul><li>注：<code>keys/values()</code> Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致，默认遍历器生成函数就是values方法</li></ul></li><li><p>应用：Set 实现并集（Union）、交集（Intersect）和差集（Difference）</p><pre><code class="lang-js"> let a = new Set([1, 2, 3]); let b = new Set([4, 3, 2]); // 并集 let union = new Set([...a, ...b]);                                // Set {1, 2, 3, 4} // 交集 let intersect = new Set([...a].filter(x =&gt; b.has(x)));            // set {2, 3} // 差集 let difference = new Set([...a].filter(x =&gt; !b.has(x)));          // Set {1}</code></pre></li></ol><h3 id="header-31">WeakSet</h3><ul><li>与Set区别：<ul><li>成员只能是对象，而不能是其他类型的值    </li><li>成员对象都是弱引用，随时可能消失（即如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中）</li><li>垃圾回收机制运行前后可能会导致成员数不一样，所以ES6 规定 WeakSet不可遍历</li></ul></li><li>方法：<ul><li>add(value)</li><li>delete(value)</li><li>has(value)</li></ul></li></ul><p><strong> 示例：</strong></p><ol><li><p>构造使用 WeakSet</p><pre><code class="lang-js"> const ws = new WeakSet(); const obj = {}; const foo = {}; ws.add(window); ws.add(obj); ws.has(window);             // true ws.has(foo);                // false ws.delete(window); ws.has(window);                // false // WeakSet 没有size属性，不能遍历：因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在 ws.size                     // undefined ws.forEach                     // undefined</code></pre></li><li><p>有参构造 WeakSet（注：WeakSet的成员只能是对象）</p><pre><code class="lang-js"> // 可以接受具有 Iterable 接口的对象 const a = [[1, 2], [3, 4]]; const ws1 = new WeakSet(a);            // WeakSet {[1, 2], [3, 4]} 注：a数组的成员成为 WeakSet 的成员，不是a数组本身 const b = [3, 4]; const ws2 = new WeakSet([3, 4]);      // Uncaught TypeError: Invalid value used in weak set(…) 注：b数组的成员不是对象</code></pre></li><li><p>应用：Weakset 储存 DOM 节点，不用担心这些节点从文档移除时，会引发内存泄漏</p><pre><code class="lang-js"> const foos = new WeakSet()            // foos对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑foos，也不会出现内存泄漏 class Foo {   constructor() {     foos.add(this)   }   method () {     if (!foos.has(this)) {       throw new TypeError(&#39;Foo.prototype.method 只能在Foo的实例上调用！&#39;);     }   } }</code></pre></li></ol><h2 id="header-32">Map/WeakMap</h2><h3 id="header-33">Map</h3><ul><li>键值对集合，类似对象（Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，key不限于字符串，各种类型的值包括对象都可以当作键，是一种更完善的 Hash 结构实现）</li><li>键唯一，跟内存地址绑定的，只要内存地址不一样，就视为两个键（0和-0是一个键，NaN视为同一个键）    </li><li>Map 的遍历顺序就是插入顺序</li><li>属性：<ul><li>size</li></ul></li><li>方法（操作）：<ul><li>set(key,value)</li><li>get(key)</li><li>has(key)</li><li>delete(key)</li><li>clear()</li></ul></li><li>方法（遍历）：<ul><li>keys()</li><li>values()</li><li>entries()</li><li>forEach()</li></ul></li></ul><p><strong> 示例：</strong></p><ol><li><p>无参数构造</p><pre><code class="lang-js"> const m = new Map(); const o = {p: &#39;Hello World&#39;}; m.set(o, &#39;content&#39;) m.get(o)                        // &quot;content&quot; m.set(1,&#39;Hello&#39;)  m.get(1)                        // &quot;Hello&quot; m.get(&#39;a&#39;)                        // undefined m.set(undefined, 3);             m.get(undefined)                // 3 m.set([&#39;a&#39;], 555); m.get([&#39;a&#39;])                    // undefined m.set(1,&#39;a&#39;).set(2,&#39;b&#39;)</code></pre></li><li><p>可枚举对象作为参数构造</p><pre><code class="lang-js"> const m= new Map([   [&#39;name&#39;, &#39;张三&#39;],   [&#39;title&#39;, &#39;Author&#39;] ]);                             // Map {&#39;name&#39;:&#39;张三&#39;,&#39;title&#39;:&#39;Author&#39;} // 相当于 param.forEach(   ([key, value]) =&gt; m.set(key, value) ); m.size                            // 2 m.has(&#39;name&#39;)                    // true m.get(&#39;name&#39;)                    // &quot;张三&quot;</code></pre></li><li><p>遍历</p><pre><code class="lang-js"> m.keys()        // [&#39;name&#39;,&#39;title&#39;] m.values()        // [&#39;张三&#39;,&#39;Author&#39;] m.entries()        // [ [&#39;name&#39;, &#39;张三&#39;],[&#39;title&#39;, &#39;Author&#39;] ] // forEach循环遍历 m.forEach(function(value, key, map) {   console.log(&quot;Key: %s, Value: %s&quot;, key, value); }); // for...of循环遍历 for (let [key, value] of map) {   console.log(key, value); } for (let [key, value] of map.entries()) {   console.log(key, value); } for (let item of map.entries()) {   console.log(item[0], item[1]); } // name 张三 // title Author</code></pre><ul><li>注：<code>entries()</code> 是Map结构的默认遍历器接口（部署在Symbol.iterator属性上，即<code>map[Symbol.iterator] === map.entries</code>）</li></ul></li><li><p>Map &lt;-&gt; Array 转换</p><ul><li>Map -&gt; Array: 使用扩展运算符 <code>...</code><pre><code class="lang-js">  const myMap = new Map()    .set(true, 7)    .set({foo: 3}, [&#39;abc&#39;]);  [...myMap]                                    // [ [ true, 7 ], [ { foo: 3 }, [ &#39;abc&#39; ] ] ]</code></pre></li><li>Array -&gt; Map: 直接作为参数传入Map构造函数<pre><code class="lang-js">  new Map([    [true, 7],    [{foo: 3}, [&#39;abc&#39;]]  ])                                           // Map { true:7, {foo:3}:[&#39;abc&#39;] }</code></pre></li></ul></li></ol><h3 id="header-34">Weakmap</h3><ul><li>与Map区别：<ul><li>只接受对象作为键名（null除外）</li><li>键名所指向的对象为弱引用（不计入垃圾回收机制，即一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用）</li><li>注：WeakMap 弱引用的只是键名，而不是键值，所以即使在 WeakMap 外部消除了键值的引用，WeakMap 内部的引用依然存在</li><li>没有遍历操作（即没有keys()、values()，entries()，forEach方法），也没有size属性</li><li>无法清空，即不支持clear方法</li></ul></li><li>方法：<ul><li>get()、set()、has()、delete()</li></ul></li><li>应用（WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏）<ul><li>DOM 节点作为键名（在网页的 DOM 元素上添加数据，当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除，有助于防止内存泄漏）</li><li>部署私有属性</li></ul></li></ul><p><strong> 示例：</strong></p><ol><li><p>构造使用 WeakMap</p><pre><code class="lang-js"> const wm = new WeakMap(); const key = {foo: 1}; wm.set(key, 2);                        // set 添加成员 wm.get(key)                         // get 获取成员 // 只接受对象作为键名（null除外） wm.set(1, 2)                        // TypeError: 1 is not an object! wm.set(Symbol(), 2)                    // TypeError: Invalid value used as weak map key // size、forEach、clear 方法都不存在 wm.size                             // undefined wm.forEach                             // undefined wm.clear                             // undefined // 可接受一个数组，作为构造函数的参数 const k1 = [1, 2, 3]; const k2 = [4, 5, 6]; const wm2 = new WeakMap([[k1, &#39;foo&#39;], [k2, &#39;bar&#39;]]); wm2.get(k2) // &quot;bar&quot;</code></pre></li><li><p>应用：DOM 节点作为键名存储在Weakmap中，防止内存泄漏</p><pre><code class="lang-js"> // myElement是一个 DOM 节点，每当发生click事件，就更新一下状态 // 一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险 let myElement = document.getElementById(&#39;logo&#39;); let myWeakmap = new WeakMap(); myWeakmap.set(myElement, {timesClicked: 0}); myElement.addEventListener(&#39;click&#39;, function() {   let logoData = myWeakmap.get(myElement);   logoData.timesClicked++; }, false);</code></pre></li><li><p>应用：Weakmap 部署私有属性，实例消失，它们也就随之消失</p><pre><code class="lang-js"> // Countdown类的两个内部属性_counter和_action，是实例的弱引用 // 如果删除实例，它们也就随之消失，不会造成内存泄漏 const _counter = new WeakMap(); const _action = new WeakMap(); class Countdown {   constructor(counter, action) {     _counter.set(this, counter);     _action.set(this, action);   }   dec() {     let counter = _counter.get(this);     if (counter &lt; 1) return;     counter--;     _counter.set(this, counter);     if (counter === 0) {       _action.get(this)();     }   } } const c = new Countdown(2, () =&gt; console.log(&#39;DONE&#39;)); c.dec() c.dec() // DONE</code></pre></li></ol><h2 id="header-35">类 Class</h2><p>类的数据类型就是函数，类本身就指向构造函数</p><ul><li><code>constructor</code> 构造函数<ul><li>默认返回实例对象，即this（this 代表实例对象）</li><li>无参构造，可以不显式定义，会默认添加一个空的constructor方法</li></ul></li><li><code>new</code> 创建实例对象<ul><li><code>new 构造函数(args)</code>： 从prototype对象生成一个实例对象 ( 注：ES6 class必须使用new调用,否则会报错 )</li><li><code>new.target</code>: 一般在构造函数中调用，返回new命令作用于的那个构造函数，若不是用new命令调用，返回undefined (这个属性可以用来确定构造函数是怎么调用的)</li></ul></li></ul><p><strong> 类成员: </strong></p><ul><li>变量：定义在this上，是类的实例对象自身的属性，属于类实例对象<pre><code class="lang-js">  class Point {    constructor(x, y) {      this.x = x;      this.y = y;    }  }</code></pre><ul><li>提案：实例属性: 用等式直接写入类的定义之中（以前只能写在类的constructor方法里面）<pre><code class="lang-js">  class MyClass {    myProp = 42;    constructor() {      console.log(this.myProp); // 42    }  }</code></pre></li></ul></li><li>方法: 定义在class上，是原型对象prototype的属性，属于类<pre><code class="lang-js">  class Point {      say(){          console.log(&quot;Hello&quot;);      }  }</code></pre></li><li><p>注：<code>getter/setter</code> 对某个属性设置存值函数和取值函数(部署在Descriptor属性描述对象上)，拦截该属性的存取行为</p><pre><code class="lang-js">  class MyClass {    get prop() {      return &#39;getter&#39;;    }    set prop(value) {      console.log(&#39;setter: &#39;+value);    }  }  let inst = new MyClass();  inst.prop = 123;        // setter: 123  inst.prop                    // &#39;getter&#39;</code></pre></li></ul><p><strong> 私有属性/方法: </strong> </p><ul><li><p>利用<code>Symbol</code>值的唯一性，将私有方法的名字命名为一个Symbol值</p><pre><code class="lang-js">  const bar = Symbol(&#39;bar&#39;);  const snaf = Symbol(&#39;snaf&#39;);  export default class myClass{    // 公有方法    foo(x) {      this[bar](x);    }    // 私有方法    [bar](x) {      return this[snaf] = x;    }  }</code></pre></li><li>提案：使用<code>#</code>表示<pre><code class="lang-js">  class Foo {    #a;    #b;    #sum() { return #a + #b; }    printSum() { console.log(#sum()); }    constructor(a, b) { #a = a; #b = b; }  }</code></pre></li></ul><p><strong> 静态属性/方法：</strong> 直接通过类来调用（实例上调用，会抛出错误，表示不存在）</p><ul><li><p>静态属性：ES6 没有静态属性，可在类外部定义实现</p><pre><code class="lang-js">  class Foo {}  Foo.prop = 1;        // 为Foo类定义了一个静态属性prop  Foo.prop // 1</code></pre><ul><li><p>提案：在实例属性写法前面加上static关键字</p><pre><code class="lang-js">  class MyClass {    static myStaticProp = 42;    constructor() {      console.log(MyClass.myStaticProp); // 42    }  }</code></pre></li></ul></li><li><p>静态方法: 可以与非静态方法重名 ( 注：static方法中的this指向类，不是实例 )</p><pre><code class="lang-js">  class Foo {    static classMethod() {      return &#39;hello&#39;;    }  }  Foo.classMethod() // &#39;hello&#39;  var foo = new Foo();  foo.classMethod()                // TypeError: foo.classMethod is not a function</code></pre></li></ul><p><strong> 示例：</strong></p><ol><li><p>定义使用类</p><ul><li><p>ES5方式</p><pre><code class="lang-js">  // 构造函数：  function Point(x, y) {    this.x = x;    this.y = y;  }  // 类的所有方法都定义在类的prototype属性上面：  Point.prototype={      constructor:Point,      toString:function(){          return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;};      }  }  // 使用  var p = new Point(1, 2);  console.log(p.toString());</code></pre></li><li><p>ES6方式</p><pre><code class="lang-js">  class Point {    constructor(x, y) {      this.x = x;      this.y = y;    }    toString() {      return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;    }  }  var p = new Point(1, 2);  console.log(p.toString());</code></pre></li><li><p>注: </p><ul><li>类的数据类型就是函数，类本身就指向构造函数<pre><code class="lang-js">  typeof Point // &quot;function&quot;  Point === Point.prototype.constructor // true</code></pre></li><li>类属性定义在this变量上，属于类实例对象； 类方法定义在class上 ，属于类<pre><code class="lang-js">  p.hasOwnProperty(&#39;x&#39;) // true  p.hasOwnProperty(&#39;y&#39;) // true  p.hasOwnProperty(&#39;toString&#39;) // false  p.__proto__.hasOwnProperty(&#39;toString&#39;) // true</code></pre></li><li><p>类的内部所有定义的方法，ES6定义的不可枚举，ES5方式定义的可枚举</p><pre><code class="lang-js">  /* ES5 */  Object.keys(Point.prototype)    // [&quot;toString&quot;]  Object.getOwnPropertyNames(Point.prototype)    // [&quot;constructor&quot;,&quot;toString&quot;]  /* ES6 */  Object.keys(Point.prototype)    // []  Object.getOwnPropertyNames(Point.prototype)    // [&quot;constructor&quot;,&quot;toString&quot;]</code></pre></li><li>ES6 class必须使用new调用,否则会报错<pre><code class="lang-js">  var point = Point(2, 3);        // 报错  var point = new Point(2, 3);    // 正确</code></pre></li></ul></li></ul></li><li><p>无参构造类( constructor可以不显式定义)</p><ul><li><p>ES5方式</p><pre><code class="lang-js">  /* Javascript */  function Point() {}  Point.prototype.toString=function(){...}  // 等同于  function Point(){}  Point.prototype={      constructor:Point,      toString:function(){...}  }</code></pre></li><li><p>ES6方式</p><pre><code class="lang-js">  class Point{      toString(){...}  }  // 等同于  class Point {    constructor() {}    toString(){...}  }</code></pre></li></ul></li><li><p>匿名类</p><pre><code class="lang-js"> let person = new class {   constructor(name) {         this.name = name;   }   sayName() {     console.log(this.name);   } }(&#39;张三&#39;); person.sayName();     // &quot;张三&quot;</code></pre></li><li><p><code>new.target</code>: 用在构造函数中调用，返回new命令作用于的那个构造函数</p><ul><li><p>ES5方式</p><pre><code class="lang-js">  function Person(name) {    if (new.target === Person) {      this.name = name;    } else {      throw new Error(&#39;必须使用 new 命令生成实例&#39;);    }  }  var person = new Person(&#39;张三&#39;); // 正确  var notAPerson = Person.call(person, &#39;张三&#39;);  // throw Error: 必须使用 new 命令生成实例</code></pre></li></ul><ul><li><p>ES6</p><pre><code class="lang-js">  class Rectangle {    constructor(length, width) {      console.log(new.target === Rectangle);      this.length = length;      this.width = width;    }  }  var obj = new Rectangle(3, 4);         // 输出 true  var obj2 = Rectangle(2, 3);         // 报错,ES6 class必须使用new调用</code></pre></li><li><p>应用：创建不能独立使用、必须继承后才能使用的类</p><pre><code class="lang-js">  //Class内部调用new.target，返回当前Class；子类继承父类时，返回子类  class Shape {    constructor() {      if (new.target === Shape) {        throw new Error(&#39;本类不能实例化&#39;);      }    }  }  class Rectangle extends Shape {    constructor(length, width) {      super();      // ...    }  }  var x = new Shape();  // 报错  var y = new Rectangle(3, 4);  // 正确</code></pre></li></ul></li></ol><h3 id="header-36">extened 继承</h3><pre><code class="lang-js">class A {  constructor() {    console.log(new.target.name);  // new.target 指向new命令作用于的那个构造函数  }}class B extends A {  constructor() {    super();                  // 相当于 A.prototype.constructor.call(this)， 这里this指的是B的实例 -- super代表父类的构造函数  }}new A()     // Anew B()     // B</code></pre><p><strong> 继承机制：</strong></p><ul><li>ES5：创造子类的实例对象this，再将父类的方法添加到this上面</li><li>ES6：将父类实例对象的属性和方法加到this上面，再用子类的构造函数修改this<ul><li>子类必须在constructor方法中调用super方法，且只有调用super之后，才可以使用this关键字，否则新建实例时会报错</li><li>子类会继承父类的静态方法，也可通过super对象调用父类的静态方法</li></ul></li><li>获取对象原型: <code>Object.getPrototypeof(obj)</code><ul><li>可以用来从子类上获取父类，使用这个方法判断，一个类是否继承了另一个类</li><li>eg:  <code>Object.getPrototypeOf(ColorPoint) === Point</code> 为 true</li></ul></li></ul><p><strong> 原生构造函数的继承（原生类的继承）：</strong></p><ul><li>语言内置的构造函数，ES5无法继承，ES6可以（ ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承）</li><li>ECMAScript 的原生构造函数：<ul><li>Boolean()</li><li>Number()</li><li>String()</li><li>Array()</li><li>Date()</li><li>Function()</li><li>RegExp()</li><li>Error()</li><li>Object()</li></ul></li><li><p>特例：继承Object的子类，无法通过super方法向父类Object传参</p><pre><code class="lang-js">  class NewObj extends Object{    constructor(){      super(...arguments);    }  }  var o = new NewObj({attr: true});  o.attr === true                                      // false</code></pre><ul><li>因为 ES6 改变了Object构造函数的行为，一旦发现Object方法不是通过<code>new Object()</code>这种形式调用，ES6 规定Object构造函数会忽略参数</li></ul></li><li><p>应用实例：定义一个带版本功能的数组</p><pre><code class="lang-js">  class VersionedArray extends Array {    constructor() {      super();      this.history = [[]];    }    commit() {      this.history.push(this.slice());    }    revert() {      this.splice(0, this.length, ...this.history[this.history.length - 1]);    }  }  var x = new VersionedArray();  x.push(1);  x.push(2);  x                                 // [1, 2]  x.history                     // [[]]  x.commit();  x.history                    // [[], [1, 2]]  x.push(3);  x                                 // [1, 2, 3]  x.history                     // [[], [1, 2]]  x.revert();  x                                 // [1, 2]</code></pre></li></ul><h3 id="header-37">super/this 关键字</h3><p><strong> this: </strong> 一般指向该方法运行时所在的环境</p><ul><li>在类中：<ul><li>普通方法中：指向类的实例；</li><li>静态方法中：指向类；</li></ul></li><li>在子类中：<ul><li>普通方法中：指向子类实例；注：用super对象调用父类方法时，父类方法中的this指向的也是子类实例</li><li>静态方法中：指向子类；注：用super对象调用父类方法时，父类方法中的this指向的也是子类</li></ul></li><li>在箭头函数中：<ul><li>指向是固定的，为定义时所在的对象，不是使用时所在的对象（因为箭头函数没有自己的this，只能使用外层代码块的this）</li><li>注：箭头函数不能用作构造函数，也不能使用call，apply，bind这些方法去改变this的指向</li></ul></li><li></li></ul><p><strong> 示例：</strong>    </p><pre><code class="lang-js">class Logger {  printName(name = &#39;there&#39;) {    this.print(`Hello ${name}`);            // this 指向类的实例  }  print(text) {    console.log(text);  }}const logger = new Logger();logger.printName();                        // Hello there</code></pre><p>注：单独使用类方法，而此类方法中使用this调用其他类方法，可能会报错，eg：将printName方法提取出来单独使用会报错</p><pre><code class="lang-js">const { printName } = logger;printName();                              // TypeError: Cannot read property &#39;print&#39; of undefined// 解决方案： 在构造方法中绑定thisclass Logger {  constructor() {    this.printName = this.printName.bind(this);  }  // ...}</code></pre><p><strong> super </strong></p><ul><li><code>super(...)</code>: super方法代表父类的构造函数，只能用在子类的构造函数之中，用在其他地方就会报错</li><li><code>super.xxx</code>: super对象一般指向当前对象的原型对象, 只能用在对象的方法中<ul><li>在子类：<ul><li>普通方法中: super指向父类的原型对象；注：通过super调用父类的方法时，父类方法内部的this指向的是子类实例</li><li>静态方法中：super指向父类本身；注：通过super方法调用父类的方法时，父类方法内部的this指向的是子类</li></ul></li></ul></li><li>注：使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错</li></ul><p><strong> 示例: </strong></p><ol><li><p><strong>super方法</strong> vs <strong>super对象</strong></p><pre><code class="lang-js"> class Point {   constructor(x, y) {     this.x = x;     this.y = y;   }   p() {     return 2;   } } class ColorPoint extends Point {   constructor(x, y, color) {     this.color = color;                 // ReferenceError     super(x, y);                        // 调用父类构造函数     this.color = color;                 // 正确，super之后，才可以使用this     console.log(super.p());             // 2 -- super指向父类原型对象，相当于Point.prototype.p()     console.log(super);                   // 报错： 使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错     // super.valueOf()表明super是一个对象，指向父类原型对象，super使得this指向B的实例，所以返回的是一个B的实例     console.log(super.valueOf() instanceof B);    // true    } } let cp = new ColorPoint(25, 8, &#39;green&#39;); cp instanceof ColorPoint         // true cp instanceof Point              // true</code></pre></li><li><p>super对象调用父类静态方法和普通方法</p><pre><code class="lang-js"> class Parent {   static hello() {     console.log(&#39;hello world&#39;);   }   static myMethod(msg) {     console.log(&#39;static&#39;, msg);   }   myMethod(msg) {     console.log(&#39;instance&#39;, msg);   } } class Child extends Parent {   static myMethod(msg) {     super.myMethod(msg);        // 在子类静态方法中，super对象指向父类本身，调用父类静态方法   }   myMethod(msg) {     super.myMethod(msg);        // 在子类普通方法中，super对象指向父类原型对象，调用父类方法   } } // 调用子类静态方法 Child.hello();              // hello world Child.myMethod(1);          // static 1 // 调用子类普通方法 var child = new Child(); child.myMethod(2);          // instance 2</code></pre></li></ol><h3 id="header-38">Decorator 修饰器</h3><pre><code class="lang-js">@decoratorclass A {}// 等同于class A {}A = decorator(A) || A;</code></pre><p>只能用于修饰类和类属性（eg：不能用于函数，因为存在函数提升），本质即<strong>编译时执行的函数</strong> （不是在运行时）</p><ul><li>类修饰器<ul><li>参数（只有一个）：<ul><li><code>target</code>：所要修饰的目标类（即类本身）</li></ul></li></ul></li><li>类属性修饰器<ul><li>参数（三个）：<ul><li><code>target</code> ： 类的原型对象（类.prototype）– 修饰器的本意是要“修饰”类的实例，但是这个时候实例还没生成，所以只能去修饰原型</li><li><code>name</code> ： 修饰的类属性名</li><li><code>decriptor</code>：修饰类属性的描述对象</li></ul></li><li>返回：该属性的描述对象<code>Descriptor</code></li></ul></li><li>修饰器参数扩展：<ul><li>可以通过在修饰器外面再封装一层函数来传入入其他参数</li></ul></li><li>多个修饰器：<ul><li>会像剥洋葱一样，先从外到内进入，然后由内向外执行</li></ul></li><li>第三方模块提供的修饰器：<ul><li><code>core-decorators.js</code>：<ul><li>@autobind : 使得方法中的this对象，绑定原始对象</li><li>@readonly : 使得属性或方法不可写</li><li>@override : 检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错</li><li>@deprecate/@deprecated : 在控制台显示一条警告，表示该方法将废除</li><li>@suppressWarnings : 抑制deprecated修饰器导致的console.warn()调用 （异步代码发出的调用除外）</li></ul></li><li><code>traits-decorator</code>：<ul><li>@traits : 效果与 Mixin 类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等      </li></ul></li></ul></li></ul><p><strong> 示例: </strong> </p><ol><li><p>类修饰器</p><pre><code class="lang-js"> @testable class MyTestableClass {   // ... } function testable(target) {    // target为所要修饰的目标类（类本身），即MyTestClass   target.isTestable = true;    // 为类MyTestClass添加静态属性isTestable，想添加实例属性，可以通过目标类的prototype对象操作 } MyTestableClass.isTestable     // true</code></pre></li><li><p>类属性修饰器</p><pre><code class="lang-js"> function readonly(target, name, descriptor){   descriptor.writable = false;   return descriptor; } // descriptor对象原来的值如下 // { //   value: specifiedFunction, //   enumerable: false, //   configurable: true, //   writable: true // }; class Person {   @readonly                                                                // readonly(Person.prototype, &#39;name&#39;, descriptor);   name() { return `${this.first} ${this.last}` } }</code></pre><pre><code class="lang-js"> class Math {   @log   add(a, b) {     return a + b;   } } function log(target, name, descriptor) {   var oldValue = descriptor.value;   descriptor.value = function() {     console.log(`Calling ${name} with`, arguments);     return oldValue.apply(this, arguments);   };   return descriptor; } const math = new Math(); math.add(2, 4);                            // Calling add with 2,4</code></pre></li><li><p>多个修饰器</p><pre><code class="lang-js"> function dec(id){   console.log(&#39;evaluated&#39;, id);   return (target, property, descriptor) =&gt; console.log(&#39;executed&#39;, id); } class Example {     @dec(1)     @dec(2)     method(){} } const example=new Example(); example.method(); // evaluated 1 // evaluated 2 // executed 2 // executed 1</code></pre></li><li><p>应用: 实现Mixin模式（在一个对象之中混入另外一个对象的方法）</p><ul><li><p>使用类修饰器实现</p><pre><code class="lang-js">  // mixins.js  export function mixins(...list) {              // 可以在修饰器外面再封装一层函数，以便传入其他参数    return function (target) {      Object.assign(target.prototype, ...list)   // 添加实例属性    }  }  // main.js  import { mixins } from &#39;./mixins&#39;  const Foo = {    foo() { console.log(&#39;foo&#39;) }  };  // 在MyClass类上面“混入”Foo对象的foo方法  @mixins(Foo)  class MyClass {}  let obj = new MyClass();  obj.foo()                                                 // &#39;foo&#39;</code></pre></li><li><p>通过类的继承实现 Mixin （上面的方法会改写MyClass类的prototype对象）</p><pre><code class="lang-js">  // 返回一个继承superclass的子类，该子类包含一个foo方法   let MyMixin = (superclass) =&gt; class extends superclass {               foo() {      console.log(&#39;foo from MyMixin&#39;);    }  };  class MyClass extends MyMixin(MyBaseClass) {}  let c = new MyClass();  c.foo();                                                     // &quot;foo from MyMixin&quot;</code></pre></li></ul></li><li><p>应用: React 与 Redux 库结合使用</p><pre><code class="lang-js"> class MyReactComponent extends React.Component {} export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent); // 有了装饰器，就可以写成如下方式： @connect(mapStateToProps, mapDispatchToProps) export default class MyReactComponent extends React.Component {}</code></pre></li></ol><h2 id="header-39">模块 Module</h2><p><strong> 模块加载方案：</strong></p><ul><li>CommonJS：用于服务器，动态加载（运行时加载）</li><li>AMD：用于浏览器，动态加载（运行时加载）</li><li>ES6：浏览器和服务器通用,静态加载（编译时加载）</li></ul><p><strong> 动态加载 vs 静态加载：</strong></p><ul><li>动态加载：<ul><li>运行时加载，无法在编译时做“静态优化”</li><li>模块输出的是值的拷贝，不存在动态更新</li></ul></li><li>静态加载：<ul><li>编译时加载，编译时就能确定模块的依赖关系，以及输入和输出的变量；</li><li>模块输出的是值的引用（类似Unix 系统的“符号连接”），可动态更新</li></ul></li></ul><h3 id="header-40">ES6 Module</h3><ul><li>自动采用严格模式，不管有没有在模块头部加上”use strict” （ES5引入的）</li><li>一个模块就是一个独立的文件，该文件内部的内容，外部无法获取</li><li>导出/导入<ul><li><code>export ...</code> ：定义模块的对外接口，可处于模块顶层的任何位置<ul><li>一个module可以有多条export，但只能有一条<code>export default</code></li><li><code>export default</code>：<ul><li>指定默认输出，这样 import 时就可以指定一个任意名字给加载项</li><li>本质上，就是输出一个叫做default的变量或方法 ( 将default后面的值，赋给default变量 )，然后系统允许你为它取任意名字</li></ul></li></ul></li><li><code>import ... from ...</code>：加载模块，Singleton 模式，静态加载（在静态解析阶段执行，所以它是一个模块之中最早执行的）<ul><li>静态执行，不能使用表达式和变量，不能使用逻辑判断动态加载</li><li>输入的加载项是只读的（本质是输入接口），即不允许在加载模块的脚本里面改写接口</li><li>多次重复执行同一句import语句或多次加载同一module，也只会执行一次</li><li><code>import &lt;module&gt;</code> : 不导入任何值，仅仅执行所加载的模块，eg: import ‘lodash’;</li></ul></li><li><code>export ... from ...</code>: <ul><li>在一个模块之中，输入输出同一个模块，export 和 import 可复合成一条</li><li>注： <code>export * from &#39;xxx&#39;</code> 会忽略export default输出</li></ul></li><li>可使用<code>as</code>重命名加载对象</li></ul></li></ul><ul><li>注： <ul><li>模块之中，顶层的this指向undefined（CommonJS 模块的顶层this指向当前模块）</li><li>通过 Babel 转码，CommonJS 模块的require命令和 ES6 模块的import命令，可以写在同一个模块里面 – 但不建议这样使用</li></ul></li></ul><p><strong> 示例：</strong></p><ol><li><p><code>export...</code> </p><ul><li><p>export 变量</p><pre><code class="lang-js">  // 写法一  export var m = 1;  // 写法二  var m = 1;  export {m};  // 写法三  var m = 1;  export {m as n};</code></pre></li><li><p>export 方法</p><pre><code class="lang-js">  // 写法一  export function f() {};  //写法二  function f() {}  export {f};  // 写法三  function f() {}  export {f as fun};</code></pre></li><li>export 多个，重命名<pre><code class="lang-js">  export {m,f}  export {m as n, f as fun, f as fun2}</code></pre></li></ul></li><li><p><code>import...from...</code></p><ul><li>cicle.js (module export)：<pre><code class="lang-js">  // circle.js  export function area(radius) {    return Math.PI * radius * radius;  }  export function circumference(radius) {    return 2 * Math.PI * radius;  }</code></pre></li><li><p>import 部分：</p><pre><code class="lang-js">  import { area, circumference } from &#39;./circle&#39;;  console.log(&#39;圆面积：&#39; + area(4));  console.log(&#39;圆周长：&#39; + circumference(14));  // 输入的变量都是只读的，因为它的本质是输入接口，不允许在加载模块的脚本里面，改写接口  area.foo = &#39;hello&#39;;            // 合法操作  area = {};                         // Syntax Error : &#39;area&#39; is read-only;</code></pre></li><li><p>import 所有（整体加载）：</p><pre><code class="lang-js">  import * as circle from &#39;./circle&#39;;  console.log(&#39;圆面积：&#39; + circle.area(4));  console.log(&#39;圆周长：&#39; + circle.circumference(14));  // 整体加载所在的那个对象，应该是可以静态分析的，不允许运行时改变  circle.foo = &#39;hello&#39;;                    // Syntax Error  circle.area = function () {};        // Syntax Error</code></pre></li><li><p>注：</p><ul><li>以上加载部分和整体加载的区别</li><li><p>import是静态执行，不能使用表达式和变量</p><pre><code class="lang-js">  // 报错  import { &#39;f&#39; + &#39;oo&#39; } from &#39;my_module&#39;;  // 报错  let module = &#39;my_module&#39;;  import { foo } from module;      // 报错  if (x === 1) {    import { foo } from &#39;module1&#39;;  } else {    import { foo } from &#39;module2&#39;;  }</code></pre></li><li><p>多次重复执行同一句import语句或多次加载同一module，也只会执行一次</p><pre><code class="lang-js">  import &#39;lodash&#39;;         import &#39;lodash&#39;;        // 只执行一次，等同于：import &#39;lodash&#39;;  import { foo } from &#39;my_module&#39;;  import { bar } from &#39;my_module&#39;;  // 只执行一次，等同于：import { foo, bar } from &#39;my_module&#39;;</code></pre></li></ul></li></ul></li><li><p><code>export default ...</code></p><ul><li><p>export和export default混合</p><pre><code class="lang-js">  export default function (obj) { ···}  export function each(obj, iterator, context) {···}  export { each as forEach };  import _ , { each, forEach } from &#39;lodash&#39;;        // _ 即代表export default的内容</code></pre></li><li><p>export和export default比较</p><pre><code class="lang-js">  // 第一组：export  export function crc32() { ...};  import {crc32} from &#39;crc32&#39;;            // import 使用大括号 {}  // 第二组：export default  export default function crc32() { ...}  // 同 export default function () { ... }  import a from &#39;crc32&#39;;                    // import 不使用大括号{}，且可直接指定一个任意的名字</code></pre></li><li><p>export default 变量（export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句）</p><pre><code class="lang-js">  var a = 1;   export default a;                     // 正确  export default var a = 1;            // 错误  export default 42;        // 正确  export 42;                // 错误</code></pre></li></ul></li><li><p><code>export ... from ...</code> </p><ul><li><p>部分导入导出： <code>export {...} from ...</code></p><pre><code>  export { foo, bar } from &#39;my_module&#39;;    // foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口  // 可以简单理解为  import { foo, bar } from &#39;my_module&#39;;  export { foo, bar };</code></pre></li><li><p>整体导入导出：<code>export * from ...</code>  ( 注：会忽略模块的default方法)</p><pre><code class="lang-js">  // 整体输出  export * from &#39;my_module&#39;;                    // 会忽略模块的default方法  //默认接口的写法  export { default } from &#39;my_module&#39;;  export { default as es6 } from &#39;./my_module&#39;;</code></pre></li></ul></li></ol><h3 id="header-41">浏览器环境加载</h3><p>使用<code>type=&quot;module&quot;</code> </p><ul><li>默认异步加载</li><li>按在页面出现的顺序依次执行加载</li><li>模块：<ul><li>代码是在模块作用域之中运行，而不是在全局作用域运行</li><li>可以使用<code>import</code>命令加载其他模块，<code>.js</code>后缀不可省略</li><li>顶层的this关键字返回undefined，而不是指向window，利用这个特点，可以侦测当前代码是否在 ES6 模块之中（eg：<code>const isNotModuleScript = this !== undefined;</code>）    </li></ul></li><li>转码：若浏览器不支持 ES6 Module，可以将其转为 ES5 的写法，eg：使用Babal，SystemJS</li></ul><p><strong> 示例：</strong></p><ol><li><p>浏览器加载javascript（使用 <code>type=&quot;application/javascript&quot;</code> 默认语言，可省略）</p><pre><code class="lang-js"> // 默认同步加载 &lt;script src=&quot;path/to/myModule.js&quot;&gt;&lt;/script&gt; // 异步加载 // defer： 渲染完再执行；多个defer时，会按照它们在页面出现的顺序加载； // async：下载完就执行，会中断渲染，执行完成后恢复渲染； 多个async时，不保证加载顺序； &lt;script src=&quot;path/to/myModule.js&quot; defer&gt;&lt;/script&gt; &lt;script src=&quot;path/to/myModule.js&quot; async&gt;&lt;/script&gt;</code></pre></li><li><p>浏览器加载ES6 Module</p><pre><code class="lang-js"> &lt;script type=&quot;module&quot; src=&quot;./foo.js&quot;&gt;&lt;/script&gt; &lt;!-- 等同于 --&gt; &lt;script type=&quot;module&quot; src=&quot;./foo.js&quot; defer&gt;&lt;/script&gt;</code></pre></li></ol><h3 id="header-42">Node环境加载</h3><p><strong> CommonJS Module VS ES6 Module：</strong></p><table class="table"><thead><tr><th>操作</th><th style="text-align:left">CommonJS Module</th><th style="text-align:left">ES6 Module</th></tr></thead><tbody><tr><td>输出</td><td style="text-align:left">值的拷贝，不存在动态更新</td><td style="text-align:left">值的引用，可动态更新</td></tr><tr><td>加载</td><td style="text-align:left">运行时加载，无法做“静态优化” <br> （加载的是一个对象，即module.exports属性，该对象只有在脚本运行完才会生成）</td><td style="text-align:left">编译时加载，可做“静态优化” <br> （只是一种静态定义，编译时就能确定模块的依赖关系，以及输入和输出的变量）</td></tr><tr><td>循环加载</td><td style="text-align:left">使用require命令加载脚本 <br> ( 返回的是当前已经执行的部分的值，而不是代码全部执行后的值)</td><td style="text-align:left">使用import命令加载 <br> ( 返回的是引用，需要开发者自己保证，真正取值的时候能够取到值）</td></tr><tr><td></td><td style="text-align:left">第一次加载: 会执行整个脚本，在内存中生成一个对象; <br> 第N次加载：不会再执行，直接到缓存中取值，除非手动清除缓存</td><td style="text-align:left">加载项不会被缓存，已加载项不会重复加载</td></tr></tbody></table><p>注：</p><ol><li><p>CommonJS Module第一次加载在内存中生成的对象如下：</p><pre><code class="lang-js"> {   id: &#39;...&#39;,               // 模块名   exports: { ... },        // 模块输出的各个接口（以后需要用到这个模块的时候，就会到exports属性上面取值）   loaded: true,            // 表示该模块的脚本是否执行完毕   ... }</code></pre></li><li><p>CommonJS Module 循环加载示例：（加载返回的是当前已经执行的部分的值，而不是代码全部执行后的值）</p><ul><li>a.js : 加载 b.js<pre><code class="lang-js">  exports.done = false;  var b = require(&#39;./b.js&#39;);  console.log(&#39;在 a.js 之中，b.done = %j&#39;, b.done);  exports.done = true;  console.log(&#39;a.js 执行完毕&#39;);</code></pre></li><li>b.js : 加载 a.js<pre><code class="lang-js">  exports.done = false;  var a = require(&#39;./a.js&#39;);  console.log(&#39;在 b.js 之中，a.done = %j&#39;, a.done);  exports.done = true;  console.log(&#39;b.js 执行完毕&#39;);</code></pre></li><li>main.js : 加载 a.js,b.js<pre><code class="lang-js">  var a = require(&#39;./a.js&#39;);  var b = require(&#39;./b.js&#39;);  console.log(&#39;在 main.js 之中, a.done=%j, b.done=%j&#39;, a.done, b.done);</code></pre></li><li><p>node执行</p><pre><code>  $ node main.js  在 b.js 之中，a.done = false  b.js 执行完毕  在 a.js 之中，b.done = true  a.js 执行完毕  在 main.js 之中, a.done=true, b.done=true</code></pre></li></ul></li></ol><p><strong> Node 模板加载方案：</strong></p><p>Node 有自己的 CommonJS 模块格式，与 ES6 模块格式不兼容，所以ES6 模块和 CommonJS 需采用各自的加载方案</p><ul><li>ES6<ul><li>采用<code>.mjs</code>后缀文件名</li><li>使用<code>export</code>/<code>import</code>命令，不能使用<code>require</code>命令</li></ul></li><li>CommonJS<ul><li>使用<code>module.export</code>/<code>require</code>命令</li></ul></li><li>ES6 module 加载 CommonJS module: <ul><li>使用 <code>import ... from ...</code> 命令</li><li>Node 会将<code>module.exports</code>属性，当作模块的默认输出，即等同于<code>export default ...</code></li></ul></li><li>CommonJS module 加载 ES6 module: <ul><li>使用<code>import(...)</code>函数</li><li>ES6 模块的所有输出接口，会成为输入对象的属性（注：不能使用require命令）</li></ul></li></ul><ul><li>注：<ul><li>通过 Babel 转码，CommonJS 模块的require命令和 ES6 模块的import命令，可以写在同一个模块里面，但不建议这样使用</li><li>ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量<ul><li>ES6 模块之中，顶层的this指向undefined；CommonJS 模块的顶层this指向当前模块</li><li>在 ES6 模块之中不存在的顶层变量：arguments,require,module,exports,<strong>filename,</strong>dirname</li></ul></li></ul></li></ul><p><strong> 说明：</strong>    </p><ol><li><code>import ... from ...</code> 命令：异步加载，只支持加载本地模块，不支持加载远程模块<ul><li>模块名不含路径：会去node_modules目录寻找这个模块</li><li>模块名包含路径：会按照路径去寻找这个名字的脚本文件</li><li>省略了后缀名的加载,依次尝试:<ul><li>依次尝试四个后缀名：mjs，js，json，node;</li><li>尝试加载该目录下的package.json的main字段指定的脚本；</li><li>尝试加载该目录下的名为index，后缀为mjs,js,json,node的文件</li></ul></li></ul></li><li><code>import(...)</code>函数：同步加载<ul><li>返回一个Promise对象，实现动态加载，类似于 Node 的require方法（异步加载）</li><li>与所加载的模块没有静态连接关系，可以用在任何地方，非模块的脚本也可以使用</li></ul></li></ol><p><strong> 示例：</strong> </p><ol><li><p>ES6 Module加载CommonJS Module : 使用 <code>import...from...</code>命令</p><ul><li><p>a.js （CommonJS module）： CommonJS模块的输出都定义在module.exports这个属性上面</p><pre><code class="lang-js">  module.exports = {    foo: &#39;hello&#39;,    bar: &#39;world&#39;  };  // 等同于 ES6：  export default {    foo: &#39;hello&#39;,    bar: &#39;world&#39;  };</code></pre></li><li><p>ES6 Module导入a.js （注：需使用整体输入）：使用Node的<code>import...from...</code>命令加载 CommonJS 模块，Node 会自动将<code>module.exports</code>属性，当作模块的默认输出，即等同于<code>export default ...</code></p><pre><code class="lang-js">  // 写法一  import baz from &#39;./a&#39;;  // baz = {foo: &#39;hello&#39;, bar: &#39;world&#39;};  // 写法二  import {default as baz} from &#39;./a&#39;;  // baz = {foo: &#39;hello&#39;, bar: &#39;world&#39;};  // 写法三  import * as baz from &#39;./a&#39;;  // baz = {  //   get default() {return module.exports;},  //   get foo() {return this.default.foo}.bind(baz),  //   get bar() {return this.default.bar}.bind(baz)  // }  baz.default         // {foo: &#39;hello&#39;, bar: &#39;world&#39;}  baz.foo                // hello  // 注意：ES6 模块是编译时确定输出接口，CommonJS 模块是运行时确定输出接口，只有在运行时才能确定foo，所以下面方式不正确  import { foo } from &#39;./a&#39;</code></pre></li></ul></li><li><p>CommonJS module加载ES6 module: 使用<code>import(...)</code>函数（注：不能使用require命令），ES6 模块的所有输出接口，会成为输入对象的属性</p><ul><li>ES6 Module：es.js<pre><code class="lang-js">  export let foo = { bar:&#39;my-default&#39; };  export { foo as bar };  export function f() {};  export class c {};</code></pre></li><li>CommonJS 导入 es.js<pre><code class="lang-js">  const es_namespace = await import(&#39;./es&#39;);  // es_namespace = {  //   get foo() {return foo;}  //   get bar() {return foo;}  //   get f() {return f;}  //   get c() {return c;}  // }</code></pre></li></ul></li></ol><h2 id="header-43">实践</h2><h3 id="header-44">var/let/const</h3><ol><li><p>let取代var</p><ul><li>两者语义相同，且let没有副作用：var命令存在变量提升效用，let命令没有这个问题,let只在其声明的代码块内有效</li></ul></li><li><p>优先使用const</p><ul><li>防止了无意间修改变量值所导致的错误（函数应该都设置为const）</li><li>const比较符合函数式编程思想，运算不改变值，只是新建值，这样也有利于将来的分布式运算；</li><li>JavaScript编译器会对const进行优化，有利于提高程序的运行效率（let和const的本质区别，其实是编译器内部的处理不同）</li><li>长远来看，JavaScript 可能会有多线程的实现,const利于保证线程安全</li></ul></li></ol><h3 id="header-45">解构赋值</h3><p>以下情况优先使用解构赋值</p><ol><li><p>使用数组成员对变量赋值</p><pre><code class="lang-js"> const arr = [1, 2, 3, 4]; // bad const first = arr[0]; const second = arr[1]; // good const [first, second] = arr;</code></pre></li><li><p>函数的参数是对象的成员</p><pre><code class="lang-js"> // bad function getFullName(user) {   const firstName = user.firstName;   const lastName = user.lastName; } // good function getFullName(obj) {   const { firstName, lastName } = obj; } // best function getFullName({ firstName, lastName }) { }</code></pre></li><li><p>函数返回多个值，优先使用对象的解构赋值（注：不是数组的解构赋值），便于以后添加返回值，以及更改返回值的顺序</p><pre><code class="lang-js"> // bad function processInput(input) {   return [left, right, top, bottom]; } // good function processInput(input) {   return { left, right, top, bottom }; } const { left, right } = processInput(input);</code></pre></li></ol><h3 id="header-46">String</h3><ul><li>静态字符串: 使用单引号或反引号</li><li>动态字符串: 使用反引号</li></ul><pre><code class="lang-js">// badconst a = &quot;foobar&quot;;const b = &#39;foo&#39; + a + &#39;bar&#39;;// acceptableconst c = `foobar`;// goodconst a = &#39;foobar&#39;;const b = `foo${a}bar`;</code></pre><h3 id="header-47">Array</h3><ol><li><p>拷贝数组: 使用扩展运算符<code>...</code></p><pre><code class="lang-js"> // bad const len = items.length; const itemsCopy = []; let i; for (i = 0; i &lt; len; i++) {   itemsCopy[i] = items[i]; } // good const itemsCopy = [...items];</code></pre></li><li><p>对象转为数组: 使用 <code>Array.from</code> 方法</p><pre><code class="lang-js"> const foo = document.querySelectorAll(&#39;.foo&#39;); const nodes = Array.from(foo);</code></pre></li></ol><h3 id="header-48">Object</h3><ol><li><p>定义对象</p><ul><li>单行定义：最后一个成员不以逗号结尾</li><li><p>多行定义：最后一个成员可以逗号结尾</p><pre><code class="lang-js">// badconst a = { k1: v1, k2: v2, };const b = {k1: v1,k2: v2};// goodconst a = { k1: v1, k2: v2 };const b = {k1: v1,k2: v2,};</code></pre></li></ul></li><li><p>尽量静态化</p><ul><li>定义后尽量不添加新的属性</li><li><p>使用<code>Object.assign</code>方法添加属性</p><pre><code class="lang-js">  // bad  const a = {};  a.x = 3;  // if reshape unavoidable  const a = {};  Object.assign(a, { x: 3 });  // good  const a = { x: null };  a.x = 3;</code></pre></li><li>动态属性名: 可在创造对象的时候，用属性表达式定义<pre><code class="lang-js">  // bad  const obj = {      id: 5,      name: &#39;San Francisco&#39;,  };  obj[getKey(&#39;enabled&#39;)] = true;</code></pre><pre><code class="lang-js">  // good  const obj = {    id: 5,    name: &#39;San Francisco&#39;    ,[getKey(&#39;enabled&#39;)]: true,  };</code></pre></li></ul></li><li><p>尽量简洁表达属性和方法（易于描述和书写）</p><pre><code class="lang-js"> var ref = &#39;some value&#39;; // bad const atom = {   ref: ref,   value: 1,   addValue: function (value) {     return atom.value + value;   }, }; // good const atom = {   ref,   value: 1,   addValue(value) {     return atom.value + value;   }, };</code></pre></li></ol><h3 id="header-49">Function</h3><ol><li><p>建议尽量使用箭头函数的情况：</p><ul><li>立即执行函数<pre><code class="lang-js">  (() =&gt; {    console.log(&#39;Welcome to the Internet.&#39;);  })();</code></pre></li><li><p>原来一些需要使用函数表达式的场合</p><pre><code class="lang-js">  // bad  [1, 2, 3].map(function (x) {    return x * x;  });  // good  [1, 2, 3].map((x) =&gt; {    return x * x;  });  // best  [1, 2, 3].map(x =&gt; x * x);</code></pre></li><li><p>取代Function.prototype.bind(不再用 self/_this/that 绑定 this)</p><pre><code class="lang-js">  // bad  const self = this;  const boundMethod = function(...params) {    return method.apply(self, params);  }  // acceptable  const boundMethod = method.bind(this);  // best  const boundMethod = (...params) =&gt; method.apply(this, params);</code></pre></li><li>注：简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法</li></ul></li><li><p>函数参数</p><ul><li><p>使用rest运算符<code>...</code>代替<code>arguments</code>变量 (arguments 是一个类似数组的对象，而rest运算符可以提供一个真正的数组)</p><pre><code class="lang-js">  // bad  function concatenateAll() {    const args = Array.prototype.slice.call(arguments);    return args.join(&#39;&#39;);  }  // good  function concatenateAll(...args) {    return args.join(&#39;&#39;);  }</code></pre></li><li><p>使用默认值语法设置参数的默认值</p><pre><code class="lang-js">  // bad  function handleThings(opts) {    opts = opts || {};  }  // good  function handleThings(opts = {}) {    // ...  }</code></pre></li></ul></li></ol><h3 id="header-50">Class</h3><ol><li><p>用Class取代需要 prototype的操作（Class语法更简洁易理解）</p><pre><code class="lang-js"> // bad function Queue(contents = []) {   this._queue = [...contents]; } Queue.prototype.pop = function() {   const value = this._queue[0];   this._queue.splice(0, 1);   return value; } // good class Queue {   constructor(contents = []) {     this._queue = [...contents];   }   pop() {     const value = this._queue[0];     this._queue.splice(0, 1);     return value;   } }</code></pre></li><li><p>用extends实现继承（extend语法更简单，且不会有破坏instanceof运算的危险）</p><pre><code class="lang-js"> // bad const inherits = require(&#39;inherits&#39;); function PeekableQueue(contents) {   Queue.apply(this, contents); } inherits(PeekableQueue, Queue); PeekableQueue.prototype.peek = function() {   return this._queue[0]; } // good class PeekableQueue extends Queue {   peek() {     return this._queue[0];   } }</code></pre></li></ol><h3 id="header-51">Module</h3><ol><li><p>使用import取代require</p><pre><code class="lang-js"> // bad const moduleA = require(&#39;moduleA&#39;); const func1 = moduleA.func1; const func2 = moduleA.func2; // good import { func1, func2 } from &#39;moduleA&#39;;</code></pre></li><li><p>使用export取代module.exports</p><pre><code class="lang-js"> // commonJS的写法 var React = require(&#39;react&#39;); var Breadcrumbs = React.createClass({   render() {     return &lt;nav /&gt;;   } }); module.exports = Breadcrumbs; // ES6的写法 import React from &#39;react&#39;; class Breadcrumbs extends React.Component {   render() {     return &lt;nav /&gt;;   } }; export default Breadcrumbs;</code></pre></li><li><p>尽量不使用通配符来确保至少有一个默认输出(export default)</p><pre><code class="lang-js"> // bad import * as myObject from &#39;./importModule&#39;; // good import myObject from &#39;./importModule&#39;;</code></pre></li></ol><h3 id="header-52">ESLint</h3><p>一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码</p><ol><li><p>安装</p><pre><code class="lang-shell"> // 安装ESLint $ npm i -g eslint //安装 Airbnb 语法规则 $ npm i -g eslint-config-airbnb //安装import、a11y、react 插件 $ npm i -g eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react</code></pre></li><li><p>配置（项目的根目录下新建一个.eslintrc文件）</p><pre><code class="lang-json"> {   &quot;extends&quot;: &quot;eslint-config-airbnb&quot; }</code></pre></li><li><p>使用，eg：</p><ul><li><p>index.js</p><pre><code class="lang-js">  var unusued = &#39;I have no purpose!&#39;;  function greet() {      var message = &#39;Hello, World!&#39;;      alert(message);  }  greet();</code></pre></li><li><p>使用 ESLint 检查index.js，发现错误</p><pre><code class="lang-js">  $ eslint index.js  index.js    1:1  error  Unexpected var, use let or const instead          no-var    1:5  error  unusued is defined but never used                 no-unused-vars    4:5  error  Expected indentation of 2 characters but found 4  indent    4:5  error  Unexpected var, use let or const instead          no-var    5:5  error  Expected indentation of 2 characters but found 4  indent  × 5 problems (5 errors, 0 warnings)</code></pre><ul><li>不应该使用var命令，而要使用let或const</li><li>定义了变量，却没有使用</li><li>行首缩进为 4 个空格，而不是规定的 2 个空格</li></ul></li></ul></li></ol><h2 id="header-53">Reference</h2><ul><li><a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="noopener">阮一峰 ECMAScript 6 入门</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">Object.create()</a></li></ul>]]></content>
    
    <summary type="html">
    
      ES6 Introduce
    
    </summary>
    
    
      <category term="Javascript" scheme="http://sixdegree.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot</title>
    <link href="http://sixdegree.github.io/2018/09/15/Spring-Boot.html"/>
    <id>http://sixdegree.github.io/2018/09/15/Spring-Boot.html</id>
    <published>2018-09-14T16:00:00.000Z</published>
    <updated>2019-01-07T04:14:29.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>自动装配组件</li><li>外部化配置</li><li>Servlet（独立／嵌入式Servlet容器）</li><li>WebMvc</li><li>WebFlux</li></ol><a id="more"></a><h2 id="header-1">Starter</h2><blockquote><p>Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”.</p></blockquote><ul><li>全新框架，目的是简化Spring应用的搭建和开发过程，不需要定义样板化的配置（例如xml文件）</li><li>从根本上讲是一些库的集合（使用Maven／Gradle 构建项目，无需自行管理这些库的版本）</li><li>特点：<ul><li>简化Maven配置</li><li>自动配置Spring</li><li>创建独立的Spring应用程序</li><li>嵌入Web容器，无需部署war包（直接<code>java -jar</code> 就可运行）</li><li>提供生产就绪型功能（如指标，健康检查和外部配置）</li></ul></li><li>场景：<ul><li>开发Restful风格的微服务架构</li><li>微服务，自动化，横向扩展</li><li>精简配置与整合其他工具</li></ul></li><li>Vesion:<ul><li>SpringBoot 1.x - Spring 4.x</li><li>SpringBoot 2.x - Spring 5.x</li></ul></li></ul><p><img src="/2018/09/15/springboot.png" alt="Spring Boot"></p><h3 id="header-2">三大特性</h3><ol><li><p>自动装配组件： Web MVC，Web Flux，JDBC,…</p><ul><li>激活：<code>@EnableAutoConfiguration</code><pre><code class="lang-java">  @EnableAutoConfiguration  public class App {      public static void main(String[] args) {           SpringApplication.run(App.class,args);      }  }</code></pre></li><li>实现：<code>XxxAutoConfiguration</code> , eg: <code>WebMvcAutoConfiguration</code><pre><code class="lang-java">  @Configuration  @ConditionalOnWebApplication(type = Type.SERVLET)  @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })  @ConditionalOnMissingBean(WebMvcConfigurationSupport.class)  @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)  @AutoConfigureAfter({ DispatcherServletAutoConfiguration.class,ValidationAutoConfiguration.class })  public class WebMvcAutoConfiguration {      @Bean      //...  }</code></pre></li><li>配置：<code>/META-INF/spring.factories</code>,eg: the spring.factories file under spring-boot-autoconfigure-xxx.jar<pre><code>  # Auto Configure  org.springframework.boot.autoconfigure.EnableAutoConfiguration=\  org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\  org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\  org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\  org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\  ...</code></pre></li></ul></li><li><p>嵌入式Web容器：</p><ul><li>Web Servlet: <code>Tomcat</code>，<code>Jetty</code>，<code>Undertow</code></li><li>Web Reactive: <code>Netty Web Server</code></li></ul></li><li><p>生产准备特性：</p><ul><li>dependency: <code>spring-boot-starter-actuator</code></li><li><code>application.properties</code>:<pre><code>  # 开放所有的Web Endpoints  # management.endpoints.web.exposure.include=*  management.endpoints.web.exposure.include=health,info</code></pre></li><li>visit <code>/actuator</code> (eg：<code>http://localhost:8080/actuator</code> )</li><li>jconsole </li><li>端点：各类Web和JMX Endpoints<ul><li>指标: 内建Metrics，自定义Metrics (visit: <code>/actuator/metrics</code> )</li><li>健康检查: Health，HealthIndicator (visit <code>/actuator/health</code> )</li><li>外部化配置 (visit <code>/actuator/configprops</code> )</li></ul></li></ul></li></ol><h3 id="header-3">Web</h3><ol><li><p>传统Servlet</p><ul><li>jar: javax.servlet-api (或embed server jar，eg： tomcat-embed-core)</li><li>核心组件:<code>Servlet</code>,<code>Filter,Listener</code></li><li>注入：<ul><li>Servlet注解: <code>@WebServlet</code>,<code>@WebFilter</code>,<code>@WebListener</code></li><li>Spring Bean: <code>@Bean</code></li><li>SpringBoot:<code>RegistrationBean</code>,<code>@ServletComponentScan</code>,<code>ServletContextInitializer</code></li></ul></li><li>Servlet 3.0 规范：加入异步Servlet</li><li>Servlet 3.1 规范：加入非阻塞Servlet</li></ul></li><li><p>Spring WebMVC</p><ul><li>jar: <code>spring-webmvc</code> (dependency: <code>spring-web</code>)</li><li>核心组件(jar: <code>spring-webmvc</code>, package：<code>o.s.w.servlet...</code>)：<ul><li>总控 <code>DispatcherServlet</code></li><li>处理器管理<ul><li>映射 <code>HandlerMapping</code> (eg: RequestMappingHandlerMapping)</li><li>适配 <code>HandlerAdapter</code> (eg: RequestMappingHandlerAdapter)</li><li>执行 <code>HandlerExecutionChain</code></li></ul></li><li>异常解析器 <code>HandlerExceptionResolver</code></li><li>HandlerMethod: <code>@RequestMapping</code>/<code>@XxxMapping</code>标注的方法<ul><li>HandlerMethod参数解析器: <code>HandlerMethodArgumentResolver</code></li><li>HandlerMethod返回值解析器: <code>HandlerMethodReturnValueHandler</code></li></ul></li><li>视图解析器 <code>ViewResolver</code><ul><li>国际化 <code>LocaleResolver</code>,<code>LocaleContextResolver</code></li><li>个性化 <code>ThemeResolver</code></li><li>内容协商 <code>ContentNegotiatingViewResolver</code></li><li>默认 <code>InternalResourceViewResolver</code></li></ul></li><li>视图渲染 <code>View</code>, eg:<ul><li><code>RedirectView</code></li><li><code>JstlView</code></li><li><code>ThymeleafView</code></li></ul></li><li>配置 <ul><li><code>WebMvcConfigurer</code></li><li><code>ContentNegotiationConfigurer</code></li></ul></li></ul></li><li>注解：<ul><li><code>@Controller</code>,<code>@ControllerAdvice</code>,<code>@ExceptionHandler</code></li><li><code>@RequestMapping</code>（<code>@GetMapping</code>,<code>@PostMapping</code>,…)</li><li><code>@RequestBody</code>,<code>@RequestParm</code>,<code>@RequestHeader</code>,<code>@PathVariable</code>,<code>@CookieValue</code></li><li><code>@RestController</code>,<code>@RestControllerAdvice</code>,<code>@ResponseBody</code>(for Rest)</li><li><code>@ModelAttribute</code>,<code>@Valid</code>,<code>@Validated</code></li></ul></li></ul></li><li><p>Spring WebFlux</p><ul><li>jar: <code>spring-webflux</code> (dependency: <code>spring-web</code>,<code>reactor-core</code>)</li><li>是<code>Reactive</code>思想的一种实现（数据流<code>Data Stream</code>，非阻塞 <code>Non-Blocking</code>，推模式<code>push-based</code>，背压<code>Backpressure</code>）</li><li>依赖<code>Reactor</code>类库(jar:<code>reactor-core</code>)<ul><li>依赖<code>reactive-streams</code><ul><li>核心组件：<code>Publisher</code>,<code>Subscriber</code>,<code>Subscription</code>,<code>Processor</code></li><li>背压处理</li></ul></li><li>核心组件：<code>Mono</code>,<code>Flux</code>,<code>Scheduler</code></li></ul></li><li>依赖<code>SpringWeb</code>类库(jar: <code>spring-web</code>)<ul><li><code>HttpHandler</code>: <code>Mono&lt;Void&gt; handle(ServerHttpRequest request, ServerHttpResponse response);</code></li><li><code>WebHandler</code>: <code>Mono&lt;Void&gt; handle(ServerWebExchange exchange);</code></li></ul></li><li>编程模型：<ul><li>注解式驱动 <a href="https://docs.spring.io/spring/docs/5.0.x/spring-framework-reference/web-reactive.html#webflux-controller" target="_blank" rel="noopener">Annotated Controllers</a>: 同WebMvc使用的注解</li><li>函数式端点 <a href="https://docs.spring.io/spring/docs/5.0.x/spring-framework-reference/web-reactive.html#webflux-fn" target="_blank" rel="noopener">Functional Endpoints</a> : 使用<code>RouterFunction</code>(功能上代替Contoller+HandleMethod)</li></ul></li><li>核心组件(功能大同WebMvc, jar: <code>spring-webflux</code>， package：<code>o.s.w.reactive...</code>):<ul><li>总控 <code>DispatcherHandler</code> (implements <code>WebHandler</code>)</li><li>处理器管理<ul><li>映射 <code>HandlerMapping</code> (eg: RequestMappingHandlerMapping)</li><li>适配 <code>HandlerAdapter</code> (eg: RequestMappingHandlerAdapter)</li><li>执行 <code>HandlerResult</code></li></ul></li><li>异常处理 <code>HandlerResult#exceptionHandler</code></li><li>HandlerMethod: <code>@RequestMapping</code>/<code>@XxxMapping</code>标注的方法<ul><li>HandlerMethod参数解析器: <code>HandlerMethodArgumentResolver</code></li><li>Handler返回值解析器: <code>HandlerResultHandler</code><ul><li><code>ResponseBodyResultHandler</code></li><li><code>ResponseEntityResultHandler</code></li><li><code>ServerResponseResultHandler</code></li><li><code>ViewResolutionResultHandler</code><ul><li><code>RequestedContentTypeResolverBuilder</code></li><li><code>RequestedContentTypeResolver</code></li></ul></li></ul></li></ul></li><li>视图解析器 <code>ViewResolver</code></li><li>视图渲染 <code>View</code>, eg:<ul><li><code>RedirectView</code></li><li><code>FreeMarkerView</code></li><li><code>HttpMessageWriterView</code></li></ul></li><li>配置 <ul><li><code>WebFluxConfigurer</code></li><li><code>WebFluxConfigurationSupport</code></li></ul></li><li>for Functional Endpoints(函数式端点方式)<ul><li><code>RouterFunction</code></li><li><code>RouterFunctionMapping</code> (implements HandlerMapping)</li><li><code>HandlerFunctionAdapter</code> (implements HandlerAdapter)</li></ul></li></ul></li><li>使用场景：不适合RT（响应）敏感的RPC框架/Web应用，适合请求慢慢执行的场景（把请求丢过来，不care什么时候完成，完成后通知你下就即可），Reactive可以提升吞吐量，但RunTime反而会变得更长，且出现响应超时等问题    </li><li><code>Spring WebMVC</code> vs. <code>Spring WebFlux</code><ul><li>均能使用注解驱动Controller,WebFlux还能使用函数式端点方式</li><li>主要不同点在于并发模型和阻塞特性：<ul><li>Spring WebMvc: Servlet应用,通常是阻塞服务,Servlet容器一般使用较大的线程池处理请求</li><li>Spring WebFlux: Reactive应用,通常是非阻塞服务，服务器可使用少量、固定大小的线程池处理请求</li></ul></li><li>目前WebFlux并未优于WebMvc:<ul><li>性能上没有明显的速度提升(甚至性能结果稍微更恶劣)</li><li>在编程友好性方面,Reactive编程尽管没有新增大量的代码,却使编码(和调试)变得复杂了</li><li>缺少文档</li></ul></li></ul></li></ul></li></ol><h2 id="header-4">基本使用</h2><h3 id="header-5">Hello World</h3><ol><li><p>创建SpringBoot项目</p><ul><li>方式一： 使用 <a href="http://start.spring.io" target="_blank" rel="noopener">start spring</a><pre><code>  // 1. 网页中配置GAV：  Spring Boot: 2.0.0  Group: com.cj  Artifact: springboot-demo-first  Dependencies: Reactive Web  //=&gt; Generate Project  // 2. Download project and import to IDEA   import project from external model -&gt; Maven</code></pre></li><li>方式二：使用 Maven命令行<pre><code class="lang-bash"># 1. mvn archetype:generate 创建项目&gt; mvn archetype:generate -DinteractiveMode=false -DgroupId=com.cj -DartifactId=springboot-demo-second -Dversion=0.0.1-SNAPSHOT# 2. import the project to IDEA</code></pre></li><li>方式三：使用IDEA的Spring Initializr工具创建（Community版本不支持）<pre><code class="lang-bash">File -&gt; New -&gt; Project -&gt; Spring InitializrInitializr Server URL: http://start.spring.io -&gt; Next -&gt; 输入GAV等配置信息</code></pre></li></ul></li><li><p>配置依赖包（pom.xml )</p><ul><li>basic<ul><li><code>spring-boot-starter</code>：核心模块，包括自动配置支持、日志和YAML，</li><li><code>spring-boot-starter-test</code>：测试模块，包括JUnit、Hamcrest、Mockito</li></ul></li><li>web<ul><li><code>spring-boot-starter-web</code>: 引入Web模块(支持SpringMVC),默认内嵌tomcat(by including: <code>spring-boot-starter-tomcat</code>)</li><li><code>spring-boot-starter-webflux</code>：引入webflux模块(支持Reactive)，默认内嵌Reactor Netty(by including:<code>spring-boot-starter-reactor-netty</code>)</li></ul></li><li>embed web server – no need to deploy WAR files , refer <a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#howto-use-another-web-server" target="_blank" rel="noopener">How to use another web-server</a><ul><li><code>spring-boot-starter-tomcat</code></li><li><code>spring-boot-starter-jetty</code></li><li><code>spring-boot-starter-undertow</code></li><li><code>spring-boot-starter-reactor-netty</code></li></ul></li><li><p>plugin</p><ul><li><code>spring-boot-maven-plugin</code></li></ul></li><li><p>Sample1: a typical pom</p><pre><code class="lang-xml">  &lt;!-- Inherit defaults from Spring Boot --&gt;  &lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;  &lt;/parent&gt;  &lt;!-- Add typical dependencies for a web application,也可使用spring-boot-starter-webflux --&gt;  &lt;dependencies&gt;    &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;  &lt;!-- Package as an executable jar --&gt;  &lt;build&gt;    &lt;plugins&gt;      &lt;plugin&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;      &lt;/plugin&gt;    &lt;/plugins&gt;  &lt;/build&gt;</code></pre></li><li>Sample2: use another web server<pre><code class="lang-xml">  &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;exclusions&gt;    &lt;!-- Exclude the Tomcat dependency --&gt;    &lt;exclusion&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;    &lt;/exclusion&gt;        &lt;/exclusions&gt;  &lt;/dependency&gt;  &lt;!-- Use Jetty instead --&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;  &lt;/dependency&gt;</code></pre></li></ul></li><li><p>Coding</p><pre><code class="lang-java"> // 1. App.java @SpringBootApplication public class App {     public static void main( String[] args ){         SpringApplication.run(App.class, args);     } } // 2. controller/HelloWorldController.java @RestController public class HelloWorldController {     @GetMapping(&quot;&quot;)     public String index(){         return &quot;Hello World!&quot;;     } }</code></pre></li><li><p>运行/发布</p><ul><li>方式一： IDEA中run App.java （适用于：开发环境调试 ）</li><li><p>方式二：打Jar/War包运行 （适用于： 生产环境，使用脚本启动 ）</p><pre><code class="lang-bash">  # 1.打包 ( -U  表示更新maven包)  cd myProject  mvn -Dmaven.test.skip -U clean package  cd web/target  # 2. 运行jar  # pom.xml中配置packaging为jar  java -jar myProject-xxx.jar  # 3. 运行war  # pom.xml中配置packaging为war (需要有webapp/WEB-INFO/web.xml文件)，也可将war包放入外部tomcat中运行  java -jar myProject-xxx.war</code></pre></li><li><p>方式三：Maven Plugin运行 （适用于： 无图形化界面的开发环境 ）</p><pre><code class="lang-bash">  # 1.打包安装到本地仓库  cd myProject  mvn -Dmaven.test.skip -U clean install  # 2.运行  mvn spring-boot:run</code></pre></li></ul></li><li>visit <code>http://localhost:8080</code> to verify -&gt; should show “Hello World!” in the page</li></ol><h3 id="header-6">热部署</h3><p>监听classpath下的文件（class类，配置文件）变化，自动重启应用<br>（默认静态资源改变：<code>/public</code>，<code>/resource</code>，<code>/META-INF</code>,…，会重新加载，但不会重启应用）</p><ul><li><p>方式一：使用<code>springloaded</code> </p><pre><code class="lang-xml">  &lt;plugins&gt;    &lt;plugin&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;    &lt;dependencies&gt;    &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;springloaded&lt;/artifactId&gt;    &lt;version&gt;1.2.8.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;/plugin&gt;  &lt;/plugins&gt;</code></pre></li><li><p>方式二：使用<code>spring-boot-devtools</code></p><pre><code class="lang-xml">  &lt;dependency&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;     &lt;optional&gt;true&lt;/optional&gt;  &lt;/dependency&gt;</code></pre><ul><li><p>额外配置示例：</p><pre><code>  #热部署生效  spring.devtools.restart.enabled: true  #设置重启的目录  #spring.devtools.restart.additional-paths: src/main/java  #classpath目录下的WEB-INF文件夹内容修改不重启  spring.devtools.restart.exclude: WEB-INF/**</code></pre></li></ul></li><li><p>启动运行：</p><ul><li>方式一： <code>mvn spring-boot:run</code></li><li>方式二：直接运行<code>main</code>方法</li></ul></li><li><p>注：热部署自身不会去主动编译 Java 文件</p></li><li><p>示例：配置在Java 文件改动时，自动编译成 Class 文件（然后热部署工具创造的新的类加载器才会加载改变后的 Class 文件）</p><ul><li><code>IDEA</code> ：使用工具时配置自动编译：<pre><code>  1. File -&gt; Settings -&gt; Complier -&gt; 勾选Make project automatically  2. Shift+Ctrl+Alt+/，Shift+Ctrl+A -&gt; Registry -&gt; 勾选compiler.automake.allow.when.app.running</code></pre><ul><li><code>Eclipse</code>：<pre><code class="lang-xml">&lt;plugins&gt;     &lt;plugin&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;configuration&gt;     &lt;fork&gt;true&lt;/fork&gt;&lt;/configuration&gt;&lt;/plugin&gt;&lt;/plugins&gt;</code></pre></li></ul></li></ul></li></ul><p><strong> 热部署 VS. 热加载 </strong></p><ol><li><p>共点：编译／部署项目不重启服务器，都基于Java的类加载器实现 （在容器启动时，启动一后台线程，定时监测class文件的时间戳，判断是否变化了）</p></li><li><p>热部署：在服务器运行时重新部署项目 —— 多用于生产环境 （会释放内存，比热加载更加干净彻底）</p></li><li><p>热加载：在运行时重新加载改变的class —— 多用于开发环境 （ 直接修改字节码的方式，难以监控和记录逻辑变化）</p></li></ol><p><strong> 配置Tomcat实现热部署的三种方式: </strong></p><ul><li><p>方式一：直接将项目（解压后的web项目）放在tomcat的<code>webapp</code>目录下</p></li><li><p>方式二：<code>%tomcat_home%/conf/server.xml</code>的<code>&lt;host&gt;</code>内添加<code>&lt;context&gt;</code>配置</p><pre><code class="lang-xml">   &lt;Context debug=&quot;0&quot; docBase=&quot;D:/space/web&quot; path=&quot;/hot&quot; privileged=&quot;true&quot; reloadable=&quot;true&quot;/&gt;   &lt;!--     注意配置了path（虚拟路径），访问网址需使用此项目名/hot    将项目目录下的内容（META-INF,WEB-INF,...）copy到docBase的指定路径   --&gt;</code></pre></li><li><p>方式三：<code>%tomcat_home%/conf/Catalina/localhost</code>目录下添加一个xml文件,eg: <code>hot.xml</code></p><pre><code class="lang-xml">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;Context docBase=&quot;D:/space/web&quot; reloadable=&quot;true&quot;/&gt;  &lt;!-- 注意xml文件名为hot，则访问网址使用此项目名/hot --&gt;</code></pre></li></ul><h3 id="header-7">单元测试</h3><ol><li><p>Test Service:</p><pre><code class="lang-java"> @RunWith(SpringRunner.class) @SpringBootTest(classes=TagServiceTest.class) public class TagServiceTest {     @Autowired     private TagService tagService;     @Test     @Transactional     public void listTest(){         List&lt;Tag&gt; list=this.tagService.list(&quot;Benefit&quot;);         for(Tag item:list) {             System.out.println(item);         }     } }</code></pre></li><li><p>Test Controller:</p><pre><code class="lang-java"> @RunWith(SpringRunner.class) @SpringBootTest @AutoConfigureMockMvc public class HelloControllerTest {     @Autowired     private MockMvc mvc;     @Test     public void sayHello() throws Exception {         mvc.perform(MockMvcRequestBuilders.get(&quot;/say&quot;).accept(MediaType.APPLICATION_JSON))             .andExpect(status().isOk())             .andExpect(content().string(equalTo(&quot;Hello world!&quot;)))             ;     } }</code></pre></li><li><p>Test Web:</p><pre><code class="lang-java"> @RunWith(SpringRunner.class) @SpringBootTest(webEnvironment=SpringBootTest.WebEnvironment.RANDOM_PORT) public class HelloControllerIT {     @LocalServerPort     private int port;     private URL base;     @Autowired     private TestRestTemplate template;     @Before     public void setup() throws MalformedURLException {         this.base=new URL(&quot;http://localhost:&quot;+port+&quot;/hello&quot;);         System.out.println(base);     }     @Test     public void say() throws Exception {         ResponseEntity&lt;String&gt; response=template.getForEntity(base.toString()+&quot;/say&quot;, String.class);         assertThat(response.getBody(),equalTo(&quot;Hello world!&quot;));     } }</code></pre></li></ol><h3 id="header-8">属性配置</h3><p>Refer <a href="https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">Common application properties</a>                </p><ol><li><p>配置文件：<code>resources/application.properties</code> 或 <code>resources/application.yml</code></p></li><li><p>注解：</p><ul><li><code>@Value</code>, eg: <code>@Value(${content})</code></li><li><code>@ConfigurationProperties</code>,eg: <code>@ConfigurationProperties(prefix = &quot;hello&quot;)</code></li></ul></li></ol><p><strong> 示例1：<code>@Value</code>,<code>@ConfigurationProperties</code>使用 </strong></p><ol><li><p>配置文件<code>resources/application.yml</code></p><pre><code> say:   prefix: &quot;Hi&quot;   target: &quot;Tom&quot;   times: 5 content: &quot;Test: ${say.prefix} ${say.target}&quot;</code></pre></li><li><p>获取注入配置的属性值</p><pre><code class="lang-java"> // 1. 使用@ConfigurationProperties // config/SayProperties.java @Component @ConfigurationProperties(prefix = &quot;say&quot;) public class SayProperties {     private String prefix;     private String target;     private Integer times;     /*getter and setter...*/ } // 2. 使用@Value // controller/SayController @RestController public class SayController {     @Value(&quot;${content}&quot;)     private String content;     @Autowired     private SayProperties sayProperties;     @GetMapping(&quot;/testSay&quot;)     public String say(){         return content+&quot; -- &quot;+sayProperties;     } }</code></pre></li><li><p>visit <code>http://localhost:8080/testSay</code> to verify,shoud see: “Test: Hi Tom – SayProperties [prefix=Hi, target=Tom, times=5]”</p></li></ol><p><strong> 示例2：多环境配置（不同环境使用不同配置） </strong></p><ol><li><p>resource/application-dev.yml</p><pre><code> server:   port: 8080   servlet:     context-path: /hello say:   prefix: &quot;Hi&quot;   target: &quot;DevEnv&quot;   times: 5</code></pre></li><li><p>resource/application-prod.yml</p><pre><code> server:   port: 8090   servlet:     context-path: /hello say:   prefix: &quot;Hi&quot;   target: &quot;ProdEnv&quot;   times: 5</code></pre></li><li><p>resource/application.yml</p><pre><code> spring:   profiles:     active: dev content: &quot;Test: ${say.prefix} ${say.target}&quot;</code></pre></li><li><p>Verify</p><pre><code class="lang-bash"> cd springboot-helloworld mvn -Dmaven.test.skip -U clean package # Note：cmd line args的优先级高于properties file的配置 # test dev # visit: http://localhost:8080/hello/testSay # should show: Test: Hi DevEnv -- SayProperties [prefix=Hi, target=DevEnv, times=5] java -jar target/springboot-helloworld-0.0.1-SNAPSHOT.jar # test prod  # visit: http://localhost:8090/hello/testSay # should show: Test: Hi ProdEnv -- SayProperties [prefix=Hi, target=ProdEnv, times=5] java -jar target/springboot-helloworld-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod</code></pre></li></ol><h3 id="header-9">AOP</h3><ul><li>一种编程范式，与语言无关，是一种程序设计思想,eg:<ul><li><code>AOP</code> 面向切面 Aspect Oriented Programming</li><li><code>OOP</code> 面向对象 Object Oriented Programming</li><li><code>POP</code> 面向过程 Procedure Oriented Programming</li></ul></li><li>从面向过程到面向对象，换了个角度看世界，换个姿势处理问题</li><li>AOP 将通用逻辑从业务逻辑中分离出来</li><li>应用：AOP统一处理请求日志，记录每一个http请求</li></ul><pre><code class="lang-xml">&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>aspect/HttpAspect.java</p><pre><code class="lang-java">@Aspect@Componentpublic class HttpAspect{    @PointCut(&quot;execution(...)&quot;)    public void log(){}    @Before(&quot;log()&quot;)    public void doBefore(JoinPorint joinPoint ){        ...    }}</code></pre><h3 id="header-10">异常处理</h3><p><code>@ExceptionHandler</code></p><pre><code class="lang-java">@Controllerpublic class HelloController {    @RequestMapping(value=&quot;/{num}&quot;,method=RequestMethod.GET)    public String doExTest(@PathVariable int num,Model model){        model.addAttribute(&quot;message&quot;,&quot;number:&quot;+num);        return &quot;index&quot;;    }    @ExceptionHandler(Throwable.class)    public ResponseEntity&lt;String&gt; onException(Throwable ex){        return ResponseEntity.ok(&quot;handle exception:&quot;+ex.getMessage());    }}</code></pre><p>或者：</p><pre><code class="lang-java">@Controllerpublic class HelloController {    @RequestMapping(value=&quot;/{num}&quot;,method=RequestMethod.GET)    public String doExTest(@PathVariable int num,Model model){        model.addAttribute(&quot;message&quot;,&quot;number:&quot;+num);        return &quot;index&quot;;    }}@ControllerAdvice(assignableTypes=HelloController.class)public class HelloControllerAdvice {    @ExceptionHandler(Throwable.class)    public ResponseEntity&lt;String&gt; onException(Throwable ex){        return ResponseEntity.ok(&quot;handle exception:&quot;+ex.getMessage());    }}</code></pre><h2 id="header-11">装配</h2><ol><li><p>Spring装配技术：</p><ul><li>模式注解装配：<code>@Component</code>,<code>@Repository</code>,<code>@Service</code>,<code>@Controller</code>,<code>@Configuration</code></li><li>Enable模块装配: <code>@Enable模块</code></li><li>条件装配:<code>@Profile</code>,<code>@Conditional</code></li><li>工厂加载机制: <code>SpringFactoriesLoader</code> + <code>META-INF/spring.factories</code></li></ul></li><li><p>SpringBoot自动装配：</p><ul><li>依赖Spring装配技术，基于约定大于配置的原则，实现自动装配</li><li>实现步骤：<ul><li>激活自动装配 <code>@EnableAutoConfiguration</code></li><li>实现装配 <code>XxxAutoConfiguration</code></li><li>配置 <code>META-INF/spring.factories</code></li></ul></li></ul></li></ol><h3 id="header-12">Spring 装配技术</h3><h4 id="header-13">模式注解装配</h4><ol><li><p>模式注解(Stereotype Annotations):</p><blockquote><p>an annotation that is used to declare the role that a component plays within the application.</p></blockquote></li><li><p>模式注解装配：<code>@ComponentScan</code>/<code>&lt;context:component-scan&gt;</code></p><blockquote><p>扫描并找到<code>@Component</code>或者其派生Annotation(eg: <code>@Repository</code>,<code>@Service</code>,<code>@Controller</code>,<code>@Configuration</code>) 标注的Class，将它们注册为Spring Bean</p></blockquote></li><li><p>使用示例：</p><ul><li>使用<code>&lt;context:component-scan&gt;</code><pre><code class="lang-xml">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans      http://www.springframework.org/schema/beans/spring-beans.xsd      http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/springcontext.xsd&quot;&gt;      &lt;!-- 激活注解驱动特性 --&gt;      &lt;context:annotation-config /&gt;      &lt;!-- 找到指定package下@Component及其派生标注的类，注册为SpringBean对象 --&gt;      &lt;context:component-scan base-package=&quot;com.cj.demo&quot; /&gt;  &lt;/beans&gt;</code></pre></li><li>使用<code>@ComponentScan</code><pre><code class="lang-java">  @ComponentScan(basePackages=&quot;com.cj.demo&quot;)  public class HelloWorldSpringScanApplication {       public static void main(String[] args) {          ConfigurableApplicationContext context = new SpringApplicationBuilder(HelloWorldSpringScanApplication.class)              .web(WebApplicationType.NONE)              .run(args);                              Hello hello = context.getBean(&quot;hello&quot;,Hello.class);          System.out.println(&quot;Hello Bean : &quot;+hello);              context.close();      }  }</code></pre></li></ul></li></ol><h4 id="header-14">模块装配</h4><p><code>@Enable模块</code> （模块：具备相同领域的功能组件集合， 组合所形成一个独立的单元）</p><ol><li><p>Spring Framework 3.1 开始支持,eg:</p><table class="table"><thead><tr><th style="text-align:left">框架实现</th><th style="text-align:left">@Enable注解模块</th><th style="text-align:left">激活模块</th></tr></thead><tbody><tr><td style="text-align:left">Spring Framework</td><td style="text-align:left"><code>@EnableWebMvc</code></td><td style="text-align:left">Web MVC 模块</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>@EnableTransactionManagement</code></td><td style="text-align:left">事务管理模块</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>@EnableCaching</code></td><td style="text-align:left">Caching（缓存）模块</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>@EnableMBeanExport</code></td><td style="text-align:left">JMX（Java管理扩展）模块</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>@EnableAsync</code></td><td style="text-align:left">异步处理模块</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>@EnableWebFlux</code></td><td style="text-align:left">Web Flux 模块</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>@EnableAspectJAutoProxy</code></td><td style="text-align:left">AspectJ 代理模块</td></tr><tr><td style="text-align:left">Spring Boot</td><td style="text-align:left"><code>@EnableAutoConfiguration</code></td><td style="text-align:left">自动装配模块</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>@EnableManagementContext</code></td><td style="text-align:left">Actuator 管理模块</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>@EnableConfigurationProperties</code></td><td style="text-align:left">配置属性绑定模块</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>@EnableOAuth2Sso</code></td><td style="text-align:left">OAuth2 单点登录模块</td></tr><tr><td style="text-align:left">Spring Cloud</td><td style="text-align:left"><code>@EnableEurekaServer</code></td><td style="text-align:left">Eureka服务器模块</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>@EnableConfigServer</code></td><td style="text-align:left">配置服务器模块</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>@EnableFeignClients</code></td><td style="text-align:left">Feign客户端模块</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>@EnableZuulProxy</code></td><td style="text-align:left">服务网关 Zuul 模块</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>@EnableCircuitBreaker</code></td><td style="text-align:left">服务熔断模块</td></tr></tbody></table></li><li><p>实现方式：</p><ul><li><p>注解驱动方式,eg: <code>@EnableWebMvc</code></p><pre><code class="lang-java">  @Retention(RetentionPolicy.RUNTIME)  @Target(ElementType.TYPE)  @Documented  @Import(DelegatingWebMvcConfiguration.class) // import: Configuration class  public @interface EnableWebMvc {  }  @Configuration  public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {      //@Bean,eg:      // RequestMappingHandlerMapping      // RequestMappingHandlerAdapter      // ContentNegotiationManager      // ...  }</code></pre></li><li><p>接口编程方式,eg: <code>@EnableCaching</code></p><pre><code class="lang-java">  @Target(ElementType.TYPE)  @Retention(RetentionPolicy.RUNTIME)  @Documented  @Import(CachingConfigurationSelector.class) // import: interface ImportSelector 实现类，用于获取Configuration类名  public @interface EnableCaching {      //...  }  public interface ImportSelector {      /**       * Select and return the names of which class(es) should be imported based on       * the {@link AnnotationMetadata} of the importing @{@link Configuration} class.       */      String[] selectImports(AnnotationMetadata importingClassMetadata);  }  public class CachingConfigurationSelector       extends AdviceModeImportSelector&lt;EnableCaching&gt; {       // Note: AdviceModeImportSelector implements ImportSelector      // 实现interface ImportSelector#selectImports(AnnotationMetadata importingClassMetadata)      // 返回要import的Congifuration类名      // eg:      // return new String[] { AutoProxyRegistrar.class.getName(), ProxyCachingConfiguration.class.getName() };      // return new String[] { AnnotationConfigUtils.CACHE_ASPECT_CONFIGURATION_CLASS_NAME };  }</code></pre></li></ul></li><li><p>示例：自定义一个<code>@EnableHelloWorld</code>并使用</p><ul><li><p>方式一：<code>@EnableHelloWorld</code> Import <code>Configuration class</code></p><pre><code class="lang-java">  @Retention(RetentionPolicy.RUNTIME)  @Target(ElementType.TYPE)  @Documented  @Import(HelloWorldConfiguration.class)  public @interface EnableHelloWorld {  }  //@Configuration  public class HelloWorldConfiguration {      // @Bean：      // 方法级别上的注解，产生一个Bean对象并交给Spring管理，默认bean的名称就是其方法名      // 好处：      // 1. 动态获取一个Bean对象      // 2. 可将非Spring组件交给Spring管理      @Bean      public String helloWorld() {          return new String(&quot;Hello world!&quot;);      }      @Bean      public HelloController helloController() {          return new HelloController();      }  }</code></pre></li><li><p>方式二：<code>@EnableHelloWorld</code> Import <code>ImportSelector implements Class</code> that used to return <code>Configuration Classname</code> (适合需要使用多个Configuration类的情况）</p><pre><code class="lang-java">  @Retention(RetentionPolicy.RUNTIME)  @Target(ElementType.TYPE)  @Documented  @Import(HelloWorldImportSelector.class)  public @interface EnableHelloWorld {  }  public class HelloWorldImportSelector implements ImportSelector {      @Override      public String[] selectImports(AnnotationMetadata importingClassMetadata) {          // 更灵活，例如可在这里加入判断分支          return new String[]{HelloWorldConfiguration.class.getName()};      }  }  // HelloWorldConfiguration 内容同上  public class HelloWorldConfiguration {      // @Bean      // ...  ｝</code></pre></li><li><p>测试使用<code>@EnableHelloWorld</code></p><pre><code class="lang-java">  @EnableHelloWorld  public class HelloWorldSpringEnableApplication {      public static void main(String[] args) {          ConfigurableApplicationContext context = new SpringApplicationBuilder(HelloWorldSpringScanApplication.class)              .web(WebApplicationType.NONE)              .run(args);          HelloController helloController = context.getBean(&quot;helloController&quot;,HelloController.class);          System.out.println(&quot;helloController Bean : &quot;+helloController);              String helloWorld = context.getBean(&quot;helloWorld&quot;,String.class);          System.out.println(&quot;helloWorld Bean : &quot;+helloWorld);              context.close();      }  }  // Result:  // helloController Bean : com.cj.outside.HelloController@12164beb  // helloWorld Bean : Hello world!</code></pre></li></ul></li></ol><h4 id="header-15">条件装配</h4><p>Bean装配时根据前置判断是否装配该Bean</p><ul><li>实现方式：<ul><li>注解方式： 使用<code>@Profile</code> 配置化条件装配（Spring 3.1+）</li><li>编程方式： 使用<code>@Conditional</code> 编程条件装配 （Spring 4.0+）</li></ul></li></ul><ol><li><p><code>@Profile</code> 配置化条件装配（Spring 3.1+）</p><pre><code class="lang-java"> @Profile(&quot;Java7&quot;) @Service public class Java7CalculateService implements CalculateService {     @Override     public Integer sum(Integer... values) {         Integer sum=0;         for(Integer item:values) {             sum+=item;         }         System.out.println(&quot;Java7 sum result:&quot;+sum);         return sum;     } } @Profile(&quot;Java8&quot;) @Service public class Java8CalculateService implements CalculateService {     @Override     public Integer sum(Integer... values) {         Integer sum=Stream.of(values).reduce(0, Integer::sum);         System.out.println(&quot;Java8 sum result:&quot;+sum);         return sum;     } } public interface CalculateService {     public Integer sum(Integer...values); } // Test @ComponentScan(basePackages=&quot;com.cj.autoconfig.service&quot;) public class ProfileApplication {     public static void main(String[] args) {         ConfigurableApplicationContext context = new SpringApplicationBuilder(ProfileApplication.class)             .web(WebApplicationType.NONE)             .profiles(&quot;Java8&quot;)        // switch Profile             .run(args);         CalculateService calculateService = context.getBean(CalculateService.class);         System.out.println(&quot;calculateService Bean : &quot;+calculateService);             calculateService.sum(1,2,3,4,5,6,7,8,9,10);         context.close();     } }</code></pre></li><li><p><code>@Conditional</code> 编程条件装配 （Spring 4.0+）</p><pre><code class="lang-java"> // 自定义一个Annotation @Retention(RetentionPolicy.RUNTIME) @Target({ ElementType.TYPE, ElementType.METHOD }) @Documented @Conditional(SystemPropertyCondition.class) public @interface ConditionalOnSystemProperty {     String name() default &quot;&quot;;     String value() default &quot;&quot;; } // Condition实现类 public class SystemPropertyCondition implements Condition {     @Override     public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {         Map&lt;String, Object&gt; attrs= metadata.getAnnotationAttributes(ConditionalOnSystemProperty.class.getName());         String name=String.valueOf(attrs.get(&quot;name&quot;));         String value=String.valueOf(attrs.get(&quot;value&quot;));         String systemPropertyValue=System.getProperty(name);         System.out.println(&quot;condition--&quot;+value+&quot; vs. &quot;+systemPropertyValue);         return systemPropertyValue.equals(value);     } } // Test public class ConditionApplication {     @Bean     @ConditionalOnSystemProperty(name=&quot;user.name&quot;,value=&quot;jinc&quot;)     public String helloWorld() {         return &quot;Hello world!&quot;;     }     public static void main(String[] args) {         ConfigurableApplicationContext context = new SpringApplicationBuilder(ConditionApplication.class)                 .web(WebApplicationType.NONE)                 .run(args);         String helloWorld = context.getBean(&quot;helloWorld&quot;,String.class);             System.out.println(&quot;helloWorld Bean:&quot;+helloWorld);         context.close();     } }</code></pre></li></ol><h4 id="header-16">工厂加载机制</h4><p>使用<code>SpringFactoriesLoader</code> ：</p><pre><code class="lang-java">public abstract class SpringFactoriesLoader {    public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;    public static &lt;T&gt; List&lt;T&gt; loadFactories(Class&lt;T&gt; factoryClass, @Nullable ClassLoader classLoader) {        ClassLoader classLoaderToUse = classLoader!=null? classLoader:SpringFactoriesLoader.class.getClassLoader();        List&lt;String&gt; factoryNames = loadFactoryNames(factoryClass, classLoaderToUse);        List&lt;T&gt; result = new ArrayList&lt;&gt;(factoryNames.size());        for (String factoryName : factoryNames) {            result.add(instantiateFactory(factoryName, factoryClass, classLoaderToUse));        }        AnnotationAwareOrderComparator.sort(result);        return result;    }}</code></pre><ul><li>方法：<ul><li><code>SpringFactoriesLoader#loadFactoryNames</code> ： 读取配置文件获取要装载的类名</li><li><code>SpringFactoriesLoader#loadFactories</code> ： 按顺序装载配置的类的实例 </li></ul></li><li>配置：<code>META-INF/spring.factories</code></li><li>排序：<code>AnnotationAwareOrderComparator#sort</code> （要装载的类可通过注解<code>@Order</code>或<code>implements Ordered</code>来配置顺序）</li><li>使用示例：<code>SpringApplication#getSpringFactoriesInstances</code></li></ul><h3 id="header-17">SpringBoot自动装配</h3><p>依赖Spring装配技术，基于约定大于配置的原则，实现自动装配</p><ol><li><p>实现步骤：</p><ul><li>实现装配配置类 <code>XxxAutoConfiguration</code><pre><code class="lang-java">  @Configuration  public class XxxxConfiguration {      //@Bean      // ...  }</code></pre></li><li>配置 <code>META-INF/spring.factories</code>到resources下    <pre><code>  # Auto Configure  org.springframework.boot.autoconfigure.EnableAutoConfiguration=\  xxx.xxx....xxx.XxxAutoConfiguration,\  #...</code></pre></li><li>激活自动装配 <code>@EnableAutoConfiguration</code><pre><code class="lang-java">  @SpringBootApplication     // @SpringBootApplication中使用了@EnableAutoConfiguration，会激活自动装配  public class App {      SpringApplication.run(App.class, args)  }</code></pre></li></ul></li><li><p>源码分析：SpringBoot自动装配WebMvc模块</p><ul><li><p><code>@EnableAutoConfiguration</code>: Spring<code>@Enable模块</code>装配技术</p><pre><code class="lang-java">  @Target(ElementType.TYPE)  @Retention(RetentionPolicy.RUNTIME)  @Documented  @Inherited  @AutoConfigurationPackage  @Import(AutoConfigurationImportSelector.class)    //  import: interface ImportSelector 实现类，用于获取Configuration类名   public @interface EnableAutoConfiguration {      String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;      Class&lt;?&gt;[] exclude() default {};      String[] excludeName() default {};  }  public class AutoConfigurationImportSelector          implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware,          BeanFactoryAware, EnvironmentAware, Ordered {      //...      @Override      public String[] selectImports(AnnotationMetadata annotationMetadata) {          if (!isEnabled(annotationMetadata)) {              return NO_IMPORTS;          }          AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader                                                  .loadMetadata(this.beanClassLoader);          AnnotationAttributes attributes = getAttributes(annotationMetadata);          List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,attributes);              =&gt;{                  List&lt;String&gt; configurations = SpringFactoriesLoader                          .loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());                              // 使用Spring工厂加载机制（读取配置文件`META-INF/spring.factories`）获取Configuration类名                  Assert.notEmpty(configurations,                          &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;                          + &quot;are using a custom packaging, make sure that file is correct.&quot;);                  return configurations;              }          // remove duplicates,remove exclusions,filter,fire imported events of exclusions          //..          return StringUtils.toStringArray(configurations);      }      }  // =&gt; `SpringFactoriesLoader` :   public abstract class SpringFactoriesLoader {      public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;      public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) {          String factoryClassName = factoryClass.getName();          return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());      }      //...  }  // =&gt; `META-INF/spring.factories` (jar: spring-boot-autoconfigure): 配置装载了`WebMvcAutoConfiguration`配置类  # Auto Configure  org.springframework.boot.autoconfigure.EnableAutoConfiguration=\  org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\  org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\  org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\  org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\  #...</code></pre></li><li><code>WebMvcAutoConfiguration</code>：负责WebMvc相关Bean装配的Configure类 <pre><code class="lang-java">  @Configuration                            // 使用了Spring模式装配  @ConditionalOnWebApplication            // 使用了Spring 条件装配  @ConditionalOnClass({ Servlet.class, DispatcherServlet.class,WebMvcConfigurerAdapter.class })  @ConditionalOnMissingBean(WebMvcConfigurationSupport.class)  @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)  @AutoConfigureAfter(DispatcherServletAutoConfiguration.class)  public class WebMvcAutoConfiguration {      //@Bean  }</code></pre></li><li><p><code>@SpringBootApplication</code>中使用了<code>@EnableAutoConfiguration</code>,使用<code>@SpringBootApplication</code>就会激活使用自动装配这个功能模块</p><pre><code class="lang-Java">  @Target(ElementType.TYPE)  @Retention(RetentionPolicy.RUNTIME)  @Documented  @Inherited  @SpringBootConfiguration  @EnableAutoConfiguration            // 使用了自动装配模块  @ComponentScan(excludeFilters = {          @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),          @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })  public @interface SpringBootApplication {      @AliasFor(annotation = EnableAutoConfiguration.class)      Class&lt;?&gt;[] exclude() default {};      @AliasFor(annotation = EnableAutoConfiguration.class)      String[] excludeName() default {};      @AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;)      String[] scanBasePackages() default {};      @AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackageClasses&quot;)      Class&lt;?&gt;[] scanBasePackageClasses() default {};  }</code></pre></li></ul></li><li><p>示例：自定义一个配置类，实现自动装配</p><ol><li><p>自定义一个配置类 <code>HelloWorldAutoConfiguration</code></p><ul><li>方式一：<pre><code class="lang-java">  @Configuration  @ConditionalOnSystemProperty(name=&quot;user.name&quot;,value=&quot;jinc&quot;)  public class HelloWorldAutoConfiguration {      @Bean      public String helloWorld() {          System.out.println(&quot;new bean:helloWrold&quot;);          return new String(&quot;Hello world!&quot;);      }      @Bean      public HelloController helloController() {          System.out.println(&quot;new bean:helloController&quot;);          return new HelloController();      }  }</code></pre></li><li><p>方式二：使用了Spring的<code>@Enable模块</code>装配技术</p><pre><code class="lang-java">  @Configuration  @EnableHelloWorld                                            // Spring @Enable模块装配  @ConditionalOnSystemProperty(name=&quot;user.name&quot;,value=&quot;jinc&quot;)  public class HelloWorldAutoConfiguration {  }  @Retention(RetentionPolicy.RUNTIME)  @Target(ElementType.TYPE)  @Documented  @Import(HelloWorldConfiguration.class)  public @interface EnableHelloWorld {  }  public class HelloWorldImportSelector implements ImportSelector {      @Override      public String[] selectImports(AnnotationMetadata importingClassMetadata) {          System.out.println(&quot;HelloWorld--selectImports&quot;);          return new String[] {HelloWorldConfiguration.class.getName()};      }  }  public class HelloWorldConfiguration {      @Bean      public String helloWorld() {          System.out.println(&quot;new bean:helloWrold&quot;);          return new String(&quot;Hello world!&quot;);      }      @Bean      public HelloController helloController() {          System.out.println(&quot;new bean:helloController&quot;);          return new HelloController();      }  }</code></pre></li></ul></li><li>在<code>resources/META-INF/spring.factories</code>中配置自定义的AutoConfiguration类<pre><code class="lang-properties"> org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ com.cj.autoconfig.auto.HelloWorldAutoConfiguration</code></pre></li><li><p>激活自动装配，并测试</p><pre><code class="lang-java"> @EnableAutoConfiguration                // 激活自动装配 或使用@SpringBootApplication也可 public class HelloWorldAutoApplication {     public static void main(String[] args) {         ConfigurableApplicationContext context = new SpringApplicationBuilder(HelloWorldAutoApplication.class)             .web(WebApplicationType.NONE)             .run(args);         HelloController helloController = context.getBean(&quot;helloController&quot;,HelloController.class);         System.out.println(&quot;helloController Bean : &quot;+helloController);             String helloWorld = context.getBean(&quot;helloWorld&quot;,String.class);         System.out.println(&quot;helloWorld Bean : &quot;+helloWorld);             context.close();     } }</code></pre></li></ol></li></ol><h2 id="header-18">SpringApplication</h2><p><code>SpringApplication</code> : SpringBoot启动运行 (jar:<code>spring-boot</code>)</p><h3 id="header-19">使用</h3><ol><li><p><code>SpringApplication.run</code></p><pre><code class="lang-java"> ConfigurableApplicationContext ctx=SpringApplication.run(ApplicationConfiguration.class, args);</code></pre></li><li><p><code>new SpringApplication</code></p><pre><code class="lang-java"> //SpringApplication app = new SpringApplication(ApplicationConfiguration.class); SpringApplication app = new SpringApplication(); Set&lt;String&gt; sources = new HashSet&lt;String&gt;(); sources.add(ApplicationConfiguration.class.getName()); app.setSources(sources); app.setWebApplicationType(WebApplicationType.NONE); app.setAdditionalProfiles(&quot;Java8&quot;); ConfigurableApplicationContext context=app.run(args);</code></pre></li><li><p><code>new SpringApplicationBuilder</code></p><pre><code class="lang-java"> ConfigurableApplicationContext context = new SpringApplicationBuilder(ApplicationConfiguration.class)                 .web(WebApplicationType.NONE)    // NONE,SERVLET,REACTIVE                 .profiles(&quot;Java8&quot;)                 .run(args);</code></pre></li></ol><p><strong> 示例：</strong></p><ol><li><p>最简式：</p><pre><code class="lang-java"> @SpringBootApplication public class DemoSpringApplication {     public static void main(String[] args) {         SpringApplication.run(DemoSpringApplication.class,args)     } }</code></pre></li><li><p>可配置式：</p><pre><code class="lang-java"> public class DemoSpringApplication {     public static void main(String[] args) {         // 1 //        ConfigurableApplicationContext context=SpringApplication.run(ApplicationConfiguration.class, args);         // 2 //        //SpringApplication app = new SpringApplication(ApplicationConfiguration.class); //        SpringApplication app = new SpringApplication(); //        Set&lt;String&gt; sources = new HashSet&lt;String&gt;(); //        sources.add(ApplicationConfiguration.class.getName()); //        app.setSources(sources); //        app.setWebApplicationType(WebApplicationType.NONE); //        app.setAdditionalProfiles(&quot;Java8&quot;); //        ConfigurableApplicationContext context=app.run(args);         // 3         ConfigurableApplicationContext context = new SpringApplicationBuilder(ApplicationConfiguration.class)                 .web(WebApplicationType.NONE)    // NONE,SERVLET,REACTIVE                 .profiles(&quot;Java8&quot;)                 .run(args);         /*          - WebApplicationType.NONE:             + ConfigurableApplicationContext: AnnotationConfigApplicationContext              + Environment: StandardEnvironment          - WebApplicationType.SERVLET:             + ConfigurableApplicationContext: AnnotationConfigServletWebServerApplicationContext             + Environment: StandardServletEnvironment          - WebApplicationType.REACTIVE:             + ConfigurableApplicationContext: AnnotationConfigReactiveWebServerApplicationContext             + Environment: StandardEnvironment         */         System.out.println(&quot;ConfigurableApplicationContext 类型：&quot; + context.getClass().getName());             System.out.println(&quot;Environment 类型：&quot; + context.getEnvironment().getClass().getName());         CalculateService calculateService = context.getBean(CalculateService.class);         System.out.println(&quot;calculateService Bean : &quot;+calculateService);             calculateService.sum(1,2,3,4,5,6,7,8,9,10);         context.close();     }     @SpringBootApplication     public static class ApplicationConfiguration {     } }</code></pre></li></ol><h3 id="header-20">启动过程</h3><ol><li><p>准备阶段（构造函数）</p><ul><li>1.1 推断<code>WebApplicationType</code>：根据当前应用ClassPath 中是否存在相关实现类来推断WebApplication的类型<ul><li><code>WebApplicationType.REACTIVE</code>: Web Reactive</li><li><code>WebApplicationType.SERVLET</code>: Web Servlet</li><li><code>WebApplicationType.NONE</code>: 非Web</li></ul></li><li>1.2 加载<code>ApplicationContextInitializer</code>上下文初始器: 利用 Spring 工厂加载机制，实现类实例化，并排序对象集合</li><li>1.3 加载<code>ApplicationListener</code> 事件监听器: 利用 Spring 工厂加载机制，实现类实例化，并排序对象集合</li><li>1.4 推断引导类（<code>Main Class</code>）: 根据 Main 线程执行堆栈判断实际的引导类</li></ul></li><li><p>运行阶段 （run函数）</p><ul><li>2.1 加载并运行<code>SpringApplicationRunListeners</code>运行监听器，监听SpringBoot／Spring事件</li><li>2.2 创建 <code>Environment</code>： 根据准备阶段推断的<code>WebApplicationType</code>创建对应的<code>ConfigurableEnvironment</code>实例<ul><li>Web Reactive： <code>StandardEnvironment</code></li><li>Web Servlet： <code>StandardServletEnvironment</code></li><li>非 Web： <code>StandardEnvironment</code></li></ul></li><li>2.3 创建Spring应用上下文：根据准备阶段推断的<code>WebApplicationType</code>创建对应的<code>ConfigurableApplicationContext</code>实例<ul><li>Web Reactive： <code>AnnotationConfigReactiveWebServerApplicationContext</code></li><li>Web Servlet： <code>AnnotationConfigServletWebServerApplicationContext</code></li><li>非 Web： <code>AnnotationConfigApplicationContext</code></li></ul></li><li>2.4 加载<code>SpringBootExceptionReporter</code>故障分析报告（利用 Spring 工厂加载机制），供以后失败时使用</li><li>2.5 加载Bean到应用上下文：加载Annotation/XML配置的Bean给Spring管理</li></ul></li></ol><h3 id="header-21">源码分析</h3><ol><li><p>constructor:</p><ul><li><code>WebApplicationType</code> Web应用类型<ul><li>WebApplicationType.REACTIVE</li><li>WebApplicationType.SERVLET</li><li>WebApplicationType.NONE</li></ul></li><li><code>ApplicationContextInitializer</code> 上下文初始器<pre><code class="lang-java">  public interface ApplicationContextInitializer&lt;C extends ConfigurableApplicationContext&gt; {      /**       * Initialize the given application context.       * @param applicationContext the application to configure       */      void initialize(C applicationContext);  }</code></pre></li><li><code>ApplicationListener</code> 事件监听器<pre><code class="lang-java">  @FunctionalInterface  public interface ApplicationListener&lt;E extends ApplicationEvent&gt;       extends EventListener {      /**       * Handle an application event.       * @param event the event to respond to       */      void onApplicationEvent(E event);  }</code></pre></li><li><code>Main Class</code></li></ul></li><li><p>run:</p><ul><li><code>SpringApplicationRunListener</code> 运行监听器<pre><code class="lang-java">  public interface SpringApplicationRunListener {      void starting();      void environmentPrepared(ConfigurableEnvironment environment);      void contextPrepared(ConfigurableApplicationContext context);      void contextLoaded(ConfigurableApplicationContext context);      void started(ConfigurableApplicationContext context);      void running(ConfigurableApplicationContext context);      void failed(ConfigurableApplicationContext context, Throwable exception);  }</code></pre><ul><li>eg: SpringBoot实现类<code>EventPublishingRunListener</code> (order:0)<table class="table"><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">说明</th><th style="text-align:left">实现</th></tr></thead><tbody><tr><td style="text-align:left">0. EventPublishingRunListener(application,args)</td><td style="text-align:left">构造方法</td><td style="text-align:left">application.getListeners() -&gt; SimpleApplicationEventMulticaster#addApplicationListener 所以此Listener下面广播的Event会被SpringApplication的ApplicationListener监听到</td></tr><tr><td style="text-align:left">1. starting()</td><td style="text-align:left">应用开始启动</td><td style="text-align:left">广播 ApplicationStartingEvent</td></tr><tr><td style="text-align:left">2. environmentPrepared(env)</td><td style="text-align:left">Environment准备好了（允许将其调整了）</td><td style="text-align:left">广播 ApplicationEnvironmentPreparedEvent</td></tr><tr><td style="text-align:left">3. contextPrepared(ctx)</td><td style="text-align:left">ApplicationContext准备好了（允许将其调整了）</td><td style="text-align:left">／</td></tr><tr><td style="text-align:left">4. contextLoaded(ctx)</td><td style="text-align:left">ApplicationContext装载好了（但仍未启动）</td><td style="text-align:left">广播 ApplicationPreparedEvent</td></tr><tr><td style="text-align:left">5. started(ctx)</td><td style="text-align:left">ApplicationContext已刷新，应用启动完成（此时 Spring Bean 已完成初始化）</td><td style="text-align:left">广播 ApplicationStartedEvent</td></tr><tr><td style="text-align:left">6. running(ctx)</td><td style="text-align:left">应用开始运行</td><td style="text-align:left">广播 ApplicationReadyEvent</td></tr><tr><td style="text-align:left">7. failed(ctx,Throwable)</td><td style="text-align:left">应用运行失败</td><td style="text-align:left">广播 ApplicationFailedEvent</td></tr></tbody></table></li></ul></li><li><code>listeners.starting()</code></li><li><code>ConfigurableEnvironment</code> 环境对象<ul><li>StandardEnvironment (for REACTIVE,NONE)</li><li>StandardServletEnvironment (for SERVLET)</li><li><code>listeners.environmentPrepared(environment)</code></li></ul></li><li><code>ConfigurableApplicationContext</code> 应用上下文<ul><li>AnnotationConfigReactiveWebServerApplicationContext (for REACTIVE)</li><li>AnnotationConfigServletWebServerApplicationContext (for SERVLET)</li><li>AnnotationConfigServletWebServerApplicationContext (for NONE)</li></ul></li><li><code>SpringBootExceptionReporter</code> 故障分析报告<pre><code class="lang-java">  @FunctionalInterface  public interface SpringBootExceptionReporter {          boolean reportException(Throwable failure);  }</code></pre></li><li>prepare context<ul><li>context.setEnvironment(environment)</li><li>applyInitializers(context): <code>ApplicationContextInitializer#initialize</code></li><li><code>listeners.contextPrepared(context);</code></li><li>load sources</li><li><code>listeners.contextLoaded(context);</code></li></ul></li><li>refresh context<ul><li><code>AbstractApplicationContext#refresh</code></li></ul></li><li><code>listeners.started(context)</code>;</li><li><code>listeners.running(context)</code>;</li></ul></li><li><p>总结 key：</p><ul><li><code>WebApplicationType.NONE/SERVLET/REACTIVE</code></li><li><code>ApplicationContextInitializer#initialize(ctx)</code></li><li><code>ApplicationListener#onApplicationEvent(event)</code></li><li>mainClass</li><li><code>SpringApplicationRunListener#starting,environmentPrepared,contextPrepared,contextLoaded,started,running,failed</code> (eg: <code>EventPublishingRunListener</code>)</li><li><code>ConfigurableEnvironment</code> (StandardEnvironment,StandardServletEnvironment)</li><li><code>ConfigurableApplicationContext</code> (AnnotationConfigServletWebServerApplicationContext,AnnotationConfigReactiveWebServerApplicationContext)</li><li><code>SpringBootExceptionReporter#reportException</code></li><li>context: setEnvironment,applyInitializers(trigger <code>ApplicationContextInitializer#initialize</code>),loadSources, refresh</li></ul></li></ol><p><strong> 源码：</strong></p><pre><code class="lang-java">package org.springframework.boot;public class SpringApplication {    // 1. 构造函数（准备阶段）    public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) {        this.resourceLoader = resourceLoader;        Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);        this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));        // 1.1 根据当前应用ClassPath中是否存在相关实现类来推断WebApplication的类型        this.webApplicationType = deduceWebApplicationType();        ＝&gt;{            if (ClassUtils.isPresent(REACTIVE_WEB_ENVIRONMENT_CLASS, null)                &amp;&amp; !ClassUtils.isPresent(MVC_WEB_ENVIRONMENT_CLASS, null)) {                return WebApplicationType.REACTIVE;            }            for (String className : WEB_ENVIRONMENT_CLASSES) {                if (!ClassUtils.isPresent(className, null)) {                    return WebApplicationType.NONE;                }            }            return WebApplicationType.SERVLET;        }        // 1.2 加载`ApplicationContextInitializer`上下文初始器(利用 Spring 工厂加载机制)        setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));        =&gt;{            getSpringFactoriesInstances(ApplicationContextInitializer.class);            // META-INF/spring.factories (jar:spring-boot-autoconfigure):            # Initializers            org.springframework.context.ApplicationContextInitializer=\            org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\            org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener            // META-INF/spring.factories (jar:spring-boot):            # Application Context Initializers            org.springframework.context.ApplicationContextInitializer=\            org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\            org.springframework.boot.context.ContextIdApplicationContextInitializer,\            org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\            org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer        }        // 1.3 加载`ApplicationListener` 事件监听器 (利用 Spring 工厂加载机制)        setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));        =&gt;{            getSpringFactoriesInstances(ApplicationListener.class);            // META-INF/spring.factories (jar:spring-boot-autoconfigure):            # Application Listeners            org.springframework.context.ApplicationListener=\            org.springframework.boot.autoconfigure.BackgroundPreinitializer            // META-INF/spring.factories (jar:spring-boot-autoconfigure):            # Application Listeners            org.springframework.context.ApplicationListener=\            org.springframework.boot.ClearCachesApplicationListener,\            org.springframework.boot.builder.ParentContextCloserApplicationListener,\            org.springframework.boot.context.FileEncodingApplicationListener,\            org.springframework.boot.context.config.AnsiOutputApplicationListener,\            org.springframework.boot.context.config.ConfigFileApplicationListener,\            org.springframework.boot.context.config.DelegatingApplicationListener,\            org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\            org.springframework.boot.context.logging.LoggingApplicationListener,\            org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener        }        // 1.4 推断引导类（Main Class）: 根据 Main 线程执行堆栈判断实际的引导类        this.mainApplicationClass = deduceMainApplicationClass();        =&gt;{            try {                StackTraceElement[] stackTrace = new RuntimeException().getStackTrace();                for (StackTraceElement stackTraceElement : stackTrace) {                    if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) {                        return Class.forName(stackTraceElement.getClassName());                    }                }            }            catch (ClassNotFoundException ex) {                // Swallow and continue            }            return null;        }    }    // 2. run函数（运行阶段）    public ConfigurableApplicationContext run(String... args) {        StopWatch stopWatch = new StopWatch();        stopWatch.start();        ConfigurableApplicationContext context = null;        Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();        configureHeadlessProperty();        // 2.1 加载运行`SpringApplicationRunListeners`运行监听器（利用 Spring 工厂加载机制）        SpringApplicationRunListeners listeners = getRunListeners(args);        =&gt;{            Class&lt;?&gt;[] types = new Class&lt;?&gt;[] { SpringApplication.class, String[].class };            return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances(                    SpringApplicationRunListener.class, types, this, args));            // META-INF/spring.factories (jar:spring-boot):            # Run Listeners            org.springframework.boot.SpringApplicationRunListener=\            org.springframework.boot.context.event.EventPublishingRunListener        }        listeners.starting();    // Trigger: SpringApplicationRunListener#starting        try {            ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);            // 2.2 创建`Environment`: 根据准备阶段(构造函数中)推断的`WebApplicationType`，创建对应的`ConfigurableEnvironment`实例            ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments);            =&gt;{                // Create and configure the environment                ConfigurableEnvironment environment = getOrCreateEnvironment();                configureEnvironment(environment, applicationArguments.getSourceArgs());                listeners.environmentPrepared(environment);     // Trigger: SpringApplicationRunListener#environmentPrepared                bindToSpringApplication(environment);                if (this.webApplicationType == WebApplicationType.NONE) {                    environment = new EnvironmentConverter(getClassLoader())                            .convertToStandardEnvironmentIfNecessary(environment);                }                ConfigurationPropertySources.attach(environment);                return environment;            }            configureIgnoreBeanInfo(environment);            Banner printedBanner = printBanner(environment);            // 2.3 创建Spring应用上下文：根据准备阶段推断的`WebApplicationType`创建对应的`ConfigurableApplicationContext`实例            context = createApplicationContext();            =&gt;{                Class&lt;?&gt; contextClass = this.applicationContextClass;                if (contextClass == null) {                    try {                        switch (this.webApplicationType) {                        case SERVLET:                            contextClass = Class.forName(DEFAULT_WEB_CONTEXT_CLASS);                            break;                        case REACTIVE:                            contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);                            break;                        default:                            contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);                        }                    }                    catch (ClassNotFoundException ex) {                        throw new IllegalStateException(                                &quot;Unable create a default ApplicationContext, &quot;                                + &quot;please specify an ApplicationContextClass&quot;,                                ex);                    }                }                return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);            }            // 2.4 加载`SpringBootExceptionReporter`故障分析报告（利用 Spring 工厂加载机制），供以后失败时使用            exceptionReporters = getSpringFactoriesInstances(                    SpringBootExceptionReporter.class,                    new Class[] { ConfigurableApplicationContext.class }, context);            =&gt;{                // META-INF/spring.factories (jar:spring-boot):                # Error Reporters                org.springframework.boot.SpringBootExceptionReporter=\                org.springframework.boot.diagnostics.FailureAnalyzers            }            // 2.5 加载Bean到应用上下文：加载Annotation/XML配置的Bean给Spring管理            prepareContext(context, environment, listeners, applicationArguments,printedBanner);            =&gt;{                context.setEnvironment(environment);                postProcessApplicationContext(context);                    applyInitializers(context);                // Trigger: ApplicationContextInitializer#initialize                listeners.contextPrepared(context);        // Trigger: SpringApplicationRunListener#contextPrepared                // Add boot specific singleton beans                context.getBeanFactory().registerSingleton(&quot;springApplicationArguments&quot;,applicationArguments);                if (printedBanner != null) {                    context.getBeanFactory().registerSingleton(&quot;springBootBanner&quot;, printedBanner);                }                // Load the sources                Set&lt;Object&gt; sources = getAllSources();                Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);                load(context, sources.toArray(new Object[0]));                listeners.contextLoaded(context);        // Trigger: SpringApplicationRunListener#contextLoaded            }            refreshContext(context);            =&gt;{                ((AbstractApplicationContext) applicationContext).refresh();    //Trigger: AbstractApplicationContext#refresh            }            afterRefresh(context, applicationArguments);            stopWatch.stop();            if (this.logStartupInfo) {                new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);            }            listeners.started(context);                                      // Trigger: SpringApplicationRunListener#started            callRunners(context, applicationArguments);        }        catch (Throwable ex) {            handleRunFailure(context, ex, exceptionReporters, listeners); // Trigger: SpringApplicationRunListener#failed            throw new IllegalStateException(ex);        }        try {            listeners.running(context);                                     // Trigger: SpringApplicationRunListener#running        }        catch (Throwable ex) {            handleRunFailure(context, ex, exceptionReporters, null);     // Trigger: SpringApplicationRunListener#failed            throw new IllegalStateException(ex);        }        return context;    }}</code></pre><h3 id="header-22">使用扩展</h3><ul><li><p>利用Spring工厂加载机制，按指定顺序装载自定义的扩展类</p></li><li><p>示例1: 装载自定义的<code>ApplicationInitializer</code></p><ol><li><p>自定义 <code>ApplicationInitializer</code></p><pre><code class="lang-java"> @Order(Ordered.HIGHEST_PRECEDENCE+10) public class HelloApplicationInitializer&lt;C extends ConfigurableApplicationContext&gt;      implements ApplicationContextInitializer&lt;C&gt; {     @Override     public void initialize(C applicationContext) {         System.out.println(&quot;Hello: ApplicationContext id=&quot;+applicationContext.getId());     } } public class WorldApplicationInitializer&lt;C extends ConfigurableApplicationContext&gt;      implements ApplicationContextInitializer&lt;C&gt;,Ordered {     @Override     public void initialize(C applicationContext) {         System.out.println(&quot;World: ApplicationContext id=&quot;+applicationContext.getId());     }     @Override     public int getOrder() {         return Ordered.HIGHEST_PRECEDENCE+10-1;     } }</code></pre></li><li><p>配置<code>META-INF/spring.factories</code></p><pre><code> # ApplicationContextInitializer org.springframework.context.ApplicationContextInitializer=\ com.cj.application.initializer.HelloApplicationInitializer,\ com.cj.application.initializer.WorldApplicationInitializer</code></pre></li><li><p>测试</p><pre><code class="lang-java"> public class DemoSpringApplication {     public static void main(String[] args) {         SpringApplication.run(DemoSpringApplication.class, args);     } } /* Result: World: ApplicationContext id=org.springframework.context.annotation.AnnotationConfigApplicationContext@69b794e2 Hello: ApplicationContext id=org.springframework.context.annotation.AnnotationConfigApplicationContext@69b794e2 */</code></pre></li></ol></li><li><p>示例2: 装载自定义的<code>ApplicationListener</code></p><ol><li><p>自定义 <code>ApplicationListener</code></p><pre><code class="lang-java"> // HelloApplicationListener -- 监听所有ApplicationEvent @Order(Ordered.HIGHEST_PRECEDENCE+20) public class HelloApplicationListener&lt;C extends ApplicationEvent&gt; implements ApplicationListener&lt;C&gt;{     @Override     public void onApplicationEvent(C event) {         System.out.println(&quot;Hello ApplicationEvent: &quot;+event.getClass().getSimpleName());     } } // WorldApplicationListener -- 监听 ContextRefreshedEvent public class WorldApplicationListener implements ApplicationListener&lt;ContextRefreshedEvent&gt;,Ordered{     @Override     public void onApplicationEvent(ContextRefreshedEvent event) {         System.out.println(&quot;World ApplicationEvent: &quot;+event.getClass().getSimpleName());     }     @Override     public int getOrder() {         return Ordered.HIGHEST_PRECEDENCE+30;     } } // MySmartApplicationListener -- 监听所有ApplicationEvent，处理ApplicationEnvironmentPreparedEvent public class MySmartApplicationListener implements SmartApplicationListener{     @Override     public void onApplicationEvent(ApplicationEvent event) {         System.out.println(&quot;MySmart ApplicationEvent: &quot;+ event.getClass().getSimpleName());         if (event instanceof ApplicationEnvironmentPreparedEvent) {             ApplicationEnvironmentPreparedEvent preparedEvent = (ApplicationEnvironmentPreparedEvent) event;             Environment environment = preparedEvent.getEnvironment();             System.out.println(&quot;environment: &quot; + environment);         }     }     @Override     public boolean supportsEventType(Class&lt;? extends ApplicationEvent&gt; eventType) {         return ApplicationEnvironmentPreparedEvent.class.isAssignableFrom(eventType)                 || ContextRefreshedEvent.class.isAssignableFrom(eventType);     }     @Override     public boolean supportsSourceType(Class&lt;?&gt; sourceType) {         return true;     }     @Override     public int getOrder() {         return Ordered.HIGHEST_PRECEDENCE+25;     } }</code></pre></li><li>配置<code>META-INF/spring.factories</code><pre><code class="lang-java"> # ApplicationListener # Listener处理顺序（根据Order排序）：Hello -&gt; MySmart -&gt; World org.springframework.context.ApplicationListener=\ com.cj.application.listener.HelloApplicationListener,\ com.cj.application.listener.WorldApplicationListener,\ com.cj.application.listener.MySmartApplicationListener</code></pre></li><li><p>测试</p><pre><code class="lang-java"> public class DemoSpringApplication {     public static void main(String[] args) {         SpringApplication.run(DemoSpringApplication.class, args);     } } /* Hello ApplicationEvent: ApplicationStartingEvent Hello ApplicationEvent: ApplicationEnvironmentPreparedEvent MySmart ApplicationEvent: ApplicationEnvironmentPreparedEvent environment: StandardEnvironment {activeProfiles=[Java8], defaultProfiles=[default], propertySources=[MapPropertySource {name=&#39;systemProperties&#39;}, OriginAwareSystemEnvironmentPropertySource {name=&#39;systemEnvironment&#39;}, RandomValuePropertySource {name=&#39;random&#39;}]} World: ApplicationContext id=org.springframework.context.annotation.AnnotationConfigApplicationContext@15d9bc04 Hello: ApplicationContext id=org.springframework.context.annotation.AnnotationConfigApplicationContext@15d9bc04 Hello ApplicationEvent: ApplicationPreparedEvent Hello ApplicationEvent: ContextRefreshedEvent MySmart ApplicationEvent: ContextRefreshedEvent World ApplicationEvent: ContextRefreshedEvent Hello ApplicationEvent: ApplicationStartedEvent Hello ApplicationEvent: ApplicationReadyEvent Hello ApplicationEvent: ContextClosedEvent */</code></pre></li></ol></li></ul><h3 id="header-23">Spring事件监听模型</h3><ul><li>事件(Event): <code>ApplicationEvent</code>,<code>ApplicationContextEvent</code></li><li>监听器(Listener): <code>ApplicationListener</code>,<code>@EventListener</code></li><li>广播器(Multicaster): <code>ApplicationEventMulticaster</code> (执行模式:同步或异步)</li><li><p>示例：<code>ApplicationContext</code>注册<code>Listener</code> &amp; 发送<code>Event</code></p><pre><code class="lang-java">  public class DemoSpringApplicationEvent {       public static void main(String[] args) {          // 创建上下文          AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();          // 注册应用事件监听器          context.addApplicationListener(event -&gt; {              if(event instanceof PayloadApplicationEvent){                  PayloadApplicationEvent payloadEvent=(PayloadApplicationEvent)event;                  System.out.println(&quot;监听到Payload事件: &quot; + payloadEvent.getPayload());              }else                  System.out.println(&quot;监听到事件: &quot; + event.getClass().getSimpleName()                      +&quot;[source=&quot;+event.getSource()+&quot;]&quot;);          });          // 启动上下文          context.refresh();          // 发送事件          context.publishEvent(&quot;HelloWorld&quot;);          context.publishEvent(new ApplicationEvent(&quot;Outside&quot;) {});          // 关闭上下文          context.close();      }  }  /*  监听到事件: ContextRefreshedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@50cbc42f: startup date [Feb Oct 09 02:03:32 CST 2018]; root of context hierarchy]  监听到Payload事件: HelloWorld  监听到事件: [source=Outside]  监听到事件: ContextClosedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@50cbc42f: startup date [Sun Feb 09 02:03:32 CST 2018]; root of context hierarchy]  */</code></pre></li></ul><h2 id="header-24">外部化配置</h2><p>Refer <a href="https://docs.spring.io/spring-boot/docs/2.0.2.RELEASE/reference/htmlsingle/#boot-features-external-config" target="_blank" rel="noopener">SpringBoot Doc</a></p><blockquote><p>Spring Boot allows you to externalize your configuration so you can work with the same application code in different environments. You can use properties files, YAML files, environment variables and command-line arguments to externalize configuration.</p></blockquote><p>加载外部配置资源的内容到程序变量中用于动态控制：</p><ol><li><p>外部化配置资源（保存到<code>PropertySource</code>对象）</p><ul><li>常见的加载项顺序：<ul><li><code>@TestPropertySource#properties</code></li><li><code>@SpringBootTest#properties</code></li><li><code>@TestPropertySource#location</code></li><li>cmd line args (eg:<code>-Duser.id=13</code>)</li><li>system properties (eg:<code>-Duser.city.post_code=0731</code>),可通过<code>System.getProperties()</code>获取</li><li>os env variables (eg:<code>USER_CITY_POST_CODE=001</code>)</li><li>application property files/yaml variants (eg:<code>user.city.post-code=0571</code>)<ul><li><code>application-{profile}.properties</code>outside pkg jar</li><li><code>application-{profile}.properties</code> packaged inside jar</li><li><code>application.properties</code> outside pkg jar</li><li><code>application.properties</code> packaged inside jar</li></ul></li><li><code>@PropertySouce</code> on <code>@Configuration</code> class</li><li>default properties</li></ul></li><li>注意：<ul><li>前面的优先级更高（后面同属性的值不会覆盖前面已经加载到的）</li><li>允许松散绑定（特例：<code>@ConditionalOnProperty</code> prefix name 要与 <code>application.properties</code> 完全一致,在环境变量里面,允许松散绑定）</li></ul></li><li><code>PropertySource</code><ul><li>带有名称的外部化配置属性源(eg source : Properties file,YAML file,environment variables, and command-line arguments,Map键值对)</li><li>主要方法：<code>abstract Object getProperty(String name)</code></li><li>与<code>Environment</code>对应关系 <ul><li><code>Environment</code> : <code>PropertySources</code>:<code>PropertySource</code>= 1:1:N</li><li>eg: <code>ConfigurableEnvironment</code> : <code>MutablePropertySources</code>:<code>PropertySource</code> = 1:1:N</li><li>参考<code>SpringApplication#run</code> -&gt; <code>prepareEnvironment</code> -&gt; <code>configureEnvironment</code> -&gt; <code>configurePropertySources</code></li></ul></li><li>查看Environment中加载各个的PropertySource: <code>environment.getPropertySources().forEach</code><pre><code class="lang-java">  MutablePropertySources propertySources=environment.getPropertySources();  propertySources.forEach(item-&gt;{      System.out.printf(&quot;[%s] : %s\n&quot;, item.getName(), item);  });</code></pre></li></ul></li></ul></li><li><p>绑定到变量</p><ul><li>XML方式：<code>&lt;bean&gt;</code> -&gt; <code>&lt;property name=&quot;xxx&quot; value=&quot;${...}&quot; /&gt;</code></li><li>Annotation方式: <code>@Value</code> ,<code>@ConfigurationProperties</code></li></ul></li></ol><h3 id="header-25">加载外部化配置（XML方式）</h3><p>示例：</p><ol><li><p>Spring应用</p><ul><li><p>Key:</p><ul><li>配置装载属性占位符：<code>PropertyPlaceholderConfigurer</code>，装载外部化配置文件</li><li>配置bean：<code>&lt;property name=&quot;xxx&quot; value=&quot;${...}&quot; /&gt;</code>，注意bean需要有get/set方法</li></ul></li><li><p>domain: User</p><pre><code class="lang-java">  public class User{      private Long id;      private String name;      private Integer age;      // get/set function -- must need!  }</code></pre></li><li><p>resouces/spring-context.xml</p><pre><code class="lang-xml">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;      &lt;!-- 属性占位符配置--&gt;      &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;          &lt;!-- Properties 文件 classpath 路径 --&gt;          &lt;property name=&quot;location&quot; value=&quot;classpath:test.properties&quot;/&gt;          &lt;!-- 文件字符编码 --&gt;          &lt;property name=&quot;fileEncoding&quot; value=&quot;UTF-8&quot;/&gt;      &lt;/bean&gt;        &lt;!-- User Bean --&gt;      &lt;bean id=&quot;user&quot; class=&quot;com.cj.demo1.domain.User&quot;&gt;          &lt;property name=&quot;id&quot; value=&quot;${user.id}&quot;/&gt;          &lt;property name=&quot;name&quot; value=&quot;${user.name}&quot;/&gt;      &lt;/bean&gt;  &lt;/beans&gt;</code></pre></li><li><p>resources/test.properties</p><pre><code>  user.id=12  user.name=Tom</code></pre></li><li><p>verify</p><pre><code class="lang-java">  public class SpringPlaceholderApp {       public static void main(String[] args) {          String[] locations = {&quot;spring-context.xml&quot;};          ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(locations);          User user = ctx.getBean(&quot;user&quot;, User.class);          System.err.println(user);    // User{id=12, name=&#39;Tom&#39;, age=null}          ctx.close();      }  }</code></pre></li></ul></li><li><p>SpringBoot应用</p><ul><li>Key：<ul><li>自动装配不需要另外配置装载属性占位符：<code>PropertyPlaceholderConfigurer</code></li><li>配置bean：<code>&lt;property name=&quot;xxx&quot; value=&quot;${...}&quot; /&gt;</code>，注意bean需要有get/set方法</li></ul></li><li><p>domain: User</p><pre><code class="lang-java">  public class User{      private Long id;      private String name;      private Integer age;      // get/set function -- must need!  }</code></pre></li><li><p>resources/bean.xml</p><pre><code class="lang-xml">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;      &lt;!-- User Bean --&gt;      &lt;bean id=&quot;user&quot; class=&quot;com.cj.demo1.domain.User&quot;&gt;          &lt;property name=&quot;id&quot; value=&quot;${user.id}&quot;/&gt;          &lt;property name=&quot;name&quot; value=&quot;${user.name}&quot;/&gt;      &lt;/bean&gt;  &lt;/beans&gt;</code></pre></li><li><p>resources/application.properties</p><pre><code>  user.id=15  user.name=Lucy</code></pre></li><li><p>verify</p><pre><code class="lang-java">  @ImportResource(&quot;bean.xml&quot;) // 加载 XML 文件  @EnableAutoConfiguration  public class SpringBootPlaceholderApp {      public static void main(String[] args) {          ConfigurableApplicationContext ctx =                  new SpringApplicationBuilder(SpringBootPlaceholderApp.class)                          .web(WebApplicationType.NONE) // 非 Web 应用                          .run(args);          User user = ctx.getBean(&quot;user&quot;, User.class);          System.err.println(user);          System.err.printf(&quot;System.getProperty(\&quot;%s\&quot;) : %s \n&quot;, &quot;user.name&quot;, System.getProperty(&quot;user.name&quot;));                      ConfigurableEnvironment environment = ctx.getEnvironment();          environment.getPropertySources().forEach(item-&gt;{              System.out.printf(&quot;[%s] : %s\n&quot;, item.getName(), item);          });                      ctx.close();      }  }  // Note：  // 会发现不是Tom，而是User{id=15, name=&#39;cj&#39;, age=null}  // 因为System Property的优先级高于property file</code></pre></li></ul></li></ol><h3 id="header-26">Annotation方式</h3><ol><li><code>@Value</code></li><li><code>@ConfigurationProperties</code></li><li>扩展：<ul><li><code>@Validated</code> 校验</li><li><code>@ConditionalOnProperty</code> 判断</li></ul></li></ol><h3 id="header-27">源码分析</h3><p>SpringBoot中<code>Environment</code>的生命周期（参考<code>SpringApplication#run</code>）</p><ul><li><p>Key：</p><ul><li>prepareEnvironment:<ul><li>create</li><li>configure: <code>PropertySources</code></li><li>trigger <code>SpringApplicationRunListener#environmentPrepared</code></li><li>convert</li></ul></li><li>prepareContext:<ul><li>setEnvironment</li><li>trigger <code>ApplicationContextInitializer#initialize</code></li><li>trigger <code>SpringApplicationRunListener#contextPrepared</code></li><li>…</li><li>trigger <code>SpringApplicationRunListener#contextLoaded</code></li></ul></li></ul></li><li><p><code>PropertySource</code></p><pre><code class="lang-java">  public abstract class PropertySource&lt;T&gt; {      protected final String name;      protected final T source;      public abstract Object getProperty(String name);      //...  }</code></pre><ul><li>ConfigurationPropertySourcesPropertySource</li><li>AnnotationsPropertySource</li><li>CommandLinePropertySource<t></t></li><li>MapPropertySource</li><li>ServletConfigPropertySource</li><li>ServletContextPropertySource</li><li>…</li></ul></li><li><p><code>SpringApplication#run</code>:</p><pre><code class="lang-java">  // 1. SpringApplicationRunListeners  // 2. ConfigurableEnvironment:   ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments);  =&gt;{      // Create and configure the environment      ConfigurableEnvironment environment = getOrCreateEnvironment();      configureEnvironment(environment, applicationArguments.getSourceArgs());      =&gt;{          // Add, remove or re-order any {@link PropertySource}s in this application&#39;s environment.          configurePropertySources(environment, args);          // setActiveProfiles for this application&#39;s environment.          configureProfiles(environment, args);      }      listeners.environmentPrepared(environment);    // Trigger: SpringApplicationRunListener#environmentPrepared      bindToSpringApplication(environment);      if (this.webApplicationType == WebApplicationType.NONE) {          environment = new EnvironmentConverter(getClassLoader())                  .convertToStandardEnvironmentIfNecessary(environment);      }      ConfigurationPropertySources.attach(environment);      return environment;  }  // 3. ConfigurableApplicationContext  // 4. SpringBootExceptionReporter  // 5. prepare context  prepareContext(context, environment, listeners, applicationArguments,printedBanner);  =&gt;{      context.setEnvironment(environment);      postProcessApplicationContext(context);          applyInitializers(context);                // Trigger: ApplicationContextInitializer#initialize      listeners.contextPrepared(context);        // Trigger: SpringApplicationRunListener#contextPrepared      //...      listeners.contextLoaded(context);        // Trigger: SpringApplicationRunListener#contextLoaded  }  // 6. refresh context</code></pre></li></ul><h3 id="header-28">获取<code>Environment</code></h3><ul><li><p>方法／构造器</p><pre><code class="lang-java">  @Component  public class A{      private Environment environment;      @Autowired      public A(Environment environment){          this.environment = environment;      }  }</code></pre><pre><code class="lang-java">  @Configuration  public class B{      @Bean      @Autowired    // will auto inject Environment,not add this annotation still work.      public String hello(Environment environment){          return environment.getRequiredProperty(&quot;say&quot;, String.class);      }  }</code></pre></li><li><p><code>@Autowired</code></p><pre><code class="lang-java">  @Component  public class A{      @Autowired      private Environment environment;  }</code></pre></li><li><p>implements<code>BeanFactoryAware</code></p><pre><code class="lang-java"> @Component public class A implements BeanFactoryAware {     private Environment environment;     @Override     public void setBeanFactory(BeanFactory beanFactory)          throws BeansException {         this.environment=beanFactory.getBean(Environment.class);     } }</code></pre></li><li><p>implements <code>EnvironmentAware</code></p><pre><code class="lang-java">  @Component  public class A implements EnvironmentAware{      private Environment environment;      @Override      public void setEnvironment(Environment environment) {          this.environment=environment;      }  }</code></pre></li></ul><h3 id="header-29">实时扩展外部化配置属性源</h3><p>实时扩展外部化配置属性源: 基于<code>Environment</code>抽象实现</p><ul><li><code>Environment</code> 可以</li><li><code>@Value</code> 不行</li><li><code>@ConfiguratinProperties</code> 不行</li></ul><ol><li><p>可考虑扩展以下类，并依据Spring工厂加载机制配置装配：</p><ul><li><code>SpringApplicationRunListener#environmentPrepared</code><pre><code class="lang-java">  EventPublishingRunListener#environmentPrepared       -&gt; ApplicationListener#onApplicationEvent : ApplicationEnvironmentPreparedEvent          -&gt; ConfigFileApplicationListener#onApplicationEvent : ApplicationEnvironmentPreparedEvent              -&gt; EnvironmentPostProcessor#postProcessEnvironment : ApplicationEnvironmentPreparedEvent</code></pre><ul><li><code>ApplicationListener#onApplicationEvent</code></li><li><code>EnvironmentPostProcessor#postProcessEnvironment</code></li></ul></li><li><code>ApplicationContextInitializer#initialize</code></li><li><code>SpringApplicationRunListener#contextPrepared</code></li><li><code>SpringApplicationRunListener#contextLoaded</code></li><li>注：根据Environment生命周期，需在refresh context前，且注意触发调用顺序（参考<code>SpringApplication#run</code>）</li></ul></li><li><p>示例</p><ul><li><p>示例1：使用<code>EnvironmentPostProcessor#postProcessEnvironment</code>自定义实现类</p><pre><code class="lang-java">  public class ExtendPropertySourcesEnvironmentPostProcessor implements EnvironmentPostProcessor{      @Override      public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {          System.err.println(&quot;execute ExtendPropertySourcesEnvironmentPostProcessor#postProcessEnvironment: put user.id=60&quot;);          MutablePropertySources propertySources=environment.getPropertySources();          Map&lt;String,Object&gt; source=new HashMap&lt;String,Object&gt;();          source.put(&quot;user.id&quot;,60);          MapPropertySource ps=new MapPropertySource(&quot;from-postProcessEnvironment&quot;, source);          propertySources.addFirst(ps);      }  }  // config: resources/META-INF/spring.factories  # EnvironmentPostProcessor  org.springframework.boot.env.EnvironmentPostProcessor=\  com.cj.demo2.processor.ExtendPropertySourcesEnvironmentPostProcessor</code></pre></li><li><p>示例2：使用<code>ApplicationListener#onApplicationEvent</code>自定义实现类</p><pre><code class="lang-java">  // after `ConfigFileApplicationListener`  public class ExtendPropertySourcesApplicationListener implements ApplicationListener&lt;ApplicationEnvironmentPreparedEvent&gt; {      @Override      public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) {          System.err.println(&quot;execute ExtendPropertySourcesApplicationListener#onApplicationEvent(ApplicationEnvironmentPreparedEvent): put user.id=55&quot;);          MutablePropertySources propertySources=event.getEnvironment().getPropertySources();          Map&lt;String,Object&gt; source=new HashMap&lt;String,Object&gt;();          source.put(&quot;user.id&quot;,55);          MapPropertySource ps=new MapPropertySource(&quot;from-applicationEnvironmentPreparedEvent&quot;, source);          propertySources.addFirst(ps);      }  }  // config: resources/META-INF/spring.factories  # Application Listeners  org.springframework.context.ApplicationListener=\  com.cj.demo2.listener.ExtendPropertySourcesApplicationListener</code></pre></li><li><p>示例3：使用<code>SpringApplicationRunListener#environmentPrepared</code>自定义实现类</p><pre><code class="lang-java">  // after `EventPublishingRunListener`  public class ExtendPropertySourcesRunListener implements SpringApplicationRunListener,Ordered{      private final SpringApplication application;      private final String[] args;      public ExtendPropertySourcesRunListener(SpringApplication application, String[] args) {          this.application = application;          this.args = args;      }      @Override      public int getOrder() {          return 1;    // set after EventPublishingRunListener(order=0)      }      @Override      public void environmentPrepared(ConfigurableEnvironment environment) {          System.err.println(&quot;execute ExtendPropertySourcesRunListener#environmentPrepared: put user.id=50&quot;);          MutablePropertySources propertySources=environment.getPropertySources();          Map&lt;String,Object&gt; source=new HashMap&lt;String,Object&gt;();          source.put(&quot;user.id&quot;,50);          MapPropertySource ps=new MapPropertySource(&quot;from-environmentPrepared&quot;, source);          propertySources.addFirst(ps);      }      //...  }  // config: resources/META-INF/spring.factories  # Run Listeners, Refer META-INF/spring.factories (jar:spring-boot):  org.springframework.boot.SpringApplicationRunListener=\  com.cj.demo2.listener.ExtendPropertySourcesRunListener</code></pre></li><li><p>示例4：使用<code>ApplicationContextInitializer#initialize</code>自定义实现类</p><pre><code class="lang-java">  public class ExtendPropertySourcesApplicationContextInitializer&lt;C extends ConfigurableApplicationContext&gt; implements ApplicationContextInitializer&lt;C&gt; {      @Override      public void initialize(ConfigurableApplicationContext applicationContext) {          System.err.println(&quot;execute ExtendPropertySourcesApplicationContextInitializer#initialize: put user.id=65&quot;);          MutablePropertySources propertySources=applicationContext.getEnvironment().getPropertySources();          Map&lt;String,Object&gt; source=new HashMap&lt;String,Object&gt;();          source.put(&quot;user.id&quot;,65);          MapPropertySource ps=new MapPropertySource(&quot;from-applicationContextInitialize&quot;, source);          propertySources.addFirst(ps);      }  }  // config: resources/META-INF/spring.factories  # Application Context Initializers  org.springframework.context.ApplicationContextInitializer=\  com.cj.demo2.initializer.ExtendPropertySourcesApplicationContextInitializer</code></pre></li></ul></li></ol><h2 id="header-30">Servlet</h2><p>Servlet:</p><blockquote><p>是一种基于 Java 技术的 Web 组件，用于生成动态内容，由容器管理。<br>类似于其他 Java 技术组件，Servlet 是平台无关的 Java 类组成，且由 Java Web 服务器加载执行。通常情况，由 Servlet容器提供运行时环境。</p></blockquote><p>Servlet 容器/引擎:</p><blockquote><p>作为Web服务器或应用服务器的一部分，管理Servlets实例以及它们的生命周期<br>通过请求和响应对话，提供Web Client与Servlets交互的能力</p></blockquote><p>从功能上:</p><blockquote><p>Servlet 介于 CGI（Common Gateway Interface）与服务扩展（如：Netscape Server API 或 Apache 模块）之间</p></blockquote><p>在体系上:</p><blockquote><p>Servlet 技术（或者规范）属于 Java EE 技术（规范）的一部分</p></blockquote><ol><li><p>Servlet 版本</p><table class="table"><thead><tr><th style="text-align:left">规范版本</th><th style="text-align:left">发布时间</th><th style="text-align:left">Java 平台</th><th style="text-align:left">主要更新</th></tr></thead><tbody><tr><td style="text-align:left">Servlet 4.0</td><td style="text-align:left">2017 年 9 月</td><td style="text-align:left">Java EE 8</td><td style="text-align:left">支持 HTTP/2</td></tr><tr><td style="text-align:left">Servlet 3.1</td><td style="text-align:left">2013 年 5 月</td><td style="text-align:left">Java EE 7</td><td style="text-align:left">非阻塞 I/O、HTTP 协议更新机制（WebSocket）</td></tr><tr><td style="text-align:left">Servlet 3.0</td><td style="text-align:left">2009 年 12 月</td><td style="text-align:left">Java EE 6</td><td style="text-align:left">可插拔、简化部署、异步 Servlet、安全、文件上传</td></tr><tr><td style="text-align:left">Servlet 2.5</td><td style="text-align:left">2005 年 9 月</td><td style="text-align:left">Java EE 5</td><td style="text-align:left">Annotation 支持</td></tr><tr><td style="text-align:left">Servlet 2.4</td><td style="text-align:left">2003 年 11 月</td><td style="text-align:left">J2EE 1.4</td><td style="text-align:left">web.xml 支持 XML Scheme</td></tr><tr><td style="text-align:left">Servlet 2.3</td><td style="text-align:left">2001 年 8 月</td><td style="text-align:left">J2EE 1.3</td><td style="text-align:left">新增 Filter、事件/监听器、Wrapper</td></tr><tr><td style="text-align:left">Servlet 2.2</td><td style="text-align:left">1999 年 8 月</td><td style="text-align:left">J2EE 1.2</td><td style="text-align:left">作为 J2EE 的一部分， 以 .war 文件作为独立 web 应用</td></tr></tbody></table></li><li><p>Servlet 核心组件 (Servlet,Filter,Listener,Context)</p><table class="table"><thead><tr><th style="text-align:left">核心组件 API</th><th style="text-align:left">说明</th><th style="text-align:left">起始版本</th><th style="text-align:left">Spring Framework 代表实现</th></tr></thead><tbody><tr><td style="text-align:left">javax.servlet.Servlet</td><td style="text-align:left">动态内容组件</td><td style="text-align:left">1.0</td><td style="text-align:left">DispatcherServlet</td></tr><tr><td style="text-align:left">javax.servlet.Filter</td><td style="text-align:left">Servlet 过滤器</td><td style="text-align:left">2.3</td><td style="text-align:left">CharacterEncodingFilter</td></tr><tr><td style="text-align:left">javax.servlet.ServletContext</td><td style="text-align:left">Servlet 应用上下文</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">javax.servlet.AsyncContext</td><td style="text-align:left">异步上下文</td><td style="text-align:left">3.0</td><td style="text-align:left">无</td></tr><tr><td style="text-align:left">javax.servlet.ServletContextListener</td><td style="text-align:left">ServletContext 生命周期监听器</td><td style="text-align:left">2.3</td><td style="text-align:left">ContextLoaderListener</td></tr><tr><td style="text-align:left">javax.servlet.ServletRequestListener</td><td style="text-align:left">ServletRequest 生命周期监听器</td><td style="text-align:left">2.3</td><td style="text-align:left">RequestContextListener</td></tr><tr><td style="text-align:left">javax.servlet.http.HttpSessionListener</td><td style="text-align:left">HttpSession 生命周期监听器</td><td style="text-align:left">2.3</td><td style="text-align:left">HttpSessionMutexListener</td></tr><tr><td style="text-align:left">javax.servlet.AsyncListener</td><td style="text-align:left">异步上下文监听器</td><td style="text-align:left">3.0</td><td style="text-align:left">StandardServletAsyncWebRequest</td></tr><tr><td style="text-align:left">javax.servlet.ServletContainerInitializer</td><td style="text-align:left">Servlet 容器初始化器</td><td style="text-align:left">3.0</td><td style="text-align:left">SpringServletContainerInitializer</td></tr></tbody></table></li><li><p>Servlet 组件的生命周期</p><ul><li><code>Servlet</code><ul><li>init(ServletConfig)</li><li>service(ServletRequest,ServletResponse)</li><li>destroy()</li></ul></li><li><code>Filter</code><ul><li>init(FilterConfig)</li><li>doFilter(ServletRequest,ServletResponse,FilterChain)</li><li>destroy()</li></ul></li><li><code>Listener</code><ul><li>contextInitialized(ServletContextEvent)</li><li>contextDestroyed(ServletContextEvent)</li></ul></li></ul></li><li><p>Servlet 组件注册</p><table class="table"><thead><tr><th style="text-align:left">组件</th><th style="text-align:left">传统方式</th><th style="text-align:left">注解方式</th><th style="text-align:left">编程方式（利用Servlet SPI：<code>ServletContainerInitializer#onStartup(classes,ctx)</code>）</th></tr></thead><tbody><tr><td style="text-align:left">Servlet</td><td style="text-align:left">web.xml: <code>&lt;servlet&gt;</code>,<code>&lt;servlet-mapping&gt;</code></td><td style="text-align:left"><code>@WebServlet</code></td><td style="text-align:left">ServletContext#addServlet</td></tr><tr><td style="text-align:left">Filter</td><td style="text-align:left">web.xml: <code>&lt;filter&gt;</code>,<code>&lt;filter-mapping&gt;</code></td><td style="text-align:left"><code>@WebFilter</code></td><td style="text-align:left">ServletContext#addFilter</td></tr><tr><td style="text-align:left">Listener</td><td style="text-align:left">web.xml: <code>&lt;listener&gt;</code>,<code>&lt;context-param&gt;</code></td><td style="text-align:left"><code>@WebListener</code></td><td style="text-align:left">ServletContext#addListener</td></tr></tbody></table></li><li><p>Servlet容器</p><table class="table"><thead><tr><th style="text-align:left">Servlet容器</th><th style="text-align:left">启动</th><th style="text-align:left">初始化器</th></tr></thead><tbody><tr><td style="text-align:left">独立Servlet容器</td><td style="text-align:left">独立Servlet容器 -&gt; 启动 App</td><td style="text-align:left">Servlet SPI(3.0): <code>ServletContainerInitializer</code>; Spring 适配：<code>SpringServletContainerInitializer</code>+ <code>@HandlesTypes(WebApplicationInitializer.class)</code></td></tr><tr><td style="text-align:left">嵌入式Servlet容器</td><td style="text-align:left">App －&gt; 启动嵌入式Servlet容器</td><td style="text-align:left">SpringBoot: <code>ServletContextInitializer</code></td></tr></tbody></table></li></ol><h3 id="header-31">Servlet 容器启动初始化</h3><p><code>ServletContainerInitializer</code> Servlet容器初始化器</p><ol><li><p>Servlet interface (jar: <code>javax.servlet-api</code> / <code>tomcat-embed-core</code>)</p><pre><code class="lang-java"> package javax.servlet; public interface ServletContainerInitializer {     public void onStartup(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx) throws ServletException;  }</code></pre><ul><li><code>Servlet 3.0</code> 新增的一个接口，主要用于在容器启动阶段通过<code>编程风格</code>注册Servlet/Filter/Listener，以取代通过<code>web.xml</code>配置注册</li><li>这样利于开发内聚的web应用框架，例如：对于SpringWeb应用，<code>Servlet3.0</code>前需要在<code>web.xml</code>中配置注册一些Spring实现的Servlet/Filter/Listener组件,相当于将框架和容器紧耦合了; <code>3.x</code>后注册的功能内聚到Spring里，这个SpringWeb应用就变成了一个即插即用的组件，不用依据应用环境定义一套新的配置</li><li>参考：<ul><li><a href="https://blog.csdn.net/lqzkcx3/article/details/78507169" target="_blank" rel="noopener">Servlet3.0研究之ServletContainerInitializer接口</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI3MTEwODc5Ng==&amp;mid=2650859531&amp;idx=1&amp;sn=02830d72d4bacd00c82314d0281f3eb2&amp;chksm=f13297d8c6451ece93dd5abbfff1cce10e440414838e2864d3c5b8fa794a1acc91cca0e4343f&amp;mpshare=1&amp;scene=23&amp;srcid=0920wmSB9KfBqsVAQTLYz3ly#rd" target="_blank" rel="noopener">Tomcat 中 的可插拔以及 SCI 的实现原理</a></li></ul></li></ul></li><li><p>Spring实现类 <code>SpringServletContainerInitializer</code> (Version 3.1后): 接受启动<code>WebApplicationInitializer</code>类型的initializers (jar: <code>spring-web</code>)</p><pre><code class="lang-java"> package org.springframework.web; @HandlesTypes(WebApplicationInitializer.class) public class SpringServletContainerInitializer implements ServletContainerInitializer {     @Override     public void onStartup(@Nullable Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext) throws ServletException{         List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;&gt;();         for:webAppInitializerClasses             initializers.add         AnnotationAwareOrderComparator.sort(initializers);         for:initializers             initializer.onStartup(servletContext)     } } /**  * Interface to be implemented in Servlet 3.0+ environments in order to configure the  * {@link ServletContext} programmatically -- as opposed to (or possibly in conjunction  * with) the traditional {@code web.xml}-based approach.  */ public interface WebApplicationInitializer {     /**      * Configure the given {@link ServletContext} with any servlets, filters, listeners      * context-params and attributes necessary for initializing this web application.       */     void onStartup(ServletContext servletContext) throws ServletException; }</code></pre><ul><li><code>WebApplicationInitializer</code> 实现类：<ul><li>AbstractContextLoaderInitializer<ul><li>AbstractDispatcherServletInitializer    编程驱动<ul><li>AbstractAnnotationConfigDispatcherServletInitializer 注解驱动</li></ul></li></ul></li><li>AbstractReactiveWebInitializer</li><li>AbstractSecurityWebApplicationInitializer</li><li>SpringBootServletInitializer (jar: spring-boot)</li></ul></li></ul></li></ol><p><strong> Spring WebMvc 示例：</strong></p><p>Key:</p><ul><li>使用xml配置WebMvc相关组件</li><li>使用<code>web.xml</code> 或者自定义的<code>WebApplicationInitializer</code>实现类注册<code>DispatcherServlet</code></li><li>自定义一个Servlet，并通过<code>@WebServlet</code>注册</li><li>使用独立Servlet启动运行</li></ul><ol><li><p>pom.xml</p><pre><code class="lang-xml"> &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt;     &lt;!-- Spring Web MVC 依赖 --&gt;     &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;!-- Servlet 3.1 API 依赖--&gt;      &lt;dependency&gt;          &lt;groupId&gt;javax.servlet&lt;/groupId&gt;          &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;          &lt;scope&gt;provided&lt;/scope&gt;      &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt;     &lt;finalName&gt;demo&lt;/finalName&gt;     &lt;plugins&gt;          &lt;!-- jetty:run --&gt;         &lt;plugin&gt;           &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;           &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;           &lt;version&gt;9.4.12.v20180830&lt;/version&gt;           &lt;configuration&gt;             &lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt;              &lt;webApp&gt;               &lt;contextPath&gt;/demo&lt;/contextPath&gt;             &lt;/webApp&gt;             &lt;httpConnector&gt;                 &lt;port&gt;9090&lt;/port&gt;                 &lt;idleTimeout&gt;60000&lt;/idleTimeout&gt;             &lt;/httpConnector&gt;             &lt;stopKey&gt;foo&lt;/stopKey&gt;                &lt;stopPort&gt;9999&lt;/stopPort&gt;           &lt;/configuration&gt;         &lt;/plugin&gt;         &lt;!-- tomcat --&gt;         &lt;!-- mvn -Dmaven.test.skip -U clean package --&gt;         &lt;!-- java -jar target/xxx-war-exec.jar --&gt;         &lt;!-- visit: http://localhost:8080/demo --&gt;         &lt;plugin&gt;             &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;             &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;             &lt;version&gt;2.1&lt;/version&gt;             &lt;executions&gt;                 &lt;execution&gt;                     &lt;id&gt;tomcat-run&lt;/id&gt;                     &lt;goals&gt;                         &lt;goal&gt;exec-war-only&lt;/goal&gt;                     &lt;/goals&gt;                     &lt;phase&gt;package&lt;/phase&gt;                     &lt;configuration&gt;                         &lt;!-- ServletContext path --&gt;                         &lt;path&gt;/demo&lt;/path&gt;                     &lt;/configuration&gt;                 &lt;/execution&gt;             &lt;/executions&gt;         &lt;/plugin&gt;     &lt;/plugins&gt; &lt;/build&gt;</code></pre></li><li><p>/src/main/webapp/WEB-INF/app-context.xml (配置Web MVC组件)</p><pre><code class="lang-xml">     &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xmlns:context=&quot;http://www.springframework.org/schema/context&quot;     xsi:schemaLocation=&quot;     http://www.springframework.org/schema/beans     http://www.springframework.org/schema/beans/spring-beans.xsd     http://www.springframework.org/schema/context     http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;     &lt;context:component-scan base-package=&quot;com.cj.demo&quot;/&gt;     &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;     &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;     &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;         &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;         &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;         &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;     &lt;/bean&gt; &lt;/beans&gt;</code></pre></li><li>/src/main/webapp/jsp/index.jsp<pre><code class="lang-html"> This index page: Hello World</code></pre></li><li>Controller<pre><code class="lang-java"> @Controller public class HelloController {     @RequestMapping(value={&quot;/&quot;},method=RequestMethod.GET)     public String index() {         return &quot;index&quot;;     } }</code></pre></li><li><p>部署 DispatcherServlet</p><ul><li>使用<code>web.xml</code>的传统方式注册Servlet组件<pre><code class="lang-xml">  &lt;web-app&gt;      &lt;!-- 配置注册 DispatchServlet--&gt;      &lt;servlet&gt;           &lt;servlet-name&gt;app&lt;/servlet-name&gt;           &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;           &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;           &lt;init-param&gt;              &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;              &lt;param-value&gt;/WEB-INF/app-context.xml&lt;/param-value&gt; &lt;!-- classpath*:/META-INF/spring/spring-context.xml --&gt;          &lt;/init-param&gt;       &lt;/servlet&gt;       &lt;servlet-mapping&gt;           &lt;servlet-name&gt;app&lt;/servlet-name&gt;           &lt;url-pattern&gt;/&lt;/url-pattern&gt;       &lt;/servlet-mapping&gt;  &lt;/web-app&gt;</code></pre></li><li><p>编程取代传统的<code>web.xml</code>方式注册Servlet组件（ Spring <code>SpringServletContainerInitializer</code> -&gt; <code>WebApplicationInitializer#onStartup</code> ）</p><pre><code class="lang-java">  // 使用自定义的WebApplicationInitializer实现类注册DispatchServlet  /*  WebApplicationInitializer      - AbstractContextLoaderInitializer          - AbstractDispatcherServletInitializer              - AbstractAnnotationConfigDispatcherServletInitializer  */  @ImportResource(&quot;/WEB-INF/app-context.xml&quot;)  public class MyAnnotationConfigDispatcherServletInitializer       extends AbstractAnnotationConfigDispatcherServletInitializer{      @Override      protected Class&lt;?&gt;[] getRootConfigClasses() {    //web.xml          return new Class[0];      }      @Override      protected Class&lt;?&gt;[] getServletConfigClasses() {    // DispatchServlet          System.out.println(&quot;get servlet config classes.......&quot;);          return new Class[] {this.getClass()};      }      @Override      protected String[] getServletMappings() {          System.out.println(&quot;get servlet mappings......&quot;);          return new String[]{&quot;/&quot;};      }  }</code></pre></li></ul></li><li><p>自定义一个<code>Servlet</code>并注入</p><pre><code class="lang-java"> // 自定义一个Servlet，使用注解@WebServlet来注入此Servlet (不依赖ComponentScan) @WebServlet(urlPatterns=&quot;/myServlet&quot;,name=&quot;myServlet&quot;,asyncSupported=true) public class MyServlet extends HttpServlet{     public MyServlet() {         println(&quot;MyServlet!&quot;);     }     protected void doGet(HttpServletRequest req,HttpServletResponse resp)             throws ServletException,IOException {         println(&quot;Hello world!&quot;);          if(req.isAsyncSupported()) {             AsyncContext ctx=req.startAsync();             ctx.setTimeout(500L);             ctx.start(()-&gt;{                 try{                     println(&quot;Async Hello world!&quot;);                         resp.getWriter().println(&quot;Async Hello world!&quot;);                     ctx.complete();    // must call complete                 }catch(IOException e){                     e.printStackTrace();                 }             });         }         resp.getWriter().println(&quot;Hello world!&quot;);     }     private static void println(Object object) {         String threadName = Thread.currentThread().getName();         System.out.println(&quot;MyServlet[&quot; + threadName + &quot;]: &quot; + object);     } }</code></pre></li><li><p>verify: pom.xml maven build… -&gt; <code>jetty:run</code> (使用tomcat maven插件生成可运行的jar包也可以)</p><ul><li><code>curl -i http://localhost:9090/demo/</code></li><li><code>curl -i http://localhost:9090/demo/myServlet</code></li></ul></li></ol><p><strong> SpringBoot WebMvc 示例：</strong></p><p>Key:</p><ul><li>使用<code>@EnableAutoConfiguration</code>自动装配DispatcherServlet</li><li>使用XML/Annotation(<code>@Configuration</code>) 配置WebMvc相关组件 （Spring中也可使用这种注解配置方式 + <code>@ComponentScan(basePackages=&quot;com.cj.demo&quot;)</code>配置扫描到配置类）</li><li>使用<code>SpringBootServletInitializer</code>配置主引导类 (SpringBootServletInitializer implements WebApplicationInitializer)</li><li>使用<code>独立Servlet</code>启动运行</li></ul><ol><li><p>pom.xml</p><pre><code class="lang-xml"> &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt;     &lt;!-- Spring Boot 依赖 --&gt;     &lt;dependency&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;          &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;          &lt;exclusions&gt;               &lt;!-- Exclude the Tomcat dependency --&gt;               &lt;exclusion&gt;                   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                   &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;               &lt;/exclusion&gt;          &lt;/exclusions&gt;     &lt;/dependency&gt;      &lt;!-- Servlet 3.1 API 依赖--&gt;      &lt;dependency&gt;          &lt;groupId&gt;javax.servlet&lt;/groupId&gt;          &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;          &lt;scope&gt;provided&lt;/scope&gt;      &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt;     &lt;finalName&gt;demo&lt;/finalName&gt;     &lt;plugins&gt;          &lt;!-- jetty:run --&gt;         &lt;plugin&gt;           &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;           &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;           &lt;version&gt;9.4.12.v20180830&lt;/version&gt;           &lt;configuration&gt;             &lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt;              &lt;webApp&gt;               &lt;contextPath&gt;/demo&lt;/contextPath&gt;             &lt;/webApp&gt;             &lt;httpConnector&gt;                 &lt;port&gt;9090&lt;/port&gt;                 &lt;idleTimeout&gt;60000&lt;/idleTimeout&gt;             &lt;/httpConnector&gt;             &lt;stopKey&gt;foo&lt;/stopKey&gt;                &lt;stopPort&gt;9999&lt;/stopPort&gt;           &lt;/configuration&gt;         &lt;/plugin&gt;     &lt;/plugins&gt; &lt;/build&gt;</code></pre></li><li><p>使用<code>@Configuration</code>注解方式配置WebMvc组件</p><pre><code class="lang-java"> package com.cj.demo.config; @Configuration // 还可以implements WebMvcConfigurer，方便实现更多配置，例如: @Override addInterceptors public class WebMvcConfig {     /*      &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;         &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;         &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;         &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;      &lt;/bean&gt;      */     @Bean     public ViewResolver viewResolver(){         InternalResourceViewResolver viewResolver=new InternalResourceViewResolver();         viewResolver.setViewClass(JstlView.class);         viewResolver.setPrefix(&quot;/WEB-INF/jsp/&quot;);         viewResolver.setSuffix(&quot;.jsp&quot;);         return viewResolver;     } }</code></pre></li><li><p>/src/main/webapp/jsp/index.jsp</p><pre><code class="lang-html"> This index page: Hello World</code></pre></li><li><p>Controller</p><pre><code class="lang-java"> @Controller public class HelloController {     @RequestMapping(value={&quot;/&quot;},method=RequestMethod.GET)     public String index() {         return &quot;index&quot;;     } }</code></pre></li><li><p>通过<code>SpringBootServletInitializer</code>配置主引导类</p><pre><code class="lang-java"> package com.cj.demo.initializer; // Note：SpringBootServletInitializer implements WebApplicationInitializer) public class MySpringBootServletInitializer extends SpringBootServletInitializer{     protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {         System.out.println(&quot;MySpringBootServletInitializer configure&quot;);         builder.sources(SpringBootDemoApp.class);         return builder;     } } @EnableAutoConfiguration public class SpringBootDemoApp { }</code></pre></li><li><p>verify: <code>pom.xml</code> -&gt; maven build… -&gt; <code>jetty:run</code> -&gt; <code>curl -i http://localhost:9090/demo/</code></p></li></ol><h3 id="header-32">Servlet 嵌入式容器启动初始化</h3><p>SpringBoot 实现 (jar: spring-boot) ：</p><ol><li><p><code>ServletContextInitializer</code></p><pre><code class="lang-java"> package org.springframework.boot.web.servlet; @FunctionalInterface public interface ServletContextInitializer{     void onStartup(ServletContext servletContext) throws ServletException; }</code></pre><ul><li>为减少风险，嵌入式容器（eg: embed jetty/tomcat/…) 不能使用Servlet interface <code>ServletContainerInitializer</code>和Spring interface<code>WebApplicationInitializer</code>. Refer <a href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/htmlsingle/#boot-features-embedded-container-context-initializer" target="_blank" rel="noopener">27.4.2 Servlet Context Initialization</a></li><li>SpringBoot中提供<code>ServletContextInitializer</code>接口（代替嵌入式容器无法使用的Servlet interface <code>ServletContainerInitializer</code>）来实现<code>ServletContext</code>的initialization.</li></ul></li><li><p><code>ServletContextInitializer</code>实现类</p><ul><li>RegistrationBean<ul><li>DynamicRegistrationBean<d extends="" registration.dynamic=""><ul><li>AbstractFilterRegistrationBean<t extends="" filter=""><ul><li>DelegatingFilterProxyRegistrationBean</li><li>FilterRegistrationBean<t extends="" filter=""> : <code>@WebFilter</code></t></li></ul></t></li><li>ServletRegistrationBean<t extends="" servlet=""> : <code>@WebServlet</code></t></li></ul></d></li><li>ServletListenerRegistrationBean<t extends="" eventlistener=""> : <code>@WebListener</code></t></li></ul></li></ul></li><li><p><code>@ServletComponentScan</code></p><ul><li>嵌入式容器无法自动识别并处理Servlet注解<code>@WebServlet</code>／<code>@WebFilter</code>／<code>@WebListener</code></li><li>SpringBoot提供<code>@ServletComponentScan</code>来扫描识别这些Servlet注解</li><li>处理过程：扫描 package -&gt; <code>@WebServlet</code>/<code>@WebFilter</code>/<code>@WebListener</code> -&gt; <code>RegistrationBean</code> BeanDefinition -&gt; <code>RegistrationBean</code>Bean: 嵌入式容器调用<code>ServletContextInitializer#onStartup(ServletContext)</code>时装配识别出的Servlet组件</li></ul></li><li><p>部分源码：</p><pre><code class="lang-java"> @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Import(ServletComponentScanRegistrar.class) public @interface ServletComponentScan package org.springframework.boot.web.servlet; class ServletComponentScanRegistrar implements ImportBeanDefinitionRegistrar {     @Override     public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,             BeanDefinitionRegistry registry) {         Set&lt;String&gt; packagesToScan = getPackagesToScan(importingClassMetadata);         updatePostProcessor/addPostProcessor(registry, packagesToScan);         =&gt;{             GenericBeanDefinition beanDefinition = new GenericBeanDefinition();             beanDefinition.setBeanClass(ServletComponentRegisteringPostProcessor.class); // Note !             beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(packagesToScan);             beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);             registry.registerBeanDefinition(BEAN_NAME, beanDefinition);         }      } } //=&gt; class ServletComponentRegisteringPostProcessor implements BeanFactoryPostProcessor, ApplicationContextAware {     private static final List&lt;ServletComponentHandler&gt; HANDLERS;     static {         List&lt;ServletComponentHandler&gt; servletComponentHandlers = new ArrayList&lt;&gt;();         servletComponentHandlers.add(new WebServletHandler());    // For @WebServlet         servletComponentHandlers.add(new WebFilterHandler());    // For @WebFilter         servletComponentHandlers.add(new WebListenerHandler()); // For @WebListener         HANDLERS = Collections.unmodifiableList(servletComponentHandlers);     }     @Override     public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)             throws BeansException {         if (isRunningInEmbeddedWebServer()) {    // Note: only for embed webserver!             ClassPathScanningCandidateComponentProvider componentProvider = createComponentProvider();             for (String packageToScan : this.packagesToScan)                  scanPackage(componentProvider, packageToScan);                 =&gt; {                     for beanDef:componentProvider.findCandidateComponents(packageToScan)                         for handler:HANDLERS                             handler.handle(beanDef,this.applicationContext)                 }         }     } } //=&gt; eg: WebServletHandler class WebServletHandler extends ServletComponentHandler {     WebServletHandler() {         super(WebServlet.class);     }     @Override     public void doHandle(Map&lt;String, Object&gt; attributes,         ScannedGenericBeanDefinition beanDefinition,BeanDefinitionRegistry registry) {         BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(ServletRegistrationBean.class); // Note !         builder.addPropertyValue(...); // ...         registry.registerBeanDefinition(name, builder.getBeanDefinition());     } } //=&gt;  //ServletRegistrationBean extends RegistrationBean implements ServletContextInitializer ServletRegistrationBean#onStartup(ServletContext)</code></pre></li><li><p>总结：Spring Boot 嵌入式Servlet容器限制</p><table class="table"><thead><tr><th style="text-align:left">Servlet 特性</th><th style="text-align:left">兼容性</th><th style="text-align:left">解决方案</th></tr></thead><tbody><tr><td style="text-align:left">web.xml</td><td style="text-align:left">不支持</td><td style="text-align:left">RegistrationBean 或 @Bean 注册</td></tr><tr><td style="text-align:left">ServletContainerInitializer</td><td style="text-align:left">不支持</td><td style="text-align:left">ServletContextInitializer</td></tr><tr><td style="text-align:left">@WebServlet 等</td><td style="text-align:left">有限支持</td><td style="text-align:left">依赖@ServletComponentScan</td></tr></tbody></table></li></ol><p><strong> SpringBoot 示例：</strong></p><p>Key：</p><ul><li>使用xml/annotation方式配置WebMvc组件</li><li>使用<code>@EnableAutoConfiguration</code>自动部署DispatcherServlet</li><li>自定义Servlet，通过<code>@WebServlet</code>+<code>@ServletComponentScan</code>，或<code>RegistrationBean</code>,或<code>ServletContextInitializer#onStartup-&gt;servletContext.addServlet</code>方式注册</li><li>使用嵌入式容器（直接运行main方法）/独立容器启动进行验证</li></ul><ol><li><p>pom.xml</p><pre><code class="lang-xml"> &lt;dependencies&gt;     &lt;!-- default embed webserver by spring-boot-starter-tomcat--&gt;     &lt;dependency&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;          &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;     &lt;/dependency&gt;  &lt;/dependencies&gt;</code></pre></li><li><p>使用XML方式配置Web MVC组件：/src/main/webapp/WEB-INF/app-context.xml</p><pre><code class="lang-xml">     &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xmlns:context=&quot;http://www.springframework.org/schema/context&quot;     xsi:schemaLocation=&quot;     http://www.springframework.org/schema/beans     http://www.springframework.org/schema/beans/spring-beans.xsd     http://www.springframework.org/schema/context     http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;     &lt;context:component-scan base-package=&quot;com.cj.demo&quot;/&gt;     &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;     &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;     &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;         &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;         &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;         &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;     &lt;/bean&gt; &lt;/beans&gt;</code></pre></li><li><p>/src/main/webapp/jsp/index.jsp</p><pre><code class="lang-html"> This index page: Hello World</code></pre></li><li><p>Controller</p><pre><code class="lang-java"> @Controller public class HelloController {     @RequestMapping(value={&quot;/&quot;},method=RequestMethod.GET)     public String index() {         return &quot;index&quot;;     } }</code></pre></li><li><p>部署 DispatcherServlet</p><pre><code> // @SpringBootApplication 包括 @EnableAutoConfiguration // 会自动通过DispatcherServletAutoConfiguration来注入DispatchServlet(mapped=/) @SpringBootApplication(scanBasePackages=&quot;com.cj.demo&quot;) public class SpringBootStartApp {     public static void main(String[] args) {         SpringApplication.run(SpringBootStartApp.class, args);     } }</code></pre></li><li><p>自定义一个Servlet并注入</p><pre><code class="lang-java"> // 自定义一个Servlet public class MyServlet extends HttpServlet{     public MyServlet() {         println(&quot;MyServlet!&quot;);     }     protected void doGet(HttpServletRequest req,HttpServletResponse resp)             throws ServletException,IOException {         println(&quot;Hello world!&quot;);          if(req.isAsyncSupported()) {             AsyncContext ctx=req.startAsync();             ctx.setTimeout(500L);             ctx.start(()-&gt;{                 try{                     println(&quot;Async Hello world!&quot;);                         resp.getWriter().println(&quot;Async Hello world!&quot;);                     ctx.complete();    // must call complete                 }catch(IOException e){                     e.printStackTrace();                 }             });         }         resp.getWriter().println(&quot;Hello world!&quot;);     }     private static void println(Object object) {         String threadName = Thread.currentThread().getName();         System.out.println(&quot;MyServlet[&quot; + threadName + &quot;]: &quot; + object);     } }</code></pre><ul><li>方式一：使用<code>RegistrationBean</code><pre><code class="lang-java">  @Bean  public ServletRegistrationBean&lt;Servlet&gt; myServletRegistrationBean(){      return new ServletRegistrationBean&lt;Servlet&gt;(new MyServlet(),&quot;/myServlet&quot;);    // default asyncSupported is true.  }</code></pre></li><li>方式二：使用<code>@WebServlet</code> + <code>@ServletComponentScan</code><ul><li>在自定义Servlet上添加<code>@WebServlet(urlPatterns=&quot;/myServlet&quot;,name=&quot;myServlet&quot;,asyncSupported=true)</code></li><li>在main class上添加<code>@ServletComponentScan(basePackages=&quot;com.cj.demo.servlet&quot;)</code> 以扫描到使用<code>@WebServlet</code>注入的Servlet</li><li>Note： <code>@ServletComponentScan</code> only effective for EmbeddedWebServer, will scan @WebServlet,@WebFilter,@WebListener</li></ul></li><li>方式三：使用<code>ServletContextInitializer#onStartup-&gt;servletContext.addServlet</code><pre><code class="lang-java">  @Bean  public ServletContextInitializer myServletContextInitializer(){      return servletContext-&gt;{          ServletRegistration.Dynamic reg=servletContext.addServlet(&quot;myServlet&quot;, new MyAsyncServlet());          reg.addMapping(&quot;/myServlet&quot;);          reg.setAsyncSupported(true);        // set asyncSupported to be true      };  }</code></pre></li><li>注：<ul><li>以上优先级 <code>RegistrationBean</code> &gt; <code>@ServletComponentScan</code> &gt; <code>ServletContextInitializer</code></li><li>同mappingUrl/servletName，优先级高的先注册了会自动skip掉后来的 (特： 若重复发生在ServletContextInitializer中，会报错，嵌入式容器启动失败)</li></ul></li></ul></li><li><p>verify: pom.xml maven build… -&gt; <code>jetty:run</code></p><ul><li>嵌入式容器启动<ul><li><code>curl -i http://localhost:9090/demo/</code>        -&gt; OK</li><li><code>curl -i http://localhost:9090/demo/myServlet</code> -&gt; OK</li></ul></li><li>独立容器启动<ul><li><code>curl -i http://localhost:9090/demo/</code>     -&gt; OK</li><li><code>curl -i http://localhost:9090/demo/myServlet</code> -&gt; 使用<code>@WebServlet</code>的Servlet注册成功，其他方式不成功？</li></ul></li></ul></li></ol><h3 id="header-33">组件Servlet源码分析</h3><ul><li><code>Servlet</code> (jar: servlet-api)<ul><li><code>GenericServlet</code> (jar: servlet-api)<ul><li><code>HttpServletBean</code> -&gt; <code>FrameworkServlet</code> -&gt; <code>DispatchServlet</code> (jar:spring-webmvc)    </li></ul></li></ul></li></ul><ol><li><p><code>servlet-api</code>: javax.servlet.http (eg: javax.servlet-api-3.1.0.jar)</p><ul><li><code>Servlet</code> (init,service,destroy,getServletConfig)<ul><li><code>GenericServlet</code> (abstract service,init,…)<ul><li><code>HttpServlet</code> (service,doGet,doPost,doXxx…)</li></ul></li></ul></li><li><p>Source Code：</p><pre><code class="lang-java">  interface Servlet  {      public void init(ServletConfig config) throws ServletException;      public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException;      public void destroy();      public ServletConfig getServletConfig();          =&gt;{ //ServletConfig:              public String getServletName();              public ServletContext getServletContext();              public String getInitParameter(String name);              public Enumeration&lt;String&gt; getInitParameterNames();          }      public String getServletInfo();  }  abstract class GenericServlet implements Servlet, ServletConfig,java.io.Serializable  {      // ...      public void init(ServletConfig config) throws ServletException {          this.config = config;          this.init();      }      public abstract void service(ServletRequest req, ServletResponse res) throws ServletException, IOException;  }  abstract class HttpServlet extends GenericServlet   {      @Override      public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException{           service((HttpServletRequest)request, (HttpServletResponse)response); // protected func              =&gt;{                  req.getMethod()? doHead/doGet/doPost/doPut/doXxx...    // protected func              }      }  }</code></pre></li></ul></li><li><p>Spring: org.springframework.web.servlet (jar: <code>spring-webmvc</code>)</p><ul><li><code>HttpServletBean</code> : final init -&gt; initBeanWrapper,initServletBean<ul><li><code>FrameworkServlet</code> : final initServletBean -&gt; initWebApplicationContext -&gt; onRefresh; service -&gt; abstract doService<ul><li><code>DispatchServlet</code> : onRefresh -&gt; initStrategies; doService -&gt; doDispatch</li></ul></li></ul></li><li><p><code>DispatchServlet</code></p><ul><li>init:<pre><code class="lang-java">  HttpServlet.init(ServletConfig)  -&gt; final HttpServletBean.init()   -&gt; final FrameworkServlet.initServletBean()    -&gt; protected FrameworkServlet.initWebApplicationContext()      -&gt; protected DispatcherServlet.onRefresh(wac)       -&gt; protected DispatcherServlet.initStrategies(wac)          {                  // 初始化 DispatcherServlet 各种组件              initMultipartResolver              initLocaleResolver              initThemeResolver              initHandlerMappings              initHandlerAdapters              initHandlerExceptionResolvers              initRequestToViewNameTranslator              initViewResolvers              initFlashMapManager          }</code></pre></li><li>Service:<pre><code class="lang-java">  public HttpServlet.service(ServletRequest,ServletResponse)   -&gt; protected FrameworkServlet.service(HttpServletRequest,HttpServletResponse)   -&gt; protected HttpServlet.service(HttpServletRequest,HttpServletResponse)    -&gt; final FrameworkServlet.doGet/doPost/doPut/doDelete/doOptions/doTrace(req,resp)     -&gt; abstract FrameworkServlet.doService(req,resp)      -&gt; protected DispatchServlet.doService(req,resp)       -&gt; protected DispatchServlet.doDispatch(req,resp)           {              HandlerExecutionChain mappedHandler = getHandler(processedRequest);              HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());              ModelAndView mv = ha.handle(processedRequest, response, mappedHandler.getHandler());              processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);                               }</code></pre></li></ul></li><li><p>Source Code：</p><pre><code class="lang-java">  abstract class HttpServletBean extends HttpServlet implements EnvironmentCapable, EnvironmentAware   {          @Override      public final void init() throws ServletException {          PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);          BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);          ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());          bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));          initBeanWrapper(bw); // protected func          bw.setPropertyValues(pvs, true);          initServletBean(); // protected func      }  }  public abstract class FrameworkServlet extends HttpServletBean implements ApplicationContextAware   {      public FrameworkServlet() {}      public FrameworkServlet(WebApplicationContext webApplicationContext) {          this.webApplicationContext = webApplicationContext;      }      @Override      protected final void initServletBean() throws ServletException {          this.webApplicationContext = initWebApplicationContext();              =&gt;{                  WebApplicationContext rootContext = WebApplicationContextUtils                              .getWebApplicationContext(getServletContext());                  WebApplicationContext wac = this.webApplicationContext;                  wac!=null &amp;&amp; instanceof ConfigurableWebApplicationContext =&gt; wac.setParent(rootContext);                   configureAndRefreshWebApplicationContext(wac);                  wac!=null =&gt; wac = findWebApplicationContext()                  wac!=null =&gt; wac = createWebApplicationContext(rootContext)                  if(!this.refreshEventReceived)                       onRefresh(wac);                           =&gt; {                              // DispatchServlet#onRefresh:                               initStrategies(context);                                  =&gt;{                                      initMultipartResolver(context);                                      initLocaleResolver(context);                                      initThemeResolver(context);                                      initHandlerMappings(context);                                      initHandlerAdapters(context);                                      initHandlerExceptionResolvers(context);                                      initRequestToViewNameTranslator(context);                                      initViewResolvers(context);                                      initFlashMapManager(context);                                  }                          }                  if (this.publishContext)                      getServletContext().setAttribute(getServletContextAttributeName(), wac);                  return wac;              }          initFrameworkServlet();      }      @Override      protected void service(HttpServletRequest request, HttpServletResponse response)              throws ServletException, IOException {          HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());          if (httpMethod == HttpMethod.PATCH || httpMethod == null)               processRequest(request, response);          else              super.service(request, response);              =&gt; {                  FrameworkServlet#doGet/doPost/doPut/doDelete/doOptions/doTrace                     =&gt; FrameworkServlet#processRequest(request,response)              }      }      protected final void processRequest(HttpServletRequest request, HttpServletResponse response)              throws ServletException, IOException {          initContextHolders(request, localeContext, requestAttributes);          doService(request, response);          =&gt;{              // DispatchServlet#doService:              doDispatch(request, response);              =&gt;{                  HandlerExecutionChain mappedHandler = getHandler(processedRequest);                  HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());                  ModelAndView mv = ha.handle(processedRequest, response, mappedHandler.getHandler());                  processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);              }          }          resetContextHolders(request, previousLocaleContext, previousAttributes);          publishRequestHandledEvent(request, response, startTime, failureCause);      }  }</code></pre></li></ul></li></ol><h3 id="header-34">Servlet异步支持(3.0+)</h3><ol><li><p>技术：        </p><ul><li><code>DeferredResult</code> （spring-web)</li><li><code>Callable</code>            (java)</li><li><code>CompletionStage</code>    (java)</li></ul></li><li><p>示例：</p><pre><code class="lang-java"> package com.cj.demo.controller; @RestController public class HelloAsyncController {     @GetMapping(&quot;/hello&quot;)     public String hello() {         return &quot;Hello!&quot;;     }     @GetMapping(&quot;/deffered&quot;)     public DeferredResult&lt;String&gt; helloDeffered(){         DeferredResult&lt;String&gt; result=new DeferredResult&lt;&gt;(50L);         result.setResult(&quot;[DefferedResult] Hello world!&quot;);         println(&quot;[DefferedResult] Hello world!&quot;);         result.onCompletion(()-&gt;{             println(&quot;[DefferedResult] execute complete&quot;);         });         result.onTimeout(()-&gt;{             println(&quot;[DefferedResult] execute timeout&quot;);         });         return result;     }     @GetMapping(&quot;/callable&quot;)     public Callable&lt;String&gt; helloCallable() {         final long startTime = System.currentTimeMillis();         println(&quot;[Callable] Hello world!&quot;);         return () -&gt; {             long costTime = System.currentTimeMillis() - startTime;             println(&quot;[Callable] cost &quot; + costTime + &quot; ms.&quot;);             return &quot;[Callable] Hello world!&quot;;         };     }      @GetMapping(&quot;/completionStage&quot;)     public CompletionStage&lt;String&gt; helloCompletionStage() {         final long startTime = System.currentTimeMillis();         println(&quot;[CompletionStage] Hello world!&quot;);         return CompletableFuture.supplyAsync(() -&gt; {             long costTime = System.currentTimeMillis() - startTime;             println(&quot;[CompletionStage] cost &quot; + costTime + &quot; ms.&quot;);             return &quot;[CompletionStage] Hello world!&quot;;         });     }     private static void println(Object object) {         String threadName = Thread.currentThread().getName();         System.out.println(&quot;HelloAsyncController[&quot; + threadName + &quot;]: &quot; + object);     } }</code></pre><ul><li>visit：<code>/deffered</code>,<code>/callable</code>,<code>/completionStage</code></li></ul></li></ol><h2 id="header-35">WebMVC</h2><p><img src="/2018/09/15/webmvc.png" alt="webmvc"></p><ol><li><p>核心组件 (jar:<code>spring-webmvc</code>)</p><table class="table"><thead><tr><th style="text-align:left"></th><th style="text-align:left">组件</th><th style="text-align:left">主要方法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><code>DispatcherServlet</code></td><td style="text-align:left">doService,doDispatch</td><td style="text-align:left">总控 HttpServlet#service -&gt; FrameworkServlet#service -&gt; DispatcherServlet#doService -&gt; DispatcherServlet#doDispatch</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><code>MultipartResolver</code></td><td style="text-align:left">resolveMultipart -&gt; MultipartHttpServletRequest</td><td style="text-align:left">解析多部分请求（如: 文件上传），封装Request为<code>MultipartHttpServletRequest</code>对象</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><code>HandlerMapping</code></td><td style="text-align:left">getHandler -&gt; HandlerExecutionChain(Handler+Interceptors)</td><td style="text-align:left">mapping <code>Request</code>:<code>Handler (+HandlerInterceptors)</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">eg: <code>RequestMappingHandlerMapping</code>支持标注<code>@RequestMapping</code>的<code>method</code></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><code>HandlerAdapter</code></td><td style="text-align:left">handle -&gt; ModelAndView(modelMap+viewName)</td><td style="text-align:left">invoke <code>Handler</code> -&gt; resolveArgument + doInvoke + handleReturnValue -&gt; <code>ModelAndView(modelMap+viewName)</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">eg: 1. <code>RequestMappingHandlerAdapter</code>支持标注<code>@RequestMapping</code>的<code>method</code> invoke and handle</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">eg: 2. <code>RequestResponseBodyMethodProcessor</code>(implements <code>HandlerMethodArgumentResolver</code>)支持标注<code>@RequestBody</code>的<code>method</code>的arguments resolve</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">eg: 3. <code>RequestResponseBodyMethodProcessor</code>(implements <code>HandlerMethodReturnValueHandler</code>)支持标注<code>@ResponseBody</code>的<code>method</code>的returnValue handle</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><code>HandlerExceptionResolver</code></td><td style="text-align:left">resolveException -&gt; ModelAndView</td><td style="text-align:left">处理以上发生的异常，返回一个<code>ModelAndView</code>对象供后续渲染处理</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><code>LocaleResolver</code></td><td style="text-align:left">resolveLocale -&gt; Locale</td><td style="text-align:left">从Request中解析出本地化对象<code>Locale</code> 供后面解析View及View的渲染使用，实现国际化</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><code>ViewResolver</code></td><td style="text-align:left">resolveViewName -&gt; View</td><td style="text-align:left">根据<code>ModelAndView#viewName</code> + <code>Locale</code> 解析得到最佳 <code>View</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">eg: ContentNegotiatingViewResolver</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">eg: InternalResourceViewResolver</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">eg: ThymeleafViewResolver</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><code>View</code></td><td style="text-align:left">render</td><td style="text-align:left">渲染视图(ctx: <code>ModelAndView#modelMap</code>)，得到最终效果供Response</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table></li><li><p>常用注解 (jar: <code>spring-web</code>: <code>org.springframework.web.bind.annotation</code>)</p><ul><li>控制器:<ul><li><code>@Controller</code></li><li><code>@RestController</code> = <code>@Controller</code>+<code>@ResponseBody</code></li></ul></li><li>映射:<ul><li><code>@RequestMapping</code></li><li><code>@GetMapping</code>,<code>@PostMapping</code>,<code>@PutMapping</code>,<code>@DeleteMapping</code>,<code>@PatchMapping</code></li></ul></li><li>请求:<ul><li><code>@RequestParam</code></li><li><code>@PathVariable</code></li><li><code>@CookieValue</code></li><li><code>@RequestPart</code></li><li><code>@RequestHeader</code></li><li><code>@RequestBody</code></li></ul></li><li>响应:<ul><li><code>@ResponseBody</code></li></ul></li><li>拦截（切面通知／处理）:<ul><li><code>@ControllerAdvice</code></li><li><code>@RestControllerAdvice</code></li><li><code>@ExceptionHandler</code></li></ul></li><li>属性: <ul><li><code>@ModelAttribute</code></li><li><code>@RequestAttribute</code></li><li><code>@SessionAttribute</code></li></ul></li><li>跨域:<ul><li><code>@CrossOrigin</code></li></ul></li></ul></li></ol><ol><li><p>视图处理</p><ul><li>视图解析 <code>ViewResolver#resolveViewName</code> -&gt; <code>View</code><ul><li>Order</li><li>return Matched View</li><li>Resource Location</li></ul></li><li>视图渲染 <code>View#render</code><ul><li>Context</li><li>TemplateEngine</li></ul></li></ul></li><li><p>内容协商处理</p><ul><li>解析器 <code>ContentNegotiatingViewResolver</code> (resolveViewName)</li><li>工厂 <code>ContentNegotiationManagerFactoryBean</code>（构建ContentNegotiationManager）</li><li>管理器 <code>ContentNegotiationManager</code>（管理ContentNegotiationStrategy）</li><li>策略 <code>ContentNegotiationStrategy</code> (resolveMediaTypes)</li><li>配置 <code>ContentNegotiationConfigurer</code></li></ul></li><li><p>框架：</p><ul><li><code>Spring WebMvc</code><ul><li>WebMvc总控DispatcherServlet注册: <code>web.xml</code> / <code>WebApplicationInitializer</code></li><li>WebMvc其他组件配置：<code>.xml</code> / <code>@Configuration</code> </li><li>独立Servlet容器启动运行</li></ul></li><li><code>SpringBoot WebMvc</code>(依赖<code>SpringWebMvc</code>，只是增加了自动化装配和配置部分)<ul><li>自动装配 <code>@EnableAutoConfiguration</code> : <ul><li>DispatcherServletAutoConfiguration: 装配WebMvc总控DispatcherServlet</li><li>ServletWebServerFactoryAutoConfiguration: 装配Servlet容器</li><li>WebMvcAutoConfiguration: 装配WebMvc其他组件</li></ul></li><li>配置: 自定义配置类装配 / 外部化配置<ul><li>自定义类 <code>@Configuration</code>(可implements <code>WebMvcConfigurer</code>方便添加其他配置)+<code>@Bean</code></li><li>外部化配置 <code>WebMvcProperties</code> : <code>spring.mvc.xxx</code> (eg: resources/application.properties)</li></ul></li><li>独立／嵌入式Servlet容器启动运行</li></ul></li><li>示例：参考上章 Servlet的例子<ul><li>Spring: Xml 方式</li><li>Spring: Annotation方式</li><li>SpringBoot: Auto config</li></ul></li></ul></li></ol><h3 id="header-36">模版视图之JSP</h3><p>Key:</p><ul><li>视图解析器：<code>InternalResourceViewResolver</code></li><li>视图：<code>JstlView</code></li><li>外部化配置：<code>WebMvcProperties</code></li></ul><p><strong> 示例(SpringBoot WebMvc)：</strong></p><ol><li><p>pom.xml</p><pre><code class="lang-xml"> &lt;dependencies&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;!-- jstl --&gt;     &lt;dependency&gt;         &lt;groupId&gt;javax.servlet&lt;/groupId&gt;         &lt;artifactId&gt;jstl&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;!-- 对jsp的支持的依赖 --&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;         &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;         &lt;scope&gt;provided&lt;/scope&gt;     &lt;/dependency&gt; &lt;/dependencies&gt;</code></pre></li><li><p>JSP Template：src/main/webapp/WEB-INF/jsp/hello.jsp</p><pre><code class="lang-xml"> &lt;!-- 使用jsp指令生成xml格式的文件: --&gt; &lt;jsp:root      xmlns:jsp=&quot;http://java.sun.com/JSP/Page&quot;      xmlns:c=&quot;http://java.sun.com/jsp/jstl/core&quot;     version=&quot;2.0&quot;&gt;     &lt;jsp:directive.page isELIgnored=&quot;false&quot;/&gt;     &lt;Hello&gt;         &lt;message&gt;${message}&lt;/message&gt;         &lt;language&gt;${acceptLanguage}&lt;/language&gt;         &lt;jsessionId&gt;${jsessionId}&lt;/jsessionId&gt;         &lt;users&gt;         &lt;c:forEach items=&quot;${users}&quot;  var=&quot;u&quot;&gt;           &lt;user&gt;${u}&lt;/user&gt;         &lt;/c:forEach&gt;         &lt;/users&gt;     &lt;/Hello&gt; &lt;/jsp:root&gt;</code></pre></li><li><p>Configure: resources/application.properties</p><ul><li>方式一：自定义配置类<pre><code class="lang-java">  @Configuration  public class WebMvcConfig {      /*       &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;          &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;          &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;          &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;       &lt;/bean&gt;       */      @Bean      public ViewResolver viewResolver(){          InternalResourceViewResolver viewResolver=new InternalResourceViewResolver();          viewResolver.setViewClass(JstlView.class);          viewResolver.setPrefix(&quot;/WEB-INF/jsp/&quot;);          viewResolver.setSuffix(&quot;.jsp&quot;);          return viewResolver;      }  }</code></pre></li><li>方式二：外部化配置(eg: resources/application.properties)<pre><code>  spring.mvc.view.prefix = /WEB-INF/jsp/  spring.mvc.view.suffix = .jsp</code></pre></li></ul></li><li><p>Controller: </p><ul><li>方式一：直接使用<code>Model#addAttribute</code><pre><code class="lang-java">  @Controller  public class HelloController {      @RequestMapping(value={&quot;/&quot;},method=RequestMethod.GET)      public String index(@RequestHeader(&quot;Accept-Language&quot;) String acceptLanguage              ,@CookieValue(&quot;JSESSIONID&quot;) String jsessionId              ,Model model) {          List&lt;String&gt; users=new ArrayList&lt;String&gt;();          users.add(&quot;Tom&quot;);          users.add(&quot;Susan&quot;);          users.add(&quot;Jack&quot;);          model.addAttribute(&quot;users&quot;, users);          model.addAttribute(&quot;message&quot;, &quot;Where are you?&quot;);          model.addAttribute(&quot;acceptLanguage&quot;,acceptLanguage);          model.addAttribute(&quot;jsessionId&quot;,jsessionId);          System.out.println(model);          return &quot;index&quot;;      }  }</code></pre></li><li>方式二：使用<code>@ModelAttribute</code><pre><code class="lang-java">  @Controller  public class HelloController {      @RequestMapping(value={&quot;/&quot;},method=RequestMethod.GET)      public String index(Model model){          List&lt;String&gt; users=new ArrayList&lt;String&gt;();          users.add(&quot;Tom&quot;);          users.add(&quot;Susan&quot;);          users.add(&quot;Jack&quot;);          model.addAttribute(&quot;users&quot;, users);          return &quot;index&quot;;      }      @ModelAttribute(&quot;message&quot;)      public String message(){          return &quot;Where are you?&quot;;      }      @ModelAttribute(&quot;acceptLanguage&quot;)      public String acceptLanguage(@RequestHeader(&quot;Accept-Language&quot;) String acceptLanguage){          return acceptLanguage;      }      @ModelAttribute(&quot;jsessionId&quot;)      public String jsessionId(@CookieValue(&quot;JSESSIONID&quot;) String jsessionId){          return jsessionId;      }  }</code></pre></li><li>方式三：使用<code>@ControllerAdvice</code><pre><code class="lang-java">  @Controller  public class HelloController {      @RequestMapping(value={&quot;/&quot;},method=RequestMethod.GET)      public String index(Model model){          return &quot;index&quot;;      }      @RequestMapping(value=&quot;/{num}&quot;,method=RequestMethod.GET)      public String doExTest(@PathVariable int num,Model model){          model.addAttribute(&quot;message&quot;,&quot;number:&quot;+num);          return &quot;index&quot;;      }  }  @ControllerAdvice(assignableTypes=HelloController.class)  public class HelloControllerAdvice {      @ModelAttribute(&quot;message&quot;)      public String message(){          return &quot;Where are you?&quot;;      }      @ModelAttribute(&quot;acceptLanguage&quot;)      public String acceptLanguage(@RequestHeader(&quot;Accept-Language&quot;) String acceptLanguage){          return acceptLanguage;      }      @ModelAttribute(&quot;jsessionId&quot;)      public String jsessionId(@CookieValue(&quot;JSESSIONID&quot;) String jsessionId){          return jsessionId;      }      @ExceptionHandler(Throwable.class)      public ResponseEntity&lt;String&gt; onException(Throwable ex){          return ResponseEntity.ok(&quot;handle exception:&quot;+ex.getMessage());      }  }</code></pre></li></ul></li><li><p>Main</p><pre><code class="lang-java"> @SpringBootApplication public class WebMvcViewApp {     public static void main(String[] args) {         SpringApplication.run(WebMvcViewApp.class,args);     } }</code></pre></li><li><p>Visit: <code>http://localhost:8080/</code></p><pre><code class="lang-xml"> &lt;Hello&gt;     &lt;message&gt;Where are you?&lt;/message&gt;     &lt;language&gt;zh-CN,zh;q=0.9,en;q=0.8&lt;/language&gt;     &lt;jsessionId&gt;node08vobe92o7xci1sb3hf7pn3dm56.node0&lt;/jsessionId&gt;     &lt;users&gt;         &lt;user&gt;Tom&lt;/user&gt;         &lt;user&gt;Susan&lt;/user&gt;         &lt;user&gt;Jack&lt;/user&gt;     &lt;/users&gt; &lt;/Hello&gt;</code></pre></li></ol><h3 id="header-37">模版视图之Thymeleaf</h3><p>Key:</p><ul><li>视图解析器ViewResolver：<code>ThymeleafViewResolver</code></li><li>视图View：<code>ThymeleaflView</code></li><li>模板引擎ITemplateEngine : <code>SpringTemplateEngine</code>/<code>SpringWebFluxTemplateEngine</code></li><li>外部化配置：<code>ThymeleafProperties</code></li></ul><p><strong> 示例(SpringBoot WebMvc)：</strong></p><ol><li><p>pom.xml</p><pre><code class="lang-xml"> &lt;dependency&gt;       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;       &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;     &lt;/dependency&gt;</code></pre></li><li><p>Thymeleaf Template: resources/templates/thymeleaf/hello.html</p><pre><code class="lang-html"> &lt;p th:text=&quot;${message}&quot;&gt;!!!&lt;/p&gt;</code></pre></li><li><p>Configure: resources/application.properties</p><pre><code> # ThymeleafProperties spring.thymeleaf.prefix=classpath:/templates/thymeleaf/ spring.thymeleaf.suffix=.html spring.thymeleaf.cache = false</code></pre></li><li><p>Controller</p><pre><code class="lang-java"> @Controller public class HelloController {     @GetMapping(&quot;/hello&quot;)     public String hello() {         model.addAttribute(&quot;message&quot;, &quot;Hello World&quot;);         return &quot;hello&quot;;     } }</code></pre></li><li><p>Main</p><pre><code class="lang-java"> @SpringBootApplication public class WebMvcViewApp {     public static void main(String[] args) {         SpringApplication.run(WebMvcViewApp.class,args);     } }</code></pre></li><li><p>Visit: <code>http://localhost:8080/hello</code></p></li></ol><p><strong> Thymeleaf模版处理流程: </strong></p><p><a href="https://www.thymeleaf.org/" target="_blank" rel="noopener">官网</a> | <a href="https://www.thymeleaf.org/documentation.html" target="_blank" rel="noopener">Doc</a> | <a href="https://www.thymeleaf.org/doc/articles/standarddialect5minutes.html" target="_blank" rel="noopener">Quict Start</a></p><ol><li><p>资源定位（模板来源 ）:</p><ul><li>文件资源： File</li><li>ClassPath资源： ClassLoader</li><li>统一资源： URL</li><li>Web资源： ServletContext</li><li>Spring 资源： ResourceLoader &amp; Resource</li></ul></li><li><p>渲染上下文（变量来源 ）: </p><ul><li>Spring Web MVC: <code>Model</code></li><li>Servlet: <code>Attribute</code></li><li>Thyemeaf: <code>Context</code></li></ul></li><li><p>模板引擎（模板渲染）</p><ul><li>Thymeleaf模板引擎：<code>interface ITemplateEngine</code><ul><li>Thymeleaf 原生实现: TemplateEngine</li><li>Spring 实现: SpringTemplateEngine</li><li>Spring WebFlux 实现: SpringWebFluxTemplateEngine</li></ul></li></ul></li><li><p>示例：使用 Thymeleaf API 渲染内容</p><pre><code class="lang-java"> public class ThymeleafTemplateEngineStarter {     public static void main(String[] args) throws IOException {         // 1. 资源定位，获取模板内容         //String content = &quot;&lt;p th:text=\&quot;${message}\&quot;&gt;!!!&lt;/p&gt;&quot;;         // 从 classpath:/templates/thymeleaf/hello.html 读取内容         ResourceLoader resourceLoader = new DefaultResourceLoader();         Resource resource = resourceLoader.getResource(&quot;classpath:/templates/thymeleaf/hello.html&quot;);         File templateFile = resource.getFile();         FileInputStream inputStream = new FileInputStream(templateFile);         ByteArrayOutputStream outputStream = new ByteArrayOutputStream();         IOUtils.copy(inputStream, outputStream);         inputStream.close();         String content = outputStream.toString(&quot;UTF-8&quot;);         // 2. 创建渲染上下文         Context context = new Context();         context.setVariable(&quot;message&quot;, &quot;Hello,World&quot;);         // 3. 使用模板引擎进行渲染         SpringTemplateEngine templateEngine = new SpringTemplateEngine();         String result = templateEngine.process(content, context);         System.out.println(result);     } }</code></pre><p> resources/templates/thymeleaf/hello.html</p><pre><code class="lang-html"> &lt;p th:text=&quot;${message}&quot;&gt;!!!&lt;/p&gt;</code></pre></li></ol><h3 id="header-38">多视图处理</h3><p><strong> 示例：多视图处理器并存</strong></p><ul><li>视图处理器：<ul><li>ContentNegotiatingViewResolver<ul><li>ThymeleafViewResolver</li><li>InternalResourceViewResolver</li></ul></li><li>ThymeleafViewResolver</li><li>InternalResourceViewResolver</li></ul></li><li>注意：<ul><li>ViewResolver Order</li><li>ViewResolver 模板资源查找 </li></ul></li><li>总结：<ul><li>按照ViewResolver Order，返回第一个可以resolve的View去render（eg：下面的两个Debug示例都只能有一个正确返回）</li><li>找不到Resource时就抛出异常</li></ul></li></ul><ol><li><p>pom.xml</p><pre><code class="lang-xml"> &lt;dependencies&gt;     &lt;dependency&gt;       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;       &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;!-- jstl --&gt;     &lt;dependency&gt;      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;      &lt;artifactId&gt;jstl&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;!-- 对jsp的支持的依赖 --&gt;     &lt;dependency&gt;       &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;       &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;       &lt;scope&gt;provided&lt;/scope&gt;     &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt;     &lt;plugins&gt;         &lt;plugin&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;         &lt;/plugin&gt;     &lt;/plugins&gt; &lt;/build&gt;</code></pre></li><li><p>Template:</p><ul><li>thymeleaf: resources/templates/thymeleaf/hello.html<pre><code class="lang-html">  &lt;p th:text=&quot;${message}&quot;&gt;!!!&lt;/p&gt;</code></pre></li><li>jsp: webapp/WEB-INF/jsp/index.jsp<pre><code class="lang-xml">  &lt;jsp:root   xmlns:jsp=&quot;http://java.sun.com/JSP/Page&quot;   xmlns:c=&quot;http://java.sun.com/jsp/jstl/core&quot;  version=&quot;2.0&quot;&gt;      &lt;jsp:directive.page isELIgnored=&quot;false&quot;/&gt;      &lt;Hello&gt;           &lt;message&gt;${message}&lt;/message&gt;      &lt;/Hello&gt;  &lt;/jsp:root&gt;</code></pre></li></ul></li><li><p>configure: resources/application.properties：</p><pre><code> # ThymeleafProperties spring.thymeleaf.prefix=classpath:/templates/thymeleaf/ spring.thymeleaf.suffix=.html spring.thymeleaf.cache = false # WebMvcProperties spring.mvc.view.prefix = /WEB-INF/jsp/ spring.mvc.view.suffix = .jsp</code></pre></li><li><p>Controller</p><pre><code class="lang-java"> @Controller public class HelloController {     @GetMapping(&quot;/&quot;)     public String index() {         return &quot;index&quot;;     }     @GetMapping(&quot;/hello&quot;)     public String hello() {         return &quot;hello&quot;;     }     @ModelAttribute(&quot;message&quot;)     public String message(){         return &quot;Where are you?&quot;;     } }</code></pre></li><li><p>Main</p><pre><code class="lang-java"> @SpringBootApplication public class WebMvcViewApp {     public static void main(String[] args) {         SpringApplication.run(WebMvcViewApp.class,args);     } }</code></pre></li><li><p>默认ThymeleafViewResolver的Order在InternalResourceViewResolver之前</p><ul><li>Debug得到：<ul><li>Ordered ViewResolver List:<ul><li>ContentNegotiatingViewResolver<ul><li>BeanNameViewResolver</li><li>ThymeleafViewResolver</li><li>ViewResolverComposite</li><li>InternalResourceViewResolver</li></ul></li><li>BeanNameViewResolver</li><li>ThymeleafViewResolver</li><li>ViewResolverComposite</li><li>InternalResourceViewResolver</li></ul></li><li>Verify: <ul><li>Visit: <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>    =&gt; Error(500:Error resolving template “index”, template might not exist or might not be accessible by any of the configured Template Resolvers)</li><li>Visit: <a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a> =&gt; Success </li></ul></li></ul></li></ul></li><li><p>将InternalResourceViewResolver(JstlView)顺序提到ThymeleafViewResolver(ThymeleafView)之前</p><ul><li><p>注释掉resources/application.properties中<code>WebMvcProperties</code>相关的配置</p><pre><code class="lang-properties">  # ThymeleafProperties  spring.thymeleaf.prefix=classpath:/templates/thymeleaf/  spring.thymeleaf.suffix=.html  spring.thymeleaf.cache = false  # WebMvcProperties  # spring.mvc.view.prefix = /WEB-INF/jsp/  # spring.mvc.view.suffix = .jsp</code></pre></li><li>自定义一个Configuration类，装载新配置的InternalResourceViewResolver<pre><code class="lang-java">  @Configuration  public class WebMvcConfig {      @Bean      public InternalResourceViewResolver viewResolver() {          InternalResourceViewResolver viewResolver=new InternalResourceViewResolver();          viewResolver.setPrefix(&quot;/WEB-INF/jsp/&quot;);          viewResolver.setSuffix(&quot;.jsp&quot;);          // ThymeleafAutoConfiguration: ThymeleafViewResolver Ordered.LOWEST_PRECEDENCE - 5          viewResolver.setOrder(Ordered.LOWEST_PRECEDENCE-10);          return viewResolver;      }   }</code></pre></li><li>Debug得到:<ul><li>Ordered ViewResolver List:<ul><li>InternalResourceViewResolver</li><li>BeanNameViewResolver</li><li>ViewResolverComposite</li><li>ThymeleafViewResolver</li></ul></li><li>Verify: <ul><li>Visit: <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>    =&gt; Success</li><li>Visit: <a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a> =&gt; Error(404)</li></ul></li></ul></li></ul></li><li><p>注：</p><ul><li>由于WebMvcProperties不提供order配置，所以无法通过外部化配置修改ViewResolver的顺序</li><li><p>由于上面使用了<code>public InternalResourceViewResolver viewResolver()</code>装载了一个name为<code>viewResolver</code>,class为<code>InternalResourceViewResolver</code>的Bean，所以就不会再装载<code>ContentNegotiatingViewResolver</code>和默认的<code>InternalResourceViewResolver</code>了（具体可参考<code>WebMvcAutoConfiguration</code>中的相关配置）</p><pre><code class="lang-java">  @Configuration  @ConditionalOnWebApplication(type = Type.SERVLET)  @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })  @ConditionalOnMissingBean(WebMvcConfigurationSupport.class)  @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)  @AutoConfigureAfter({ DispatcherServletAutoConfiguration.class,          ValidationAutoConfiguration.class })  public class WebMvcAutoConfiguration {      // ...      @Configuration      @Import(EnableWebMvcConfiguration.class)      @EnableConfigurationProperties({ WebMvcProperties.class, ResourceProperties.class })      @Order(0)      public static class WebMvcAutoConfigurationAdapter              implements WebMvcConfigurer, ResourceLoaderAware {          // ...           @Bean          @ConditionalOnMissingBean          public InternalResourceViewResolver defaultViewResolver() {              InternalResourceViewResolver resolver = new InternalResourceViewResolver();              resolver.setPrefix(this.mvcProperties.getView().getPrefix());              resolver.setSuffix(this.mvcProperties.getView().getSuffix());              return resolver;          }          @Bean          @ConditionalOnBean(ViewResolver.class)          @ConditionalOnMissingBean(name = &quot;viewResolver&quot;, value = ContentNegotiatingViewResolver.class)          public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) {              ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver();              resolver.setContentNegotiationManager(                      beanFactory.getBean(ContentNegotiationManager.class));              // ContentNegotiatingViewResolver uses all the other view resolvers to locate              // a view so it should have a high precedence              resolver.setOrder(Ordered.HIGHEST_PRECEDENCE);              return resolver;          }      }  }</code></pre></li></ul></li></ol><h3 id="header-39">内容协商视图解析器</h3><p><code>ContentNegotiatingViewResolver</code> (implements <code>ViewResolver</code>):</p><ol><li>优先级：最高（order=Ordered.HIGHEST_PRECEDENCE）</li><li>成员：<ul><li>包含<code>List&lt;ViewResolver&gt;</code>列表: 会包含除自己以外的所有装载的<code>ViewResolver</code>（按顺序）</li><li>包含内容协商管理工厂<code>ContentNegotiationManagerFactoryBean</code>: 生成内容协商管理器<code>ContentNegotiationManager</code></li><li>包含内容协商管理器<code>ContentNegotiationManager</code>: 管理内容协商策略<code>List&lt;ContentNegotiationStrategy&gt;</code>（用于获取HTTP Request的<code>MediaType</code>列表）</li></ul></li><li>方法：<ul><li><code>@Override resolveViewName-&gt;View</code><ul><li><code>getMediaTypes</code>： 获取与produce mediaType兼容的HTTP Request <code>MediaType</code>列表</li><li><code>getCandidateViews</code>： 获取所有可能的<code>View</code> (<code>ViewResolver#resolveViewName</code>视图解析得到的<code>View</code>)</li><li><code>getBestView</code>: 从上面获取的View中选取最佳匹配的<code>View</code><ul><li>HTTP Request <code>MediaType</code> &lt;-&gt; ViewResolver View <code>contentType</code> : 第一个匹配的那个View</li><li>注：<code>ViewResolver 顺序</code> 和 <code>Request的MediaType</code>匹配规则（Accept 头策略，请求参数策略，…）</li></ul></li></ul></li></ul></li><li>配置：<ul><li>自定义配置类：<code>@Configuration</code> + <code>implements WebMvcConfigurer</code> + <code>@Override configureContentNegotiation(ContentNegotiationConfigurer configurer)</code></li><li>外部化配置：<code>WebMvcProperties.Contentnegotiation</code></li></ul></li></ol><p><strong> 示例: 多视图处理器内容协商 </strong> </p><ol><li><p>上面Case，修改自定义配置类:</p><pre><code class="lang-java"> @Configuration public class WebMvcConfig {             // 1. 修改bean name为 myViewResolver     // 不与ContentNegotiatingViewResolver装载条件冲突,则系统会自动加载ContentNegotiatingViewResolver     // ContentNegotiatingViewResolver装载条件：     // @ConditionalOnBean(ViewResolver.class)     // @ConditionalOnMissingBean(name = &quot;viewResolver&quot;, value = ContentNegotiatingViewResolver.class)，     // 2. set viewResolver content-type (to distinguish with other viewResolvers&#39;)     @Bean     public InternalResourceViewResolver myViewResolver() {         InternalResourceViewResolver viewResolver=new InternalResourceViewResolver();         viewResolver.setPrefix(&quot;/WEB-INF/jsp/&quot;);         viewResolver.setSuffix(&quot;.jsp&quot;);         // ThymeleafAutoConfiguration: ThymeleafViewResolver Ordered.LOWEST_PRECEDENCE - 5         viewResolver.setOrder(Ordered.LOWEST_PRECEDENCE-10);         // Set ViewResolver Content-Type         viewResolver.setContentType(&quot;text/xml;charset=UTF-8&quot;);         return viewResolver;     }  }</code></pre></li><li><p>配置：</p><ul><li>方式一： 外部化配置<pre><code>  # WebMvcProperties contentnegotiation  # ?format=pdf  spring.mvc.contentnegotiation.favorParameter = true  # /users.pdf  spring.mvc.contentnegotiation.favorPathExtension = true</code></pre></li><li>方式二： 自定义Configuration类<pre><code class="lang-java">  @Configuration  public class WebMvcConfig implements WebMvcConfigurer {      //...      @Override      public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {          configurer.favorParameter(true)                  .favorPathExtension(true);      }  }</code></pre></li></ul></li><li><p>Debug得到：</p><ul><li>Ordered ViewResolver List:<ul><li>ContentNegotiatingViewResolver<ul><li>InternalResourceViewResolver ( Content-Type: text/xml;charset=UTF-8 )</li><li>BeanNameViewResolver</li><li>ThymeleafViewResolver ( Content-Type: text/html;charset=UTF-8 )</li><li>ViewResolverComposite</li></ul></li><li>InternalResourceViewResolver    </li><li>BeanNameViewResolver</li><li>ThymeleafViewResolver</li><li>ViewResolverComposite</li></ul></li><li>Verify:<ul><li><a href="http://localhost:8080/?format=xml" target="_blank" rel="noopener">http://localhost:8080/?format=xml</a> =&gt; Success (InternalResourceViewResolver resolved,show jsp page)</li><li><a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>  Accept:text/xml =&gt; Success (match InternalResourceViewResolver resolved, show jsp page)</li><li><a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a> =&gt; Success (ThymeleafViewResolver resolved, show thymeleaf page)</li></ul></li></ul></li></ol><h3 id="header-40">REST</h3><blockquote><p>REST = RESTful = Representational State Transfer,is one way of providing interoperability between computer systems on the Internet.</p></blockquote><ol><li><p>架构约束</p><ul><li>统一接口(Uniform interface) <ul><li>资源识别(Identification of resources)<ul><li>URI(Uniform Resource Identifier ) </li></ul></li><li>资源操作(Manipulation of resources through representations)<ul><li>HTTP verbs:GET、PUT、POST、DELETE </li></ul></li><li>自描述消息(Self-descriptive messages)<ul><li>Content-Type</li><li>MIME-Type</li><li>Media Type: application/javascript、text/html</li></ul></li><li>超媒体(HATEOAS)<ul><li>Hypermedia As The Engine Of Application State</li></ul></li></ul></li><li>C/S架构(Client-Server) </li><li>无状态(Stateless) </li><li>可缓存(Cacheable) </li><li>分层系统(Layered System) </li><li>按需代码(Code on demand)(可选)</li></ul></li><li><p>WebMvc Rest支持</p><ul><li>控制器：@Controller,@RestController (= @Controller+@ResponseBody)</li><li>映射：@RequestMapping,@XxxMapping(eg: @GetMapping,@PostMapping,@PutMapping,@DeleteMapping,@PatchMapping)</li><li>请求：@RequestParam,@PathVariable,@CookieValue,@RequestBody,@RequestHeader,RequestEntity(header+body)</li><li>响应：@ResponseBody,ResponseEntity(header+body),ResponseCookie</li><li>拦截：@ControllerAdvice,@RestControllerAdvice,interface HandlerInterceptor</li></ul></li><li><p>核心组件</p><ul><li><code>HandlerMethod</code>: 被<code>@RequestMapping/@XxxMapping</code>标注的方法 </li><li><code>RequestMappingHandlerMapping#getHandler</code>: 找到map <code>RequestMappingInfo</code>的<code>HandlerMethod</code><ul><li><code>RequestMappingInfo</code>: 存储解析出的@RequestMapping信息<ul><li>methods : @RequestMapping#method</li><li>params :  @RequestMapping#params</li><li>headers : @RequestMapping#headers</li><li>consumes : @RequestMapping#consumes 请求头 <code>Content-Type</code> 媒体类型映射</li><li>produces : @RequestMapping#produces  响应头 <code>Content-Type</code> 媒体类型映射 </li></ul></li></ul></li><li><code>RequestMappingHandlerAdapter#handle</code>: <code>HandlerMethod</code>的invoke and handle<ul><li><code>HandlerMethodArgumentResolver#resolveArgument</code> 处理方法参数解析器(解析HTTP请求内容为<code>HandlerMethod</code>的参数) <ul><li><code>RequestResponseBodyMethodProcessor</code>: 支持标注<code>@RequestBody</code>的<code>method</code>的arguments resolve<ul><li><code>HttpMessageConverter#read</code> : HTTP消息转换器，read: 反序列化HttpRequest</li></ul></li></ul></li><li><code>HandlerMethodReturnValueHandler#handleReturnValue</code> 处理方法返回值解析器(解析<code>HandlerMethod</code>返回值为HTTP响应内容)<ul><li><code>RequestResponseBodyMethodProcessor</code>: 支持标注<code>@ResponseBody</code>的<code>method</code>的returnValue handle<ul><li><code>ContentNegotiationManager#resolveMediaTypes</code> : 内容协商管理器，解析请求的媒体类型，返回合法的MediaTypes</li><li><code>HttpMessageConverter#write</code> : HTTP消息转换器，write: 序列化HttpResponse</li><li>注：ModelAndViewContainer#setRequestHandled:true -&gt; ModelAndView null -&gt; no viewResolver#resolveViewName and View#render call !</li></ul></li></ul></li></ul></li></ul></li><li><p>MediaType 媒体类型</p><ul><li>请求的媒体类型: <code>ContentNegotiationManager#resolveMediaTypes</code><ul><li>解析出HTTP Request中的媒体类型 (eg: <code>text/html</code>,<code>application/json</code>)</li><li>使用<code>ContentNegotiationStrategy#resolveMediaTypes</code>，有各种解析策略，例如：<ul><li>固定 MediaType : FixedContentNegotiationStrategy </li><li>“Accept” 请求头: HeaderContentNegotiationStrategy </li><li>请求参数: ParameterContentNegotiationStrategy </li><li>路径扩展名: PathExtensionContentNegotiationStrategy</li></ul></li><li>解析成功,返回合法 MediaType 列表</li><li>解析失败,返回单元素 <code>MediaType.ALL</code>(<code>*/*</code>) 媒体类型列表</li></ul></li><li>可消费的媒体类型: <code>@RequestMapping#consumes</code><ul><li>请求头 <code>Content-Type</code>的媒体类型</li><li>若请求头中的<code>Content-Type</code>和consumes中配置的不兼容，则该HandlerMethod不会被匹配到执行</li></ul></li><li>可生成的媒体类型: <code>@RequestMapping#produces</code>: <ul><li>响应头 <code>Content-Type</code> 的媒体类型</li><li>若配置了，则使用配置的MediaType列表</li><li>若未配置，则使用已注册的 HttpMessageConverter列表支持的MediaType列表</li><li>可用来匹配支持的<code>HttpMessageConverter</code>以序列化生成响应内容和生成响应头的<code>Content-Type</code>内容<ul><li>找到与请求的媒体类型兼容的MediaType列表，使用第一个匹配支持的HttpMessageConverter进行序列化，生成响应内容；</li><li>若未找到匹配的，则抛出415 HttpMediaTypeNotAcceptableException；</li></ul></li></ul></li></ul></li></ol><p><strong> 示例：REST </strong></p><ol><li>pom.xml<pre><code class="lang-xml"> &lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;</code></pre></li><li><p>Controller</p><pre><code class="lang-java"> @RestController public class UserController {     @GetMapping(value=&quot;/say&quot;)     public String say(@RequestParam(required = false) String message) {         return &quot;Say:&quot; + message;     }     @GetMapping(value=&quot;/saylimit&quot;,consumes=&quot;application/json&quot;,produces=&quot;text/html;charset=UTF-8&quot;)     public String saylimit(@RequestParam(required = false) String message) {         return &quot;Saylimit:&quot; + message;     }     @GetMapping(&quot;/users&quot;)     public Object listUsers() {         List&lt;User&gt; users=new ArrayList&lt;User&gt;();         users.add(new User(1,&quot;Tom&quot;));         users.add(new User(2,&quot;Lucy&quot;));         users.add(new User(3,&quot;Jack&quot;));         return users;     }     @PostMapping(&quot;/users&quot;)     public Object addUser(@RequestBody User user) {         System.out.println(&quot;addUser:&quot;+user);         return user;     } }</code></pre></li><li>main<pre><code class="lang-java"> @SpringBootApplication public class WebMvcRestApp {     public static void main( String[] args ){         SpringApplication.run(WebMvcRestApp.class, args);     } }</code></pre></li><li><p>Verify</p><ul><li><p>Get <code>/say?message=123</code></p><pre><code class="lang-bash">  $ curl -i http://localhost:8080/say?message=123  HTTP/1.1 200  Content-Type: text/plain;charset=UTF-8  Content-Length: 7  Date: Thu, 13 Dec 2018 07:43:44 GMT  Say:123  $ curl -i -H &quot;Content-Type:application/json&quot; http://localhost:8080/say?message=123  HTTP/1.1 200  Content-Type: text/plain;charset=UTF-8  Content-Length: 7  Date: Thu, 13 Dec 2018 08:44:02 GMT  Say:123</code></pre></li><li><p>Get <code>/saylimit?message=123</code></p><pre><code class="lang-bash">  $ curl -i http://localhost:8080/saylimit?message=123  HTTP/1.1 415  Content-Type: application/json;charset=UTF-8  Transfer-Encoding: chunked  Date: Thu, 13 Dec 2018 08:28:49 GMT  {&quot;timestamp&quot;:&quot;2018-12-13T08:42:21.574+0000&quot;,&quot;status&quot;:415,&quot;error&quot;:&quot;Unsupported Media Type&quot;,&quot;message&quot;:&quot;Content type &#39;&#39; not supported&quot;,&quot;path&quot;:&quot;/saylimit&quot;}  $ curl -i -H &quot;Content-Type:application/json&quot; http://localhost:8080/saylimit?message=123  HTTP/1.1 200  Content-Type: text/html;charset=UTF-8  Content-Length: 12  Date: Thu, 13 Dec 2018 08:43:05 GMT  Saylimit:123</code></pre></li><li><p>Get <code>/users</code></p><pre><code class="lang-bash">  $ curl -i http://localhost:8080/users  HTTP/1.1 200  Content-Type: application/json;charset=UTF-8  Transfer-Encoding: chunked  Date: Thu, 13 Dec 2018 07:45:47 GMT  [{&quot;id&quot;:1,&quot;name&quot;:&quot;Tom&quot;},{&quot;id&quot;:2,&quot;name&quot;:&quot;Lucy&quot;},{&quot;id&quot;:3,&quot;name&quot;:&quot;Jack&quot;}]</code></pre></li><li><p>Post <code>/users</code></p><pre><code class="lang-bash">  $ curl -i -X POST -d &quot;id=22&amp;name=Ketty&quot; http://localhost:8080/users  HTTP/1.1 415  Content-Type: application/json;charset=UTF-8  Transfer-Encoding: chunked  Date: Thu, 13 Dec 2018 07:47:13 GMT  {&quot;timestamp&quot;:&quot;2018-12-13T07:47:13.352+0000&quot;,&quot;status&quot;:415,&quot;error&quot;:&quot;Unsupported Media Type&quot;,&quot;message&quot;:&quot;Content type &#39;application/x-www-form-urlencoded;charset=UTF-8&#39; not supported&quot;,&quot;path&quot;:&quot;/users&quot;}  $ curl -i -X POST -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;id&quot;:22, &quot;name&quot;:&quot;Ketty&quot;}&#39; http://localhost:8080/users  HTTP/1.1 200  Content-Type: application/json;charset=UTF-8  Transfer-Encoding: chunked  Date: Thu, 13 Dec 2018 07:51:14 GMT  {&quot;id&quot;:22,&quot;name&quot;:&quot;Ketty&quot;}</code></pre></li></ul></li></ol><p><strong> 扩展示例：实现 <code>Content-Type</code> 为 <code>text/properties</code> 媒体类型的请求与响应，中间转换使用<code>Properties</code>对象 </strong></p><p>实现：</p><ul><li>方式一：依赖REST的<code>@RequestBody</code>和<code>@ResponseBody</code>(会使用<code>RequestResponseBodyMethodProcessor</code>-&gt;<code>HttpMessageConverter#read/write</code>)<ul><li>自定义<code>HttpMessageConverter</code>实现类来support <code>text/properties</code>媒体类型的 read &amp; write <ul><li>read: Request -&gt; Properties</li><li>write: Properties -&gt; Response</li></ul></li><li><code>@Configuration</code> + <code>implements WebMvcConfigurer</code>+ <code>@Override extendMessageConverters -&gt; converters#add/set</code></li></ul></li><li>方式二；不依赖REST的<code>@RequestBody</code>和<code>@ResponseBody</code><ul><li>自定义<code>HandlerMethodArgumentResolver</code>实现类，<code>@Override resolveArgument</code> 实现<code>text/properties</code> 媒体类型的请求解析为方法参数的<code>Properties</code>对象</li><li>自定义<code>HandlerMethodReturnValueHandler</code>实现类，<code>@Override handleReturnValue</code> 实现<code>Properties</code>类型方法返回值转化为<code>text/properties</code>媒体类型响应内容</li><li><code>@Configuration</code> + <code>implements WebMvcConfigurer</code>+ <code>@Override addArgumentResolvers</code> &amp; <code>@Override addReturnValueHandlers</code></li><li>注：上面自定义的实现类可复用上面自定义<code>HttpMessageConverter</code>实现类的<code>read/write</code>方法</li></ul></li></ul><p>示例（方式一）：    </p><ol><li><p>自定义HttpMessageConverter：        </p><pre><code class="lang-java"> public class PropertiesHttpMessageConverter extends AbstractGenericHttpMessageConverter&lt;Properties&gt;{     public PropertiesHttpMessageConverter() {         // 设置支持的 MediaType         super(new MediaType(&quot;text&quot;, &quot;properties&quot;));     }     @Override     public Properties read(Type type, Class&lt;?&gt; contextClass, HttpInputMessage inputMessage)             throws IOException, HttpMessageNotReadableException {         return readInternal(null, inputMessage);     }     @Override     protected void writeInternal(Properties properties, Type type, HttpOutputMessage outputMessage)             throws IOException, HttpMessageNotWritableException {         MediaType mediaType = outputMessage.getHeaders().getContentType();         Charset charset = mediaType.getCharset();         charset = (charset == null) ? Charset.forName(&quot;UTF-8&quot;) : charset;         Writer writer = new OutputStreamWriter(outputMessage.getBody(), charset);         properties.store(writer,&quot;From PropertiesHttpMessageConverter&quot;);     }     @Override     protected Properties readInternal(Class&lt;? extends Properties&gt; clazz, HttpInputMessage inputMessage)             throws IOException, HttpMessageNotReadableException {         MediaType mediaType = inputMessage.getHeaders().getContentType();         Charset charset = mediaType.getCharset();         charset = (charset == null) ? Charset.forName(&quot;UTF-8&quot;) : charset;         InputStreamReader reader = new InputStreamReader(inputMessage.getBody(),charset);         Properties properties = new Properties();         properties.load(reader);         return properties;     } }</code></pre></li><li>Configure: <code>WebMvcConfigurer#extendMessageConverters</code><pre><code class="lang-java"> @Configuration public class WebMvcConfig implements WebMvcConfigurer {         @Override     public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {         converters.add(new PropertiesHttpMessageConverter());     } }</code></pre></li><li><p>Controller</p><pre><code class="lang-java"> @RestController public class UserController {     //...     @PostMapping(value=&quot;/props&quot;,consumes = &quot;text/properties;charset=UTF-8&quot;)    // Content-Type 过滤媒体类型     public Object addProp(@RequestBody Properties prop) {         System.out.println(&quot;addProp:&quot;+prop);         return prop;     } }</code></pre></li><li>main<pre><code class="lang-java"> @SpringBootApplication public class WebMvcRestApp {     public static void main( String[] args ){         SpringApplication.run(WebMvcRestApp.class, args);     } }</code></pre></li><li><p>Verify</p><pre><code class="lang-bash"> $ curl -i X POST -H &quot;Content-Type: text/properties&quot; -d &#39;id:22&#39; http://localhost:8080/props HTTP/1.1 200 Content-Type: application/json;charset=UTF-8 Transfer-Encoding: chunked Date: Thu, 13 Dec 2018 09:13:34 GMT {&quot;id&quot;:&quot;22&quot;}</code></pre></li></ol><h3 id="header-41">跨域</h3><ul><li>注解驱动 <code>@CrossOrigin</code></li><li>代码驱动 <code>WebMvcConfigurer#addCorsMappings</code></li><li>过滤 <code>CorsFilter</code></li></ul><p><strong> 示例：</strong></p><ol><li><p>pom.xml</p><pre><code> &lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt;</code></pre></li><li><p>Controller</p><pre><code class="lang-java"> @Controller public class HelloController {     @GetMapping(&quot;/&quot;)     public String hello() {         return &quot;index&quot;;     } } @RestController public class UserController {     //@CrossOrigin(&quot;*&quot;)     @GetMapping(value=&quot;/say&quot;)     public String say(@RequestParam(required = false) String message) {         return &quot;Say:&quot; + message;     } }</code></pre></li><li><p>Configure</p><pre><code class="lang-java"> @Configuration public class WebMvcConfig implements WebMvcConfigurer {         public void addCorsMappings(CorsRegistry registry) {         registry.addMapping(&quot;/**&quot;).allowedOrigins(&quot;*&quot;);     } }</code></pre></li><li><p>resources/templates/index.html</p><pre><code class="lang-html"> &lt;!DOCTYPE html&gt; &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt;     &lt;title&gt;CORS 示例&lt;/title&gt;     &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;     &lt;script src=&quot;https://code.jquery.com/jquery-3.3.1.min.js&quot; &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;message&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;script&gt; $(document).ready(function(){      // Ajax 跨域 GET 请求      $.get( &quot;http://api.rest.org:8080/say?message=Hello&quot;, function( data ) {         alert( data );         $( &quot;#message&quot; ).html( data );      }); }); &lt;/script&gt; &lt;/html&gt;</code></pre></li><li><p>Visit <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p></li></ol><h2 id="header-42">WebMVC 源码分析</h2><h3 id="header-43">SpringBoot自动装配</h3><p>Key：</p><ol><li>配置类：<ul><li>DispatcherServlet : <code>DispatcherServletAutoConfiguration</code></li><li>WebMvc : <code>WebMvcAutoConfiguration</code> (替换<code>@EnableWebMvc</code>)</li><li>Servlet容器 ： <code>ServletWebServerFactoryAutoConfiguration</code></li></ul></li><li>装载顺序：<ul><li>绝对顺序： <code>@AutoConfigureOrder</code></li><li>相对顺序： <code>@AutoConfigureAfter</code></li></ul></li><li>装配条件<ul><li>Web 类型判断 <code>@ConditionalOnWebApplication(type = Type.SERVLET)</code></li><li>API 判断 <code>@ConditionalOnClass</code></li><li>Bean 判断 <code>@ConditionalOnMissingBean</code>,<code>@ConditionalOnBean</code></li></ul></li><li>外部化配置<ul><li>Web MVC 配置: <code>WebMvcProperties</code></li><li>资源配置: <code>ResourceProperties</code></li></ul></li></ol><p><strong> 部分源码：</strong></p><ol><li><p>META-INF/spring.factories:(jar:spring-boot-autoconfig)</p><pre><code class="lang-xml"> # Auto Configure org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\ org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\ org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\ #...</code></pre></li><li><p><code>ServletWebServerFactoryAutoConfiguration</code>,<code>DispatcherServletAutoConfiguration</code>,<code>WebMvcAutoConfiguration</code> 配置类:</p><pre><code class="lang-java"> // Servlet容器 配置类 @Configuration @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE) @ConditionalOnClass(ServletRequest.class) @ConditionalOnWebApplication(type = Type.SERVLET) @EnableConfigurationProperties(ServerProperties.class) @Import({ ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,         ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,         ServletWebServerFactoryConfiguration.EmbeddedJetty.class,         ServletWebServerFactoryConfiguration.EmbeddedUndertow.class }) public class ServletWebServerFactoryAutoConfiguration {     //... } // DispatcherServlet 配置类 @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE) @Configuration @ConditionalOnWebApplication(type = Type.SERVLET) @ConditionalOnClass(DispatcherServlet.class) @AutoConfigureAfter(ServletWebServerFactoryAutoConfiguration.class) @EnableConfigurationProperties(ServerProperties.class) public class DispatcherServletAutoConfiguration {     //... } // WebMvc 配置类 @Configuration @ConditionalOnWebApplication(type = Type.SERVLET) @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class }) @ConditionalOnMissingBean(WebMvcConfigurationSupport.class)        // 若已经有了WebMvcConfigurer.class则不会装载WebMvcAutoConfiguration @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10) @AutoConfigureAfter({ DispatcherServletAutoConfiguration.class,         ValidationAutoConfiguration.class }) public class WebMvcAutoConfiguration {     //...     @Configuration     @Import(EnableWebMvcConfiguration.class)     @EnableConfigurationProperties({ WebMvcProperties.class, ResourceProperties.class })     @Order(0)     public static class WebMvcAutoConfigurationAdapter             implements WebMvcConfigurer, ResourceLoaderAware {         //...     } }</code></pre></li><li><p>注：</p><ul><li>使用springboot自动装配，可不再使用<code>web.xml</code>配置</li><li><p><code>@EnableWebMvc</code>会装载<code>WebMvcConfigurationSupport</code>,所以使用了<code>@EnableWebMvc</code>后，<code>WebMvcAutoConfiguration</code>就不注入了（即WebMvc模块自动装载会失效)</p><pre><code class="lang-java">  // EnableWebMvc会装载Class：`WebMvcConfigurationSupport`  @Retention(RetentionPolicy.RUNTIME)  @Target(ElementType.TYPE)  @Documented  @Import(DelegatingWebMvcConfiguration.class)  public @interface EnableWebMvc {  }  @Configuration  public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {      //...  }</code></pre></li></ul></li></ol><h3 id="header-44">装载ThymeleafViewResolver</h3><p>加入<code>spring-boot-starter-thymeleaf</code>依赖包后，SpringBoot会自动装载<code>ThymeleafViewResolver</code></p><p>部分源码：</p><ol><li><p><code>META-INF/spring.factories</code>(jar: spring-boot-autoconfig)</p><pre><code> # Auto Configure org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\ #... # Template availability providers org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider=\ org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\ org.springframework.boot.autoconfigure.mustache.MustacheTemplateAvailabilityProvider,\ org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAvailabilityProvider,\ org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\ org.springframework.boot.autoconfigure.web.servlet.JspTemplateAvailabilityProvider</code></pre></li><li><p><code>ThymeleafAutoConfiguration</code></p><pre><code class="lang-java"> @Configuration @EnableConfigurationProperties(ThymeleafProperties.class) @ConditionalOnClass(TemplateMode.class) @AutoConfigureAfter({ WebMvcAutoConfiguration.class, WebFluxAutoConfiguration.class }) public class ThymeleafAutoConfiguration {     @Configuration     @ConditionalOnMissingBean(name = &quot;defaultTemplateResolver&quot;)     static class DefaultTemplateResolverConfiguration {         // ...     }     @Configuration     protected static class ThymeleafDefaultConfiguration {         // ...     }     @Configuration     @ConditionalOnWebApplication(type = Type.SERVLET)     @ConditionalOnProperty(name = &quot;spring.thymeleaf.enabled&quot;, matchIfMissing = true)     static class ThymeleafWebMvcConfiguration {         // ...         @Configuration         static class ThymeleafViewResolverConfiguration {             private final ThymeleafProperties properties;             private final SpringTemplateEngine templateEngine;             @Bean             @ConditionalOnMissingBean(name = &quot;thymeleafViewResolver&quot;)             public ThymeleafViewResolver thymeleafViewResolver() {                 ThymeleafViewResolver resolver = new ThymeleafViewResolver();                 resolver.setTemplateEngine(this.templateEngine);                 resolver.setCharacterEncoding(this.properties.getEncoding().name());                 resolver.setContentType(                         appendCharset(this.properties.getServlet().getContentType(),                                 resolver.getCharacterEncoding()));                 resolver.setExcludedViewNames(this.properties.getExcludedViewNames());                 resolver.setViewNames(this.properties.getViewNames());                 // This resolver acts as a fallback resolver (e.g. like a                 // InternalResourceViewResolver) so it needs to have low precedence                 resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 5);                 resolver.setCache(this.properties.isCache());                 return resolver;             }             // ...         }     }     @Configuration     @ConditionalOnWebApplication(type = Type.REACTIVE)     @ConditionalOnProperty(name = &quot;spring.thymeleaf.enabled&quot;, matchIfMissing = true)     static class ThymeleafReactiveConfiguration {         // ...     }     @Configuration     @ConditionalOnWebApplication(type = Type.REACTIVE)     @ConditionalOnProperty(name = &quot;spring.thymeleaf.enabled&quot;, matchIfMissing = true)     static class ThymeleafWebFluxConfiguration {         // ...     }     //... }</code></pre></li><li><p>ConfigurationProperties: ThymeleafProperties</p><pre><code class="lang-java"> @ConfigurationProperties(prefix = &quot;spring.thymeleaf&quot;) public class ThymeleafProperties {     private static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8;     public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;;     public static final String DEFAULT_SUFFIX = &quot;.html&quot;;     private String prefix = DEFAULT_PREFIX;     private String suffix = DEFAULT_SUFFIX;     private boolean cache = true;     //...     public static class Servlet {         private MimeType contentType = MimeType.valueOf(&quot;text/html&quot;);         // get/setContentType     } }</code></pre></li><li><p>ThymeleafTemplateAvailabilityProvider</p><pre><code class="lang-java"> public class ThymeleafTemplateAvailabilityProvider         implements TemplateAvailabilityProvider {     @Override     public boolean isTemplateAvailable(String view, Environment environment,             ClassLoader classLoader, ResourceLoader resourceLoader) {         if (ClassUtils.isPresent(&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;,                 classLoader)) {             String prefix = environment.getProperty(&quot;spring.thymeleaf.prefix&quot;,                     ThymeleafProperties.DEFAULT_PREFIX);             String suffix = environment.getProperty(&quot;spring.thymeleaf.suffix&quot;,                     ThymeleafProperties.DEFAULT_SUFFIX);             return resourceLoader.getResource(prefix + view + suffix).exists();         }         return false;     } }</code></pre></li></ol><h3 id="header-45">ContentNegotiatingViewResolver</h3><!-- ![contentNegotiatingViewResolver](2018-09-15-Spring-Boot/contentNegotiatingViewResolver.png) --><p><code>ContentNegotiatingViewResolver</code>:</p><ul><li>成员：<ul><li>Order: <ul><li><code>Ordered.HIGHEST_PRECEDENCE</code> 最高优先级</li></ul></li><li>视图解析器列表<code>List&lt;ViewResolver&gt;</code>: 会包含除自己以外的所有装载的<code>ViewResolver</code>（按顺序）<ul><li>ViewResolver#resolveViewName(viewName,local) -&gt; View</li></ul></li><li>内容协商管理工厂<code>ContentNegotiationManagerFactoryBean</code>: 用于生成内容协商管理器<code>ContentNegotiationManager</code><ul><li>ContentNegotiationManagerFactoryBean#build() -&gt; ContentNegotiationManager</li></ul></li><li>内容协商管理器<code>ContentNegotiationManager</code>: 管理内容协商策略<code>ContentNegotiationStrategy</code>（用于获取HTTP Request的<code>MediaType</code>列表）<ul><li><code>List&lt;ContentNegotiationStrategy&gt;</code> , eg:<ul><li>固定 MediaType : FixedContentNegotiationStrategy </li><li>“Accept” 请求头: HeaderContentNegotiationStrategy </li><li>请求参数: ParameterContentNegotiationStrategy </li><li>路径扩展名: PathExtensionContentNegotiationStrategy</li></ul></li><li><code>ContentNegotiationManager#resolveMediaTypes(request)</code> -&gt; List<mediatype></mediatype></li><li><code>ContentNegotiationManager#resolveFileExtensions(mediaType)</code> -&gt; List<string></string></li></ul></li></ul></li><li>Override 方法：<code>resolveViewName</code><ul><li><code>getMediaTypes</code>: 获取与produce兼容的HTTP Request <code>MediaType</code> （使用<code>ContentNegotiationManager</code>的<code>ContentNegotiationStrategy</code>获取HTTP Request <code>MediaType</code>）</li><li><code>getCandidateViews</code>: 获取所有可能的View (ViewResolver视图解析得到View)</li><li><code>getBestView</code>: 从上面获取的View中选取最佳匹配的View<ul><li>HTTP Request <code>MediaType</code> &lt;-&gt; ViewResolver View <code>contentType</code> : 第一个匹配的那个View</li><li>注：<code>ViewResolver 顺序</code> 和 <code>Request的MediaType</code>（Accept 头策略，请求参数策略，…）</li></ul></li></ul></li></ul><p><strong> 部分源码：</strong></p><p>Key:</p><ul><li><p>Member vars:</p><ul><li><code>order</code>: Ordered.HIGHEST_PRECEDENCE</li><li><code>ContentNegotiationManager</code></li><li><code>ContentNegotiationManagerFactoryBean</code></li><li><code>List&lt;ViewResolver&gt;</code> viewResolvers</li><li><code>List&lt;View&gt;</code> defaultViews</li></ul></li><li><p>@Override <code>resolveViewName</code></p><ul><li><code>List&lt;MediaType&gt; requestedMediaTypes</code> = getMediaTypes(((ServletRequestAttributes) attrs).getRequest());<ul><li><code>List&lt;MediaType&gt; acceptableMediaTypes</code> = this.contentNegotiationManager.resolveMediaTypes(new ServletWebRequest(request));</li><li><code>List&lt;MediaType&gt; producibleMediaTypes</code> = new ArrayList&lt;&gt;(request.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE));</li><li>foreach acceptableMediaTypes -&gt; foreach producibleMediaTypes -&gt; acceptable.isCompatibleWith(producible) -&gt; add</li><li>MediaType.sortBySpecificityAndQuality</li></ul></li><li><code>List&lt;View&gt; candidateViews</code> = getCandidateViews(viewName, locale, requestedMediaTypes);<ul><li>foreach this.viewResolvers<ul><li>candidateViews.add(viewResolver.resolveViewName(viewName, locale))</li><li>extensions = this.contentNegotiationManager.resolveFileExtensions(requestedMediaType);</li><li>foreach extensions -&gt; candidateViews.add(viewResolver.resolveViewName(viewName + ‘.’ + extension, locale))</li></ul></li><li>candidateViews.addAll(this.defaultViews)</li></ul></li><li><code>View bestView</code> = getBestView(candidateViews, requestedMediaTypes, attrs);<ul><li>foreach candidateViews -&gt; instanceof SmartView &amp;&amp; isRedirectView -&gt; return candidateView</li><li>foreach requestedMediaType:requestedMediaTypes<ul><li>foreach candidateView:candidateViews<ul><li>candidateContentType = MediaType.parseMediaType(candidateView.getContentType())</li><li>requestMediaType.isCompatibleWith(candidateContentType) -&gt; return candidateView</li></ul></li></ul></li></ul></li><li>return <code>bestView</code></li></ul></li></ul><ol><li><p><code>ContentNegotiatingViewResolver#resolveViewName</code> -&gt; <code>View</code></p><ul><li>getMediaTypes</li><li>getCandidateViews</li><li><p>getBestView</p><pre><code class="lang-java">public class ContentNegotiatingViewResolver   extends WebApplicationObjectSupport   implements ViewResolver, Ordered, InitializingBean {  private int order = Ordered.HIGHEST_PRECEDENCE;  @Nullable  private ContentNegotiationManager contentNegotiationManager;  private final ContentNegotiationManagerFactoryBean cnmFactoryBean = new ContentNegotiationManagerFactoryBean();  @Nullable  private List&lt;View&gt; defaultViews;  @Nullable  private List&lt;ViewResolver&gt; viewResolvers;  @Override  protected void initServletContext(ServletContext servletContext) {      Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(obtainApplicationContext(), ViewResolver.class).values();      if (this.viewResolvers == null) {          this.viewResolvers = new ArrayList&lt;&gt;(matchingBeans.size());          for (ViewResolver viewResolver : matchingBeans) {              if (this != viewResolver) {                  this.viewResolvers.add(viewResolver);              }          }      }      else {          for (int i = 0; i &lt; this.viewResolvers.size(); i++) {              ViewResolver vr = this.viewResolvers.get(i);              if (matchingBeans.contains(vr)) {                  continue;              }              String name = vr.getClass().getName() + i;              obtainApplicationContext().getAutowireCapableBeanFactory().initializeBean(vr, name);          }      }      AnnotationAwareOrderComparator.sort(this.viewResolvers);    // sort!      this.cnmFactoryBean.setServletContext(servletContext);  }  @Override  public void afterPropertiesSet() {      if (this.contentNegotiationManager == null) {          this.contentNegotiationManager = this.cnmFactoryBean.build();      }  }  @Override  @Nullable  public View resolveViewName(String viewName, Locale locale) throws Exception {      RequestAttributes attrs = RequestContextHolder.getRequestAttributes();      Assert.state(attrs instanceof ServletRequestAttributes, &quot;No current ServletRequestAttributes&quot;);      List&lt;MediaType&gt; requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest());      if (requestedMediaTypes != null) {          List&lt;View&gt; candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes);          View bestView = getBestView(candidateViews, requestedMediaTypes, attrs);          if (bestView != null) {              return bestView;          }      }      if (this.useNotAcceptableStatusCode) {          if (logger.isDebugEnabled()) {              logger.debug(&quot;No acceptable view found; returning 406 (Not Acceptable) status code&quot;);          }          return NOT_ACCEPTABLE_VIEW;      }      else {          logger.debug(&quot;No acceptable view found; returning null&quot;);          return null;      }  }  @Nullable  protected List&lt;MediaType&gt; getMediaTypes(HttpServletRequest request) {      try {          ServletWebRequest webRequest = new ServletWebRequest(request);          List&lt;MediaType&gt; acceptableMediaTypes = this.contentNegotiationManager.resolveMediaTypes(webRequest);          List&lt;MediaType&gt; producibleMediaTypes = getProducibleMediaTypes(request);          Set&lt;MediaType&gt; compatibleMediaTypes = new LinkedHashSet&lt;&gt;();          for (MediaType acceptable : acceptableMediaTypes) {              for (MediaType producible : producibleMediaTypes) {                  if (acceptable.isCompatibleWith(producible)) {                      compatibleMediaTypes.add(getMostSpecificMediaType(acceptable, producible));                  }              }          }          List&lt;MediaType&gt; selectedMediaTypes = new ArrayList&lt;&gt;(compatibleMediaTypes);          MediaType.sortBySpecificityAndQuality(selectedMediaTypes);          return selectedMediaTypes;      }      catch (HttpMediaTypeNotAcceptableException ex) {          return null;      }  }  @SuppressWarnings(&quot;unchecked&quot;)  private List&lt;MediaType&gt; getProducibleMediaTypes(HttpServletRequest request) {      Set&lt;MediaType&gt; mediaTypes = (Set&lt;MediaType&gt;)              request.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);      if (!CollectionUtils.isEmpty(mediaTypes)) {          return new ArrayList&lt;&gt;(mediaTypes);      }      else {          return Collections.singletonList(MediaType.ALL);      }  }  private List&lt;View&gt; getCandidateViews(String viewName, Locale locale, List&lt;MediaType&gt; requestedMediaTypes)          throws Exception {      List&lt;View&gt; candidateViews = new ArrayList&lt;&gt;();      if (this.viewResolvers != null) {          for (ViewResolver viewResolver : this.viewResolvers) {              View view = viewResolver.resolveViewName(viewName, locale);              if (view != null) {                  candidateViews.add(view);              }              for (MediaType requestedMediaType : requestedMediaTypes) {                  List&lt;String&gt; extensions = this.contentNegotiationManager.resolveFileExtensions(requestedMediaType);                  for (String extension : extensions) {                      String viewNameWithExtension = viewName + &#39;.&#39; + extension;                      view = viewResolver.resolveViewName(viewNameWithExtension, locale);                      if (view != null) {                          candidateViews.add(view);                      }                  }              }          }      }      if (!CollectionUtils.isEmpty(this.defaultViews)) {          candidateViews.addAll(this.defaultViews);      }      return candidateViews;  }  @Nullable  private View getBestView(List&lt;View&gt; candidateViews, List&lt;MediaType&gt; requestedMediaTypes, RequestAttributes attrs) {      for (View candidateView : candidateViews) {          if (candidateView instanceof SmartView) {              SmartView smartView = (SmartView) candidateView;              if (smartView.isRedirectView()) {                  if (logger.isDebugEnabled()) {                      logger.debug(&quot;Returning redirect view [&quot; + candidateView + &quot;]&quot;);                  }                  return candidateView;              }          }      }      for (MediaType mediaType : requestedMediaTypes) {          for (View candidateView : candidateViews) {              if (StringUtils.hasText(candidateView.getContentType())) {                  MediaType candidateContentType = MediaType.parseMediaType(candidateView.getContentType());                  if (mediaType.isCompatibleWith(candidateContentType)) {                      if (logger.isDebugEnabled()) {                          logger.debug(&quot;Returning [&quot; + candidateView + &quot;] based on requested media type &#39;&quot; +                                  mediaType + &quot;&#39;&quot;);                      }                      attrs.setAttribute(View.SELECTED_CONTENT_TYPE, mediaType, RequestAttributes.SCOPE_REQUEST);                      return candidateView;                  }              }          }      }      return null;  }  //...}</code></pre></li></ul></li><li><p><code>ContentNegotiationManagerFactoryBean#build</code> -&gt; <code>new ContentNegotiationManager(strategies)</code></p><pre><code class="lang-java"> public class ContentNegotiationManagerFactoryBean         implements FactoryBean&lt;ContentNegotiationManager&gt;, ServletContextAware, InitializingBean {     // ...     public ContentNegotiationManager build() {         List&lt;ContentNegotiationStrategy&gt; strategies = new ArrayList&lt;&gt;();         if (this.strategies != null) {             strategies.addAll(this.strategies);         }         else {             if (this.favorPathExtension) {                 PathExtensionContentNegotiationStrategy strategy;                 if (this.servletContext != null &amp;&amp; !useRegisteredExtensionsOnly()) {                     strategy = new ServletPathExtensionContentNegotiationStrategy(this.servletContext, this.mediaTypes);                 }                 else {                     strategy = new PathExtensionContentNegotiationStrategy(this.mediaTypes);                 }                 strategy.setIgnoreUnknownExtensions(this.ignoreUnknownPathExtensions);                 if (this.useRegisteredExtensionsOnly != null) {                     strategy.setUseRegisteredExtensionsOnly(this.useRegisteredExtensionsOnly);                 }                 strategies.add(strategy);             }             if (this.favorParameter) {                 ParameterContentNegotiationStrategy strategy = new ParameterContentNegotiationStrategy(this.mediaTypes);                 strategy.setParameterName(this.parameterName);                 if (this.useRegisteredExtensionsOnly != null) {                     strategy.setUseRegisteredExtensionsOnly(this.useRegisteredExtensionsOnly);                 }                 else {                     strategy.setUseRegisteredExtensionsOnly(true);  // backwards compatibility                 }                 strategies.add(strategy);             }             if (!this.ignoreAcceptHeader) {                 strategies.add(new HeaderContentNegotiationStrategy());             }             if (this.defaultNegotiationStrategy != null) {                 strategies.add(this.defaultNegotiationStrategy);             }         }         this.contentNegotiationManager = new ContentNegotiationManager(strategies);         return this.contentNegotiationManager;     } }</code></pre></li><li><p>ContentNegotiationManager</p><ul><li>resolveMediaTypes: <code>ContentNegotiationStrategy#resolveMediaTypes</code></li><li><p>resolveFileExtensions: <code>MediaTypeFileExtensionResolver#resolveFileExtensions</code></p><pre><code class="lang-java">public class ContentNegotiationManager implements ContentNegotiationStrategy, MediaTypeFileExtensionResolver {  private final List&lt;ContentNegotiationStrategy&gt; strategies = new ArrayList&lt;&gt;();  private final Set&lt;MediaTypeFileExtensionResolver&gt; resolvers = new LinkedHashSet&lt;&gt;();  @Override  public List&lt;MediaType&gt; resolveMediaTypes(NativeWebRequest request) throws HttpMediaTypeNotAcceptableException {      for (ContentNegotiationStrategy strategy : this.strategies) {          List&lt;MediaType&gt; mediaTypes = strategy.resolveMediaTypes(request);          if (mediaTypes.equals(MEDIA_TYPE_ALL_LIST)) {              continue;          }          return mediaTypes;      }      return MEDIA_TYPE_ALL_LIST;  }  @Override  public List&lt;String&gt; resolveFileExtensions(MediaType mediaType) {      Set&lt;String&gt; result = new LinkedHashSet&lt;&gt;();      for (MediaTypeFileExtensionResolver resolver : this.resolvers) {          result.addAll(resolver.resolveFileExtensions(mediaType));      }      return new ArrayList&lt;&gt;(result);  }  // ... }@FunctionalInterfacepublic interface ContentNegotiationStrategy {  List&lt;MediaType&gt; MEDIA_TYPE_ALL_LIST = Collections.singletonList(MediaType.ALL);  List&lt;MediaType&gt; resolveMediaTypes(NativeWebRequest webRequest)          throws HttpMediaTypeNotAcceptableException;｝</code></pre></li></ul></li></ol><h3 id="header-46">DispatcherServlet</h3><p><img src="/2018/09/15/webmvc-handler.png" alt="webmvc"></p><!-- ![webmvc](2018-09-15-Spring-Boot/webmvc-view.png)![webmvc-view](2018-09-15-Spring-Boot/webmvc-rest.png) --><p>package org.springframework.web.servlet;</p><ol><li><p><code>DispatcherServlet#doDispatch(request,response)</code></p><ul><li>HandlerExecutionChain { handler(eg:HandlerMethod) &amp; interceptorList }<ul><li>List<handlermapping> handlerMappings</handlermapping></li><li>HandlerMapping#getHandler!=null</li></ul></li><li>HandlerAdapter<ul><li>List<handleradapter> handlerAdapters</handleradapter></li><li>HandlerAdapter#support</li></ul></li><li>ModelAndView { model:ModelMap,view(eg:viewName) }<ul><li>HandlerAdapter#handle</li><li>HandlerAdapter#invokeHandlerMethod</li></ul></li><li>View<ul><li>List<viewresolver> viewResolvers</viewresolver></li><li>ViewResolver#resolveViewName(ModelAndView#view,local)</li></ul></li><li>View#render(ModelAndView#model)</li></ul></li><li><p><code>HandlerMapping#getHandler -&gt; HandlerExecutionChain</code></p><pre><code class="lang-java"> /* HandlerMapping     - AbstractHandlerMapping         + AbstractHandlerMethodMapping&lt;T&gt;             - RequestMappingInfoHandlerMapping&lt;RequestMappingInfo&gt;                 * RequestMappingHandlerMapping         + AbstractUrlHandlerMapping             - AbstractDetectingUrlHandlerMapping                 * BeanNameUrlHandlerMapping             - SimpleUrlHandlerMapping         + EmptyHandlerMapping */</code></pre><ul><li>AbstractHandlerMapping<ul><li>getHandler<ul><li>abstract getHandlerInternal</li></ul></li></ul></li><li>AbstractHandlerMethodMapping<t><ul><li>afterPropertiesSet -&gt; initHandlerMethods -&gt; detectHandlerMethods<ul><li>abstract getMappingForMethod</li><li>registerHandlerMethod</li></ul></li><li>override getHandlerInternal -&gt; lookupHandlerMethod<ul><li>abstract getMatchingMapping</li><li>protected handleMatch</li><li>protected handleNoMatch</li></ul></li></ul></t></li><li>RequestMappingInfoHandlerMapping<requestmappinginfo><ul><li>override getMatchingMapping</li><li>override handleMatch</li><li>override handleNoMatch</li></ul></requestmappinginfo></li><li>RequestMappingHandlerMapping<ul><li>override getMappingForMethod -&gt; createRequestMappingInfo</li></ul></li></ul></li><li><p><code>HandlerAdapter#handle -&gt; ModelAndView{modelMap,viewName}</code></p><pre><code class="lang-java"> /* HandlerAdapter     - AbstractHandlerMethodAdapter         * RequestMappingHandlerAdapter     - HttpRequestHandlerAdapter     - SimpleControllerHandlerAdapter     - SimpleServletHandlerAdapter HandlerMethodArgumentResolver     - AbstractMessageConverterMethodArgumentResolver         + AbstractMessageConverterMethodProcessor             * RequestResponseBodyMethodProcessor             * HttpEntityMethodProcessor         + RequestPartMethodArgumentResolver     - ... HandlerMethodReturnValueHandler     - AbstractMessageConverterMethodProcessor         * RequestResponseBodyMethodProcessor         * HttpEntityMethodProcessor     - ... HttpMessageConverter     - AbstractHttpMessageConverter&lt;T&gt;         + AbstractGenericHttpMessageConverter&lt;T&gt;             - AbstractJackson2HttpMessageConverter                 * MappingJackson2HttpMessageConverter                 * MappingJackson2XmlHttpMessageConverter                 * ...             - AbstractJsonHttpMessageConverter                 * GsonHttpMessageConverter                 * JsonbHttpMessageConverter             - PropertiesHttpMessageConverter             - ResourceRegionHttpMessageConverter         + ByteArrayHttpMessageConverter         + ObjectToStringHttpMessageConverter         + ResourceHttpMessageConverter         + StringHttpMessageConverter         + ...     - ... */</code></pre><ul><li>AbstractHandlerMethodAdapter<ul><li>support: expects the handler to be an <code>HandlerMethod</code><ul><li>abstract supportsInternal</li></ul></li><li>handler<ul><li>abstract handleInternal</li></ul></li></ul></li><li>RequestMappingHandlerAdapter<ul><li>afterPropertiesSet</li><li>override supportsInternal : return true</li><li>override handleInternal -&gt; invokeHandleMethod -&gt; ServletInvocableHandlerMethod#invokeAndHandle<ul><li>getMethodArgumentValues(HandlerMethodArgumentResolverComposite#resolveArgument)</li><li>doInvoke</li><li>handleReturnValue (HandlerMethodReturnValueHandlerComposite#handleReturnValue)</li></ul></li></ul></li><li>RequestResponseBodyMethodProcessor (extends AbstractMessageConverterMethodProcessor)<ul><li>resolve method args for <code>@RequestBody</code>(implements HandlerMethodArgumentResolver)<ul><li>supportsParameter</li><li>resolveArgument<ul><li>HttpMessageConverter#canRead</li><li>HttpMessageConverter#read</li></ul></li></ul></li><li>handle return value for <code>@ResponseBody</code>(implements HandlerMethodReturnValueHandler) <ul><li>supportsReturnType</li><li>handleReturnValue<ul><li>HttpMessageConverter#canWrite</li><li>HttpMessageConverter#write</li></ul></li></ul></li></ul></li></ul></li><li><p><code>ViewResolver#resolveViewName(ModelAndView#viewName) -&gt; View</code></p><pre><code class="lang-java"> /* ViewResolver  - AbstractCachingViewResolver      + ResourceBundleViewResolver      + ThymeleafViewResolver          - AjaxThymeleafViewResolver      + UrlBasedViewResolver          - AbstractTemplateViewResolver              * FreeMarkerViewResolver              * GroovyMarkupViewResolver          - InternalResourceViewResolver          - ...      + XmlViewResolver  - BeanNameViewResolver  - ContentNegotiatingViewResolver  - ViewResolverComposite */</code></pre><ul><li>ThymeleafViewResolver (Integer.MAX_VALUE)</li><li>ContentNegotiatingViewResolver (Ordered.HIGHEST_PRECEDENCE)</li><li>InternalResourceViewResolver (Ordered.LOWEST_PRECEDENCE)</li><li>ViewResolverComposite (Ordered.LOWEST_PRECEDENCE)</li></ul></li><li><p><code>View#render(ModelAndView#modelMap)</code></p><pre><code class="lang-java"> /* View     - AbstractView         + AbstractFeedView&lt;T extends WireFeed&gt;             * AbstractAtomFeedView             * AbstractRssFeedView         + AbstractJackson2View             * MappingJackson2JsonView             * MappingJackson2XmlView         + AbstractPdfView         + AbstractUrlBasedView             - AbstractTemplateView                 * FreeMarkerView                 * GroovyMarkupView             - InternalResourceView                 * JstlView             - RedirectView             - AbstractPdfStamperView             - ScriptTemplateView             - TilesView             - XsltView         + AbstractXlsView             - AbstractXlsxView                 * AbstractXlsxStreamingView         + MarshallingView     - AbstractThymeleafView         + ThymeleafView             - AjaxThymeleafView                 * FlowAjaxThymeleafView */</code></pre><ul><li>JstlView</li><li>ThymeleafView</li><li>FreeMarkerView</li><li>RedirectView</li><li>MappingJackson2JsonView</li></ul></li></ol><p><strong> 部分源码：</strong></p><ol><li><p>DispatcherServlet (总控)</p><pre><code class="lang-java">// 1. DispatcherServletpublic class DispatcherServlet extends FrameworkServlet { @Override protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception =&gt; doDispatch(request, response); protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception =&gt; {     // 2.1 HandlerMapping -&gt; HandlerExecutionChain: handler &amp; interceptorList     // eg: RequestMappingHandlerMapping -&gt; HandlerExecutionChain: handler (HandlerMethod) &amp; interceptorList     HandlerExecutionChain mappedHandler = getHandler(processedRequest);     =&gt; {         for (HandlerMapping hm : this.handlerMappings) {             HandlerExecutionChain handler = hm.getHandler(request);             if (handler != null) {                 return handler;             }         }     }     // 2.2 HandlerAdapter     // eg: RequestMappingHandlerAdapter     HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());     =&gt;{         for (HandlerAdapter ha : this.handlerAdapters) {             if (ha.supports(handler)) {                 return ha;             }         }     }     // 2.3 HandlerAdapter -&gt; invoke handlerMethod -&gt; ModelAndView: ModelMap &amp; View (eg: viewName) &amp; HttpStatus     ModelAndView mv = ha.handle(processedRequest, response, mappedHandler.getHandler());     // 2.4 ViewResolver -&gt; View -&gt; Render &amp; Response     processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);     =&gt;{         if(dispatchException!=null){             if dispatchException instanceof ModelAndViewDefiningException                 mv = ((ModelAndViewDefiningException) exception).getModelAndView();             else                 mv = processHandlerException(request, response, handler, exception);                     /*=&gt; {                         for (HandlerExceptionResolver handlerExceptionResolver : this.handlerExceptionResolvers) {                             exMv = handlerExceptionResolver.resolveException(request, response, handler, ex);                             if (exMv != null) {                                 break;                             }                         }                     }*/         }         render(mv, request, response);         =&gt;{             String viewName = mv.getViewName();             View view = resolveViewName(viewName, mv.getModelInternal(), locale, request);                 /*=&gt; {                     for (ViewResolver viewResolver : this.viewResolvers) {                         View view = viewResolver.resolveViewName(viewName, locale);                         if (view != null) {                             return view;                         }                     }                 }*/             view.render(mv.getModelInternal(), request, response);         }         mappedHandler.triggerAfterCompletion(request, response, null);     }     // final{...} }}</code></pre></li><li><p>HandlerMapping: RequestMappingHandlerMapping</p><ul><li>内部相当于维护了一个<code>Map&lt;RequestMappingInfo,HandlerMethod&gt;</code>，<code>getHandler</code>时根据当前<code>request</code>找到匹配的<code>HandlerMethod</code></li><li>AbstractHandlerMethodMapping<t> (extends AbstractHandlerMapping)<pre><code class="lang-java">  // 1. afterPropertiesSet -- 会注册所有mapping（requestMapping和各个Class method关系）  //        -&gt; initHandlerMethods   //            -&gt; detectHandlerMethods   //                -&gt; call abstract func:getMappingForMethod  protected void initHandlerMethods() {      //Looking for request mappings in application context      String[] beanNames = (this.detectHandlerMethodsInAncestorContexts ?              BeanFactoryUtils.beanNamesForTypeIncludingAncestors(obtainApplicationContext(), Object.class) :              obtainApplicationContext().getBeanNamesForType(Object.class));      for (String beanName : beanNames) {          if (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) {              Class&lt;?&gt; beanType = obtainApplicationContext().getType(beanName);              if (beanType != null &amp;&amp; isHandler(beanType))                  detectHandlerMethods(beanName);                  =&gt;{                      //detectHandlerMethods(handler):                      Class&lt;?&gt; handlerType = (handler instanceof String ?                              obtainApplicationContext().getType(handler) : handler.getClass());                      final Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);                      Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,                              method -&gt; {                                  return getMappingForMethod(method, userType); // abstract func!                              });                      // request handler methods found on ${userType}.${methods}                      methods.forEach((method, mapping) -&gt; {                          Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);                          registerHandlerMethod(handler, invocableMethod, mapping);                      });                  }          }      }      handlerMethodsInitialized(getHandlerMethods());  }  // 2. getHandlerInternal -- 找到与request匹配的HandleMethod  //        -&gt; lookupHandlerMethod   //            -&gt; call abstract func: getMatchingMapping  //            -&gt; call protected func: handleMatch  //            -&gt; call protected func: handleNoMatch  protected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception {      String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);      //Looking up handler method for the request path      this.mappingRegistry.acquireReadLock();      try {          HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);          return (handlerMethod != null ? handlerMethod.createWithResolvedBean() : null);      }      finally {          this.mappingRegistry.releaseReadLock();      }  }  protected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception {      List&lt;Match&gt; matches = new ArrayList&lt;&gt;();      List&lt;T&gt; directPathMatches = this.mappingRegistry.getMappingsByUrl(lookupPath);      if (directPathMatches != null) {          addMatchingMappings(directPathMatches, matches, request);          // foreach directPathMatches to get MatchingMaping by call abstract getMatchingMapping:          /*              for:directPathMatches{                  T match = getMatchingMapping(mapping, request);    // abstract func!                  if match!=null                      matches.add(new Match(match, this.mappingRegistry.getMappings().get(mapping)));              }                              */      }      if (matches.isEmpty()) {          // No choice but to go through all mappings...          addMatchingMappings(this.mappingRegistry.getMappings().keySet(), matches, request);      }      if (!matches.isEmpty()) {          Comparator&lt;Match&gt; comparator = new MatchComparator(getMappingComparator(request));          matches.sort(comparator);          Match bestMatch = matches.get(0);          if (matches.size() &gt; 1) {              if (CorsUtils.isPreFlightRequest(request)) {                  return PREFLIGHT_AMBIGUOUS_MATCH;              }              Match secondBestMatch = matches.get(1);              if (comparator.compare(bestMatch, secondBestMatch) == 0) {                  Method m1 = bestMatch.handlerMethod.getMethod();                  Method m2 = secondBestMatch.handlerMethod.getMethod();                  throw new IllegalStateException(&quot;Ambiguous handler methods mapped for HTTP path &#39;&quot; +                          request.getRequestURL() + &quot;&#39;: {&quot; + m1 + &quot;, &quot; + m2 + &quot;}&quot;);              }          }          handleMatch(bestMatch.mapping, lookupPath, request);    // protected func!          return bestMatch.handlerMethod;      }      else {          return handleNoMatch(this.mappingRegistry.getMappings().keySet(), lookupPath, request);  // protected func!      }  }</code></pre></t></li><li><p>RequestMappingInfoHandlerMapping (extends AbstractHandlerMethodMapping<requestmappinginfo>)</requestmappinginfo></p><pre><code class="lang-java">  // 1. getMatchingMapping  //        -&gt;RequestMappingInfo#getMatchingCondition  @Override  protected RequestMappingInfo getMatchingMapping(RequestMappingInfo info, HttpServletRequest request) {      return info.getMatchingCondition(request);      =&gt;{          // RequestMappingInfo#getMatchingCondition:          RequestMethodsRequestCondition methods = this.methodsCondition.getMatchingCondition(request);          ParamsRequestCondition params = this.paramsCondition.getMatchingCondition(request);          HeadersRequestCondition headers = this.headersCondition.getMatchingCondition(request);          ConsumesRequestCondition consumes = this.consumesCondition.getMatchingCondition(request);          ProducesRequestCondition produces = this.producesCondition.getMatchingCondition(request);          if (methods == null || params == null || headers == null || consumes == null || produces == null) {              return null;          }          PatternsRequestCondition patterns = this.patternsCondition.getMatchingCondition(request);          if (patterns == null) {              return null;          }          RequestConditionHolder custom = this.customConditionHolder.getMatchingCondition(request);          if (custom == null) {              return null;          }          return new RequestMappingInfo(this.name, patterns,                  methods, params, headers, consumes, produces, custom.getCondition());      }  }  // 2. handleMatch  @Override  protected void handleMatch(RequestMappingInfo info, String lookupPath, HttpServletRequest request) {      request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, lookupPath);      Set&lt;String&gt; patterns = info.getPatternsCondition().getPatterns();      //bestPattern,uriVariables,decodedUriVariables -&gt; request.setAttribute(xxx,xxx)      //...  }  // 3. handleNoMatch  @Override  protected HandlerMethod handleNoMatch(          Set&lt;RequestMappingInfo&gt; infos, String lookupPath, HttpServletRequest request) throws ServletException{      PartialMatchHelper helper = new PartialMatchHelper(infos, request);      helper.hasMethodsMismatch(): throw new HttpRequestMethodNotSupportedException(request.getMethod(), methods);      helper.hasConsumesMismatch(): throw new HttpMediaTypeNotSupportedException(contentType, new ArrayList&lt;&gt;(mediaTypes));      helper.hasProducesMismatch(): throw new HttpMediaTypeNotAcceptableException(new ArrayList&lt;&gt;(mediaTypes));      helper.hasParamsMismatch(): throw new UnsatisfiedServletRequestParameterException(conditions, request.getParameterMap());      return null;  }</code></pre></li><li>RequestMappingHandlerMapping (extends RequestMappingInfoHandlerMapping)<pre><code class="lang-java">  // 1. getMappingForMethod   //        -&gt; createRequestMappingInfo:  protected RequestMappingInfo createRequestMappingInfo(              RequestMapping requestMapping, @Nullable RequestCondition&lt;?&gt; customCondition) {      RequestMappingInfo.Builder builder = RequestMappingInfo              .paths(resolveEmbeddedValuesInPatterns(requestMapping.path()))              .methods(requestMapping.method())              .params(requestMapping.params())              .headers(requestMapping.headers())              .consumes(requestMapping.consumes())              .produces(requestMapping.produces())              .mappingName(requestMapping.name());      if (customCondition != null)          builder.customCondition(customCondition);      return builder.options(this.config).build();  }  // 2. class 成员变量: contentNegotiationManager  private ContentNegotiationManager contentNegotiationManager = new ContentNegotiationManager();</code></pre></li></ul></li><li><p>HandlerAdapter: RequestMappingHandlerAdapter</p><ul><li><p>RequestMappingHandlerAdapter (extends AbstractHandlerMethodAdapter)</p><pre><code class="lang-java">  // 1. constructor : initial messageConverters : List&lt;HttpMessageConverter&lt;?&gt;&gt;  public RequestMappingHandlerAdapter() {      StringHttpMessageConverter stringHttpMessageConverter = new StringHttpMessageConverter();      stringHttpMessageConverter.setWriteAcceptCharset(false); // See SPR-7316      this.messageConverters = new ArrayList&lt;HttpMessageConverter&lt;?&gt;&gt;();      this.messageConverters.add(new ByteArrayHttpMessageConverter());      this.messageConverters.add(stringHttpMessageConverter);      this.messageConverters.add(new SourceHttpMessageConverter&lt;Source&gt;());      this.messageConverters.add(new AllEncompassingFormHttpMessageConverter());  }  // 2. afterPropertiesSet: initial argumentResolvers,returnValueHandlers,...  //        -&gt; this.argumentResolvers : HandlerMethodArgumentResolverComposite  //        -&gt; this.initBinderArgumentResolvers : HandlerMethodArgumentResolverComposite  //        -&gt; this.returnValueHandlers : HandlerMethodReturnValueHandlerComposite  @Override  public void afterPropertiesSet(){      initControllerAdviceCache();      if (this.argumentResolvers == null) {          List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();          /*          =&gt;{              //resolvers.add(...)              //...              // use RequestResponseBodyMethodProcessor to resolve @RequestBody method arguments              resolvers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice));              //...          }*/          this.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers)      }      if (this.initBinderArgumentResolvers == null) {          List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();          this.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);      }      if (this.returnValueHandlers == null) {          List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();          /*              =&gt;{                  //handlers.add(...)                  //...                  // use RequestResponseBodyMethodProcessor to handle @ResponseBody return value                  handlers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(),                      this.contentNegotiationManager, this.requestResponseBodyAdvice));                  //...              }          */          this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);      }  }  // 3. handleInternal   //        -&gt; invokeHandleMethod  //            -&gt; ServletInvocableHandlerMethod#invokeAndHandle :  //                -&gt; getMethodArgumentValues  //                -&gt; doInvoke  //                -&gt; handleReturnValue  @Override  protected final ModelAndView handleInternal(HttpServletRequest request,          HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {      // ...  }</code></pre></li><li><p>ServletInvocableHandlerMethod (extends InvocableHandlerMethod)</p><pre><code class="lang-java">  // 1. invokeAndHandle  //        -&gt; getMethodArgumentValues(HandlerMethodArgumentResolverComposite#resolveArgument)  //        -&gt; doInvoke  //        -&gt; handleReturnValue (HandlerMethodReturnValueHandler#handleReturnValue)  public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,              Object... providedArgs) throws Exception   =&gt;{      // 1. resolveArgument(HandlerMethodArgumentResolver#resolveArgument)       //        =&gt; args -&gt; handlerMethod -&gt; returnValue      Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);              =&gt; {              // InvocableHandlerMethod#invokeForRequest:              Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);                  /*                      InvocableHandlerMethod#getMethodArgumentValues:{                      MethodParameter[] parameters = getMethodParameters();                      for:parameters{                          args[i] = resolveProvidedArgument(parameter, providedArgs)                          if (args[i] == null &amp;&amp; this.argumentResolvers.supportsParameter(parameter))                              args[i] = this.argumentResolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);                      }                  }                      */              // 2. doInvoke              Object returnValue = doInvoke(args);              return returnValue;          }      // 3. handleReturnValue (HandlerMethodReturnValueHandler#handleReturnValue)      this.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);  }  // 2. class 成员变量：argumentResolvers －－ use to resolveArgument  private HandlerMethodArgumentResolverComposite argumentResolvers = new HandlerMethodArgumentResolverComposite();  /*      class HandlerMethodArgumentResolverComposite {          private final List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers = new LinkedList&lt;&gt;();          @Override          public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,              NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception{              HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);              =&gt;{                  for resolver: this.argumentResolvers{                      if (resolver.supportsParameter(parameter))                          return resolver;                  }              }              return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);          }      }  */  // 3. class 成员变量：returnValueHandlers －－ use to handleReturnValue  private HandlerMethodReturnValueHandlerComposite returnValueHandlers;  /*      class HandlerMethodReturnValueHandlerComposite {          private final List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers = new ArrayList&lt;&gt;();          @Override          public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,                  ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception{              HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);              =&gt;{                  for:this.returnValueHandlers{                      if(handler.supportsReturnType(returnType))                          return handler;                  }              }              handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);          }      }  */</code></pre></li><li>RequestResponseBodyMethodProcessor: resolve args for <code>@RequestBody</code>  &amp; handle return value for <code>@ResponseBody</code><pre><code class="lang-java">  /**   * Resolves method arguments annotated with {@code @RequestBody} and handles return   * values from methods annotated with {@code @ResponseBody} by reading and writing   * to the body of the request or response with an {@link HttpMessageConverter}.   */  public class RequestResponseBodyMethodProcessor extends AbstractMessageConverterMethodProcessor {      @Override      public boolean supportsParameter(MethodParameter parameter) {          return parameter.hasParameterAnnotation(RequestBody.class);      }      @Override      public boolean supportsReturnType(MethodParameter returnType) {          return (AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody.class) ||                  returnType.hasMethodAnnotation(ResponseBody.class));      }      @Override      public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,              NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception{          Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());              /*                  //AbstractMessageConverterMethodArgumentResolver#readWithMessageConverters:                  contentType: get from requestHeader                  for:this.messageConverters{                      if(converter.canRead(...))                          return converter.read(...) // HttpMessageConverter#read                  }              */          return adaptArgumentIfNecessary(arg, parameter);      }      @Override      public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,              ModelAndViewContainer mavContainer, NativeWebRequest webRequest){          writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage)              /*              //AbstractMessageConverterMethodProcessor#writeWithMessageConverters:              acceptableMediaTypes &amp; producibleMediaTypes =&gt; Compatible &amp;&amp; Concrete =&gt; mediaTypes                  =&gt; {                      AcceptableMediaTypes: this.contentNegotiationManager.resolveMediaTypes(new ServletWebRequest(request));                      producibleMediaTypes:                           mediaTypes = (Set&lt;MediaType&gt;) request.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);                          or:                              for: this.messageConverters{                                  if(converter.canWrite(...))                                      result.addAll(converter.getSupportedMediaTypes())                              }                  }              for: this.messageConverters{                  if(converter.canWrite(...)){                      outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType,converter.getClass(),                      inputMessage, outputMessage);                      addContentDispositionHeader(inputMessage, outputMessage);                      converter.write(outputValue, selectedMediaType, outputMessage);    // HttpMessageConverter#write                  }              }                                  */      }  }</code></pre></li></ul></li></ol><h2 id="header-47">WebFlux</h2><ul><li>jar: <code>spring-webflux</code> (dependency: <code>spring-web</code>,<code>reactor-core</code>)</li><li>是<code>Reactive</code>思想的一种实现（数据流<code>Data Stream</code>，非阻塞 <code>Non-Blocking</code>，推模式<code>push-based</code>，背压<code>Backpressure</code>）</li><li>依赖<code>Reactor</code>类库(jar:<code>reactor-core</code>)<ul><li>依赖<code>reactive-streams</code><ul><li>核心组件：<code>Publisher</code>,<code>Subscriber</code>,<code>Subscription</code>,<code>Processor</code></li><li>背压处理</li></ul></li><li>核心组件：<code>Mono</code>,<code>Flux</code>,<code>Scheduler</code></li></ul></li><li>依赖<code>SpringWeb</code>类库(jar: <code>spring-web</code>)<ul><li><code>HttpHandler</code>: <code>Mono&lt;Void&gt; handle(ServerHttpRequest request, ServerHttpResponse response);</code></li><li><code>WebHandler</code>: <code>Mono&lt;Void&gt; handle(ServerWebExchange exchange);</code></li></ul></li><li>编程模型：<ul><li>注解式驱动 <a href="https://docs.spring.io/spring/docs/5.0.x/spring-framework-reference/web-reactive.html#webflux-controller" target="_blank" rel="noopener">Annotated Controllers</a>: 同WebMvc使用的注解</li><li>函数式端点 <a href="https://docs.spring.io/spring/docs/5.0.x/spring-framework-reference/web-reactive.html#webflux-fn" target="_blank" rel="noopener">Functional Endpoints</a> : 使用<code>RouterFunction</code></li></ul></li><li>核心组件(功能大同WebMvc, jar: <code>spring-webflux</code>， package：<code>o.s.w.reactive...</code>):<ul><li>总控 <code>DispatcherHandler</code> (implements <code>WebHandler</code>)</li><li>处理器管理<ul><li>映射 <code>HandlerMapping</code> (eg: RequestMappingHandlerMapping)</li><li>适配 <code>HandlerAdapter</code> (eg: RequestMappingHandlerAdapter)</li><li>执行 <code>HandlerResult</code></li></ul></li><li>异常处理 <code>HandlerResult#exceptionHandler</code></li><li>HandlerMethod: <code>@RequestMapping</code>/<code>@XxxMapping</code>标注的方法<ul><li>HandlerMethod参数解析器: <code>HandlerMethodArgumentResolver</code></li><li>Handler返回值解析器: <code>HandlerResultHandler</code><ul><li><code>ResponseBodyResultHandler</code></li><li><code>ResponseEntityResultHandler</code></li><li><code>ServerResponseResultHandler</code></li><li><code>ViewResolutionResultHandler</code><ul><li><code>RequestedContentTypeResolverBuilder</code></li><li><code>RequestedContentTypeResolver</code></li></ul></li></ul></li></ul></li><li>视图解析器 <code>ViewResolver</code></li><li>视图渲染 <code>View</code>, eg:<ul><li><code>RedirectView</code></li><li><code>FreeMarkerView</code></li><li><code>HttpMessageWriterView</code></li></ul></li><li>配置 <ul><li><code>WebFluxConfigurer</code></li><li><code>WebFluxConfigurationSupport</code></li></ul></li><li>for Functional Endpoints(函数式端点方式)<ul><li><code>RouterFunction</code><pre><code class="lang-java">  @FunctionalInterface   // 标注表示这是一个函数式接口  // 只能标注在接口上，且该接口只有一个抽象方法（接口默认方法以及声明中覆盖 Object 的公开方法不算）  // 标注后此接口的实例可被 Lambda 表示式、方法引用或构造器引用创建  public interface RouterFunction&lt;T extends ServerResponse&gt; {      Mono&lt;HandlerFunction&lt;T&gt;&gt; route(ServerRequest request);      // default:      // and,andOther,andRoute,andNest,filter,accept  }</code></pre></li><li><code>RouterFunctionMapping</code> (implements HandlerMapping)</li><li><code>HandlerFunctionAdapter</code> (implements HandlerAdapter)</li></ul></li></ul></li><li>使用场景：不适合RT（响应）敏感的RPC框架/Web应用，适合请求慢慢执行的场景（把请求丢过来，不care什么时候完成，完成后通知你下就即可），Reactive可以提升吞吐量，但RunTime反而会变得更长，且出现响应超时等问题    </li><li><code>Spring WebMVC</code> vs. <code>Spring WebFlux</code><ul><li>均能使用注解驱动Controller,WebFlux还能使用函数式端点方式</li><li>主要不同点在于并发模型和阻塞特性：<ul><li>Spring WebMvc: Servlet应用,通常是阻塞服务,Servlet容器一般使用较大的线程池处理请求</li><li>Spring WebFlux: Reactive应用,通常是非阻塞服务，服务器可使用少量、固定大小的线程池处理请求</li></ul></li><li>目前WebFlux并未优于WebMvc:<ul><li>性能上没有明显的速度提升(甚至性能结果稍微更恶劣)</li><li>在编程友好性方面,Reactive编程尽管没有新增大量的代码,却使编码(和调试)变得复杂了</li><li>缺少文档</li></ul></li></ul></li></ul><h3 id="header-48">Java 并发模型</h3><ul><li>阻塞／非阻塞 (编程模型)<table class="table"><thead><tr><th style="text-align:left">IO</th><th style="text-align:left">NIO</th></tr></thead><tbody><tr><td style="text-align:left">阻塞</td><td style="text-align:left">非阻塞</td></tr><tr><td style="text-align:left">面向流</td><td style="text-align:left">面向缓冲</td></tr><tr><td style="text-align:left">线程被阻塞直到读／写完</td><td style="text-align:left">无数据可读／写时，该线程可继续做其他事</td></tr><tr><td style="text-align:left">一个线程只管理一个输入输出通道</td><td style="text-align:left">一个线程可以管理多个输入输出通道</td></tr><tr><td style="text-align:left">使用场景：少量的连接使用较高的带宽，一次发送大量的数据</td><td style="text-align:left">使用场景：聊天服务器要管理很多个连接，每次只是发送少量的数据，一个线程就可以管理多个连接，提升系统吞吐量</td></tr></tbody></table></li><li>同步／异步 (线程模型)</li><li>组合：<ul><li>阻塞 &amp; 同步／异步,eg:<ul><li>迭代器模式(Iterator): 阻塞同步</li><li>Future#get: blocking &amp; 异步－&gt;串行</li></ul></li><li>非阻塞 &amp; 同步／异步，eg:<ul><li>Observer模式（观察者模式,事件/监听者模式）: 非阻塞</li><li>Reactor模式（反应堆模式）: 非阻塞同步</li><li>Proactor模式 : 非阻塞异步 </li></ul></li></ul></li></ul><p><strong> 示例：数据加载（阻塞任务） + 同步／异步 </strong></p><ol><li>在各个任务间没有数据依赖关系的情况下：<ul><li>单线程 -&gt; 串行：时间消耗线性累加</li><li>多线程 －&gt; 并行：时间消耗取最大者,性能和资源利用率明显地得到提升</li></ul></li><li>在任务间有依赖时:<ul><li>依赖任务不论是否在同一线程，都会串行执行（又回到了阻塞模式）</li><li>与非依赖的异步任务，还是并行执行</li></ul></li><li>总结：如果任务间有依赖，或则设置强制等待某个任务结束，并发模型并不会提高执行效率</li></ol><pre><code class="lang-java">public class AsyncTest {    private long startTime;    public void load(String source,int seconds) {        try {            long startTime = System.currentTimeMillis();            long milliseconds = TimeUnit.SECONDS.toMillis(seconds);            Thread.sleep(milliseconds);            long costTime = System.currentTimeMillis() - startTime;            System.out.printf(&quot;[Thread : %s] %s cost :  %d ms \n&quot;,Thread.currentThread().getName(), source, costTime);        } catch (InterruptedException e) {            throw new RuntimeException(e);        }    }    @Before    public void before() {        startTime = System.currentTimeMillis();    }    @After    public void after() {        long costTime = System.currentTimeMillis() - startTime;        System.out.println(&quot;total cost:&quot; + costTime + &quot; ms&quot;);    }    // 同步：只有一个main线程 ＝&gt; 串行执行    // total cost: 1.x + 2.x  + 3.x &gt; 6s (有些线程调度切换等花费掉的时间)    // Detail:    // [Thread : main] loadConfigurations cost :  1005 ms     // [Thread : main] loadUsers cost :  2005 ms     // [Thread : main] loadOrders cost :  3005 ms     // total cost:6016 ms    @Test    public void serialLoadTest(){         load(&quot;loadConfigurations&quot;,1);        load(&quot;loadUsers&quot;,2);        load(&quot;loadOrders&quot;,3);    }    // 异步: 多线程 ＝&gt; 并行执行    // main线程通过轮询来检查是否都完成了，各个子任务间无依赖，也不会阻塞main线程    // total cost: max(1.x, 2.x, 3.x)  = 3.x &gt; 3s    // Detail:    // [Thread : pool-1-thread-1] loadConfigurations cost :  1000 ms     // [Thread : pool-1-thread-2] loadUsers cost :  2002 ms     // [Thread : pool-1-thread-3] loadOrders cost :  3005 ms     // total cost:3063 ms    @Test    public void parallelLoadTest() {            ExecutorService executorService = Executors.newFixedThreadPool(3); // 创建线程池        CompletionService&lt;String&gt; completionService = new ExecutorCompletionService&lt;String&gt;(executorService);        completionService.submit(()-&gt;{load(&quot;loadConfigurations&quot;,1);}, null);      //  耗时 &gt;= 1s        completionService.submit(()-&gt;{load(&quot;loadUsers&quot;,2);}, null);               //  耗时 &gt;= 2s        completionService.submit(()-&gt;{load(&quot;loadOrders&quot;,3);}, null);              //  耗时 &gt;= 3s        int count = 0;        while (count &lt; 3) { // 等待三个任务完成            if (completionService.poll() != null) {                count++;            }        }        executorService.shutdown();    }    // 异步：多线程 + Future#get() ＝&gt; 并行－&gt;串行执行, main thead 阻塞    // 多个任务提交后,返回的多个Future逐一调用get()方法时,将会依次blocking main thread(等待直到当前任务执行完成),从而任务的执行从并行变为串行执行    // total cost: 1.x + 2.x + 3.x &gt; 6s     // Detail:    // [Thread : pool-1-thread-1] loadConfigurations cost :  1001 ms     // [Thread : pool-1-thread-2] loadUsers cost :  2005 ms     // [Thread : pool-1-thread-3] loadConfigurations cost :  3006 ms     // total cost:6077 ms    @Test    public void futureBlockingLoadTest() {       ExecutorService executorService = Executors.newFixedThreadPool(3); // 创建线程池       runCompletely(executorService.submit(()-&gt;{load(&quot;loadConfigurations&quot;,1);}));       runCompletely(executorService.submit(()-&gt;{load(&quot;loadUsers&quot;,2);}));       runCompletely(executorService.submit(()-&gt;{load(&quot;loadConfigurations&quot;,3);}));       executorService.shutdown();    }    private void runCompletely(Future&lt;?&gt; future) {        try {            future.get();        } catch (Exception e) {        }    }    // 异步：多线程  ＝&gt; main 和 sub-thread并行，sub-thread串行执行任务且完成时触发回调    // Detail:    // Hello    // [Thread : ForkJoinPool.commonPool-worker-1] loadConfigurations cost :  1004 ms     // [Thread : ForkJoinPool.commonPool-worker-1] loadUsers cost :  2004 ms     // [Thread : ForkJoinPool.commonPool-worker-1] loadOrders cost :  3005 ms     // [Thread ：ForkJoinPool.commonPool-worker-1] Complete 6072ms    @Test    public void chainLoadTest() throws InterruptedException {        // main -&gt; submit -&gt; ...        // sub-thread : F1 -&gt; F2 -&gt; F3        CompletableFuture            .runAsync(()-&gt;{load(&quot;loadConfigurations&quot;,1);})            .thenRun(()-&gt;{load(&quot;loadUsers&quot;,2);})            .thenRun(()-&gt;{load(&quot;loadOrders&quot;,3);})            .whenComplete((result, throwable) -&gt; { // 完成时回调                long costTime = System.currentTimeMillis() - startTime;                System.out.println(&quot;[Thread ：&quot; + Thread.currentThread().getName() + &quot;] Complete &quot;+costTime+&quot;ms&quot;);            })            .exceptionally(throwable-&gt;{                System.out.println(&quot;[Thread ：&quot; + Thread.currentThread().getName() + &quot;] Exception&quot;);                return null;            })            //.join()    // 等待完成            ;         System.out.println(&quot;Hello&quot;);        Thread.sleep(8000);    }    // Java GUI 事件/监听者模式（即观察者模式）的并发模型可为同步或异步    // 通过回调`Callbacks`实现非阻塞    // 注意：`Callbacks Hell`, 监听的维度很多时则对应的Callback实现也会很多    @Test    public void callbackTest() throws IOException {        JFrame jFrame = new JFrame(&quot;GUI 示例&quot;);        jFrame.setBounds(500, 300, 400, 300);        LayoutManager layoutManager = new BorderLayout(400, 300);        jFrame.setLayout(layoutManager);        jFrame.addMouseListener(new MouseAdapter() { // callback 1         @Override         public void mouseClicked(MouseEvent e) {             System.out.printf(&quot;[线程 : %s] 鼠标点击，坐标(X : %d, Y : %d)\n&quot;,                     Thread.currentThread().getName(), e.getX(), e.getY());         }        });        jFrame.addWindowListener(new WindowAdapter() {  // callback 2         @Override         public void windowClosing(WindowEvent e) {             System.out.printf(&quot;[线程 : %s] 清除 jFrame... \n&quot;, Thread.currentThread().getName());             jFrame.dispose(); // 清除 jFrame         }         @Override         public void windowClosed(WindowEvent e) {             System.out.printf(&quot;[线程 : %s] 退出程序... \n&quot;, Thread.currentThread().getName());             System.exit(0); // 退出程序         }        });        System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName());        jFrame.setVisible(true);        System.in.read();    }}</code></pre><h3 id="header-49">Reactive</h3><ol><li><p>Reactive 思想</p><ul><li>非阻塞下同步／异步执行 – 多功能<ul><li>阻塞导致性能瓶颈和浪费资源，但非阻塞也不一定提升性能</li><li>增加线程可能会引起资源竞争和并发问题</li></ul></li><li>数据在生产与消费间的平衡（背压）</li></ul></li><li><p>Reactive Programming (编程模型)</p><ul><li>观察者模式(observer pattern)的延伸</li><li>处理流式数据（streams: sequenced data/events）</li><li>非阻塞下的同步／异步执行 （no-blocking)</li><li>推拉相结合（push-based and pull-based）</li><li>响应数据传播时的变化 (responsive)</li><li>结合背压（Backpressure）技术处理数据生产与消费的平衡问题</li><li><code>Observable</code> vs <code>Iterable</code>: An Observable(RxJava) is the asynchronous/push “dual” to the synchronous/pull Iterable<ul><li>Observer 观察者：被动通知（非阻塞回调方式），推动模式（eg: 服务器端推送到客户端）</li><li>Iterator 迭代器：主动触发（循环遍历），拉动模式(eg: 客户端主动for循环)<table class="table"><thead><tr><th style="text-align:left">event</th><th style="text-align:left">Iterable (pull)</th><th style="text-align:left">Observable (push)</th></tr></thead><tbody><tr><td style="text-align:left">data</td><td style="text-align:left">T next()</td><td style="text-align:left">onNext(T)</td></tr><tr><td style="text-align:left">discover error</td><td style="text-align:left">throws Exception</td><td style="text-align:left">onError(Exception)</td></tr><tr><td style="text-align:left">complete</td><td style="text-align:left">!hasNext()</td><td style="text-align:left">onCompleted()</td></tr></tbody></table></li></ul></li><li>注：观察者模式（即事件/监听者模式）的并发模型可为同步或异步，eg:<ul><li>Spring （同步/异步）事件/监听器：<ul><li>事件： ApplicationEvent</li><li>事件监听器： ApplicationListener</li><li>事件广播器： ApplicationEventMulticaster</li><li>事件发布器： ApplicationEventPublisher</li></ul></li><li>Servlet 同步事件/监听器:<ul><li>事件： ServletContextEvent</li><li>事件监听器： ServletContextListener</li></ul></li><li>Servlet 异步事件/监听器:<ul><li>事件： AsyncEvent</li><li>事件监听器： AsyncListener    </li></ul></li></ul></li></ul></li><li><p>Reactive 实现框架</p><ul><li>RxJava (Reactive Extensions)</li><li>Reactor (Spring/SpringBoot WebFlux使用此Reactive类库）</li><li>Flow API (Java 9)</li><li>注：Java 原生技术Stream的限制Stream属于迭代器模式，拉模式）<ul><li>有限操作符</li><li>不支持背压</li><li>不支持订阅</li></ul></li></ul></li><li><p>场景</p><ul><li>管理流式数据在异步边界的交换(reactive-streams)<ul><li>govern the exchange of stream data</li><li>across an asynchronous boundary</li></ul></li><li>通常并非让应用运行更快速，而是要利用较少的资源提升伸缩性(SpringFramework)<ul><li>generally do not make applications run faster</li><li>scale with a small, fixed number of threads and less memory</li></ul></li><li>更好可读性 more readable (ReactiveX)</li><li>结构性,高层次并发抽象 High level abstraction (Reactor)</li></ul></li></ol><h3 id="header-50">Reactor</h3><ul><li>jar: <code>reactor-core</code> (dependency jar: <code>reactive-streams</code>)</li><li>核心API：<ul><li><code>Mono</code> : 0~1的非阻塞结果(类似<code>Optional</code>,点对点模式)，实现 reactive-streams <code>Publisher</code></li><li><code>Flux</code> : 0~N的非阻塞序列(类似<code>Stream</code>,发布/订阅者模式),实现 reactive-streams <code>Publisher</code></li><li><code>Scheduler</code> : Reactor调度线程池<table class="table"><thead><tr><th style="text-align:left">线程池</th><th style="text-align:left">方法</th><th style="text-align:left">内部名称</th><th style="text-align:left">线程名称</th><th style="text-align:left">线程数量</th><th style="text-align:left">线程idel时间</th></tr></thead><tbody><tr><td style="text-align:left">单复用线程</td><td style="text-align:left">Schedulers.single()</td><td style="text-align:left">single</td><td style="text-align:left">single</td><td style="text-align:left">1</td><td style="text-align:left">Long Live</td></tr><tr><td style="text-align:left">弹性线程池</td><td style="text-align:left">Schedulers.elastic()</td><td style="text-align:left">elastic</td><td style="text-align:left">elastic-evictor-{num}</td><td style="text-align:left">无限制（unbounded）</td><td style="text-align:left">60s</td></tr><tr><td style="text-align:left">并行线程池</td><td style="text-align:left">Schedulers.parallel()</td><td style="text-align:left">parallel</td><td style="text-align:left">parallel-{num}</td><td style="text-align:left">处理器数量</td><td style="text-align:left">60s</td></tr></tbody></table><ul><li>底层实现：<code>ScheduledThreadPoolExecutor</code></li><li>查看当前线程：<code>Schedulers.immediate()</code> ( 等价于 <code>Thread.currentThread()</code> )</li></ul></li></ul></li><li><p><code>reactive-streams</code>：</p><ul><li>定义<blockquote><p>Reactive Streams is a standard and specification for Stream-oriented libraries for the JVM that</p><ul><li>process a potentially unbounded number of elements</li><li>in sequence,</li><li>asynchronously passing elements between components,</li><li>with mandatory non-blocking backpressure.</li></ul></blockquote></li><li>核心API ( package: <code>org.reactivestreams</code>)<ul><li><code>Publisher</code> ：数据发布者（上游）<pre><code class="lang-java">  public interface Publisher&lt;T&gt; {      public void subscribe(Subscriber&lt;? super T&gt; s);  }</code></pre></li><li><code>Subscriber</code> ：数据订阅者（下游）<pre><code class="lang-java">  public interface Subscriber&lt;T&gt; {      public void onSubscribe(Subscription s);    // 当下游订阅时      public void onNext(T t);                    // 当下游接收数据时      public void onError(Throwable t);            // 当数据流（Data Streams）执行错误时      public void onComplete();                    // 当数据流（Data Streams）执行完成时  }</code></pre></li><li><code>Subscription</code> ：订阅信号 (Subscriber to Publisher – 背压)<pre><code class="lang-java">  public interface Subscription {      public void request(long n);    // 限定请求上游元素的数量      public void cancel();            // 请求停止发送数据并且清除资源  }</code></pre></li><li><code>Processor</code> ：<code>Publisher</code>和<code>Subscriber</code>综合体（中游，承上启下）<pre><code class="lang-java">  public interface Processor&lt;T, R&gt; extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; {  }</code></pre></li></ul></li><li>背压处理(backpressure handle)：<ul><li>publisher side maintains a higher rate than the subscriber</li><li>mediate between threads to be bounded (传播上游信号，eg: request process at most n elements; halt sending )</li><li>下游<code>Subscriber</code>工作在无边界<code>unbounded</code>大小的数据流水线，当上游<code>Publisher</code>提供数据的速率快于下游<code>Subscriber</code>的消费数据速率时，下游<code>Subscriber</code>将通过传播信号<code>request</code>到上游<code>Publisher</code>: 请求限制数据的数量(limit number)或通知上游停止数据生产(halt)</li></ul></li></ul></li><li><p>示例：<code>Flux</code></p><ol><li>pom.xml<pre><code class="lang-xml"> &lt;dependency&gt;     &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;     &lt;artifactId&gt;reactor-core&lt;/artifactId&gt; &lt;/dependency&gt;</code></pre></li><li><p>lambde编程方式</p><pre><code class="lang-java"> private static void println(Object object) {     String threadName = Thread.currentThread().getName();     System.out.println(&quot;[Thread:&quot; + threadName + &quot;] &quot; + object); } // 异步 @Test public void fluxSyncFunctinalProgramingTest() {     println(&quot;Run fluxSyncFunctinalProgramingTest ...&quot;);     Flux.just(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)             // Sequence: A -&gt; B -&gt; C         .map(value -&gt; &quot;+&quot; + value)         // &quot;A&quot; -&gt; &quot;+A&quot;          .subscribe(                 ReactorTest::println,     // 数据消费 = onNext(T)                 ReactorTest::println,     // 异常处理 = onError(Throwable)                 () -&gt; {                 // 完成回调 = onComplete()                     println(&quot;Complete!&quot;);                 },                 subscription -&gt; {         // 背压操作 onSubscribe(Subscription)                     subscription.request(Integer.MAX_VALUE); // 请求的元素数量                     subscription.cancel();     // 取消上游传输数据到下游                 }         );     /*      Summary:      subscription.request(0);    =&gt; Exception (n must &gt;0)      subscription.request(2);    =&gt; main: +A -&gt; +B      subscription.request(5);    =&gt; main: +A -&gt; +B -&gt; +C -&gt; Complete!      subscription.request(2); subscription.cancel(); =&gt; main: +A -&gt; +B      subscription.request(5); subscription.cancel(); =&gt; main: +A -&gt; +B -&gt; +C -&gt; Complete!      subscription.cancel(); ... =&gt; none      */ }   // 同步 @Test public void fluxAsyncFunctionalProgramingTest() throws InterruptedException {     println(&quot;Run fluxAsyncFunctionalProgramingTest ...&quot;);     Flux.just(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)         .publishOn(Schedulers.elastic())     // 线程池切换         .map(value -&gt; &quot;+&quot; + value)         .subscribe(                 ReactorTest::println,                 ReactorTest::println,                 () -&gt; {                     println(&quot;Complete!&quot;);                 },                 subscription -&gt; {                     subscription.request(5);                  // subscription.cancel();                 }         );     /*      Summary:      subscription.request(2); =&gt; elastic-2: +A -&gt; +B      subscription.request(5); =&gt; elastic-2: +A -&gt; +B -&gt; +C -&gt; Complete!      subscription.request(2);subscription.cancel(); =&gt; none     */             }</code></pre></li><li>传统编程方式<pre><code class="lang-java"> @Test public void fluxResponseProgramingTest() {     println(&quot;Run fluxResponseProgramingTest ...&quot;);     Flux.just(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)         //.publishOn(Schedulers.elastic())          .map(value -&gt; &quot;+&quot; + value)         .subscribe(new Subscriber&lt;String&gt;() {             private Subscription subscription;             private int count = 0;             @Override             public void onSubscribe(Subscription s) {                 subscription = s;                 subscription.request(1);             }             @Override             public void onNext(String s) {                 if (count == 2) {                     throw new RuntimeException(&quot;故意抛异常！&quot;);                 }                 println(s);                 count++;                 subscription.request(1);             }             @Override             public void onError(Throwable t) {                 println(t.getMessage());             }             @Override             public void onComplete() {                 println(&quot;Complete&quot;);             }         });                 /*      Summary:      1. sync =&gt; main: +A -&gt; +B -&gt; Exception      2. async: .publishOn(Schedulers.elastic()) =&gt; main: +A -&gt; +B       */ }</code></pre></li></ol></li></ul><h3 id="header-51">WebFlux</h3><p><strong> 示例: </strong></p><ol><li><p>注解驱动,函数式端点驱动</p><pre><code class="lang-java"> SpringBootApplication @RestController public class WebFluxApp {     public static void main(String[] args) {         SpringApplication.run(WebFluxApp.class,args);     }     private static void println(String message) {         System.out.println(&quot;[&quot; + Thread.currentThread().getName() + &quot;] : &quot; + message);     }     @GetMapping(&quot;/mvc&quot;)     public String mvc() {         println(&quot;mvc&quot;);         return &quot;MVC&quot;;     }     @GetMapping(&quot;/mono&quot;)     public Mono&lt;String&gt; mono() {         println(&quot;mono&quot;);         return Mono.just(&quot;Mono&quot;);     }     @Bean     public RouterFunction&lt;ServerResponse&gt; hello(){         // curl -i localhost:8080/hello         // curl -i -H &quot;Content-Type:application/json&quot; localhost:8080/hello2         // curl -i localhost:8080/hello3         return RouterFunctions                 .route(RequestPredicates.GET(&quot;/hello&quot;)                         ,serverRequest-&gt;{                             return ServerResponse.ok().body(Mono.just(&quot;Hello World!&quot;),String.class);                         })                 .andRoute(RequestPredicates.GET(&quot;/hello2&quot;).and(RequestPredicates.contentType(MediaType.APPLICATION_JSON))                         ,this::hello2Handler)                 .andRoute(RequestPredicates.GET(&quot;/hello3&quot;), this::hello3Handler);     }     public Mono&lt;ServerResponse&gt; hello2Handler(ServerRequest request){         Mono&lt;String&gt; helloMono=Mono.just(&quot;Hello World 2&quot;);         return ServerResponse.ok().body(helloMono,String.class);     }     public Mono&lt;ServerResponse&gt; hello3Handler(ServerRequest request){         Flux&lt;String&gt; helloFlux=Flux.just(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;);         return ServerResponse.ok().body(helloFlux,String.class);     } }</code></pre></li><li><p>非阻塞调用阻塞</p><pre><code class="lang-java"> @Configuration public class RouterFunctionConfiguration {      @Bean     //@Autowired     public RouterFunction&lt;ServerResponse&gt; listUsers(UserRepository userRepository){         return RouterFunctions.route(RequestPredicates.GET(&quot;/users&quot;)                 ,request -&gt; {                     Collection&lt;User&gt; users = userRepository.list();    // 阻塞                     Flux&lt;User&gt; userFlux = Flux.fromIterable(users); // 非阻塞                     return ServerResponse.ok().body(userFlux,User.class);                 });     } } @RestController public class UserController {     private final UserRepository userRepository;     @Autowired     public UserController(UserRepository userRepository) {         this.userRepository = userRepository;     }     @PostMapping(&quot;/users&quot;)     public User save(@RequestParam String name){         User user = new User();         user.setName(name);         if(userRepository.save(user)){             System.out.printf(&quot;Save %s Successful! \n&quot;,user);         }         return user;     } } @Repository public class UserRepository {     private final ConcurrentMap&lt;Integer,User&gt; users = new ConcurrentHashMap&lt;Integer,User&gt;();     private final static AtomicInteger idGenerator = new AtomicInteger();     public boolean save(User user){         Integer id = idGenerator.incrementAndGet();         user.setId(id);         return users.put(id,user)==null;     }     public Collection&lt;User&gt; list(){         return users.values();     } } // Domain: // User(Integer id,String name) // ... // main: @SpringBootApplication public class App {     public static void main(String[] args) {         SpringApplication.run(App.class,args);     }     /* Verify:      *  curl -i -X POST localhost:8080/users?name=Tom      *  curl -i -X POST localhost:8080/users?name=Lucy      *  curl -i localhost:8080/users      * */ }</code></pre></li></ol><!-- 1. 初始化流程    ![WebFlux 初始化流程](2018-09-15-Spring-Boot/webflux-init.png)2. 执行流程    - 注解驱动执行流程        ![WebFlux 注解驱动执行流程](2018-09-15-Spring-Boot/webflux-annotation.png)    - 函数式端点驱动执行流程        ![WebFlux 函数式端点驱动执行流程](2018-09-15-Spring-Boot/webflux-functional.png)--><h2 id="header-52">Reference</h2><ul><li><a href="https://github.com/sixDegree/springboot-demo" target="_blank" rel="noopener">Demo</a></li><li><a href="https://docs.spring.io/spring/docs/5.0.x/spring-framework-reference/" target="_blank" rel="noopener">SpringFramework Doc</a></li><li><a href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/htmlsingle/" target="_blank" rel="noopener">SpringBoot Doc</a></li><li><a href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/htmlsingle/#howto-convert-an-existing-application-to-spring-boot" target="_blank" rel="noopener">Convert an Existing Application to Spring Boot</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;自动装配组件&lt;/li&gt;
&lt;li&gt;外部化配置&lt;/li&gt;
&lt;li&gt;Servlet（独立／嵌入式Servlet容器）&lt;/li&gt;
&lt;li&gt;WebMvc&lt;/li&gt;
&lt;li&gt;WebFlux&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://sixdegree.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Oracle Procedure &amp; Cursor &amp; Array</title>
    <link href="http://sixdegree.github.io/2018/08/15/Oracle-Script.html"/>
    <id>http://sixdegree.github.io/2018/08/15/Oracle-Script.html</id>
    <published>2018-08-14T16:00:00.000Z</published>
    <updated>2018-10-26T12:33:58.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Block,Procedure,Transaction,Exception</li><li>Cursor,Bulk Collect,Forall,Dynamic SQL</li><li>Array</li></ol><a id="more"></a><h2 id="header-1">块 Block</h2><h3 id="header-2">块的结构</h3><pre><code class="lang-sql">declare  定义部分(可选)begin  可执行部分(必选)exception  异常处</code></pre><h3 id="header-3">块的分类</h3><ol><li>无名块(也叫匿名块)：动态构造并只能执行一次，常用来测试或执行存储过程。</li><li>命名块：加了用&lt;&lt;&gt;&gt;括起了带标号的无名块。</li><li>子程序：包括存储过程、函数和包等。这些块一旦被定义便会存储在数据库中，可随时调用。</li><li>触发器：根据触发的事件调用。</li></ol><h2 id="header-4">存储过程 Procedure</h2><h3 id="header-5">创建</h3><pre><code class="lang-sql">create or replace procedure test(var_name_1 in type,var_name_2 out type) as    --声明变量(变量名 变量类型)begin    --存储过程的执行体end test;</code></pre><pre><code class="lang-sql">CREATE OR REPLACE PROCEDURE 存储过程名字(    参数1 IN NUMBER,    参数2 IN NUMBER) AS    变量1 INTEGER :=0;    变量2 DATE;BEGIN    ...END 存储过程名字</code></pre><p>示例：</p><pre><code class="lang-sql">CREATE OR REPLACE PROCEDURE proc_test AS  CURSOR c1 IS SELECT * FROM dat_trade;BEGIN  FOR x IN c1 LOOP    DBMS_OUTPUT.put_line(x.id);  END LOOP;END proc_test;</code></pre><h3 id="header-6">调用</h3><p>在PL/SQL块内运行存储过程，不需要使用<code>exec</code>，直接 <code>procedure_name[(parameter,…n)]</code></p><pre><code class="lang-sql">BEGIN   proc_helloworld;END;</code></pre><p>外部程序调用：</p><pre><code class="lang-sql">exec proc_helloworld</code></pre><h2 id="header-7">事物 Transaction</h2><p>procedure中既有<code>commit</code>也有<code>rollback</code><br><code>commit</code>之前的就提交,<code>commit</code>和<code>rollback</code>之间的就回滚<br>程序出错,<code>commit</code>之前的就已经提交了,<code>commit</code>和出错之间的强制回滚.</p><p>嵌套出错:<br>出错前<code>commit</code>的就提交了,未<code>commit</code>的强制退出程序并回滚<br>把一个procedure中所有的程序和语句看成顺序执行,不管是嵌套多少层,<code>commit</code>的就起效,未<code>commit</code>的,如果出错则从出错的地方强制退出程序,如果不出错,退出session时默认提交.</p><pre><code class="lang-sql">CREATE OR REPLACE procedure SCOTT.t1asbegin  for i in 1..10000 loop        insert into test1(id,name) values(i,&#39;leng&#39;||i);        commit;        if i=20 then             rollback;             exit;        end if;  end loop;end;</code></pre><p>设置出错就<code>rollback</code> :</p><pre><code class="lang-sql">WHENEVER SQLERROR EXIT FAILURE ROLLBACK;WHENEVER OSERROR EXIT FAILURE ROLLBACK;SET SERVEROUTPUT ON;DECLARE    ...BEGIN    ...END;/commit;exit;</code></pre><h2 id="header-8">异常 Exception</h2><pre><code class="lang-sql">DECLARE       v_empno employees.employee_id%TYPE := &amp;empno;       v_sal   employees.salary%TYPE;BEGIN       SELECT salary INTO v_sal FROM employees WHERE employee_id = v_empno;       IF v_sal&lt;=1500 THEN                UPDATE employees SET salary = salary + 100 WHERE employee_id=v_empno;                DBMS_OUTPUT.PUT_LINE(&#39;编码为&#39;||v_empno||&#39;员工工资已更新!&#39;);           ELSE                DBMS_OUTPUT.PUT_LINE(&#39;编码为&#39;||v_empno||&#39;员工工资已经超过规定值!&#39;);       END IF;EXCEPTION       WHEN NO_DATA_FOUND THEN              DBMS_OUTPUT.PUT_LINE(&#39;数据库中没有编码为&#39;||v_empno||&#39;的员工&#39;);       WHEN TOO_MANY_ROWS THEN              DBMS_OUTPUT.PUT_LINE(&#39;程序运行错误!请使用游标&#39;);       WHEN OTHERS THEN              DBMS_OUTPUT.PUT_LINE(SQLCODE||&#39;---&#39;||SQLERRM);END;</code></pre><pre><code class="lang-sql">declare    v_cnt:=800;    v_name emp.ename%type;begin    begin        select ename into v_name from emp where sal=v_cnt;    exception         when no_data_found then              v_name:=&#39;&#39;;         when too_many_rows then              v_name:=&#39;&#39;;              dbms_output.put_line(&#39;存在多个雇员具有该工资&#39;);    end;    dbms_output.put_line(&#39;姓名：&#39; || v_name);exception     when others then          rollback;          dbms_output.put_line(&#39;异常回滚退出&#39;);end;</code></pre><p>自定义异常：</p><pre><code class="lang-sql">SET VERIFY OFFWHENEVER SQLERROR EXIT FAILURE ROLLBACK;WHENEVER OSERROR EXIT FAILURE ROLLBACK;SET SERVEROUTPUT ONDeclare  ex_test Exception;  PRAGMA EXCEPTION_INIT( ex_test, -20001 );  l_version number;Begin    dbms_output.put_line(&#39;Start!&#39;);    update table_a set object_version_number=object_version_number+1 where name = &#39;test&#39;;    select max(object_version_number) into l_version from table_a where name= &#39;test&#39;;    -- 使用聚合函数，则在没有数据时不会导致NO_DATA_FOUND异常    if l_version is null then        dbms_output.put_line(&#39;NO data!&#39;);    end if;    dbms_output.put_line(&#39;version:&#39;||l_version);    raise_application_error( -20001, &#39;This is a custom error&#39; );        -- 抛出自定义异常    dbms_output.put_line(&#39;Finish!&#39;);Exception        -- 这里定义了Exception捕获，则上面的WHENEVER ERROR ROLLBACK将无法捕获到异常Rollback    When others then        dbms_output.put_line(&#39;execute fail:&#39;||SQLCODE||&#39;---&#39;||SQLERRM);End;/commit;Exit;</code></pre><p>测试：</p><ol><li><p>没有name=’test’的记录的情况下:</p><pre><code class="lang-sql"> select * from table_A; name  object_version_number tom        1 lucy        2 ----------------------------------------- PL/SQL procedure successfully completed. Start! NO data! version: execute fail:-20001---ORA-20001: This is a custom error Commit complete. Disconnected from Oracle Database 12c Enterprise Edition Release 12.1.0.2.0 - 64bit Production With the Partitioning, OLAP, Advanced Analytics and Real Application Testing options</code></pre></li><li><p>有name=’test’的记录的情况下：</p><pre><code class="lang-sql"> select * from table_A; name  object_version_number tom        1 lucy        2 test        2 ----------------------------------------- PL/SQL procedure successfully completed. Start! version:3 execute fail:-20001---ORA-20001: This is a custom error Commit complete. Disconnected from Oracle Database 12c Enterprise Edition Release 12.1.0.2.0 - 64bit Production With the Partitioning, OLAP, Advanced Analytics and Real Application Testing options ---------------------------------------- -- 执行后，name=&#39;test&#39;的object_version_number更新了 select * from table_A; name  object_version_number tom        1 lucy        2 test        3</code></pre></li></ol><h2 id="header-9">读取记录到变量</h2><h3 id="header-10">SELECT INTO STATEMENT</h3><p>将<code>select</code>查询的结果存入到变量中，可以同时将多个列存储多个变量中，必须有一条记录，否则抛出异常(如果没有记录抛出<code>NO_DATA_FOUND</code>)</p><pre><code class="lang-sql">BEGIN  SELECT col1,col2 into 变量1,变量2 FROM typestruct where xxx;EXCEPTION  WHEN NO_DATA_FOUND THEN      xxxx;END;</code></pre><h3 id="header-11">游标 Cursor</h3><ol><li><p>隐性Cursor</p><pre><code class="lang-sql"> for 变量名 in （SELECT 语句）loop      ..... END LOOP;</code></pre></li><li><p>显性Cursor</p><pre><code class="lang-sql"> -- 无参数的显性游标： CURSOR 游标名 IS SELECT 语句; -- 带参数的显性游标 -- parameter 参数形式： -- 1.  参数名 数据类型 -- 2.  参数名 数据类型 DEFAULT 默认值 -- eg:  Cursor MyCursor(pSal  Number  Default   800)  Select   JOB  From  empa Where  SAL &gt;  pSal ; CURSOR 游标名(parameter[,parameter],...) IS SELECT 语句;</code></pre></li><li><p>Cursor状态属性</p><pre><code class="lang-sql"> %Found            -- Fetch语句（获取记录）执行情况 True or False。 %NotFound        -- 最后一条记录是否提取出 True or False。 %ISOpen            -- 游标是否打开True or False。 %RowCount        -- 游标当前提取的行数</code></pre></li><li><p>使用</p><ul><li>While 循环<pre><code class="lang-sql">  WHILE 游标名%found LOOP       ...  END LOOP;</code></pre></li><li><p>For 循环: 隐式打开游标，自动滚动获取一条记录，并自动创建临时记录类型变量存储记录。处理完后自动关闭游标</p><pre><code class="lang-sql">  For  变量名  In  游标名    Loop        数据处理语句；  End Loop；  -- 示例：  Declare       Cursor myCur is select * from emp;  Begin       for varA in myCur       loop           dbms_output.put_line(myCur%rowCount || &#39;    &#39; || varA.empno || &#39;    &#39; || varA.ename || &#39;  &#39; || varA.sal);       end loop;  End;</code></pre></li><li><p>Loop 循环: 需手动打开，关闭游标</p><pre><code class="lang-sql">  open 游标名;  Loop       Fetch  游标名 InTo  临时记录或属性类型变量；       Exit  When  游标名%NotFound；        数据处理语句；  End   Loop；  Close 游标名;  -- 示例：  Declare       Cursor myCur is select ename,job,sal,empno from emp;       varE myCur%rowType;  Begin       if myCur%isopen = false then          open myCur;          dbms_output.put_line(&#39;Opening...&#39;);       end if;       loop          fetch myCur into varE;          exit when myCur%notfound;          dbms_output.put_line(myCur%rowCount || &#39;    &#39; || vare.empno || &#39;    &#39; || vare.ename || &#39;    &#39; || vare.sal);       end loop;       if myCur%isopen then          Close myCur;          dbms_output.put_line(&#39;Closing...&#39;);       end if;  End;</code></pre></li></ul></li><li><p>嵌套Cursor</p><pre><code class="lang-sql"> declare      v_id char(2);      cursor c1 is select id,name from  a;      cursor c2 is select * from  b where id0000=v_id;   begin      for i in c1 loop           v_id:=i.id;           for j in c2 loop                ...           end loop;      end loop;   end;</code></pre><ul><li>示例：<pre><code class="lang-sql">  declare      v_0 number;       v_1 number;       cursor c1 is select productordernumber from his_productorder@pro_crm where productid in (9000045516);       cursor c2 is select cust_order_id from suf_cust_order_q_his where cust_order_num like v_0||&#39;%&#39;;       cursor c3 is select * from suf_work_order_q_his where cust_order_id=v_1;   begin       for i in c1 loop           v_0:=i.productordernumber;           for j in c2 loop               v_1:=j.cust_order_id;               for k in c3 loop                    dbms_output.put_line(k.work_order_id||&#39; &#39;||k.status);               end loop;           end loop;       end loop;     end;</code></pre><pre><code class="lang-sql">  create or replace procedure proc_nest_cursor  as      cursor cur_acctinactprocess is select mediumid,acctnbr,vouchnbr from acctinactprocess;      v_mediumid ACCTINACTPROCESS.MEDIUMID%type;      v_acctnbr  ACCTINACTPROCESS.Acctnbr%type;      v_vouchnbr ACCTINACTPROCESS.Vouchnbr%type;      v_vouchname vouchinfo.vouchname%type;      cursor cur_vouchinfo(lvsvouchnbr vouchinfo.vouchnbr%type) is select vouchnbr,vouchname from vouchinfo where vouchnbr=lvsvouchnbr;  begin      open cur_acctinactprocess;      loop            fetch cur_acctinactprocess into v_mediumid,v_acctnbr,v_vouchnbr;            exit when cur_acctinactprocess%notfound;            dbms_output.put_line(&#39;外层循环开始: &#39;||&#39;介质号:&#39;||v_mediumid||&#39; 账号:&#39;||v_acctnbr||&#39; 凭证号:&#39;||v_vouchnbr);            -- 内层游标以外层游标的数据为基础，如果匹配外层游标，就进入内层游标进行处理            open cur_vouchinfo(v_vouchnbr);            loop                fetch cur_vouchinfo into v_vouchnbr,v_vouchname;                exit when cur_vouchinfo%notfound;                dbms_output.put_line(&#39;内层循环的值: &#39;||&#39; 凭证号:&#39;||v_vouchnbr||&#39; 凭证名称&#39;||v_vouchname);            end loop;            close cur_vouchinfo;        end loop;        close cur_acctinactprocess;  end;</code></pre></li></ul></li></ol><h3 id="header-12">Bulk Collect &amp; Forall</h3><p><strong> BLUK COLLECT </strong> </p><p>一次取出一个数据集合，比用游标条取数据效率高，尤其是在网络不大好的情况下 ，但需要大量内存 </p><ul><li>可将查询结果一次性地加载到<code>collections</code>中，而不是通过<code>cursor</code>一条一条地处理</li><li>可以在<code>select into</code> ，<code>fetch into</code> ， <code>returning into</code>语句中使用</li><li>使用<code>BULK COLLECT</code>时，所有的<code>INTO</code>变量都必须是<code>collections</code></li><li>可以限制<code>BULK COLLECT</code> 提取的记录数，eg：<code>FETCH cursor BULK COLLECT INTO ...[LIMIT rows];</code></li></ul><p>示例：</p><ol><li><p>可变数组取表（<code>bulk collect into</code>），执行效率高于<code>cursor</code></p><pre><code class="lang-sql"> declare      type type_array is table of t_user%rowtype index by binary_integer;   -- 类似二维数组      var_array type_array; begin      select * bulk collect into var_array from t_user;      for i in 1..var_array.count loop          dbms_output.put_line(var_array(i).user_id);                          -- 二维数组的访问          dbms_output.put_line(var_array(i).username);      end loop; end;</code></pre></li><li><p>在<code>returning into</code>中使用bulk collect :（有了<code>returning</code>子句后，我们可以轻松地确定刚刚完成的DML操作的结果，无须再做额外的查询工作）</p><pre><code class="lang-sql"> CREATE TABLE test_forall2 AS SELECT * FROM test_forall;   ----在returning into中使用bulk collect   DECLARE      TYPE IdList IS TABLE OF test_forall.User_Id%TYPE;      enums IdList;      TYPE NameList IS TABLE OF test_forall.user_name%TYPE;      names NameList;   BEGIN      DELETE FROM test_forall2 WHERE user_id = 10100           RETURNING user_id, user_name BULK COLLECT INTO enums, names;      dbms_output.put_line(&#39;Deleted &#39; || SQL%ROWCOUNT || &#39; rows:&#39;);      FOR i IN enums.FIRST .. enums.LAST      LOOP        dbms_output.put_line(&#39;User #&#39; || enums(i) || &#39;: &#39; || names(i));      END LOOP;      COMMIT;   EXCEPTION       WHEN OTHERS THEN           ROLLBACK;   END;</code></pre></li><li><p><code>bulk collection limit</code></p><pre><code class="lang-sql"> declare   type v_t_oid is table of ljz_all_objects.object_id%type;   v_oid_lst      v_t_oid;   type v_t_cur_oid is ref cursor;   v_cur_oid      v_t_cur_oid;   v_cnt          simple_integer := 1000; begin   open v_cur_oid for &#39;select object_id from ljz_all_objects where object_id&gt;:1&#39;     using 1;   fetch v_cur_oid bulk collect into v_oid_lst limit v_cnt;   while v_oid_lst.count &gt; 0 loop     for i in 1 .. v_oid_lst.count loop       --业务处理逻辑       v_oid_lst(i) := v_oid_lst(i) + 1;     end loop;     forall i in v_oid_lst.first .. v_oid_lst.last       insert into ljz_test (col) values (v_oid_lst(i));     fetch v_cur_oid bulk collect into v_oid_lst limit 1000;     commit;   end loop;   close v_cur_oid; end;</code></pre></li></ol><p><strong> Forall </strong> </p><p>比FOR效率高，只切换一次上下文 ( FOR 在循环次数一样多个上下文间切换 ) </p><ul><li>只允许一条 sql 语句</li><li>INDICES OF 当绑定数组为稀疏数组或者包含有间隙时，会有用</li><li>VALUES OF 只想使用该数组中元素的一个子集时，会有用</li></ul><p>语法：</p><pre><code class="lang-sql">FORALL index_name IN    { lower_bound .. upper_bound        | INDICES OF collection_name [ BETWEEN lower_bound AND upper_bound ]        | VALUES OF index_collection    }[ SAVE EXCEPTIONS ] dml_statement;</code></pre><p>说明：</p><ul><li><code>index_name</code> : 一个无需声明的标识符，作为集合下标使用</li><li><code>lower_bound .. upper_bound</code> : 数字表达式，来指定一组连续有效的索引数字下限和上限。该表达式只需解析一次</li><li><code>INDICES OF collection_name</code> : 用于指向稀疏数组的实际下标。跳过没有赋值的元素，例如被 <code>DELETE</code> 的元素，<code>NULL</code> 也算值</li><li><code>VALUES OF index_collection</code> : 把该集合中的值当作下标，且该集合值的类型只能是<code>PLS_INTEGER/BINARY_INTEGER</code></li><li><code>SAVE EXCEPTIONS</code> : 可选关键字，表示即使一些DML语句失败，直到<code>FORALL LOOP</code>执行完毕才抛出异常。可以使用<code>SQL%BULK_EXCEPTIONS</code> 查看异常信息</li><li><code>dml_statement</code> : 静态语句，例如：<code>UPDATE</code>或者<code>DELETE</code>；或者动态（<code>EXECUTE IMMEDIATE</code>）DML语句</li></ul><p>例如：</p><pre><code class="lang-sql">FORALL i IN dr_table.first .. dr_table.last FORALL i IN INDICES OF  demo_tableFORALL i IN VALUES OF index_poniter</code></pre><p>示例:</p><ol><li><p><code>lower_bound .. upper_bound</code></p><pre><code class="lang-sql"> declare     type dr_type is table of test1%ROWTYPE index by binary_integer;     dr_table dr_type;   begin     select id, name BULK COLLECT into dr_table from test1;     FORALL i IN dr_table.first .. dr_table.last       insert into test2 values dr_table (i);     --error statement     --1.insert into test2 values(dr_table(i));报没有足够的值错误，此处外面不可以加括号，当有多个字段的时候，单个字段可以加括号     --2.insert into test2 values(dr_table(i).id,dr_table(i).name);集合的field不可以在forall中使用，必须是整体使用     --3.insert into test2 values dr_table(i+1);错误，不可以对索引变量进行运算     --4.insert into test2 values dr_table(i);dbms_output.put_line(i);不正确，找不到i，因为forall中只能使用单条语句可以引用索引变量   end;</code></pre></li><li><p><code>indices of</code></p><pre><code class="lang-sql"> DECLARE   TYPE demo_table_type IS TABLE OF tmp_tab%rowtype INDEX BY BINARY_INTEGER;   demo_table demo_table_type; BEGIN   FOR i IN 1..10 LOOP     demo_table(i).id:=i;     demo_table(i).name:=&#39;NAME&#39;||i;   END LOOP;   -- 使用集合的delete方法移除第3、6、9三个成员    demo_table.delete(3);    demo_table.delete(6);    demo_table.delete(9);    FORALL i IN INDICES OF  demo_table      INSERT INTO tmp_tab VALUES demo_table(i);  END ;</code></pre></li><li><p><code>values of</code></p><pre><code class="lang-sql"> DECLARE   TYPE index_poniter_type IS TABLE OF pls_integer;   index_poniter index_poniter_type;   TYPE demo_table_type IS TABLE OF tmp_tab%rowtype INDEX BY BINARY_INTEGER;   demo_table demo_table_type; BEGIN    index_poniter := index_poniter_type(1,3,5,7);   FOR i IN 1..10 LOOP      demo_table(i).id:=i;      demo_table(i).name:=&#39;NAME&#39;||i;    END LOOP;    FORALL i IN VALUES OF index_poniter      INSERT INTO  tmp_tab VALUES demo_table(i);  END;</code></pre></li></ol><h2 id="header-13">动态SQL</h2><pre><code class="lang-sql">declare  compDetail_cur number;  vQuery varchar2(500);  vStat NUMBER;  vId Number;  vColDesc dbms_sql.desc_tab;  vColCnt Number;begin  vQuery := &#39;select * from pay_dir_comp_details_f where dir_card_comp_id=:pCompId&#39;;  compDetail_cur := dbms_sql.open_cursor;  dbms_sql.parse(compDetail_cur,vQuery,dbms_sql.native);  dbms_sql.bind_variable(compDetail_cur,&#39;:pCompId&#39;,&#39;300100090712274&#39;);  dbms_sql.define_column(compDetail_cur,1,vId);  dbms_sql.describe_columns(compDetail_cur, vColCnt, vColDesc);  for i in 1..vColCnt  loop    dbms_output.put_line(vColDesc(i).col_type || &#39; &#39; || vColDesc(i).col_name || &#39; &#39; || vColDesc(i).col_max_len);  end loop;  vStat := dbms_sql.execute(compDetail_cur);  loop      exit when dbms_sql.fetch_rows(compDetail_cur)&lt;=0;      dbms_sql.column_value(compDetail_cur,1,vId);      dbms_output.put_line(vId);  end loop;  dbms_sql.close_cursor(compDetail_cur);end;</code></pre><pre><code class="lang-sql">declare     v_sql varchar2(2000);begin  v_sql:=&#39;insert into test values (sysdate)&#39;;        --给sql赋值  dbms_output.put_line(v_sql);                        --打印  execute immediate v_sql;                            --执行sql  commit;end;</code></pre><h2 id="header-14">EXECUTE IMMEDIATE</h2><ul><li>不会提交一个DML(CRUD)事务执行，应该显式提交 </li><li>处理DDL命令(Create/Drop/Alter),它提交所有以前改变的数据</li></ul><pre><code class="lang-sql">EXECUTE IMMEDIATE    &#39;CREATE TABLE &#39;|| l_ctx_b_backup ||&#39; AS     ( SELECT a.* , &#39;&#39;Y&#39;&#39; AS process_flag, systimestamp as run_date from tableA a where a.protected_flag !=&#39;&#39;Y&#39;&#39; )&#39;;EXECUTE IMMEDIATE &#39;UPDATE &#39;|| l_ctx_b_backup || &#39; SET process_flag = &#39;&#39;N&#39;&#39; WHERE process_flag = &#39;&#39;Y&#39;&#39;&#39;;</code></pre><h2 id="header-15">数组 Array</h2><p>oracle 数组类型，没有现成的类型，但是可以自己随意定义</p><p>示例： </p><ol><li><p>定长字符数组</p><pre><code class="lang-sql"> /*定长字符数组，数组大小为10*/   declare       type v_arr is varray(10) of varchar2(30);       my_arr v_arr;       my_arr:=v_arr(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;);   begin       for i in 1..my_arr.count       loop           dbms_output_line(my_arr(i));       end loop;   end;</code></pre></li><li><p>可变长字符数组</p><pre><code class="lang-sql"> /*可变长字符数组，元素大小30，索引标号integer类型自增长*/   declare     type v_table is table of varchar2(30) index by binary_integer;      --类型可以是前面的类型定义，index by binary_integer子句代表以符号整数为索引，      --这样访问表类型变量中的数据方法就是“表变量名(索引符号整数)”。      my_table v_table;      begin          for i in 1..20           loop                my_table(i):=i;                dbms_output.put_line(my_table(i));            end loop;      end;</code></pre></li><li><p>定义含有多个字段的数组类型变量</p><pre><code class="lang-sql"> -- PLSQL 定义含有多个字段的数组类型变量 DECLARE   TYPE user_info_type IS RECORD(     user_name VARCHAR2(20),     user_age  NUMBER(3),     user_sex  VARCHAR2(5)   );     -- 自定义属性   TYPE user_info_arr_type IS TABLE OF user_info_type INDEX BY BINARY_INTEGER;     -- 使用这个属性来创建动态数组   user_info_arr user_info_arr_type; BEGIN   user_info_arr(0).user_name := &#39;张三&#39;;   user_info_arr(0).user_age := 19;   user_info_arr(0).user_sex := &#39;男&#39;;   user_info_arr(1).user_name := &#39;李菁菁&#39;;   user_info_arr(1).user_age := 23;   user_info_arr(1).user_sex := &#39;女&#39;;   FOR i IN 0 .. 1   LOOP     dbms_output.put_line(&#39;User Name:&#39; || user_info_arr(i).user_name);     dbms_output.put_line(&#39;User Age:&#39; || user_info_arr(i).user_age);     dbms_output.put_line(&#39;User Sex:&#39; || user_info_arr(i).user_sex);   END LOOP; END;</code></pre><ul><li>输出结果：<pre><code>  User Name:张三   User Age:19   User Sex:男   User Name:李菁菁   User Age:23   User Sex:女</code></pre></li></ul></li><li><p>可变数组取表（<code>bulk collect into</code>），执行效率高于<code>cursor</code></p><pre><code class="lang-sql"> declare      type type_array is table of t_user%rowtype index by binary_integer;   -- 类似二维数组      var_array type_array; begin      select * bulk collect into var_array from t_user;      for i in 1..var_array.count loop          dbms_output.put_line(var_array(i).user_id);          -- 二维数组的访问          dbms_output.put_line(var_array(i).username);      end loop; end;</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      Write Oracle Script
    
    </summary>
    
    
      <category term="SQL" scheme="http://sixdegree.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB</title>
    <link href="http://sixdegree.github.io/2018/08/04/MongoDB.html"/>
    <id>http://sixdegree.github.io/2018/08/04/MongoDB.html</id>
    <published>2018-08-03T16:00:00.000Z</published>
    <updated>2018-11-25T13:51:57.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>使用Docker搭建MongoDB测试环境</li><li>Transaction，ACID，WriteConcern</li><li>CRUD</li><li>Index</li><li>Aggregate</li><li>Replica Set &amp; Sharding</li><li>MongoDB 4.0 New Feature</li><li>Applicaiton</li></ol><a id="more"></a><h2 id="header-1">Starter</h2><blockquote><p>文档型数据库： 一条记录就是一个文档，由字段和值对组成（BSON）</p></blockquote><p><a href="www.mongodb.org">官网</a> | <a href="http://www.mongoing.com/docs/index.html" target="_blank" rel="noopener">Doc</a> | <a href="http://www.mongoing.com/" target="_blank" rel="noopener">中文社区</a> | <a href="https://github.com/mongodb" target="_blank" rel="noopener">Github</a> | <a href="https://jira.mongodb.org" target="_blank" rel="noopener">Jira (bug fix)</a></p><ol><li><p>特性：</p><ul><li>无数据结构限制（每条记录可以有完全不同的结构）</li><li>完全的索引支持（单键／多键索引，复合索引，全文索引，地理位置索引）</li><li>丰富的查询语言（Shell内置javascript引擎可以直接执行JS代码）</li><li>方便的冗余和扩展（复制集Replica Set：保证数据安全，高可用性，分片Sharding：水平扩展数据规模）</li><li>插件化的存储引擎支持（WiredTiger, MMAPv1, In-Memory, Encrypted, 3rd Party Engine）<ul><li>WiredTiger（存储引擎）: <ul><li>MongoDB3.2 之后的默认存储引擎</li><li>拥有效率非常高的缓存机制</li><li>支持在内存中和磁盘上对索引进行压缩（压缩时使用了前缀压缩的方式以减少RAM的使用）</li><li>能够保证对于同一个文档的操作都是原子的，任意一个写操作都不能原子性地影响多个文档或者多个集合</li></ul></li></ul></li></ul></li><li><p>使用：</p><ul><li>CRUD -&gt; 索引创建和使用 -&gt; 复杂聚合查询 -&gt; 数据集分片，在不同分片间维持数据均衡 -&gt; 数据备份和恢复 -&gt; 数据迁移</li></ul></li><li><p>部署：</p><ul><li>单机 -&gt; 拥有冗余容错功能的复制集 -&gt; 分片大规模数据集群(横向扩展，自动分片，轻松支持TB-PB数量级) -&gt; 集群的自动部署<br><img src="/2018/08/04/High-Deploy.png" alt="High Deploy"></li></ul></li></ol><h3 id="header-2">数据模型</h3><p><strong> RelationDB vs. MongoDB : </strong></p><ol><li>RelationDB: <ul><li>Table -&gt; Record -&gt; field &amp; value</li></ul></li><li>MongoDB: <ul><li>Collection -&gt; Document -&gt; key &amp; value</li><li>表示文档间关系的方式：<ul><li><code>Reference</code> 引用：标准化的数据模型，可通过某个引用值链接到其他文档（与 MySQL 的外键非常相似，但不会对引用的对象是否真正存在做出任何的约束）<br>  <img src="/2018/08/04/model-reference.png" alt="model-reference"> </li><li><code>Embedded Data</code> 嵌入：非标准化的数据模型，相关联的数据保存在同一个文档结构之内<br>  <img src="/2018/08/04/model-embedded.png" alt="model-embeded"></li></ul></li><li>注：MongoDB不对Collection的数据结构进行限制，但在实际使用中，尽量同一个Collection中的文档具有类似的结构</li></ul></li></ol><h3 id="header-3">搭建MongoDB测试环境</h3><p>这里直接使用Docker搭建MongoDB测试环境</p><ol><li>搜索下载mongo image<pre><code class="lang-bash"> $ docker search mongo $ docker pull mongo</code></pre></li><li><p>启动一个容器(micro-mongo)作为mongo server</p><pre><code class="lang-bash"> # 建一个单独的数据卷store-mongo (为防止docker machine重启后数据丢失) $ docker create --name store-mongo mongo # 创建启动一个container as mongo server : micro-mongo，并挂载数据卷store-mongo $ docker run --volumes-from store-mongo --name micro-mongo -p 27017:27017 -e MONGO_INITDB_ROOT_USERNAME=mongoadmin -e MONGO_INITDB_ROOT_PASSWORD=123456 -d mongo:latest # 检查 $ docker ps $ docker log</code></pre></li><li>使用：<ul><li>方式一：直接进入刚才创建的mongo server容器(micro-mongo)<pre><code class="lang-bash">  $ docker exec -it micro-mongo /bin/bash  root@480e8bf33600:/# mongo -u mongoadmin -p 123456 --authenticationDatabase admin  &gt; show dbs  admin   0.000GB  config  0.000GB  demo    0.000GB  local   0.000GB</code></pre></li><li>方式二：启动一个容器(mongo)作为mongo client连接刚才的micro-mongo<pre><code class="lang-bash">  $ docker run -it --rm --link micro-mongo:mongod --name mongo-client mongo:latest mongo -host mongod -u mongoadmin -p 123456 --authenticationDatabase admin demo  &gt; show dbs  admin   0.000GB  config  0.000GB  demo    0.000GB  local   0.000GB</code></pre></li><li>方式三：客户端工具 MongoDB Compass</li></ul></li><li>导入测试数据 <pre><code class="lang-bash"> # load(filename): Loads and runs a JavaScript file into the current shell environment &gt; load(&quot;testData.js&quot;)</code></pre></li></ol><h3 id="header-4">Server/Client</h3><ul><li><p>Server: 启动服务，使用命令<code>mongod</code></p><pre><code class="lang-bash">  $ vi conf/mongod.conf  port = 12345  dbpath = data  logpath = log/mongod.log  fork = true  $ mongod -f conf/mongod.conf</code></pre></li><li><p>Client: 连接数据库，使用命令<code>mongo</code></p><pre><code class="lang-bash">  $ mongo --help  $ mongo localhost:12345/testdb  &gt; use admin  &gt; db.shutdownServer()</code></pre></li></ul><h3 id="header-5">Mongo Shell</h3><p>MongoDB的Shell内置javascript引擎可以直接执行JS代码</p><pre><code class="lang-bash"># 列出所有可用dbshow dbs# 查看当前正在使用的dbdb# 切换当前数据库上下文，即切换当前使用db# Note：可以切换到一个不存在的db，后面执行db.&lt;collection&gt;.insert(...)操作时会自动创建use &lt;database&gt;# 查看当前db的集合集(table)show collectionsshow tables# 格式化打印结果db.myCollection.find().pretty()# 无格式打印db.myCollection.print()# JSON格式打印db.myCollection.printjson()# 多行操作# 代码行以 &#39;(&#39;，&#39;{&#39;,&#39;[&#39; 结束，则随后一行将以省略号 &quot;...&quot; 开始，直到输入对应的&#39;)&#39;，&#39;}&#39;，&#39;]&#39;if(x&gt;0){...count++;...print(x);...}# Tab命令补全# 例如下面 &lt;Tab&gt; 补全后将列出各种以‘c’开头的方法db.myCollection.c&lt;Tab&gt;</code></pre><h2 id="header-6">ACID</h2><p><img src="/2018/08/04/txn.png" alt="Transaction"></p><table class="table"><thead><tr><th>事物特性</th><th style="text-align:left">MongoDB</th><th style="text-align:left">MySQL (InnoDB)</th></tr></thead><tbody><tr><td>原子性 Atomicity</td><td style="text-align:left">单行/文档级原子性</td><td style="text-align:left">多行原子性</td></tr><tr><td>一致性 Consistency</td><td style="text-align:left">强一致或最终一致</td><td style="text-align:left">强一致</td></tr><tr><td>隔离性 Isolation</td><td style="text-align:left">提交读</td><td style="text-align:left">可重复读</td></tr><tr><td>持久性 Durability</td><td style="text-align:left">日志及复制</td><td style="text-align:left">日志</td></tr></tbody></table><h3 id="header-7">原子性 Atomicity</h3><p><img src="/2018/08/04/txn-atomicity1.png" alt="Atomicity"> <img src="/2018/08/04/txn-atomicity2.png" alt="Non-Atomicity"></p><ul><li>支持: 单行/文档级原子性<pre><code class="lang-javascript">  db.users.update({ username:&quot;Tom&quot;},{$set:{salary:5000}});</code></pre></li><li>尚不支持(4.0以下): 多行/多文档/多语句原子性 <pre><code class="lang-javascript">  db.users.update({ salary:{$lt:5000}},{$set:{salary:5000}});</code></pre><ul><li>开始状态:<table class="table"><thead><tr><th style="text-align:left">username</th><th style="text-align:left">salary</th></tr></thead><tbody><tr><td style="text-align:left">James</td><td style="text-align:left">3000</td></tr><tr><td style="text-align:left">Tom</td><td style="text-align:left">4000</td></tr><tr><td style="text-align:left">Melody</td><td style="text-align:left">4500</td></tr><tr><td style="text-align:left">Frank</td><td style="text-align:left">2500</td></tr><tr><td style="text-align:left">Kelly</td><td style="text-align:left">3500</td></tr><tr><td style="text-align:left">Lucy</td><td style="text-align:left">7600</td></tr></tbody></table></li><li>结束状态：中间出错（eg：宕机）<table class="table"><thead><tr><th style="text-align:left">username</th><th style="text-align:left">salary</th></tr></thead><tbody><tr><td style="text-align:left">James</td><td style="text-align:left">5000</td></tr><tr><td style="text-align:left">Tom</td><td style="text-align:left">5000</td></tr><tr><td style="text-align:left">Melody</td><td style="text-align:left">5000</td></tr><tr><td style="text-align:left">Frank</td><td style="text-align:left">2500 &lt;- 宕机</td></tr><tr><td style="text-align:left">Kelly</td><td style="text-align:left">3500</td></tr><tr><td style="text-align:left">Lucy</td><td style="text-align:left">7600</td></tr></tbody></table></li></ul></li></ul><h3 id="header-8">一致性 Consistency</h3><p><img src="/2018/08/04/txn-consistency.png" alt="Consistency"></p><p>多文档一致性处理：</p><ul><li>通过建模来避免</li><li>二阶段提交</li><li>记录日志，人工干预</li></ul><p>注：</p><ul><li>传统数据库：规则校验主外键</li><li>分布式数据库：多节点数据一致（Read your writes）<br>  <img src="/2018/08/04/txn-consistency-nodes.png" alt="MongoDB：可调一致性"></li></ul><h3 id="header-9">隔离性 Isolation</h3><p><img src="/2018/08/04/txn-isolation.png" alt="Isolation"></p><table class="table"><thead><tr><th style="text-align:left">Isolation Level</th><th style="text-align:left">Default Setting</th></tr></thead><tbody><tr><td style="text-align:left">Serializable</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Repeatable Read</td><td style="text-align:left">MySQL</td></tr><tr><td style="text-align:left">Read Committed</td><td style="text-align:left">PostgreSQL,Oracle</td></tr><tr><td style="text-align:left">Read UnCommitted</td><td style="text-align:left">MongoDB</td></tr></tbody></table><h3 id="header-10">持久性 Durability</h3><p><img src="/2018/08/04/txn-durability.png" alt="Durability"></p><ul><li>机制：<br>  <img src="/2018/08/04/txn-durability-journal.png" alt="MongoDB vs. 传统数据库"></li><li>MongoDB单节点写操作<br>  <img src="/2018/08/04/write-single-node.png" alt="MongoDB单节点写操作"></li><li>MongoDB多节点写操作<br>  <img src="/2018/08/04/write-multiple-nodes.png" alt="MongoDB多节点写操作"></li></ul><h3 id="header-11">写关注机制 WriteConcern</h3><pre><code class="lang-javascript">{ w: &lt;value&gt;, j: &lt;boolean&gt;, wtimeout: &lt;number&gt; }</code></pre><ul><li>用来指定mongoDB对写操作的回执行为</li><li>可在｀connection level｀或者｀写操作level｀(insert/update/delete操作的最后一个参数)指定</li><li>支持以下值：<ul><li><code>w</code>: 0/1/n/majority/tag</li><li><code>j</code>: true/false 或 0/1</li><li><code>wtimeout</code>: millis – only applicable for <code>w&gt;1</code></li></ul></li></ul><p><strong> 具体：</strong></p><ol><li><p><strong> <code>w</code>: write acknowledgement instance </strong></p><ul><li><p><code>w:0</code> Unacknowledged (无任何回执)</p><ul><li>2.2及以前版本的默认行为</li><li>网络丢包，系统崩溃，无效数据（早期版本丢数据之罪魁祸首）<br><img src="/2018/08/04/w0-unacknowledged.png" alt="Unacknowledged"></li></ul></li><li><p><code>w:1</code> Acknowledged （Mongod在写完内存后返送确认）</p><ul><li>2.4版本以后的默认行为</li><li>能够处理网络故障，无效数据等错误状态</li><li>系统崩溃时可能会丢失最多100ms数据<br><img src="/2018/08/04/w1-acknowledged.png" alt="Acknowledged"></li></ul></li><li><p><code>w:2/n/majority</code> Replica Acknowledged (等待数据复制到<code>n个/大部分</code>节点后再发送回执)<br>  <img src="/2018/08/04/wn-replicaAcknowledged.png" alt="Replica Acknowledged"></p></li></ul></li><li><p><strong> <code>j</code>: journal(恢复日志) </strong></p><ul><li>用于系统宕机时恢复内存数据,保证MongoDB中数据的持久性，<code>journal</code>与检查点<code>Checkpoint</code>协作：<ul><li>在数据文件中查找上一个Checkpoint标识符；</li><li>在 journal 日志文件中查找Checkpoint标识符对应的记录；</li><li>重做对应记录之后的全部操作；</li></ul></li><li>刷盘间隔：<ul><li>MMAP: 30~100ms</li><li>WiredTiger: 100MB/Checkpoint</li><li>eg: 每隔<code>60s</code> 或在 <code>journal文件</code>数据的写入达到<code>2GB</code>时设置一次<code>检查点Checkpoint</code></li></ul></li><li>默认为异步刷盘，可用<code>j:1</code>强制同步刷盘</li><li><code>j:1/true</code> Journaled，强制 journal 文件的同步 (Journal刷盘后再发送写回执)<br>  <img src="/2018/08/04/j1-journaled.png" alt="Journaled"></li></ul></li></ol><p><strong> 示例：</strong> </p><ol><li><p>场景：插入一些无效数据（eg：10个document同一个<code>_id</code>），检查实际插入数据数目</p><ul><li><p>不使用写关注 <code>{w:0}</code> : 未报错，本以为是10条记录但却显示1条记录</p><pre><code class="lang-bash">  &gt; db.test.count()  0  &gt; for(var i=0;i&lt;10;i++){      var res=db.test.insert({_id:10,a:i},{writeConcern:{w:0}})      if(!res.getWriteError())          print(&quot;Inserted doc #&quot;+(i+1));      else          print(res.getWriteError().errmsg);  }  Inserted doc #1  Inserted doc #2  Inserted doc #3  Inserted doc #4  Inserted doc #5  Inserted doc #6  Inserted doc #7  Inserted doc #8  Inserted doc #9  Inserted doc #10  &gt; db.test.count()  1                            # 期望值为10</code></pre></li></ul><ul><li><p>指定写关注<code>{w:1}</code> (2.4以后版本默认为1) : 会acknowledge写错误，返回给客户端，最后显示1条记录</p><pre><code class="lang-bash">  &gt; db.test.count()  0  &gt; for(var i=0;i&lt;10;i++){      var res=db.test.insert({_id:10,a:i},{writeConcern:{w:1}})      if(!res.getWriteError())          print(&quot;Inserted doc #&quot;+(i+1));      else          print(res.getWriteError().errmsg);  }  Inserted doc #1  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }  &gt; db.test.count()  1                            # 期望值为1</code></pre></li></ul></li><li><p>场景：系统崩溃导致数据丢失（eg：<code>w:1</code> 高速持续写入数据，<code>kill -9 mongod</code>强制关闭mongo服务，然后重新启动mongo检查程序汇报写入的数据和实际插入的数据）</p><pre><code class="lang-bash"> function journalDataLoss(journal){     var count=0,start=new Date();     try{         var docs=[];         for(var i=0;i&lt;1000;i++)             docs.push({a:i});         while(true){             var res=db.test.insert(docs,{writeConcern:{j:journal}})        # 0/1             count+=res.nInserted;             if(count%100000==0)                 print(&quot;inserted &quot;+count+&quot; time used:&quot;+(((new Date()).getTime()-start.getTime())/1000)+&quot; seconds&quot;);             }     }catch(error){         print(&quot;Total doc inserted successfully:&quot;+count);     } }</code></pre><ul><li><p><code>j:0</code> 不实时刷日志</p><pre><code class="lang-bash">  &gt; journalDataLoss(0)  Inserted 10000 times used: 3.579 seconds  Inserted 20000 times used: 7.123 seconds  ...  ...                                         &lt;- execute: kill -9 mongod  Total doc inserted successfully:715000  # 重启mongod，检查插入数量  &gt; db.test.count()  713000                        # 数据丢失</code></pre><p>  <img src="/2018/08/04/j0-journaled.png" alt="No Journaled"></p></li><li><p><code>j:1</code> 实时刷日志</p><pre><code class="lang-bash">  &gt; journalDataLoss(1)  Inserted 10000 times used: 4.579 seconds  Inserted 20000 times used: 8.123 seconds  ...  ...                                         &lt;- execute: kill -9 mongod  Total doc inserted successfully:726000  # 重启mongod，检查插入数量  &gt; db.test.count()  726000                        # 数据未丢失</code></pre></li></ul></li><li><p>场景：主备置换导致数据丢失（eg：<code>w:1/majority</code>,<code>j:1</code>高速持续写入数据，<code>kill -9 mongod</code>主节点，连接到新的主节点，检查实际插入的数据与程序汇报的插入数据）</p><ul><li><code>w:1</code><br>  <img src="/2018/08/04/write-case-1.png" alt="CaseC-1"><br>  <img src="/2018/08/04/write-case-2.png" alt="CaseC-2"><br>  <img src="/2018/08/04/write-case-3.png" alt="CaseC-3"></li><li><code>w:majority</code> 设置确认数据写到大部分节点再返回<br>  <img src="/2018/08/04/write-case-solution.png" alt="CaseC-Solution"></li></ul></li></ol><h3 id="header-12">MongoDB数据安全总结</h3><p><img src="/2018/08/04/write-concern.png" alt="WriteConcern"><br><img src="/2018/08/04/read-perference.png" alt="ReadPerference"></p><blockquote><p>Read preference describes how MongoDB clients route read operations to the members of a replica set.By default, an application directs its read operations to the primary member in a replica set.</p></blockquote><h2 id="header-13">CRUD</h2><h3 id="header-14">Create(insert)</h3><p>Insert Document into Collection<br>注：</p><ul><li>单条document操作是原子性的</li><li>每一个document都有一个唯一的<code>_id</code> 字段作为 primary_key（若未指定，则MongoDB自动为<code>_id</code>生成一个<code>ObjectId</code>）</li><li><code>_id</code>字段值无法修改</li></ul><pre><code class="lang-javascript">db.myCollection.insert({...})            # 返回WriteResult对象db.myCollection.insert([{},{},..])         # 返回BulkWriteResult对象db.myCollection.insertOne({...})db.myCollection.insertMany([{},{},..])</code></pre><h3 id="header-15">Read(find)</h3><pre><code class="lang-javascript">db.myCollection.find(&lt;query filter&gt;,&lt;projection&gt;)db.myCollection.findOne(...)// 参数&lt;query filter&gt;/&lt;projection&gt;格式：{  &lt;field1&gt;: &lt;value1&gt;,  &lt;field2&gt;: { &lt;operator&gt;: &lt;value&gt; },  ...}</code></pre><ol><li><p><code>&lt;query filter&gt;</code></p><ul><li>value：<ul><li>普通特定值</li><li><code>{ &lt;operator&gt;: &lt;value&gt; }</code>：specify conditions</li></ul></li><li><p>operator:</p><pre><code class="lang-bash">  #  Comparison  $eq,$gt,$gte,$lt,$lte,$ne,$in,$nin  # Logical  $or,$and,$not,$nor  # Element  $exists,$type  # Evaluation  $mod,$regex,$text,$where  # Geospatial  $geoWithin,$geoIntersects,$near,$nearsphere  # Array  $all,$elemMatch,$size  # Bitwise  $bitsAllSet,$bitsAnySet,$bitsAllClear,$bitsAnyClear  # Comments  $comment</code></pre></li></ul></li><li><p><code>&lt;projection&gt;</code></p><ul><li>value：<ul><li><code>1/true</code>: 返回文档包含该字段</li><li><code>0/false</code>: 返回文档排除该字段</li><li><code>{ &lt;operator&gt;: &lt;value&gt; }</code>: specify conditions</li></ul></li><li>operator：<pre><code class="lang-bash">  $,$elemMatch,$slice,$meta</code></pre></li><li>注：不能使用数组索引来指定映射的特定数组元素，eg： <code>{ &quot;ratings.0&quot;: 1 } -- wrong</code></li></ul></li><li><p>示例：</p><ul><li><p>查询</p><pre><code class="lang-bash">  db.users.find( { status:&quot;A&quot; } )  db.users.find( { status:{ $in:[&quot;P&quot;,&quot;D&quot;] } } )  db.users.find({      status:&quot;A&quot;,      $or:[ {age:{$lt:30}},{type:1} ]  })  # 嵌入式document匹配  db.users.find({      favorites:{artist:&quot;Picasso&quot;}  })  db.users.find({      &quot;favorites.artist&quot;:&quot;Picasso&quot;  })  # 精确匹配  db.users.find({      badges:[&quot;blue&quot;,&quot;black&quot;]  })      # 匹配包含black的  db.users.find({      badges:&quot;black&quot;  })      # 匹配第一个元素为black的  db.users.find({      &quot;badges.0&quot;:&quot;black&quot;  })      # 查询 finished 数组至少包含一个大于15并且小于20的元素的文档  # $elemMatch 为数组元素指定复合条件，查询数组中至少一个元素满足所有指定条件的文档  db.users.find({       finished: { $elemMatch: { $gt: 15, $lt: 20 } }   })  # 查询 finished 数组中包含大于15 ，或者小于20的元素的文档  db.users.find({       finished: { $gt: 15, $lt: 20 }   })</code></pre></li><li><p>查询返回部分字段</p><pre><code class="lang-javascript">  // 返回文档 _id,name,status 字段  db.users.find(      {status:&quot;A&quot;},      {name:1,status:1}  )  // 返回文档 name,status 字段  // Note: 除了 _id 字段，不能在映射文档中组合包含和排除语句  // Eg: name:1,status:0 -- wrong!  db.users.find({      {status:&quot;A&quot;},      {name:1,status:1,_id:0}  })  // 返回文档不显示 favorites,points字段  db.users.find({      {status:&quot;A&quot;},      {favorites:0,points:0}  })  // 返回文档显示_id,name,status,points的bonus字段  db.users.find({      {status:&quot;A&quot;},      {name:1,status:1,&quot;points.bonus&quot;:1}  })  // 使用$slice映射操作符来返回 points数组中最后的元素  db.users.find({      {status:&quot;A&quot;},      {name:1,status:1,&quot;points&quot;:{$slice:-1}}  })</code></pre></li></ul></li><li><p>注：</p><ul><li><p>查询值为Null或不存在的字段</p><pre><code class="lang-javascript">  { &quot;_id&quot; : 900, &quot;name&quot; : null },  { &quot;_id&quot; : 901 }</code></pre><ul><li><code>db.users.find({name:null})</code>: 会返回name为null和不存在name字段的记录（注：若使用了sparse稀疏索引，只会匹配到name为null的记录，不会匹配到不存在的）</li><li><code>db.users.find({name:{$type:&quot;null&quot;}})</code>: 只会返回name为null的记录 （<code>$type</code> <a href="http://www.mongoing.com/docs/reference/operator/query/type.html#op._S_type" target="_blank" rel="noopener">类型筛查</a>）</li><li><code>db.users.find({name:{$exists:false}})</code>: 只返回不存在name字段的documents (<code>$exists</code> 存在性筛查)</li></ul></li><li><p>游标Cursor</p><pre><code class="lang-javascript">  var myCursor=db.users.find({type:&quot;string&quot;})  while(myCursor.hasNext()){      printjson(myCursor.next())  }  myCursor.forEach(printjson);  myCursor.forEach(function(myDoc){      print(&quot;user:&quot;+myDoc.name);  })  var myArray=myCursor.toArray();  myArray[3];  myCursor[1]             // same with myCursor.toArray()[1]</code></pre><ul><li><code>find</code>方法返回的（若不赋给一个变量，则会自动遍历显示，默认是展示20条记录，可以使用<code>DBQuery.shellBatchSize</code> 来改变迭代结果的数量）</li><li>Cursor Method: count,hint,forEach,map,limit,sort,size,skip,toArray,… <a href="http://www.mongoing.com/docs/reference/method/js-cursor.html" target="_blank" rel="noopener">More</a></li></ul></li></ul></li></ol><h3 id="header-16">Update</h3><pre><code class="lang-javascript">db.myCollection.update(&lt;query filter&gt;,&lt;update document&gt;,&lt;option&gt;)    # 默认情况下只更新 一个 文档db.myCollection.updateOne(...)db.myCollection.updateMany(...)db.myCollection.replaceOne(...)// 更多：db.myCollection.findOneAndReplace()db.myCollection.findOneAndUpdate()db.myCollection.findAndModify()</code></pre><ol><li><code>&lt;query filter&gt;</code>: 同上</li><li><p><code>&lt;update document&gt;</code>: </p><ul><li><code>{ &lt;field1&gt;: &lt;value1&gt;, ... }</code></li><li><code>{&lt;update operator&gt;: { &lt;field1&gt;: &lt;value1&gt;, ... },...}</code></li><li><p>update operators:</p><pre><code class="lang-bash">  # Field  $inc  $mul  $rename  $setOnInsert  $set  $unset  $min  $max  $currentDate  # Array  $  $[]  $[&lt;identifier&gt;]  $addToSet  $pop  $pull  $push  $pullAll  # Modifiers  $each  $position  $slice  $sort  # Bitwise  $bit</code></pre></li></ul></li><li><p><code>&lt;option&gt;</code> </p><ul><li>multi:false/true 配置是否更新多个文档</li><li>upsert:false/true 表示不存在时是否插入新的document</li></ul></li><li><p>示例：</p><pre><code class="lang-javascript"> db.users.update(    { name: &quot;xyz&quot; },    { name: &quot;mee&quot;, age: 25, type: 1, status: &quot;A&quot;, favorites: { &quot;artist&quot;: &quot;Matisse&quot;, food: &quot;mango&quot; } } ) db.users.update(     {status:&quot;A&quot;},     {         $set:{status:&quot;B&quot;,type:0},         $currentDate:{lastModified:true}     },     {multi:true} )</code></pre></li></ol><h3 id="header-17">Delete</h3><pre><code class="lang-javascript">// deletedb.myCollection.deleteOne(&lt;query filter&gt;)// delete all matcheddb.myCollection.deleteMany(...)db.myCollection.remove(&lt;query filter&gt;, &lt;justOne&gt;)// delete all,include indexdb.myCollection.drop()// 删除以指定顺序排序的文档中的第一个文档.db.myCollection.findOneAndDelete().</code></pre><p>示例：</p><pre><code class="lang-javascript">// delete all documentsdb.users.deleteMany({})db.users.remove({})// delete all matcheddb.users.remove({status:&quot;D&quot;})db.users.deleteMany({status:&quot;D&quot;})// delete just one// &lt;justOne&gt;:1db.users.remove({status:&quot;D&quot;},1}db.users.deleteOne({status:&quot;D&quot;})</code></pre><h3 id="header-18">WriteConcern</h3><p>在安全写情况下,可以指定MongoDB写操作要求的确认级别（insert/update/delete 操作的最后一个参数）</p><pre><code class="lang-javascript">{ w: &lt;value&gt;, j: &lt;boolean&gt;, wtimeout: &lt;number&gt; }</code></pre><ul><li><code>w</code>:0/1/“majority” – write acknowledgement instance</li><li><code>j</code>:true/false – journal</li><li><code>wtimeout</code> – only applicable for w&gt;1</li></ul><h2 id="header-19">索引 Index</h2><ul><li>优点：加快索引相关的查询；</li><li>缺点：增加磁盘空间消耗，降低写入性能</li></ul><h3 id="header-20">CRUD</h3><ol><li><p>创建索引</p><pre><code class="lang-javascript"> // &lt;field&gt;: &lt; 1 or -1 &gt; // 1 : 索引正序，－1 : 索引倒序 db.collection.createIndex( &lt;Key Index specification&gt;, &lt;options&gt;)</code></pre></li><li><p>查看索引</p><pre><code class="lang-javascript"> db.collection.getIndexes()</code></pre></li><li><p>删除索引</p><pre><code class="lang-javascript"> db.collection.dropIndex({...}) db.collection.dropIndexs()</code></pre></li><li><p>重建索引: ( drop all indexes,include _id index,then rebuilds all in the background,rebuild _id index in the foreground,which takes the db’s write lock.)</p><pre><code class="lang-javascript"> db.collection.reIndex()</code></pre></li><li><p>检查索引</p><pre><code class="lang-javascript"> // 扫描集合中的数据和索引以检查正确性的内部命令 db.collection.validate()</code></pre></li></ol><h3 id="header-21">单字段/复合/多键索引</h3><ol><li><p>单字段索引 Single Field Index</p><pre><code class="lang-javascript"> db.users.createIndex({age:-1});</code></pre><ul><li>在任意一个field上（包括Embedded Field）建立索引</li><li>默认索引 <code>_id</code>：类型ObjectId(代替递增的 id，能够解决分布式的 MongoDB 生成唯一标识符的问题)，12个字节构成: <code>Timestamp(4)+MachineIdentifier(3)+ProcessIdentifier(2)+Coounter(3)</code></li><li>可配置顺序/倒序(<code>1</code>: 正序，<code>-1</code>:倒序)</li></ul></li><li><p>复合索引 Compound Index</p><pre><code class="lang-javascript"> db.users.createIndex( { username: 1, age: -1 } ) db.users.createIndex( { username: 1, age: 1 } ) // 方便按照username和age查找 db.users.find({username:&quot;Tom&quot;,age:5});</code></pre><ul><li>多个不同field组成</li><li>注：上面的两个索引是完全不同的，在磁盘上的 <code>B+树</code> 其实也按照了完全不同的顺序进行存储，在使用查询语句对集合中数据进行查找时，是会使用不同的索引，所以在索引创建时要考虑好使用的场景，避免创建无用的索引。</li></ul></li><li><p>多键索引 Multikey Index</p><pre><code class="lang-javascript"> //{ _id: 1, item: &quot;ABC&quot;, ratings: [ 2, 5, 9 ] } db.survey.createIndex( { ratings: 1 } )</code></pre><ul><li>在一个储存数组的键上添加索引，会对数组中的每个元素都添加索引项，加速对数组中元素的查找</li><li>注：不需要显示地指定索引为多键类型，MongoDB会自动地决定是否需要创建一个多键索引</li></ul></li></ol><h3 id="header-22">文本索引</h3><p>Text Index 文本索引（也叫全文索引）</p><ul><li>支持在字符串内容上的文本检索查询</li><li>一个集合只能有一个文本检索索引，但是这个索引可以覆盖多个字段</li><li>创建文本索引（<code>name:&quot;text&quot;</code>）：<pre><code class="lang-javascript">  db.stores.createIndex({name:&quot;text&quot;,description:&quot;text&quot;})        # 在name，description字段建立文本索引</code></pre></li><li>查询：使用<code>$text</code>操作符在一个创建了text index的Collection上执行文本检索<pre><code class="lang-javascript">  {    $text:      {        $search: &lt;string&gt;,        $language: &lt;string&gt;,        $caseSensitive: &lt;boolean&gt;,        $diacriticSensitive: &lt;boolean&gt;      }  }</code></pre></li><li>查询示例：<ul><li><code>$text</code> 会使用空格和标点符号作为分隔符对检索字符串进行分词 (OR操作)<pre><code class="lang-javascript">  // 包含 aa or bb or cc  db.stores.find({ $text:{$search:&quot;aa bb cc&quot;} })  // 包含 (aa or bb ) and not cc  db.stores.find({ $text:{$search:&quot;aa bb -cc&quot;} })  // 包含 aa or &quot;bb cc&quot;  db.stores.find({ $text:{$search:&quot;aa \&quot;bb cc\&quot;&quot;} })</code></pre></li><li><code>$text</code>+<code>$meta</code> 显示匹配相似度<pre><code class="lang-javascript">  # Sort by Additional Query and Text Search Score and Return top 2 matching documents  # score: 计算一个相关性分数，表明该文档与查询的匹配程度  # 显式地对 $meta:&quot;textScore&quot; 字段进行映射然后基于该字段进行sort排序  db.stores.find({      {$text:{$search:&quot;aa bb cc&quot;}},      {score:{$meta:&quot;textScore&quot;}}  }).sort({ date:1, score:{$meta:&quot;textScore&quot;} }).limit(2)</code></pre></li><li>聚合管道中，在 $match 阶段使用文本搜索（限制：只能是管道中的第一个阶段，$text只能在阶段中出现一次，$text不能出现在$or,$nor表达式中）<pre><code class="lang-javascript">  db.articles.aggregate([      { $match:{ $text:{$search:&quot;aa bb&quot;} } },      { $sort:{ score:{$meta:&quot;textScore&quot;} } },      { $project:{ title:1,_id:0 } }  ])  db.articles.aggregate([      { $match:{ $text:{$search:&quot;aa bb&quot;} } },      { $project:{ title:1,_id:0,score:{$meta:&quot;textScore&quot;} } },      { $match:{ score:{$gt:1.0} } }  ])</code></pre></li></ul></li><li>注：如果要做更细致的全文索引的话，推荐使用 Elasticsearch</li></ul><h3 id="header-23">索引属性</h3><p>创建索引时的可配置选项<code>&lt;options&gt;</code>，说明Index的一些特性</p><pre><code class="lang-javascript">db.collection.createIndex( &lt;Key Index specification&gt;, &lt;options&gt;)</code></pre><ol><li><p><code>expireAfterSeconds</code> (TTL): 过一段时间后自动移除集合中的document</p><pre><code class="lang-javascript"> db.users.createIndex(     {lastModifiedDate:1},     {expireAfterSeconds:3600} ) // 设置文档过期的时间expireAt字段的值一致 db.log_events.createIndex(      { &quot;expireAt&quot;: 1 },      { expireAfterSeconds: 0 }  )</code></pre><ul><li>index 字段存储数据类型必需是date或date数组（若是数组，则其中最低过期阈值得到匹配时，删除此document）</li><li>不能保证过期数据会被立刻删除,删除过期数据的后台任务每隔60秒运行一次</li><li>应用场景：机器生成的事件数据，日志，会话信息等，这些数据都只需要在数据库中保存有限时间</li></ul></li><li><p><code>unique</code></p><pre><code class="lang-javascript"> db.members.createIndex( { &quot;user_id&quot;: 1 }, { unique: true } )</code></pre></li><li><p><code>collation</code>: Case Insensitive Indexes</p><pre><code class="lang-javascript"> db.fruit.createIndex(      { type: 1},     { collation: { locale: &#39;en&#39;, strength: 2 } } )</code></pre></li><li><p><code>sparse</code>( 稀疏索引): null值不计入索引，常和唯一索引连用</p><pre><code class="lang-javascript"> db.users.createIndex({name:1},{sparse:true})</code></pre></li><li><p><code>partialFilterExpression</code> ( 局部索引Partial Indexes )：稀疏索引进化版，一种在指定赛道上（可跨赛道），消耗更低的索引</p><pre><code class="lang-javascript"> db.users.createIndex(     {name:1},     {unique:true,partialFilterExpression:{age:{$gt:18}}} )</code></pre><ul><li>不能作为分片的片键</li><li><code>_id</code>不能创建局部索引</li><li>同一个索引不能和sparse同时使用</li><li>一个键上不能有多个不同的局部索引</li><li>particalFilterExpression 支持的过滤操作：<pre><code>  $eq,$gt,$gte,$lt,$lte,  $exists:true,  $type,  $and -- at top level</code></pre></li></ul></li><li><p><code>background</code> : 后台创建索引会比默认的慢，但不会锁表（生产环境使用<code>background:true</code>比较好）</p><pre><code class="lang-javascript"> db.users.createIndex({username:1},{background:true})</code></pre></li></ol><h3 id="header-24">衡量索引使用情况</h3><ol><li>mongostat工具－查看mongodb运行状态的程序 <pre><code class="lang-bash"> mongostat --help mongostat -h localhost:12345</code></pre></li><li>profile集合<pre><code class="lang-javascript"> db.getProfilingLevel() db.getProfilingStatus() db.setProfilingLevel(2) show tables db.system.profile.find().sort({$natural:-1}).limit(10)</code></pre></li><li><p>日志</p><pre><code class="lang-bash"> # 配置日志 vim conf/mongod.conf ... verbose = vvvvv    # v,vv,...,vvvvv</code></pre></li><li><p>查看容量占用（注意: 确保索引与内存相适应）</p><pre><code class="lang-javascript"> // indexSizes: 查看索引在磁盘存储的大小 db.users.stats().indexSizes` // indexDetails: 查看索引占用内存的大小 (内存中会放最近使用的索引) db.users.stats({indexDetails:true}).indexDetails // totalIndexSize 查询索引大小  db.users.totalIndexSize()</code></pre></li><li><p><code>$indexStats</code> 索引具体信息</p><pre><code class="lang-javascript"> // { $indexStats: { } } 返回包括 name,key,host,accesses字段 db.orders.aggregate([      { $indexStats: { } }  ]) db.orders.aggregate([      { $indexStats: { } } ,     {$match:{name:&quot;_id_ type_1_item_1&quot;}} ]) // Eg: Return {    &quot;name&quot; : &quot;_id_&quot;,    &quot;key&quot; : {&quot;_id&quot; : 1},    &quot;host&quot; : &quot;examplehost.local:27017&quot;,    &quot;accesses&quot; : {       &quot;ops&quot; : NumberLong(0),       &quot;since&quot; : ISODate(&quot;2015-10-02T14:31:32.479Z&quot;)    } } {    &quot;name&quot; : &quot;type_1_item_1&quot;,    &quot;key&quot; : {&quot;type&quot; : 1,&quot;item&quot; : 1},    &quot;host&quot; : &quot;examplehost.local:27017&quot;,    &quot;accesses&quot; : {       &quot;ops&quot; : NumberLong(1),       &quot;since&quot; : ISODate(&quot;2015-10-02T14:31:58.321Z&quot;)    } }</code></pre></li><li><p><code>explain()</code> 返回查询计划(query plan)，即查询的详细信息</p><pre><code class="lang-javascript"> // 返回一个含有查询过程的统计数据的文档，包括所使用的索引，扫描过的文档数，查询所消耗的毫秒数 db.users.find(...).explain(&quot;executionStats&quot;)</code></pre></li><li><p><code>hint()</code> 以索引作为方法参数, 强制 MongoDB使用指定的索引来匹配查询</p><pre><code class="lang-javascript"> db.people.find(    { name: &quot;John Doe&quot;, zipcode: { $gt: &quot;63000&quot; } } ).hint( { zipcode: 1 } ).explain(&quot;executionStats&quot;) // 指定 $natural 操作符来避免MongoDB使用任何索引(注; 亦即，查询不会使用索引) db.people.find(    { name: &quot;John Doe&quot;, zipcode: { $gt: &quot;63000&quot; } } ).hint( { $natural: 1 } ).explain(&quot;executionStats&quot;)</code></pre></li></ol><h3 id="header-25">索引优化</h3><p><strong> 索引策略: </strong></p><ul><li>创建索引以支持查询</li><li>使用索引来排序查询结果</li><li>确保索引与内存相适应</li><li>创建能确保选择力的查询</li></ul><p><strong> 优化策略: </strong>    </p><ol><li>重复率越低越适合做索引（distinct／count 越接近1越适合），例如状态，性别等重复率不适合</li><li>联合索引，索引前缀由低到高，eg: <code>db.test.createIndex({a:1,b:1,c:1})</code>,则 a b c, a b, a</li><li>索引顺序：等值，范围，顺序<pre><code class="lang-javascript"> // 查询 db.test.find({     a:2,     b:{$gt2,$le:10} }).sort({c:1}) // 则建立索引如下所以更优： db.test.createIndex({a:1,c:1:b:1})</code></pre></li><li>有条件尽量匹配覆盖索引<pre><code class="lang-javascript"> db.test.createIndex({a:1,b:1,c:1}) db.test.find({a:3},{b:1,c:1,_id:0})     # select b,c from test where a=3 -&gt; 能用到索引，且获取的值在索引中</code></pre></li><li>指定<code>从节点</code>创建索引,这样不影响<code>主节点</code>的写入，不会驱逐掉常规缓存(适用于BI，报表查询，需添加大量索引的情况)，步骤：<ol><li>指定从节点priority为0 （不会变成主节点）</li><li>单机模式重启该从节点（配置文件注释）</li><li>添加索引</li><li>副本集模式重启该节点（配置文件还原）</li></ol></li></ol><h2 id="header-26">聚合 Aggregate</h2><p>MongoDB中有三种实现聚合的方式：</p><ul><li>聚合管道 Aggregator pipeline</li><li>Map-Reduce function</li><li>单目聚合方法（group,count,distinct)</li></ul><h3 id="header-27">聚合管道</h3><p>Aggregation Pipeline</p><ul><li>基于数据处理的聚合管道，使用内置的原生sql操作，效率高 （支持类似mysql的group by功能 ）</li><li>每个document通过一个由多个阶段（stage）组成的管道，经过一系列的处理（例如对每个阶段的管道进行分组、过滤等）输出相应的结果</li><li>限制：<ul><li>每个阶段管道限制为<code>100MB</code>的内存，超过将报错（可以设置<code>allowDiskUse</code>为<code>true</code>来在聚合管道节点把数据写入临时文件来解决100MB的内存的限制）</li><li>输出的结果只能保存在一个文档中，BSON Document大小限制为<code>16M</code>（2.6后：<code>DB.collect.aggregate()</code>方法返回一个指针cursor ，可以返回任何结果集的大小）</li><li>可作用在分片集合，但结果不能输在分片集合（MapReduce可作用在分片集合，结果也可输在分片集合）</li></ul></li></ul><p><img src="/2018/08/04/aggregation-pipeline.png" alt="aggregation-pipeline"></p><p><a href="https://docs.mongodb.com/manual/reference/method/db.collection.aggregate/index.html" target="_blank" rel="noopener">Doc</a>     </p><pre><code class="lang-javascript">// 方式一：db.collection.aggregate(pipeline, options)// 方式二：db.runCommand({  aggregate: &quot;&lt;collection&gt;&quot; || 1,  pipeline: [ &lt;stage&gt;, &lt;...&gt; ],  //options ( belows are optional )  explain: &lt;boolean&gt;,  allowDiskUse: &lt;boolean&gt;,  cursor: &lt;document&gt;,  maxTimeMS: &lt;int&gt;,  bypassDocumentValidation: &lt;boolean&gt;,  readConcern: &lt;document&gt;,  collation: &lt;document&gt;,  hint: &lt;string or document&gt;,  comment: &lt;string&gt;,  writeConcern: &lt;document&gt;})</code></pre><ol><li><p>参数<code>pipeline</code>: </p><pre><code class="lang-javascript"> [&lt;stage&gt;,&lt;Stage&gt;,...] //&lt;stage&gt; $stageOperator:{&lt;key&gt;:&lt;value&gt;,&lt;key&gt;:&lt;expression&gt;...} // &lt;expression&gt;  { &lt;expressionOperator&gt;:&lt;arg&gt; } { &lt;expressionOperator&gt;:[&lt;arg1&gt;,&lt;arg2&gt;,... &lt;argN&gt;] }</code></pre><ul><li><p>StageOperator <a href="https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/#aggregation-pipeline-operator-reference" target="_blank" rel="noopener">阶段操作符</a></p><pre><code class="lang-javascript">  $match          // 过滤数据,传输到下一个阶段管道  $project        // 投影，过滤显示文档字段(可选择字段，重命名字段，派生字段)  $group          // 将数据根据key进行分组,统计结果  $unwind         // 将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值  $lookup         // 进行两个集合之间左连接操作  $sort           // 将输入文档排序后输出  $skip           // 跳过指定数量的文档，返回余下的文档  $limit          // 限制返回的文档数  $redact         // 根据字段所处的document结构的级别，对文档进行“修剪”，通常和“判断语句if-else”结合使用，即＄cond  $sample         // 抽样输出  $geoNear        // 用于地理位置数据分析  $indexStats     // 返回数据集合的每个索引的使用情况 { $indexStats: { } }  $out            // 将最后计算结果写入到指定的collection中,必须为pipeline最后一个阶段管道  ...  // 常用组合  $match -&gt; $project  $match -&gt; $group  $match -&gt; $group -&gt; $sort  $match -&gt; $match -&gt; $ project -&gt; $group  $match -&gt; $lookup -&gt; $match -&gt; $sort  $match -&gt; $project -&gt; $sort -&gt; $skip -&gt; $limit  $match -&gt; $project -&gt; $unwind -&gt; $group -&gt; $sort -&gt;$skip -&gt; $limit</code></pre></li><li><p>ExpressionOperator <a href="https://docs.mongodb.com/manual/meta/aggregation-quick-reference/#aggregation-expressions" target="_blank" rel="noopener">表达式操作符</a></p><pre><code class="lang-javascript">  // 1. 布尔管道 Boolean Operators   // eg: $or: [ { $gt: [ &quot;$qty&quot;, 250 ] }, { $lt: [ &quot;$qty&quot;, 200 ] } ]  $and,$or,$not  // 2. 条件操作符 Conditinal Operator   // eg: $cond: { if: { $gte: [ &quot;$qty&quot;, 250 ] }, then: 30, else: 20 }  $cond,$ifNull,$switch  // 3. 数据类型 DataType Operators  $type  // 4. 集合操作 Set Operators  // eg: $setUnion: [ &quot;$A&quot;, &quot;$B&quot; ]   $setEquals                                     // 完全相等  $setIsSubset                                   // 完全被包含  $anyElementTrue                                // 集合中任一元素符合，则true  $allElementsTrue                               // 集合中所有元素符合，则true  $setIntersection                               // 交集  $setUnion                                      // 并集  $setDifference                                 // 差集  // 5. 比较操作符 Comparison Operators  $cmp                                         // 0/1/-1  $eq,$gt,$lt,$gte,$lte,$ne  // 6. 算术操作符 Arithmetic Operators  // eg: $abs: { $subtract: [ &quot;$start&quot;, &quot;$end&quot; ] }   $abs                                         // 绝对值  $in  $add, $substract, $multiply, $divide, $mod  $ceil, $floor ,$trunc  $log, $log10, $sqrt, $pow, $exp  // 7. 字符串操作 String Operators  // eg: $split: [&quot;$city&quot;, &quot;, &quot;]  $concat, $split  $trim, $ltrim, $rtrim  $toLower, $toUpper  $toString  $dateFromString, $dateToString  $strcasecmp                                  // case-insensitive,return 0,1/-1  $substr                                      // Deprecated!  $substrBytes, $substrCP  $indexOfBytes, $indexOfCP  $strLenBytes,$strLenCP  // 8. 数组 Array Operators  // eg: $arrayElemAt: [ &quot;$favorites&quot;, -1 ]  $arrayElemAt  $map  $filter  $slice                                      // subset  $zip                                        // merge two arrays  $reduce                                     // combine into a single value return  $isArray, $arrayToObject, $objectToArray  $concatArrays  $reverseArray  $indexOfArray  $in  $range  $size  // 9. 日期 Date Operators  $dateFromParts, $dateToParts  $dateFromString, $dateToString  $dateOfMonth, $dateOfWeek, $dateOfYear  $year,$month, $week, $hour, $minute, $second, $millisecond  $isoDayOfWeek, $isoWeek, $isoWeekYear  $toDate  ...</code></pre></li></ul></li><li><p>参数<code>options</code>:</p><pre><code class="lang-javascript"> {   explain: &lt;boolean&gt;,   allowDiskUse: &lt;boolean&gt;,   cursor: &lt;document&gt;,   maxTimeMS: &lt;int&gt;,   bypassDocumentValidation: &lt;boolean&gt;,   readConcern: &lt;document&gt;,   collation: &lt;document&gt;,   hint: &lt;string or document&gt;,   comment: &lt;string&gt;,   writeConcern: &lt;document&gt; }</code></pre></li></ol><p><strong> 示例：</strong></p><ol><li><p>Prepare Test data</p><pre><code class="lang-javascript"> // catalogues: name,description db.catalogues.insert([ {name:&quot;Spring&quot;,description:&quot;spring framework&quot;}, {name:&quot;ReactJS&quot;,description:&quot;reactJS front framework&quot;}, {name:&quot;NoSql&quot;,description:&quot;not only sql databases&quot;} {name:&quot;Docker&quot;,description:&quot;Build, Ship, and Run Any App, Anywhere&quot;} ]); // articles: title,author,description,tags,catalogue,postDate,content db.articles.insert([ {title:&quot;Spring Basic&quot;,author:&quot;Tom&quot;,description:&quot;introduce spring basic&quot;,tags:[&quot;java&quot;,&quot;spring&quot;],catalogueId:db.catalogues.findOne({name:&quot;Spring&quot;})._id,postDate:&quot;2015-01-01&quot;,content:&quot;spring basic:ioc,aop&quot;,click:1}, {title:&quot;Spring MVC&quot;,author:&quot;Tom&quot;,description:&quot;introduce spring mvc&quot;,tags:[&quot;java&quot;,&quot;spring&quot;,&quot;mvc&quot;],catalogueId:db.catalogues.findOne({name:&quot;Spring&quot;})._id,postDate:&quot;2015-01-11&quot;,content:&quot;spring mvc:dispatchServlet,restful&quot;,click:5}, {title:&quot;Spring Security&quot;,author:&quot;Tom&quot;,description:&quot;introduce spring security&quot;,tags:[&quot;java&quot;,&quot;spring&quot;,&quot;security&quot;],catalogueId:db.catalogues.findOne({name:&quot;Spring&quot;})._id,postDate:&quot;2015-01-21&quot;,content:&quot;spring security:securityFilter,authentication,accessDecide&quot;,click:20}, {title:&quot;ReactJS Basic&quot;,author:&quot;Lucy&quot;,description:&quot;introduce reactJS front framework basic&quot;,tags:[&quot;front&quot;,&quot;reateJS&quot;],catalogueId:db.catalogues.findOne({name:&quot;ReactJS&quot;})._id,postDate:&quot;2015-02-01&quot;,content:&quot;reactJS basic:component,lifecycle,props,state&quot;,click:30}, {title:&quot;ReactJS Flux&quot;,author:&quot;Lucy&quot;,description:&quot;introduce reactJS Flux&quot;,tags:[&quot;front&quot;,&quot;reateJS&quot;],catalogueId:db.catalogues.findOne({name:&quot;ReactJS&quot;})._id,postDate:&quot;2015-02-11&quot;,content:&quot;reactJS Flux:reflux,redux&quot;}, {title:&quot;Redis&quot;,author:&quot;Jack&quot;,description:&quot;introduce redis key-value db&quot;,tags:[&quot;nosql&quot;,&quot;redis&quot;],catalogueId:db.catalogues.findOne({name:&quot;NoSql&quot;})._id,postDate:&quot;2015-03-11&quot;,content:&quot;redis:install,master-slave,persist,subscribe,crud&quot;,click:0}, {title:&quot;MongoDB&quot;,author:&quot;Jack&quot;,description:&quot;introduce mongo document database&quot;,tags:[&quot;nosql&quot;,&quot;mongodb&quot;],catalogueId:db.catalogues.findOne({name:&quot;NoSql&quot;})._id,postDate:&quot;2015-03-21&quot;,content:&quot;mongodb:mongo shell,crud,index,aggregation,replica,sharding&quot;,click:25} ]);</code></pre></li><li><p><code>$lookup</code>: Join</p><pre><code class="lang-bash"> # $lookup # { #      $lookup: { #           from: &lt;collection to join&gt;, #           localField: &lt;field from the input documents&gt;, #           foreignField: &lt;field from the documents of the &quot;from&quot; collection&gt;, #           as: &lt;output array field&gt; #      } # } &gt; db.catalogues.aggregate([      {$project:{id:1,name:1}},     { $lookup:{ from:&quot;articles&quot;, localField:&quot;_id&quot;, foreignField:&quot;catalogueId&quot; ,as:&quot;articles&quot;} },     {$project:{&quot;_id&quot;:0,&quot;name&quot;:1,&quot;articles.title&quot;:1,&quot;articles.click&quot;:1}}  ]) { &quot;name&quot; : &quot;Spring&quot;, &quot;articles&quot; : [ { &quot;title&quot; : &quot;Spring Basic&quot;, &quot;click&quot; : 1 }, { &quot;title&quot; : &quot;Spring MVC&quot;, &quot;click&quot; : 5 }, { &quot;title&quot; : &quot;Spring Security&quot;, &quot;click&quot; : 20 } ] } { &quot;name&quot; : &quot;ReactJS&quot;, &quot;articles&quot; : [ { &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;click&quot; : 30 }, { &quot;title&quot; : &quot;ReactJS Flux&quot; } ] } { &quot;name&quot; : &quot;NoSql&quot;, &quot;articles&quot; : [ { &quot;title&quot; : &quot;Redis&quot;, &quot;click&quot; : 0 }, { &quot;title&quot; : &quot;MongoDB&quot;, &quot;click&quot; : 25 } ] } { &quot;name&quot; : &quot;Docker&quot;, &quot;articles&quot; : [ ] }</code></pre></li><li><p><code>$group</code> : 按照特定的字段的值进行分组（非流式运算:必须等收到所有的文档之后，才能对文档进行处理）</p><pre><code class="lang-bash"> &gt; db.articles.count() 7 # 1. $sum # select count(*) as count from articles; &gt; db.articles.aggregate([     { $group:{_id:&quot;null&quot;,count:{$sum:1}} } ]) { &quot;_id&quot; : &quot;null&quot;, &quot;count&quot; : 7 } # select catalogueId as _id,count(*) as count as from articles group by catalogueId &gt; db.articles.aggregate([     { $group:{_id:&quot;$catalogueId&quot;,count:{$sum:1}} } ]) { &quot;_id&quot; : ObjectId(&quot;5b8e342212b995b45c17d5ec&quot;), &quot;count&quot; : 2 } { &quot;_id&quot; : ObjectId(&quot;5b8e342212b995b45c17d5eb&quot;), &quot;count&quot; : 2 } { &quot;_id&quot; : ObjectId(&quot;5b8e342212b995b45c17d5ea&quot;), &quot;count&quot; : 3 } # select author as _id, sum(click) as total_click from articles group by author &gt; db.articles.aggregate([     { $group:{_id:&quot;$author&quot;,total_click:{$sum:&quot;$click&quot;}} } ]) { &quot;_id&quot; : &quot;Lucy&quot;, &quot;total_click&quot; : 30 } { &quot;_id&quot; : &quot;Jack&quot;, &quot;total_click&quot; : 25 } { &quot;_id&quot; : &quot;Tom&quot;, &quot;total_click&quot; : 26 } # 2. $max/$min # select author as _id, max(click) as max_click from articles group by author &gt; db.articles.aggregate([     { $group:{_id:&quot;$author&quot;,max_click:{$max:&quot;$click&quot;}} } ])  { &quot;_id&quot; : &quot;Lucy&quot;, &quot;max_click&quot; : 30 } { &quot;_id&quot; : &quot;Jack&quot;, &quot;max_click&quot; : 25 } { &quot;_id&quot; : &quot;Tom&quot;, &quot;max_click&quot; : 20 } # 3. $avg # select author as _id, avg(click) as avg_click from articles group by author &gt; db.articles.aggregate([     { $group:{_id:&quot;$author&quot;,avg_click:{$avg:&quot;$click&quot;}} } ])  { &quot;_id&quot; : &quot;Lucy&quot;, &quot;avg_click&quot; : 30 } { &quot;_id&quot; : &quot;Jack&quot;, &quot;avg_click&quot; : 12.5 } { &quot;_id&quot; : &quot;Tom&quot;, &quot;avg_click&quot; : 8.666666666666666 } # 4. $first/$last &gt; db.articles.aggregate([     { $group:{_id:&quot;$author&quot;,click_list:{$first:&quot;$click&quot;}} } ])  { &quot;_id&quot; : &quot;Lucy&quot;, &quot;click_list&quot; : 30 } { &quot;_id&quot; : &quot;Jack&quot;, &quot;click_list&quot; : 0 } { &quot;_id&quot; : &quot;Tom&quot;, &quot;click_list&quot; : 1 } # 5. $push/$addToSet &gt; db.articles.aggregate([     { $group:{_id:&quot;$author&quot;,click_list:{$push:&quot;$click&quot;}} } ])  { &quot;_id&quot; : &quot;Lucy&quot;, &quot;click_list&quot; : [ 30 ] } { &quot;_id&quot; : &quot;Jack&quot;, &quot;click_list&quot; : [ 0, 25 ] } { &quot;_id&quot; : &quot;Tom&quot;, &quot;click_list&quot; : [ 1, 5, 20 ] }</code></pre></li><li><p><code>$match</code> 过滤（尽量放在前面，提高效率）</p><pre><code class="lang-bash"> # select _id,title,author from articles where click&gt;0 and click&lt;25 db.articles.aggregate([     { $match:{click:{$gt:0,$lt:25}} },     { $project:{&quot;_id&quot;:0,&quot;title&quot;:1,&quot;author&quot;:1,&quot;click&quot;:1}} ])  { &quot;title&quot; : &quot;Spring Basic&quot;, &quot;author&quot; : &quot;Tom&quot;, &quot;click&quot; : 1 } { &quot;title&quot; : &quot;Spring MVC&quot;, &quot;author&quot; : &quot;Tom&quot;, &quot;click&quot; : 5 } { &quot;title&quot; : &quot;Spring Security&quot;, &quot;author&quot; : &quot;Tom&quot;, &quot;click&quot; : 20 } # select author as _id,sum(click) as total_click from articles group by author having sum(click)&gt;0 and sum(click)&lt;30 db.articles.aggregate([     { $group:{_id:&quot;$author&quot;,total_click:{$sum:&quot;$click&quot;} } },     { $match:{total_click:{$gt:0,$lt:30}} } ])  { &quot;_id&quot; : &quot;Jack&quot;, &quot;total_click&quot; : 25 } { &quot;_id&quot; : &quot;Tom&quot;, &quot;total_click&quot; : 26 }</code></pre></li><li><p><code>$project</code>: 选择字段，重命名字段，派生字段    </p><pre><code class="lang-bash"> # 选择字段: field:1/0，表示选择/不选择 field；将无用的字段从pipeline中过滤掉，能够减少聚合操作对内存的消耗 &gt; db.articles.aggregate([     { $project:{&quot;_id&quot;:0,&quot;title&quot;:1,&quot;postData&quot;:1,&quot;click&quot;:1,&quot;tags&quot;:1} } ]) { &quot;title&quot; : &quot;Spring Basic&quot;, &quot;tags&quot; : [ &quot;java&quot;, &quot;spring&quot; ], &quot;click&quot; : 1 } { &quot;title&quot; : &quot;Spring MVC&quot;, &quot;tags&quot; : [ &quot;java&quot;, &quot;spring&quot;, &quot;mvc&quot; ], &quot;click&quot; : 5 } { &quot;title&quot; : &quot;Spring Security&quot;, &quot;tags&quot; : [ &quot;java&quot;, &quot;spring&quot;, &quot;security&quot; ], &quot;click&quot; : 20 } { &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;tags&quot; : [ &quot;front&quot;, &quot;reateJS&quot; ], &quot;click&quot; : 30 } { &quot;title&quot; : &quot;ReactJS Flux&quot;, &quot;tags&quot; : [ &quot;front&quot;, &quot;reateJS&quot; ] } { &quot;title&quot; : &quot;Redis&quot;, &quot;tags&quot; : [ &quot;nosql&quot;, &quot;redis&quot; ], &quot;click&quot; : 0 } { &quot;title&quot; : &quot;MongoDB&quot;, &quot;tags&quot; : [ &quot;nosql&quot;, &quot;mongodb&quot; ], &quot;click&quot; : 25 } # 重命名字段: 引用符$，格式是：&quot;$field&quot;，表示引用doc中 field 的值 &gt; db.articles.aggregate([     { $project:{_id:0,title:1,&quot;preClick&quot;:&quot;$click&quot;} } ]) { &quot;title&quot; : &quot;Spring Basic&quot;, &quot;preClick&quot; : 1 } { &quot;title&quot; : &quot;Spring MVC&quot;, &quot;preClick&quot; : 5 } { &quot;title&quot; : &quot;Spring Security&quot;, &quot;preClick&quot; : 20 } { &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;preClick&quot; : 30 } { &quot;title&quot; : &quot;ReactJS Flux&quot; } { &quot;title&quot; : &quot;Redis&quot;, &quot;preClick&quot; : 0 } { &quot;title&quot; : &quot;MongoDB&quot;, &quot;preClick&quot; : 25 } # 派生字段: 对字段进行计算，派生出一个新的字段 &gt; db.articles.aggregate([     { $project:{         &quot;title&quot;:1,         &quot;click&quot;:1,         &quot;result&quot;: { $or: [ { $gt: [ &quot;$click&quot;, 20 ] }, { $lt: [ &quot;$click&quot;, 100 ] } ] }       }      } ]) { &quot;_id&quot; : ObjectId(&quot;5be2b3347ec0ecb208b54816&quot;), &quot;title&quot; : &quot;Spring Basic&quot;, &quot;click&quot; : 1, &quot;result&quot; : true } { &quot;_id&quot; : ObjectId(&quot;5be2b3347ec0ecb208b54817&quot;), &quot;title&quot; : &quot;Spring MVC&quot;, &quot;click&quot; : 5, &quot;result&quot; : true } { &quot;_id&quot; : ObjectId(&quot;5be2b3347ec0ecb208b54818&quot;), &quot;title&quot; : &quot;Spring Security&quot;, &quot;click&quot; : 20, &quot;result&quot; : true } { &quot;_id&quot; : ObjectId(&quot;5be2b3347ec0ecb208b54819&quot;), &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;click&quot; : 30, &quot;result&quot; : true } { &quot;_id&quot; : ObjectId(&quot;5be2b3347ec0ecb208b5481a&quot;), &quot;title&quot; : &quot;ReactJS Flux&quot;, &quot;result&quot; : true } { &quot;_id&quot; : ObjectId(&quot;5be2b3347ec0ecb208b5481b&quot;), &quot;title&quot; : &quot;Redis&quot;, &quot;click&quot; : 0, &quot;result&quot; : true } { &quot;_id&quot; : ObjectId(&quot;5be2b3347ec0ecb208b5481c&quot;), &quot;title&quot; : &quot;MongoDB&quot;, &quot;click&quot; : 25, &quot;result&quot; : true } # 派生字段 &gt; db.articles.aggregate([     { $project:{         _id:0,         title:1,         click:1,         level: { $cond:{if:{$gte:[&quot;$click&quot;,20]},then: &quot;High&quot;,else: &quot;Low&quot;} }      }      } ]) { &quot;title&quot; : &quot;Spring Basic&quot;, &quot;click&quot; : 1, &quot;level&quot; : &quot;Low&quot; } { &quot;title&quot; : &quot;Spring MVC&quot;, &quot;click&quot; : 5, &quot;level&quot; : &quot;Low&quot; } { &quot;title&quot; : &quot;Spring Security&quot;, &quot;click&quot; : 20, &quot;level&quot; : &quot;High&quot; } { &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;click&quot; : 30, &quot;level&quot; : &quot;High&quot; } { &quot;title&quot; : &quot;ReactJS Flux&quot;, &quot;level&quot; : &quot;Low&quot; } { &quot;title&quot; : &quot;Redis&quot;, &quot;click&quot; : 0, &quot;level&quot; : &quot;Low&quot; } { &quot;title&quot; : &quot;MongoDB&quot;, &quot;click&quot; : 25, &quot;level&quot; : &quot;High&quot; }</code></pre></li><li><p><code>$limit</code>,<code>$skip</code>,<code>$sort</code></p><pre><code class="lang-bash"> &gt; db.articles.aggregate([     {$skip:2},     {$limit:3},     {$sort:{&quot;postDate&quot;:1}},     {$project:{&quot;_id&quot;:0,&quot;title&quot;:1,&quot;postDate&quot;:1}} ]) { &quot;title&quot; : &quot;Spring Security&quot;, &quot;postDate&quot; : &quot;2015-01-21&quot; } { &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;postDate&quot; : &quot;2015-02-01&quot; } { &quot;title&quot; : &quot;ReactJS Flux&quot;, &quot;postDate&quot; : &quot;2015-02-11&quot; } &gt; db.articles.aggregate([     {$sort:{&quot;postDate&quot;:1}},     {$limit:3},     {$skip:2},     {$project:{&quot;_id&quot;:0,&quot;title&quot;:1,&quot;postDate&quot;:1}} ]) { &quot;title&quot; : &quot;Spring Security&quot;, &quot;postDate&quot; : &quot;2015-01-21&quot; }</code></pre></li><li><p><code>$unwind</code>: 拆分数组字段</p><pre><code class="lang-bash"> &gt; db.articles.aggregate([     {$project:{&quot;_id&quot;:0,&quot;title&quot;:1,&quot;tags&quot;:1}},     {$unwind:&quot;$tags&quot;} ]) { &quot;title&quot; : &quot;Spring Basic&quot;, &quot;tags&quot; : &quot;java&quot; } { &quot;title&quot; : &quot;Spring Basic&quot;, &quot;tags&quot; : &quot;spring&quot; } { &quot;title&quot; : &quot;Spring MVC&quot;, &quot;tags&quot; : &quot;java&quot; } { &quot;title&quot; : &quot;Spring MVC&quot;, &quot;tags&quot; : &quot;spring&quot; } { &quot;title&quot; : &quot;Spring MVC&quot;, &quot;tags&quot; : &quot;mvc&quot; } { &quot;title&quot; : &quot;Spring Security&quot;, &quot;tags&quot; : &quot;java&quot; } { &quot;title&quot; : &quot;Spring Security&quot;, &quot;tags&quot; : &quot;spring&quot; } { &quot;title&quot; : &quot;Spring Security&quot;, &quot;tags&quot; : &quot;security&quot; } { &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;tags&quot; : &quot;front&quot; } { &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;tags&quot; : &quot;reateJS&quot; } { &quot;title&quot; : &quot;ReactJS Flux&quot;, &quot;tags&quot; : &quot;front&quot; } { &quot;title&quot; : &quot;ReactJS Flux&quot;, &quot;tags&quot; : &quot;reateJS&quot; } { &quot;title&quot; : &quot;Redis&quot;, &quot;tags&quot; : &quot;nosql&quot; } { &quot;title&quot; : &quot;Redis&quot;, &quot;tags&quot; : &quot;redis&quot; } { &quot;title&quot; : &quot;MongoDB&quot;, &quot;tags&quot; : &quot;nosql&quot; } { &quot;title&quot; : &quot;MongoDB&quot;, &quot;tags&quot; : &quot;mongodb&quot; }</code></pre><ul><li>参数数组字段为空或不存在时，待处理的文档将会被忽略，该文档将不会有任何输出</li><li>参数不是一个数组类型时，将会抛出异常</li></ul></li><li><p><code>$out</code>: 把执行的结果写入指定数据表(会先清空原数据)</p><pre><code class="lang-bash"> &gt; db.articles.aggregate([     { $group:{_id:&quot;$author&quot;,total_click:{$sum:&quot;$click&quot;}} },     { $out:&quot;author_click&quot; } ]) &gt; db.author_click.find() { &quot;_id&quot; : &quot;Lucy&quot;, &quot;total_click&quot; : 30 } { &quot;_id&quot; : &quot;Jack&quot;, &quot;total_click&quot; : 25 } { &quot;_id&quot; : &quot;Tom&quot;, &quot;total_click&quot; : 26 } &gt; db.articles.aggregate([     { $group:{_id:&quot;$author&quot;,total_click:{$sum:&quot;$click&quot;}} },     { $project:{&quot;_id&quot;:0}},     { $limit:2},     { $out:&quot;author_click&quot; } ]) &gt; db.author_click.find() { &quot;_id&quot; : ObjectId(&quot;5be3a0ec58072db74ca83569&quot;), &quot;total_click&quot; : 30 } { &quot;_id&quot; : ObjectId(&quot;5be3a0ec58072db74ca8356a&quot;), &quot;total_click&quot; : 25 }</code></pre></li><li><p>options:<code>explain</code> 返回aggregate各个阶段管道的执行计划信息</p><pre><code class="lang-bash"> &gt; db.articles.aggregate([     { $group:{_id:&quot;$author&quot;,click_list:{$push:&quot;$click&quot;}} } ])  { &quot;_id&quot; : &quot;Lucy&quot;, &quot;click_list&quot; : [ 30 ] } { &quot;_id&quot; : &quot;Jack&quot;, &quot;click_list&quot; : [ 0, 25 ] } { &quot;_id&quot; : &quot;Tom&quot;, &quot;click_list&quot; : [ 1, 5, 20 ] } &gt; db.articles.aggregate([     { $group:{_id:&quot;$author&quot;,click_list:{$push:&quot;$click&quot;}} } ],{explain:true}) {     &quot;stages&quot; : [             {                     &quot;$cursor&quot; : {                             &quot;query&quot; : {                             },                             &quot;fields&quot; : {                                     &quot;author&quot; : 1,                                     &quot;click&quot; : 1,                                     &quot;_id&quot; : 0                             },                             &quot;queryPlanner&quot; : {                                     &quot;plannerVersion&quot; : 1,                                     &quot;namespace&quot; : &quot;demo.articles&quot;,                                     &quot;indexFilterSet&quot; : false,                                     &quot;parsedQuery&quot; : {                                     },                                     &quot;winningPlan&quot; : {                                             &quot;stage&quot; : &quot;COLLSCAN&quot;,                                             &quot;direction&quot; : &quot;forward&quot;                                     },                                     &quot;rejectedPlans&quot; : [ ]                             }                     }             },             {                     &quot;$group&quot; : {                             &quot;_id&quot; : &quot;$author&quot;,                             &quot;click_list&quot; : {                                     &quot;$push&quot; : &quot;$click&quot;                             }                     }             }     ],     &quot;ok&quot; : 1 }</code></pre></li></ol><h3 id="header-28">Map-Reduce</h3><ul><li>是一种计算模型（能够在多台Server上并行执行），将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）</li><li>分为两个阶段:Map和Reduce；主要分为三步：Map，Shuffle，Reduce<ul><li>Map: 将操作映射到每条document，产生key和value。eg：Map一个document产生key value对：<code>{female,{count:1}}</code>,<code>{male,{count:1}}</code></li><li>Shuffle: 按照key进行分组，并将key相同的value组合成数组。eg：产生<code>(female:[{count:1},{count:1},...])</code>,<code>(male:[{count:1},{count:1},...])</code></li><li>Reduce: 把Value数组化简为单值(聚合运算统计)。eg：<code>(female:{count:20})</code>,<code>(male:{count:15})</code></li><li>注：Map和Reduce需要显式定义，shuffle由MongoDB来实现</li></ul></li></ul><p><img src="/2018/08/04/map-reduce.png" alt="map-reduce"></p><pre><code class="lang-javascript">db.collection.mapReduce(     &lt;map&gt;,                            // map 映射函数,生成键值对 (遍历 collection,调用emit(key, value))     &lt;reduce&gt;,                        // reduce 统计函数 (key-values -&gt; key-value,把values数组变成一个单一的值value)     {       out: &lt;collection&gt;,            // 存放统计结果 (不指定则使用临时集合,在客户端断开后自动删除)       query: &lt;document&gt;,            // 一个筛选条件，只有满足条件的文档才会调用map函数       sort: &lt;document&gt;,            // 发往map函数前给文档排序       limit: &lt;number&gt;,                // 发往map函数的文档数量的上限       finalize: &lt;function&gt;,       scope: &lt;document&gt;,       jsMode: &lt;boolean&gt;,       verbose: &lt;boolean&gt;,       bypassDocumentValidation: &lt;boolean&gt;     })</code></pre><p><strong> 示例：</strong></p><pre><code class="lang-bash">&gt; db.articles.find({},{&quot;_id&quot;:0,&quot;title&quot;:1,&quot;author&quot;:1,&quot;click&quot;:1,&quot;tags&quot;:1}){ &quot;title&quot; : &quot;Spring Basic&quot;, &quot;author&quot; : &quot;Tom&quot;, &quot;tags&quot; : [ &quot;java&quot;, &quot;spring&quot; ], &quot;click&quot; : 1 }{ &quot;title&quot; : &quot;Spring MVC&quot;, &quot;author&quot; : &quot;Tom&quot;, &quot;tags&quot; : [ &quot;java&quot;, &quot;spring&quot;, &quot;mvc&quot; ], &quot;click&quot; : 5 }{ &quot;title&quot; : &quot;Spring Security&quot;, &quot;author&quot; : &quot;Tom&quot;, &quot;tags&quot; : [ &quot;java&quot;, &quot;spring&quot;, &quot;security&quot; ], &quot;click&quot; : 20 }{ &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;author&quot; : &quot;Lucy&quot;, &quot;tags&quot; : [ &quot;front&quot;, &quot;reateJS&quot; ], &quot;click&quot; : 30 }{ &quot;title&quot; : &quot;ReactJS Flux&quot;, &quot;author&quot; : &quot;Lucy&quot;, &quot;tags&quot; : [ &quot;front&quot;, &quot;reateJS&quot; ] }{ &quot;title&quot; : &quot;Redis&quot;, &quot;author&quot; : &quot;Jack&quot;, &quot;tags&quot; : [ &quot;nosql&quot;, &quot;redis&quot; ], &quot;click&quot; : 0 }{ &quot;title&quot; : &quot;MongoDB&quot;, &quot;author&quot; : &quot;Jack&quot;, &quot;tags&quot; : [ &quot;nosql&quot;, &quot;mongodb&quot; ], &quot;click&quot; : 25 }# 1. 各author的click大于0的文章总数&gt; db.articles.mapReduce(    function(){emit(this.author,1)},    function(key,values){return Array.sum(values)},    {query:{click:{$gt:0}},out: &quot;author_sum&quot;}){        &quot;result&quot; : &quot;author_sum&quot;,            // 储存结果的collection的名字        &quot;timeMillis&quot; : 122,                    // 执行花费的时间，毫秒为单位        &quot;counts&quot; : {                &quot;input&quot; : 5,                // 满足条件被发送到map函数的文档个数                &quot;emit&quot; : 5,                    // 在map函数中emit被调用的次数，也就是所有集合中的数据总量                &quot;reduce&quot; : 1,                // reduce函数调用次数                &quot;output&quot; : 3                // 结果集合中的文档个数        },        &quot;ok&quot; : 1                            // 是否成功，成功为1}&gt; db.author_sum.find(){ &quot;_id&quot; : &quot;Jack&quot;, &quot;value&quot; : 1 }{ &quot;_id&quot; : &quot;Lucy&quot;, &quot;value&quot; : 1 }{ &quot;_id&quot; : &quot;Tom&quot;, &quot;value&quot; : 3 }# 2. 各author文章的平均点击数&gt; db.articles.mapReduce(    function(){emit(this.author,{click:this.click||0,article:1})},    function(key,values){         reducedVal={sum_click:0,sum_article:0};        values.forEach(function(item){            reducedVal.sum_click+=item.click;            reducedVal.sum_article+=item.article;        })        return reducedVal.sum_click/reducedVal.sum_article;    },    {out:&quot;author_sum&quot;}){        &quot;result&quot; : &quot;author_sum&quot;,        &quot;timeMillis&quot; : 241,        &quot;counts&quot; : {                &quot;input&quot; : 7,                &quot;emit&quot; : 7,                &quot;reduce&quot; : 3,                &quot;output&quot; : 3        },        &quot;ok&quot; : 1}&gt; db.author_sum.find(){ &quot;_id&quot; : &quot;Jack&quot;, &quot;value&quot; : 12.5 }{ &quot;_id&quot; : &quot;Lucy&quot;, &quot;value&quot; : 15 }{ &quot;_id&quot; : &quot;Tom&quot;, &quot;value&quot; : 8.666666666666666 }</code></pre><h3 id="header-29">单目聚合操作</h3><p><img src="/2018/08/04/distinct.png" alt="distinct"></p><ol><li><p>count: <code>db.collection.count(query, options)</code></p><pre><code class="lang-bash"> &gt; db.articles.count() 7 &gt; db.articles.count({click:{$gt:10}}) 3 &gt; db.articles.count({click:{$gt:10},tags:{$size:2}}) 2 &gt; db.articles.find({click:{$gt:10},tags:{$size:2}}).count() 2</code></pre></li><li><p>distinct: <code>db.collection.distinct(field, query, options)</code></p><pre><code class="lang-bash"> &gt; db.articles.distinct(&quot;click&quot;) [ 1, 5, 20, 30, 0, 25 ] &gt; db.articles.distinct(&quot;tags&quot;) [&quot;java&quot;,&quot;spring&quot;,&quot;mvc&quot;,&quot;security&quot;,&quot;front&quot;,&quot;reateJS&quot;,&quot;nosql&quot;,&quot;redis&quot;,&quot;mongodb&quot;] &gt; db.articles.distinct(&quot;tags&quot;,{click:{$gt:20}}) [ &quot;front&quot;, &quot;reateJS&quot;, &quot;mongodb&quot;, &quot;nosql&quot; ]</code></pre></li></ol><h2 id="header-30">Security</h2><p>安全:</p><ul><li>物理隔离（最安全）</li><li>网络隔离</li><li>IP白名单隔离（防火墙配置等）</li><li>用户名密码鉴权</li></ul><p>开启权限认证:</p><ul><li>auth开启<pre><code class="lang-bash">  &gt; vim conf/mongod.conf  ...  auth = true</code></pre></li><li>keyfile开启</li></ul><p><strong> 操作：</strong></p><ol><li><p>查看用户<code>db.getUsers()</code>，查看角色<code>db.getRoles()</code></p><pre><code class="lang-bash"> &gt; use admin switched to db admin &gt; db.getUsers() [     {             &quot;_id&quot; : &quot;admin.mongoadmin&quot;,             &quot;user&quot; : &quot;mongoadmin&quot;,             &quot;db&quot; : &quot;admin&quot;,             &quot;roles&quot; : [                     {                             &quot;role&quot; : &quot;root&quot;,                             &quot;db&quot; : &quot;admin&quot;                     }             ],             &quot;mechanisms&quot; : [                     &quot;SCRAM-SHA-1&quot;,                     &quot;SCRAM-SHA-256&quot;             ]     } ] &gt; db.getRoles() [ ]</code></pre></li><li><p>创建用户<code>db.createUser</code> (role内建类型：read,readWrite,dbAdmin,dbOwner,userAdmin)</p><pre><code class="lang-bash"> &gt; db.createUser({     user:&quot;cj&quot;,     pwd:&quot;123&quot;,     roles:[         {role:&quot;userAdmin&quot;,db:&quot;demo&quot;},         {role:&quot;read&quot;,db:&quot;local&quot;}     ] }) &gt; mongo localhost:12345 -u cj -p 123 &gt; use testdb &gt; show tables</code></pre></li><li><p>创建角色<code>db.createRole</code></p><pre><code class="lang-bash"> # 用户角色： # 数据库角色（read,readWrite,dbAdmin,dbOwner,userAdmin) # 集群角色（clusterAdmin,clusterManager,...） # 备份角色（backup,restore,...） # 其他特殊权限（DBAdminAnyDatabase,...） &gt; db.createRole({     role:&quot;appUser&quot;,     db:&quot;myApp&quot;     privileges:[         {             resource:{db:&quot;myApp&quot;,collection:&quot; &quot;},             actions:[&quot;find&quot;,&quot;createCollection&quot;,&quot;dbStates&quot;,&quot;collStats&quot;]         },         {             resource:{db:&quot;myApp&quot;,collection:&quot;logs&quot;},             actions:[&quot;insert&quot;]         },         {             resource:{db:&quot;myApp&quot;,collection:&quot;data&quot;},             actions:[&quot;insert&quot;,&quot;update&quot;,&quot;remove&quot;,&quot;compact&quot;]         },         {             resource:{db:&quot;myApp&quot;,collection:&quot;system.indexes&quot;},             actions:[&quot;find&quot;]         }     ],     roles:[] })</code></pre></li></ol><h2 id="header-31">复制集 &amp; 分片</h2><ol><li>复制集 Replica Set （纵向）: 基于领导（Leader-based）复制状态机 (关键：选举和数据复制)</li><li>分片 Sharding（横向）：将数据进行拆分，水平的分散到不同的服务器上；架构上：读写均衡，去中心化</li><li>分片与复制集集群对比<table class="table"><thead><tr><th style="text-align:left">-</th><th style="text-align:left">Shard</th><th style="text-align:left">Replication</th></tr></thead><tbody><tr><td style="text-align:left">实现意义</td><td style="text-align:left">提升并发性能，提高大量数据随机访问性能</td><td style="text-align:left">数据冗余，提升读性能</td></tr><tr><td style="text-align:left">架构上</td><td style="text-align:left">水平化</td><td style="text-align:left">中心化</td></tr><tr><td style="text-align:left">实现原理</td><td style="text-align:left">数据打散分布</td><td style="text-align:left">数据镜像</td></tr><tr><td style="text-align:left">维护成本</td><td style="text-align:left">相对较高</td><td style="text-align:left">相对容易</td></tr></tbody></table></li></ol><p><strong> More about Sharding </strong></p><ol><li><p>分片成员节点：<br> <img src="/2018/08/04/sharding-nodes.png" alt="Sharding nodes"></p><ul><li><code>Shard节点</code>： 存储数据的节点（单个mongod或者副本集） <code>mongod --shardsvr --rpelSet</code></li><li><code>Config Server</code>：存储元数据，为mongos服务，将数据路由到Shard <code>mongod --configsvr</code></li><li><code>Query routers</code>: 查询路由节点，即<code>Mongos</code>节点，接入Client请求，根据路由规则转发给合适的shard或者shards <code>mongos --configdb &lt;configdb server&gt;</code></li></ul></li><li><p>概念：</p><ol><li>分片片键（Shard Key）：集合里面选个键，用该键的值作为数据拆分的依据,例如配置<code>sh.shardCollection(&quot;records.people&quot;, {user_id:&quot;hashed&quot;})</code></li><li>数据块（Chunk）：mongodb分片后，存储数据的单元块，默认大小为64M</li><li>拆分 （Split Chunk）：一个后台进程避免chunk增长的过大，当chunk尺寸超过指定的chunk size时，拆分此chunk（split后shard将会修改config server上这个chunk的metadata元信息）</li><li>平衡 （Balancing Chunks）：一个后台线程用于对chunks迁移以达到平衡，会周期性的检查分片是否存在不均衡，如果存在则会进行块的迁移（balancer均衡器运行在mongos上，注：balancer进行均衡的条件是块数量的多少，而不是块大小）</li><li>拆分－&gt;平衡过程：<br> <img src="/2018/08/04/sharding-spliting.png" alt="Spliting"><br> <img src="/2018/08/04/sharding-balancing.png" alt="Balancing"></li></ol></li><li><p>Sharding Strategy：</p><ul><li>Hashed Sharding（哈希切片) : 能将写入均衡分布到各个 shard</li><li>Ranged Sharding（范围切片）: 能很好的支持基于 shard key的范围查询</li><li>Tag aware Sharding</li><li>好的shard key：<ul><li>key分布足够离散 sufficient cardinality: 片键相同导致数据块不拆分，容易形成大的数据块，导致数据不均</li><li>写请求均匀分布 （evenly distributed write）: 例如单调递增的<code>_id</code>或者时间戳作为片键，会导致一直往最后一个复本集添加数据</li><li>尽量避免 scatter-gather 查询 （targeted read） </li></ul></li></ul></li><li><p>添加分片过程：</p><ol><li>连接到mongos</li><li>Add Shards</li><li>Enable Sharding</li><li>对一个Collection进行分片    </li></ol></li><li><p>示例：手动分片（减少自动平衡过程带来的IO等资源消耗，前提：充分了解数据，对数据进行预先划分）</p><pre><code class="lang-bash"> # 关闭自动平衡 auto balance     sh.stopBalancer()    # Currently enabled: no # 分片切割 spliting &gt; use admin &gt; db.runCommand({&quot;enablesharding&quot;:&quot;myapp&quot;}) &gt; db.runCommand({&quot;shardcollection&quot;:&quot;myapp.users&quot;,&quot;key&quot;:{&quot;email&quot;:1}}) for(var x=97;x&lt;97+26;x++){     for(var y=97;y&lt;97+26;y+=6){         var prefix=String.fromCharCode(x)+String.fromCharCode(y);         db.runCommand({split:&quot;myapp.users&quot;,middle:{email:prefix}})     } } # 手动移动分割块 balancing var shServer=[     &quot;ShardServer 1&quot;,     &quot;ShardServer 2&quot;,     &quot;ShardServer 3&quot;,     &quot;ShardServer 4&quot;,     &quot;ShardServer 5&quot; ] for(var x=97;x&lt;97+26;x++){     for(var y=97;y&lt;97+26;y+=6){         var prefix=String.fromCharCode(x)+String.fromCharCode(y);         db.adminCommand({moveChunk:&quot;myapp.users&quot;,find:{email:prefix},to:shServer[(y-97)/6]})     } } # 循环(y-97)/6的数值结果为0，6，12，18，24； shServer[0] -&gt; shServer[4]</code></pre></li></ol><h2 id="header-32">MongoDB 4.0 新特性</h2><ol><li><p>多文档事务</p><ul><li>4.0: 单文档事务 -&gt; 跨文档事务</li><li>4.2: 复制集事务 -&gt; 分片集群事务</li></ul></li><li><p>聚合类型转换: 引入<code>$convert</code>聚合操作符来简化ETL（抽取，转化，加载）流程和负荷</p><ul><li>可结合:<pre><code class="lang-bash">  # 1. 类型转换  $toBool,$toDate,$toDecimal,$toDouble,$toInt,$toLong,$toObjectId,$toString  # 2. 日期操作转换  $dateToParts,$dateFromParts,$dateFromString  # 3. 修剪  $trim,$rtrim,$ltrim  {$trim:{input:&lt;expression&gt;}}  {$trim:{input:[&lt;expression&gt;],chars:&lt;string&gt;}}</code></pre></li><li>prepare test data:<pre><code class="lang-bash">  &gt; db.address.insert([      { street: &quot;Canal st&quot;, building: NumberDecimal(21), _id: 0},      { street: &quot;43rd st&quot;, building: &quot;229&quot;, _id: 1},      { street: &quot;Fulton st&quot;, building: &quot;31&quot;, _id: 2 },      { street: &quot;52nd st&quot;, building: &quot;11w&quot;, _id: 3},       { street: &quot;78th st&quot;, building: null, _id: 4},       { street: &quot;78th st&quot;,  _id: 5},       { street: &quot;Rector st&quot;, building: NumberInt(10), _id: 6,last_visited: {year: 2017, month: 10}}  ]);</code></pre></li><li><code>$convert</code>示例：<pre><code class="lang-bash">  &gt; db.address.aggregate( [    {      $addFields: {        building: {          $convert: {            input: &quot;$building&quot;,            to: &quot;int&quot;,            onError: 0,            onNull: -1          }        }      }    },    { $sort: {building: 1}}  ]);  { &quot;_id&quot; : 4, &quot;street&quot; : &quot;78th st&quot;, &quot;building&quot; : -1 }  { &quot;_id&quot; : 5, &quot;street&quot; : &quot;78th st&quot;, &quot;building&quot; : -1 }  { &quot;_id&quot; : 3, &quot;street&quot; : &quot;52nd st&quot;, &quot;building&quot; : 0 }  { &quot;_id&quot; : 6, &quot;street&quot; : &quot;Rector st&quot;, &quot;building&quot; : 10, &quot;last_visited&quot; : { &quot;year&quot; : 2017, &quot;month&quot; : 10 } }  { &quot;_id&quot; : 0, &quot;street&quot; : &quot;Canal st&quot;, &quot;building&quot; : 21 }  { &quot;_id&quot; : 2, &quot;street&quot; : &quot;Fulton st&quot;, &quot;building&quot; : 31 }  { &quot;_id&quot; : 1, &quot;street&quot; : &quot;43rd st&quot;, &quot;building&quot; : 229 }</code></pre></li><li><code>$dateFromParts</code>示例：<pre><code class="lang-bash">  # Add 15 months to month date field:  &gt; db.address.aggregate([    {      $addFields: {        next_visit: {            $convert:{              input: {                $dateFromParts: {                  year: &quot;$last_visited.year&quot;,                  month: {$add:[15, &quot;$last_visited.month&quot;]},                }},              to: &quot;date&quot;,              onNull: &quot;&quot;,              onError: &quot;&quot;          }        }      }    }  ]);  { &quot;_id&quot; : 0, &quot;street&quot; : &quot;Canal st&quot;, &quot;building&quot; : NumberDecimal(&quot;21.0000000000000&quot;), &quot;next_visit&quot; : &quot;&quot; }  { &quot;_id&quot; : 1, &quot;street&quot; : &quot;43rd st&quot;, &quot;building&quot; : &quot;229&quot;, &quot;next_visit&quot; : &quot;&quot; }  { &quot;_id&quot; : 2, &quot;street&quot; : &quot;Fulton st&quot;, &quot;building&quot; : &quot;31&quot;, &quot;next_visit&quot; : &quot;&quot; }  { &quot;_id&quot; : 3, &quot;street&quot; : &quot;52nd st&quot;, &quot;building&quot; : &quot;11w&quot;, &quot;next_visit&quot; : &quot;&quot; }  { &quot;_id&quot; : 4, &quot;street&quot; : &quot;78th st&quot;, &quot;building&quot; : null, &quot;next_visit&quot; : &quot;&quot; }  { &quot;_id&quot; : 5, &quot;street&quot; : &quot;78th st&quot;, &quot;next_visit&quot; : &quot;&quot; }  { &quot;_id&quot; : 6, &quot;street&quot; : &quot;Rector st&quot;, &quot;building&quot; : 10, &quot;last_visited&quot; : { &quot;year&quot; : 2017, &quot;month&quot; : 10 }, &quot;next_visit&quot; : ISODate(&quot;2019-01-01T00:00:00Z&quot;) }</code></pre></li><li><p><code>$trim</code>示例：</p><pre><code class="lang-bash">  # conversion error:  &gt; db.address.aggregate( [    {      $addFields: {         building: {$convert: { input: &quot;$building&quot;, to: &quot;int&quot;  }}  }    },    {$sort: {building: 1}}  ]);  Error: command failed: {      &quot;ok&quot; : 0,      &quot;errmsg&quot; : &quot;Failed to parse number &#39;11w&#39; in $convert with no onError value: Bad digit \&quot;w\&quot; while parsing 11w&quot;,      &quot;code&quot; : 241,      &quot;codeName&quot; : &quot;ConversionFailure&quot;  } : aggregate failed  # avoid conversion error: Using $trim expression with longer list of chars to remove:  &gt; db.address.aggregate( [    {$match: { building: {$type: &quot;string&quot;} }},    {      $addFields: {        building: {          $convert: {            input: {$trim: {              input: &quot;$building&quot;,              chars: &quot;abcdefghijklmnopqrstuvwxyz &quot;}},            to: &quot;int&quot;  }          }       }    },    {$sort: {building: 1}}  ]);  { &quot;_id&quot; : 3, &quot;street&quot; : &quot;52nd st&quot;, &quot;building&quot; : 11 }  { &quot;_id&quot; : 2, &quot;street&quot; : &quot;Fulton st&quot;, &quot;building&quot; : 31 }  { &quot;_id&quot; : 1, &quot;street&quot; : &quot;43rd st&quot;, &quot;building&quot; : 229 }</code></pre></li></ul></li><li><p>修改订阅扩展</p><ul><li>3.6 集合层面的修改订阅</li><li>4.0 数据库／集群层面的修改订阅(为修改事件返回clusterTime)</li></ul></li><li><p>后备节点读取: 阻塞 -&gt; 非阻塞性(引入快照机制)</p><ul><li>阻塞性后备节点：<br>  <img src="/2018/08/04/mongo4-block.png" alt="Block"> <img src="/2018/08/04/mongo4-block-rw.png" alt="Block Read and Write"><ul><li>读取：需等待批量数据复制写入操作完成才可</li><li>写入： 需等待数据读取操作完成，否则会导致一致性问题</li><li>形成了一个恶性循环</li></ul></li><li>非阻塞性后备节点:<br>  <img src="/2018/08/04/mongo4-unblock.png" alt="Unblock"> <img src="/2018/08/04/mongo4-unblock-rw.png" alt="UnBlock Read and Write"></li><li>改进优化了性能：<br>  <img src="/2018/08/04/mongo4-delay-cmp.png" alt="Delay Cmp"></li></ul></li></ol><h2 id="header-33">Application</h2><ul><li>Java: <code>mongodb-driver</code><ul><li>Refer <a href="http://www.runoob.com/mongodb/mongodb-java.html" target="_blank" rel="noopener">MongoDB Java</a></li><li>Demo <a href="https://github.com/sixDegree/java-mongo" target="_blank" rel="noopener">java-mongo</a></li></ul></li><li>NodeJS: <code>mongoose</code><ul><li>Refer <a href="https://mongoosejs.com/docs/guide.html" target="_blank" rel="noopener">mongoose</a></li><li>Demo <a href="https://github.com/sixDegree/node-mongo" target="_blank" rel="noopener">node-mongo</a></li></ul></li></ul><h2 id="header-34">Reference</h2><p><a href="http://www.mongoing.com/docs/index.html" target="_blank" rel="noopener">MongoDB 3.4 中文文档</a><br><a href="https://docs.mongodb.com/manual/" target="_blank" rel="noopener">MongoDB 4.0 Manual</a><br><a href="http://www.runoob.com/mongodb/mongodb-tutorial.html" target="_blank" rel="noopener">MongoDB 教程</a><br><a href="https://draveness.me/mongodb-wiredtiger" target="_blank" rel="noopener">『浅入浅出』MongoDB 和 WiredTiger</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;使用Docker搭建MongoDB测试环境&lt;/li&gt;
&lt;li&gt;Transaction，ACID，WriteConcern&lt;/li&gt;
&lt;li&gt;CRUD&lt;/li&gt;
&lt;li&gt;Index&lt;/li&gt;
&lt;li&gt;Aggregate&lt;/li&gt;
&lt;li&gt;Replica Set &amp;amp; Sharding&lt;/li&gt;
&lt;li&gt;MongoDB 4.0 New Feature&lt;/li&gt;
&lt;li&gt;Applicaiton&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="NoSql" scheme="http://sixdegree.github.io/tags/NoSql/"/>
    
  </entry>
  
  <entry>
    <title>Koa</title>
    <link href="http://sixdegree.github.io/2018/08/03/Koa.html"/>
    <id>http://sixdegree.github.io/2018/08/03/Koa.html</id>
    <published>2018-08-02T16:00:00.000Z</published>
    <updated>2018-10-26T12:33:58.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>module bundler</li><li>loader</li><li>plugin</li></ol><a id="more"></a><h2 id="header-1">Starter</h2><blockquote><p>Koa: next generation web framework for node.js</p></blockquote><p><a href="https://koajs.com" target="_blank" rel="noopener">官网</a></p><p>一个比expess更简洁轻量的nodeJS web框架 （requires node v7.6.0 or higher）<br>如今版本已更新到了koa2，性能更优异，还支持async/await（JS原生支持，本身是generator语法糖，实现了同步写异步，终结异步回调）</p><h3 id="header-2">Hello world</h3><ol><li><p>init:</p><pre><code class="lang-bash"> cd koa-demo npm init npm install koa -s</code></pre></li><li><p>app.js:</p><pre><code class="lang-javascript"> const Koa=require(&quot;koa&quot;); const app=new Koa(); const main=ctx=&gt;{    ctx.response.type=&quot;json&quot;;    ctx.response.body={     success:1,     msg:&quot;Hello world!&quot;    } } app.use(main); // app.listen(...) return an HTTP Server app.listen(3000,()=&gt;{   console.log(&#39;app started at port 3000...&#39;); });</code></pre></li><li><p>start http server:</p><pre><code class="lang-bash"> &gt; node app app started at port 3000...</code></pre></li><li><p>visit to verify:</p><pre><code class="lang-bash"> &gt; curl -i http://localhost:3000   % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                  Dload  Upload   Total   Spent    Left  Speed 100    34  100    34    0     0    435      0 --:--:-- --:--:-- --:--:--   548HTTP/1.1 200 OK Content-Type: application/json; charset=utf-8 Content-Length: 34 Date: Thu, 25 Oct 2018 02:44:39 GMT Connection: keep-alive {&quot;success&quot;:1,&quot;msg&quot;:&quot;Hello world!&quot;}</code></pre></li></ol><h3 id="header-3">API</h3><pre><code class="lang-javascript">const Koa=require(&quot;koa&quot;);const app=new Koa();</code></pre><ul><li><p><code>app.listen(...)</code>: 创建并返回一个http服务器</p><pre><code class="lang-javascript">  const http = require(&#39;http&#39;)  const Koa = require(&#39;koa&#39;)  const app = new Koa()  http.createServer(app.callback()).listen(3000)  // 等同于  const Koa = require(&#39;koa&#39;)  const app = new Koa()  app.listen(3000);</code></pre></li><li><code>app.callback()</code>：返回一个可被<code>http.createServer()</code> 接受的程序实例，可将此实例添加到Connect/Express应用中</li><li><code>app.use(function)</code>： 加载中间件</li><li><code>app.keys=</code>：设置cookie 密钥，eg：<code>app.keys = [&#39;im a newer secret&#39;, &#39;i like turtle&#39;];</code></li><li><p><code>app.context</code>: 是ctx的来源，可使用app.context添加额外的属性到ctx</p><pre><code class="lang-javascript">  // 从ctx添加一个数据库引用  add.context.db = db()  app.use(async (ctx)=&gt;{  console.log(ctx.db)  })</code></pre></li><li><code>app.on(eventName,function)</code>: 添加事件侦听器<pre><code class="lang-javascript">  // 默认情况下，所有错误输出到 stderr（ 若app.silent=true 或 err.status=404 或 err.expose=true，默认错误处理程序不会输出错误）  app.on(&#39;error&#39;, (err, ctx) =&gt;    log.error(&#39;server error&#39;, err, ctx)  );</code></pre></li><li><code>app.env</code>: 默认是 <code>NODE_ENV</code> 或 <code>development</code></li><li><code>app.proxy</code>: 设置为true时，porxy头部将被信任</li><li><code>app.subdomainOffset</code>: 设置<code>.subdomains</code>的偏移量</li></ul><h2 id="header-4">Middleware</h2><p>Koa 应用程序是一个包含一组中间件函数的对象，按照类似堆栈的方式组织和执行。</p><p>Middleware 实际就是一个函数，使用<code>use(function)</code>加载middleware，使用<code>next</code>进入下一个middleware。</p><h3 id="header-5">Express VS Koa</h3><p>Express Middleware： 顺序执行，从第一个中间件执行到最后一个中间件，发出响应<br><img src="/2018/08/03/express-middleware.jpg" alt="Express Middleware"></p><p>Koa Middleware： 洋葱模型，一层层的打开，再一层层的闭合，直到第一个中间件执行结束才发出响应<br><img src="/2018/08/03/koa-middleware.jpg" alt="Koa Middleware"></p><p>Express: <code>A-&gt;B-&gt;C-&gt;...-&gt;N</code></p><pre><code class="lang-javascript">// middleware Aapp.use(function(request,response,next){    //...    next();        // move to next middleware in the stack});// middle B// middle C// ...// middle Napp.use(function(request,response,next){    //...    response.send(&quot;done!&quot;);            // done!});</code></pre><p>Koa：<code>A-&gt;B-&gt;C-&gt;...-&gt;N-&gt;...-&gt;C-&gt;B-&gt;A</code></p><pre><code class="lang-javascript">// middleware Aapp.use((ctx,next)=&gt;{    console.log(&quot;A begin&quot;);    next();    console.log(&quot;A end&quot;);            // done!});// middle B// middle C// ...// middle Napp.use((ctx,next)=&gt;{    console.log(&quot;N begin&quot;);    next();    console.log(&quot;N end&quot;);})</code></pre><h3 id="header-6">异步中间件</h3><p>异步操作（比如读取数据库，文件等）</p><p>处理方式：</p><ol><li><p><code>callback</code>：回调函数（Express使用这种方式）；缺点：层层回调，若逻辑很复杂，可能会陷入回调地狱</p><pre><code class="lang-javascript"> fs.readFile(&#39;a.txt&#39;,function(err,data){     // do something     fs.readFile(&#39;b.txt&#39;,function(err,data){         //...     });     // do something });</code></pre></li><li><p><code>promise</code>: 用来传递异步操作流的对象；缺点：代码冗余，只是回调函数的改进</p><pre><code class="lang-javascript"> // 创造一个Promise实例 const promise = new Promise(function(resolve, reject) {   // ... some code   if (/* 异步操作成功 */){     resolve(value);   } else {     reject(error);   } }); // 后续处理 promise   .then(function(data) { //cb     // success   })   .then(function(data) { //cb     // success   })   .catch(function(err) {     // error   })   .finally(function(){     // no args,always exec   });</code></pre></li><li><p><code>generator/yield</code>: es6引入，以同步的方式来写异步编程；异步操作需要暂停的地方，都用yield语句注明；</p><pre><code class="lang-javascript"> function* gen(x){   try {     var y = yield x + 2;   } catch (e){     console.log(e);   }   return y; } var g = gen(1); //next:分阶段执行Generator函数 g.next()             // { value: 3, done: false } g.next(2)             // { value: 2, done: true } g.throw(&#39;出错了&#39;);    // 出错了</code></pre><pre><code class="lang-javascript"> // 引入co模块，用于 Generator 函数的自动执行，返回一个Promise对象 var co = require(&#39;co&#39;); var gen = function* () {   var f1 = yield readFile(&#39;/etc/fstab&#39;);   var f2 = yield readFile(&#39;/etc/shells&#39;);   console.log(f1.toString());   console.log(f2.toString()); }; co(gen).then(function (){   console.log(&#39;Generator 函数执行完成&#39;); });</code></pre></li><li><p><code>async/await</code>: es7引入，generator/yield的语法糖，语义更清晰，且javascript原生支持；注：await命令只能用在async函数之中，如果用在普通函数，就会报错</p><pre><code class="lang-javascript"> async function main() {   try {     const val1 = await firstStep();     const val2 = await secondStep(val1);     const val3 = await thirdStep(val1, val2);     console.log(&#39;Final: &#39;, val3);   }   catch (err) {     console.error(err);   } } main(); main() .then(v =&gt; console.log(v)) .catch(e =&gt; console.log(e)) ;</code></pre></li><li><p><code>generator/yield</code> vs. <code>async/await</code></p><table class="table"><thead><tr><th></th><th style="text-align:left">generator/yield</th><th style="text-align:left">async/await</th></tr></thead><tbody><tr><td>1</td><td style="text-align:left">执行必须靠执行器（eg：co模块–用于 Generator 函数的自动执行）</td><td style="text-align:left">async函数自带执行器</td></tr><tr><td>2</td><td style="text-align:left">co模块约定yield命令后面只能是 Thunk函数(自动执行 Generator 函数的一种方法)或 Promise 对象</td><td style="text-align:left">await后面可以是 Promise 对象和原始类型的值（这时等同于同步操作）</td></tr><tr><td>3</td><td style="text-align:left">Generator 函数的返回值是 Iterator 对象</td><td style="text-align:left">async函数返回值是 Promise对象（可以用then方法指定下一步的操作）</td></tr></tbody></table><ul><li>koa@1.x: 使用generator/yield语法<pre><code class="lang-javascript">  app.use(function *(next){      this.response.type=&#39;html&#39;;      this.response.body=yield fs.readFile(&#39;./demos/template.html&#39;, &#39;utf8&#39;);  });</code></pre></li><li>koa@2.x: 使用async/await语法<pre><code class="lang-javascript">  app.use((ctx,next)=&gt;{      ctx.response.type = &#39;html&#39;;      ctx.response.body = await fs.readFile(&#39;./demos/template.html&#39;, &#39;utf8&#39;);  });</code></pre></li></ul></li></ol><h2 id="header-7">Context</h2><p>Koa Context对象： 表示一次对话的上下文，每个请求会创建属于此请求的context对象，并在koa中间件中传递</p><ul><li>封装了node的request和response对象，通过加工这个对象，就可以控制返回给用户的内容。</li><li>对 Koa 内部一些常用的属性或者方法做了代理操作，使得我们可以直接通过这个context对象获取（eg：ctx.url与ctx.request.url等同）</li><li>约定了一个中间件的存储空间state，可以通过context对象的state存储一些数据，比如用户数据，版本信息等</li><li>注：<ul><li>koa@1.x: 使用this引用Context对象</li><li>koa@2.x: 使用ctx来访问Context对象</li></ul></li></ul><p>示例：</p><pre><code class="lang-javascript">const Koa = require(&#39;koa&#39;);const app = new Koa();app.use((ctx,next)=&gt;{    console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);    next();})app.use((ctx,next)=&gt;{    ctx.response.body = { data: &#39;Hello World&#39; };})app.use(async (ctx,next)=&gt;{    next();    ctx.response.type=&quot;json&quot;;});app.listen(3000);</code></pre><p><strong> API : </strong></p><ul><li>ctx.req: Node 的 request 对象</li><li>ctx.res: Node 的 response 对象，注：Koa 不支持直接调用底层res进行响应处理，请避免使用以下 node 属性：res.statusCode(),res.writeHead(),res.write(),res.end()</li><li>ctx.request: Koa 的 request 对象</li><li>ctx.response: Koa 的 response 对象</li><li>ctx.app: 应用实例引用</li><li>ctx.cookies.get(name, [options]): 获得 cookie 中名为 name 的值，options：<ul><li>signed: 所请求的cookie应该被签名</li></ul></li><li>ctx.cookies.set(name, value, [options]): 设置 cookie 中名为 name 的值，options：<ul><li>signed: 是否要做签名</li><li>expires: cookie 有效期时间</li><li>path: cookie 的路径，默认为 <code>/</code></li><li>domain: cookie 的域</li><li>secure: false 表示 cookie 通过 HTTP 协议发送，true 表示 cookie 通过 HTTPS 发送。</li><li>httpOnly: true 表示 cookie 只能通过 HTTP 协议发送</li></ul></li><li>ctx.throw(msg, [status]): 抛出包含 <code>.status</code> 属性的错误，默认为 500<pre><code class="lang-javascript">  ctx.throw(&#39;name required&#39;, 400)   //等价于：  var err = new Error(&#39;name required&#39;);  err.status = 400;  throw err;</code></pre></li><li><p>ctx.respond: 设为false，则表示绕过 Koa 的内置 response 处理，直接操作原生 res 对象</p></li><li><p><strong> 与Request等价的API: </strong></p><ul><li>ctx.header</li><li>ctx.method</li><li>ctx.method=</li><li>ctx.url</li><li>ctx.url=</li><li>ctx.originalUrl</li><li>ctx.path</li><li>ctx.path=</li><li>ctx.query</li><li>ctx.query=</li><li>ctx.querystring</li><li>ctx.querystring=</li><li>ctx.host</li><li>ctx.hostname</li><li>ctx.fresh</li><li>ctx.stale</li><li>ctx.socket</li><li>ctx.protocol</li><li>ctx.secure</li><li>ctx.ip</li><li>ctx.ips</li><li>ctx.subdomains</li><li>ctx.is()</li><li>ctx.accepts()</li><li>ctx.acceptsEncodings()</li><li>ctx.acceptsCharsets()</li><li>ctx.acceptsLanguages()</li><li>ctx.get()</li></ul></li><li><p><strong> Response等价的API: </strong></p><ul><li>ctx.body</li><li>ctx.body=</li><li>ctx.status</li><li>ctx.status=</li><li>ctx.length=</li><li>ctx.length</li><li>ctx.type=</li><li>ctx.type</li><li>ctx.headerSent</li><li>ctx.redirect()</li><li>ctx.attachment()</li><li>ctx.set()</li><li>ctx.remove()</li><li>ctx.lastModified=</li><li>ctx.etag=</li></ul></li></ul><h2 id="header-8">Exception</h2><h3 id="header-9">抛出错误</h3><pre><code class="lang-javascript">const main = ctx =&gt; {  ctx.response.status = 404;  ctx.response.body = &#39;Page Not Found&#39;;};</code></pre><pre><code class="lang-javascript">const main = ctx =&gt; {  ctx.throw(&#39;Page Not Found&#39;,404); // ctx.throw(404)};</code></pre><h3 id="header-10">监听错误</h3><pre><code class="lang-javascript">app.on(&#39;error&#39;,function(err){    console.log(&#39;logging error &#39;, err.message);    console.log(err);});</code></pre><h3 id="header-11">处理错误</h3><p>在最外层添加一个中间件，使用<code>try...catch</code>捕获错误</p><pre><code class="lang-javascript">app.use(async (ctx, next) =&gt; {  try {    await next();  } catch (err) {    ctx.response.status = err.statusCode || err.status || 500;    ctx.response.body = {      message: err.message    };    ctx.app.emit(&#39;error&#39;, err, ctx);    // 调用ctx.app.emit()，手动释放error事件，才能让监听函数生效  }});app.use(ctx =&gt; {  ctx.throw(500);});</code></pre><h2 id="header-12">常用第三方插件</h2><h3 id="header-13">static</h3><pre><code class="lang-javascript">const path=require(&#39;path&#39;);const static = require(&#39;koa-static&#39;);app.use(static(path.resolve(__dirname, &quot;./public&quot;)));</code></pre><h3 id="header-14">body</h3><p>koa-body模块可以用来从请求的数据体里面提取键值对（方便处理表单，上传文件：ctx.request.files）</p><pre><code class="lang-javascript">const KoaBody = require(&#39;koa-body&#39;);app.use(KoaBody());    app.use(async(ctx,next)=&gt;{    console.log(&quot;request body:&quot;);    console.log(ctx.request.body);    if (!body.name)         ctx.throw(400, &#39;.name required&#39;);    await next();});</code></pre><h3 id="header-15">Router</h3><p>app.js:</p><pre><code class="lang-javascript">const Router=require(&quot;koa-router&quot;);const router=new Router();var catalogueController=require(&quot;./controller/catalogueController&quot;);router.get(&#39;/catalogues&#39;,catalogueController.list);router.get(&#39;/catalogues/:id&#39;,catalogueController.get);router.put(&#39;/catalogues/:id&#39;,catalogueController.update);router.post(&#39;/catalogues&#39;,catalogueController.create);router.delete(&#39;/catalogues/:id&#39;,catalogueController.delete);app.use(router.routes());app.use(router.allowedMethods());</code></pre><p>./controller/catalogueController.js:</p><pre><code class="lang-javascript">module.exports={  list:async (ctx,next)=&gt;{      ...  },  get:async (ctx,next)=&gt;{    let id=ctx.params.id;      ...  },  update:async (ctx,next)=&gt;{    let id=ctx.params.id;    let catalogue=ctx.request.body;    ...  }  ...}</code></pre><h3 id="header-16">Session</h3><pre><code class="lang-javascript">const session=require(&#39;koa-session2&#39;);app.keys=[&#39;a secret key&#39;];    // if set signed:true,need setting the .keys.app.use(session({    key:&quot;SESSIONID&quot;,    signed:true,        // SESSIONID.sig,need to set app.keys,作用：给cookie加上一个sha256的签名,防止cookie被篡改    maxAge:86400000,    // cookie expire after maxAge ms: 1 day = 24h*60m*60s*1000=86400,000ms}));const logger=async (ctx,next)=&gt;{  let path=ctx.request.path;  console.log(&quot;log:&quot;+ctx.request.method+&quot; &quot;+path+&quot;,&quot;+ctx.request.url);  if(ctx.session){        console.log(&quot;loginUser&quot;,ctx.session.loginUser);      console.log(&quot;cookie&quot;,ctx.request.header.cookie);    //ctx.cookies    }  await next();}app.use(logger);app.use(async(ctx,next)=&gt;{    // get: ctx.session.xxx    // set: ctx.session.Xxx=xxx    // remove: delete ctx.session.Xxx    ...})</code></pre><p>扩展：使用MongoDB/Redis等存储Session (具体参看下节)</p><h2 id="header-17">示例</h2><h3 id="header-18">Koa</h3><pre><code class="lang-javascript">const Koa=require(&quot;koa&quot;);const app=new Koa();const errorHandler=async(ctx,next)=&gt;{    try{        await next();    }catch(e){        console.log(&quot;catch exception&quot;);        ctx.response.type=&quot;json&quot;;        ctx.response.body={            success:0,            status: e.statusCode || e.status || 500,            message: e.message        }    }}const prefixHandler=async(ctx,next)=&gt;{    console.log(&quot;prefix Handler...&quot;+ctx.request.path);    if(ctx.request.path==&#39;/error&#39;)        ctx.throw(&quot;go to error!&quot;);    await next();}const postHandler=async(ctx,next)=&gt;{    await next();    console.log(&quot;post Handler...&quot;+ctx.request.path);    ctx.response.type=&quot;json&quot;;    ctx.set(&quot;micro-test&quot;,true);        // set header}const fs = require(&#39;fs&#39;);const main=async(ctx,next)=&gt;{    console.log(&quot;main&quot;)    let data = await fs.readFileSync(&#39;./public/1.txt&#39;,&#39;utf8&#39;);    console.log(&quot;readed:&quot;+data);    ctx.response.body={        success:1,        data:data    }}app.use(errorHandler);app.use(prefixHandler);app.use(postHandler);app.use(main);app.listen(3000,()=&gt;{  console.log(&#39;app started at port 3000...&#39;);});</code></pre><ol><li><p>测试成功情况：</p><pre><code class="lang-bash"> &gt; curl -i http://localhost:3000/1 HTTP/1.1 200 OK Content-Type: application/json; charset=utf-8 micro-test: true Content-Length: 35 Date: Sun, 09 Sep 2018 16:07:48 GMT Connection: keep-alive {&quot;success&quot;:1,&quot;data&quot;:&quot;Static File!&quot;} # server console: prefix Handler.../1 main readed:Static File! post Handler.../1</code></pre></li><li><p>测试异常情况：</p><pre><code class="lang-bash"> &gt; curl -i http://localhost:3000/error HTTP/1.1 200 OK Content-Type: application/json; charset=utf-8 Content-Length: 51 Date: Sun, 09 Sep 2018 16:09:19 GMT Connection: keep-alive {&quot;success&quot;:0,&quot;status&quot;:500,&quot;message&quot;:&quot;go to error!&quot;} # server console: prefix Handler.../error catch exception */</code></pre></li></ol><h3 id="header-19">async/await</h3><ol><li><p>计时器函数执行顺序：</p><pre><code class="lang-javascript"> function sleep(time){     console.log(&quot;sleep func start&quot;)                        // 1     setTimeout(()=&gt;{         console.log(&quot;sleep wakeup after &quot;+time+&quot; !&quot;)    // 3 [ execute after sleep `${time} ms` ]     },time);     console.log(&quot;sleep func end&quot;)                        // 2 }</code></pre></li><li><p>Promise函数（+timeout函数）执行顺序：</p><pre><code class="lang-javascript"> function promiseFunc(timeout){     console.log(&quot;a1. build promise instance&quot;);            // 1     let inst=new Promise((resolve,reject)=&gt;{                             console.log(&quot;b1. start promise instance func&quot;)    // 2         setTimeout(()=&gt;{                                     console.log(&quot;promise wakeup&quot;)                         resolve(&quot;promise resolved after &quot;+timeout);    // 5 &lt;pending&gt; -&gt; &lt;resolved&gt;                 },timeout);             console.log(&quot;b2. end promise instance func&quot;)    // 3     });     console.log(&quot;a2. return promise instance&quot;);                     return inst;                                        // 4 }</code></pre></li><li><p>async函数使用await和不使用await：</p><pre><code class="lang-javascript"> async function asyncFunc(timeout){     console.log(&quot;async 1-&gt;2&quot;)     let msg=await promiseFunc(timeout);    // 1      console.log(&quot;await result:&quot;+msg);    // 2 [ 1-&gt;2 `blocked ${timeout} ms`, get resolved data ]     console.log(&quot;async 3-&gt;4&quot;)     sleep(timeout-2000);                // 3      return msg;                            // 4  [ 3-&gt;4 no block,return a promise instance ]  }</code></pre></li><li><p>async函数调用async函数：</p><pre><code class="lang-javascript"> async function test1(timeout){     console.log(&quot;test timeout:&quot;+timeout);     console.log(&quot;1-&gt;2&quot;)     let result=asyncFunc(timeout);        // 1     console.log(result);                // 2 [ 1 -&gt; 2 no block,get a promise instance]     console.log(&quot;3-&gt;4&quot;)     let msg=await result;                // 3      console.log(msg);                    // 4 [ 3 -&gt; 4 blocked `${timeout} ms`, get resolved data ] };</code></pre></li><li><p>async/await+Promise 多条异步：顺序trigger，reject同throw error）</p><pre><code class="lang-javascript"> function promiseFunc2(code){     console.log(&quot;a1. build promise instance&quot;);            // 1     let inst=new Promise((resolve,reject)=&gt;{                             console.log(&quot;b1. start promise instance func&quot;)             if(code==1)                                         resolve(code+&quot; resolve!&quot;);            // 2 &lt;pending&gt; -&gt; &lt;fulfilled&gt;             else if(code==0)             reject(code+&quot; reject!&quot;);            // 2 &lt;peinding&gt; -&gt; &lt;rejected&gt;          else if(code==-1)             throw new Error(code+&quot; error!&quot;);    // 2 exception         else{                                    // 2 reject(e) == throw new Error(xxx);             try {                 throw new Error(`${code} error! [same with code -1 error!]`);             } catch(e) {                 reject(e);             }         }         console.log(&quot;b2. end promise instance func&quot;)     });     console.log(&quot;a2. return promise instance&quot;);            // 3                     return inst;         } async function test2(code){     console.log(&quot;test code:&quot;+code);     try{         let msg=await promiseFunc2(code);         console.log(&quot;get return: &quot;+msg);     }catch(e){         console.log(&quot;get error: &quot;+(e.message||e));     } } //exec test: test2(1); test2(0); test2(-1); test2(-2); /* test code:1 a1. build promise instance b1. start promise instance func b2. end promise instance func a2. return promise instance test code:0 a1. build promise instance b1. start promise instance func b2. end promise instance func a2. return promise instance test code:-1 a1. build promise instance b1. start promise instance func a2. return promise instance test code:-2 a1. build promise instance b1. start promise instance func b2. end promise instance func a2. return promise instance get return: 1 resolve! get error: 0 reject! get error: -1 error! get error: -2 error! [same with code -1 error!] */</code></pre></li></ol><h3 id="header-20">Mongoose</h3><ol><li><p>MongoDB Data Model: catalogues(name,description,meta:createTime,updateTime,updator)</p><pre><code class="lang-bash"> &gt; db.catalogues.insert([ {name:&quot;Spring&quot;,description:&quot;spring framework&quot;,meta:{createTime:new Date(),updateTime:new Date(),updator:&quot;Tom&quot;}}, {name:&quot;ReactJS&quot;,description:&quot;reactJS front framework&quot;,meta:{createTime:new Date(),updateTime:new Date(),updator:&quot;Tom&quot;}}, {name:&quot;NoSql&quot;,description:&quot;not only sql databases&quot;,meta:{createTime:new Date(),updateTime:new Date(),updator:&quot;Tom&quot;}} ]);</code></pre></li><li><p>mongoTest.js</p><pre><code class="lang-javascript"> const mongoose =require(&quot;mongoose&quot;); mongoose.connect(&#39;mongodb://cj:123456@localhost:27017/demo?authSource=admin&#39;,{ useNewUrlParser: true}); mongoose.set(&#39;useCreateIndex&#39;,true); let catalogueSchema=mongoose.Schema({     name:{type:String,required:true,unique:true},     description:{type:String},     meta:{       createTime:{type:Date,default:Date.now},       updateTime:{type:Date,default:Date.now},       updator:{type:String}     } },{versionKey: false}); // Pre and post save() hooks are not executed on update(), findOneAndUpdate() catalogueSchema.pre(&#39;save&#39;,function(next){   console.log(&#39;pre save:&#39;+this.isNew);   if(this.isNew)     this.meta.createTime=this.meta.updateTime=Date.now();   else     this.meta.updateTime=Date.now();   next(); }); let catalogueDao=mongoose.model(&#39;catalogues&#39;,catalogueSchema); /* Operation */ async function list(){     let catalogueList= await catalogueDao.find({},{meta:0});     return catalogueList; }; async function get(id){     let catalogue=await catalogueDao.findOne({_id:id});     return catalogue; } async function create(catalogue){     let result=await catalogueDao.create(catalogue);     console.log(&quot;create:&quot;);     console.log(result);     return result; } async function udpateCatalogue(id,catalogue){   let result=await catalogueDao.updateOne({_id:id}     ,{$set:{name:catalogue.name,description:catalogue.description       ,&quot;meta.updateTime&quot;:new Date(),&quot;meta.updator&quot;:catalogue.updator}},{new:true});     return result; } async function deleteCatalogue(id){     let result=await catalogueDao.deleteOne({_id:id});     return result; } // test async function test(){   console.log(&quot;start test&quot;);   let catalogue={name:&quot;Docker&quot;,description:&quot;Build, Ship, and Run Any App, Anywhere&quot;};   let newCatalogue= await create(catalogue);   let id=newCatalogue._id;   console.log(&quot;list:&quot;)   let catalogueList=await list();   console.log(catalogueList);   console.log(`update ${id}:`);   let catalogueChange={name:&quot;Docker Feature&quot;,     description:&quot;Container:Build, Ship, and Run Any App, Anywhere&quot;,     updator:&quot;anomy&quot;   };   let result=await udpateCatalogue(id,catalogueChange);   console.log(result);   console.log(`get ${id}:`)   result=await get(id);   console.log(result);   console.log(`delete ${id}:`)   result=await deleteCatalogue(newCatalogue._id);   console.log(result);   console.log(&quot;end test&quot;);   mongoose.disconnect();   console.log(&quot;finish!&quot;); } // clear same records in mongodb first // db.catalogues.remove({name:{$regex:&quot;Docker*&quot;}}) test();</code></pre></li></ol><h3 id="header-21">koa-session2+mongo</h3><p>store session on mongodb</p><ol><li><p>app.js</p><pre><code class="lang-javascript"> const session=require(&#39;koa-session2&#39;); const MongoStore=require(&#39;./util/mongoStore&#39;); const mongoose =require(&quot;mongoose&quot;); mongoose.connect(&#39;mongodb://cj:123456@localhost:27017/demo?authSource=admin&#39;   ,{ useNewUrlParser: true}); mongoose.set(&#39;useCreateIndex&#39;,true); app.keys=[&#39;a secret key&#39;];    // if set signed:true,need setting the .keys. app.use(session({     key:&quot;SESSIONID&quot;,     //signed:true,        // SESSIONID.sig,need to set .keys,作用：给cookie加上一个sha256的签名,防止cookie被篡改     maxAge:86400000,    // cookie expire after maxAge ms: 1 day = 24h*60m*60s*1000=86400,000ms     store: new MongoStore({         collection:&quot;sessions&quot;,         connection:mongoose,         expireAfterSeconds:30    // mongo TTL expireAfterSeconds ( unit:s )     }) })); ... app.use(async(ctx,next)=&gt;{     /*         login: do get/set session             get session: ctx.session.Xxx , eg: ctx.session.loginUser             set session: ctx.session.Xxx=xxx , eg: ctx.session.loginUser={username:result.username,roles:result.roles};         logout: do remove session             delete ctx.session.Xxx , eg: delete ctx.session.loginUser;     */      ... })</code></pre></li><li><p>mongoStore.js</p><pre><code class="lang-javascript"> const mongoose = require(&#39;mongoose&#39;); const { Store } = require(&quot;koa-session2&quot;); class MongoStore extends Store {   constructor({connection=mongoose,collection=&#39;sessions&#39;,expireAfterSeconds=86400000}={}){     super();     let storeSchema=new connection.Schema({       _id:String,       data:Object,       updatedAt: {         default: new Date(),         expires: expireAfterSeconds, // 1 day: 86400 s = 60s*60m*24h =&gt; expireAfterSeconds         type: Date       }     })     this.modelDao=connection.model(collection,storeSchema);   }   async get(sid,ctx){     console.log(&quot;get mongo session:&quot;+sid);     let result= await this.modelDao.findOne({_id:sid});     console.log(result);     return result?result.data:null;   }   async set(session, { sid =  this.getID(24), maxAge = 86400000 } = {}, ctx) {     console.log(&quot;set mongo session:&quot;+sid+&quot;,cookie maxAge:&quot;+maxAge);       try {           let record={_id:sid,data:session,updatedAt:new Date()};           console.log(record);           await this.modelDao.updateOne({_id:sid}, record, { upsert: true, safe: true });       } catch (e) {         console.log(&quot;set mongo session fail:&quot;);         console.log(e);       }       return sid;   }   async destroy(sid){     console.log(&quot;destroy mongo session:&quot;+sid);     return await this.modelDao.deleteOne({_id:sid});   } } module.exports = MongoStore; session stored in mongodb:</code></pre></li><li><p>Session Stored on MongoDB:</p><pre><code class="lang-bash"> &gt; db.sessions.find().pretty() {     &quot;_id&quot; : &quot;53094f8db3e399e17616a4d910676c58b6cde92f3b9435be&quot;,     &quot;__v&quot; : 0,     &quot;data&quot; : {         &quot;loginUser&quot; : {             &quot;username&quot; : &quot;admin&quot;,             &quot;roles&quot; : [                 &quot;admin&quot;             ]         }     },     &quot;updatedAt&quot; : ISODate(&quot;2018-09-09T09:40:40.277Z&quot;) }</code></pre><pre><code class="lang-bash"> &gt; db.sessions.getIndexes() [   {     &quot;v&quot; : 2,     &quot;key&quot; : {       &quot;_id&quot; : 1     },     &quot;name&quot; : &quot;_id_&quot;,     &quot;ns&quot; : &quot;demo.sessions&quot;   },   {     &quot;v&quot; : 2,     &quot;key&quot; : {       &quot;updatedAt&quot; : 1     },     &quot;name&quot; : &quot;updatedAt_1&quot;,     &quot;ns&quot; : &quot;demo.sessions&quot;,     &quot;expireAfterSeconds&quot; : 30,     &quot;background&quot; : true   } ]</code></pre></li></ol><p>Verify:</p><ol><li><p>login</p><pre><code class="lang-bash"> &gt; curl -i -c cookie.txt -d &quot;username=admin&amp;password=123&quot; http://localhost:3000/login HTTP/1.1 200 OK Content-Type: application/json; charset=utf-8 Set-Cookie: SESSIONID=8cbe57db55bb6c944df99ec9a10481a431c41e5ba1400a4a; path=/; expires=Wed, 12 Sep 2018 16:29:57 GMT; httponly Set-Cookie: SESSIONID.sig=TsESPv34Ny1rOA9jimTrlybpHDE; path=/; expires=Wed, 12 Sep 2018 16:29:57 GMT; httponly Content-Length: 59 Date: Tue, 11 Sep 2018 16:29:57 GMT Connection: keep-alive {&quot;success&quot;:1,&quot;data&quot;:{&quot;username&quot;:&quot;admin&quot;,&quot;roles&quot;:[&quot;admin&quot;]}}</code></pre></li><li><p>logout</p><pre><code class="lang-bash"> &gt; curl -i -b cookie.txt -X POST http://localhost:3000/logout HTTP/1.1 200 OK Content-Type: application/json; charset=utf-8 Set-Cookie: SESSIONID=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT; httponly Content-Length: 13 Date: Tue, 11 Sep 2018 16:00:55 GMT Connection: keep-alive {&quot;success&quot;:1}</code></pre></li></ol><h3 id="header-22">Privilege Filter</h3><ol><li><p>MongoDB data Model: privileges(path,method,roles)</p><pre><code class="lang-bash"> &gt; db.privileges.insert([ {path:&quot;/catalogues&quot;,method:&quot;GET&quot;,roles:[]}, {path:&quot;/catalogues/:id&quot;,method:&quot;GET&quot;}, {path:&quot;/catalogues/:id&quot;,method:&quot;PUT&quot;,roles:[&quot;admin&quot;]}, {path:&quot;/catalogues/:id&quot;,method:&quot;DELETE&quot;,roles:[&quot;admin&quot;]}, {path:&quot;/catalogues&quot;,method:&quot;POST&quot;,roles:[&quot;admin&quot;]}, {path:&quot;/articles&quot;,method:&quot;GET&quot;}, {path:&quot;/articles/:id&quot;,method:&quot;GET&quot;}, {path:&quot;/articles/:id&quot;,method:&quot;PUT&quot;,roles:[&quot;user&quot;]}, {path:&quot;/articles/:id&quot;,method:&quot;DELETE&quot;,roles:[&quot;user&quot;,&quot;admin&quot;]}, {path:&quot;/articles&quot;,method:&quot;POST&quot;,roles:[&quot;user&quot;]}, {path:&quot;/login&quot;,method:&quot;POST&quot;}, {path:&quot;/register&quot;,method:&quot;POST&quot;}, {path:&quot;/logout&quot;,method:&quot;POST&quot;}, ]);</code></pre></li><li><p>app.js:</p><pre><code class="lang-javascript"> const PrivilegeStore=require(&#39;./util/PrivilegeStore&#39;); let privilegeStore=new PrivilegeStore(); const privilegeFilter=async (ctx,next)=&gt;{     /*     Note:         1. ctx.request.path: /catalogues/1 ; ctx.request.url: /catalogues/1?x=1         2. roles: get from ctx.session.loginUser,eg: {username:&quot;Tom&quot;,roles:[&quot;user&quot;]}         3. url-pattern:             let pattern=new UrlPattern(&#39;/catalogues/:id&#39;);             console.log(pattern.match(&#39;/catalogues&#39;));            //null             console.log(pattern.match(&#39;/catalogues/1&#39;));        //{id:&#39;1&#39;}             console.log(pattern.match(&#39;/catalogues/1/2&#39;));        //null             console.log(pattern.match(&#39;/catalogues/1?x=3&#39;));    //null             console.log(pattern.match(&#39;catalogues&#39;));            //null     */     let reqItem={path:ctx.request.path,method:ctx.request.method         ,roles:(ctx.session &amp;&amp; ctx.session.loginUser)?ctx.session.loginUser.roles||[]:[]};     let privileges = await privilegeStore.privileges;     let matched = privileges.find((item)=&gt;{         return privilegeStore.verify(item,reqItem);     });     console.log(&quot;pass priv:&quot;+matched);     if(matched)       await next();     else       ctx.throw(401); } app.use(privilegeFilter);</code></pre></li><li><p>PrivilegeStore.js:</p><pre><code class="lang-javascript"> const mongoose = require(&#39;mongoose&#39;); const UrlPattern=require(&#39;url-pattern&#39;); class PrivilegeStore{   constructor({connection=mongoose,collection=&#39;privileges&#39;}={}){     let storeSchema=this.initSchema();     this.privilegeDao=connection.model(collection,storeSchema);     this.privileges=this.loadPrivileges();   }   initSchema(){     let privilegeSchema=mongoose.Schema({         path:{type:String,required:true},         method:{type:String,required:true},         roles:{type:Array},         meta:{           createTime:{type:Date,default:Date.now},           updateTime:{type:Date,default:Date.now},           updator:{type:String}         }     });     privilegeSchema.pre(&#39;save&#39;,function(next){       if(this.isNew)         this.meta.createTime=this.meta.updateTime=Date.now();       else         this.meta.updateTime=Date.now();       next();     });     return privilegeSchema;   }   async loadPrivileges(){     let result=await this.privilegeDao.find({},{_id:0,meta:0});     result.map((item,index,arr)=&gt;{        item.pattern=new UrlPattern(item.path);        return item;     });     console.log(result);     return result;   }   async refresh(){     this.privileges=this.loadPrivileges();   }   verify(item,reqItem){     // console.log(item);     if(item.method!=reqItem.method)       return false;     let pattern = item.pattern;     if(!pattern){       console.log(&quot;init pattern&quot;);       pattern=new UrlPattern(item.path);     }     let match=pattern.match(reqItem.path);     if(match==null){       // console.log(&quot;path not match&quot;);       return false;     }     if(!item.roles || item.roles.length==0){       console.log(&quot;guest pass&quot;);       return true;     }     if(item.roles.find((n)=&gt;reqItem.roles.includes(n))){       console.log(&quot;auth pass&quot;);       return true;     }     return false;    } } module.exports = PrivilegeStore;</code></pre></li></ol><h2 id="header-23">Reference</h2><p><a href="https://github.com/sixDegree/node-mongo" target="_blank" rel="noopener">my demo</a></p><p>Blog:</p><ul><li><a href="http://www.ruanyifeng.com/blog/2017/08/koa.html" target="_blank" rel="noopener">ruanyf/koa</a> | <a href="https://github.com/ruanyf/koa-demos.git" target="_blank" rel="noopener">ruanyf/koa demo</a></li><li><a href="https://www.jianshu.com/p/f59594b90500" target="_blank" rel="noopener">如何使用koa2+es6/7打造高质量Restful API</a></li><li><a href="https://www.jianshu.com/p/d3afa36aa17a" target="_blank" rel="noopener">koa2入门笔记</a></li><li><a href="https://www.jianshu.com/p/6b816c609669" target="_blank" rel="noopener">koa2从起步到填坑</a></li><li><a href="https://www.jianshu.com/p/f8cfb82b4dad" target="_blank" rel="noopener">koa2 async和await 实战详解</a></li><li><a href="https://segmentfault.com/a/1190000013039187" target="_blank" rel="noopener">koa-session学习笔记</a></li><li><a href="https://segmentfault.com/a/1190000012412299" target="_blank" rel="noopener">从koa-session中间件源码学习cookie与session</a></li><li><a href="https://mongoosejs.com/docs/guide.html" target="_blank" rel="noopener">Mongoose</a></li><li><a href="https://www.jianshu.com/p/554a5bf67b31" target="_blank" rel="noopener">mongoose使用之查询篇</a></li><li><a href="https://www.jianshu.com/p/265ff15bca7a" target="_blank" rel="noopener">Mongoose初使用总结</a></li><li><a href="https://www.jianshu.com/p/dcdd116600fe" target="_blank" rel="noopener">koa2+mongodb搭建简易nodejs后台接口服务</a></li></ul><p>Useful npm:</p><ul><li><a href="https://www.npmjs.com/package/koa-session2" target="_blank" rel="noopener">koa session2</a></li><li><a href="https://www.npmjs.com/package/route-parser" target="_blank" rel="noopener">route-parser</a></li><li><a href="https://www.npmjs.com/package/path-parser" target="_blank" rel="noopener">path-parser</a></li><li><a href="https://www.npmjs.com/package/url-pattern" target="_blank" rel="noopener">url-pattern</a></li></ul>]]></content>
    
    <summary type="html">
    
      a Web framework for node.js (simpler then express)
    
    </summary>
    
    
      <category term="Node" scheme="http://sixdegree.github.io/tags/Node/"/>
    
  </entry>
  
</feed>
