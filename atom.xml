<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SixDegree</title>
  
  <subtitle>host by chenjin</subtitle>
  <link href="//atom.xml" rel="self"/>
  
  <link href="http://sixdegree.github.io/"/>
  <updated>2019-08-22T05:15:39.000Z</updated>
  <id>http://sixdegree.github.io/</id>
  
  <author>
    <name>Chen Jin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python Matplotlib</title>
    <link href="http://sixdegree.github.io/2019/08/21/Python-Matplotlib.html"/>
    <id>http://sixdegree.github.io/2019/08/21/Python-Matplotlib.html</id>
    <published>2019-08-20T16:00:00.000Z</published>
    <updated>2019-08-22T05:15:39.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="header-1">Matplotlib</h2><ul><li>第三方可视化库</li><li>由各种可视化类构成,内部结构复杂,受Matlab启发 </li><li><code>matplotlib.pyplot</code>是绘制各类可视化图形的命令子库,相当于快捷方式</li></ul><p>导入使用：</p><pre><code class="lang-python">import matplotlib.pyplot as plt</code></pre><h2 id="header-2">基础绘图函数</h2><table class="table"><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">plt.plot(x,y,fmt,…)</td><td style="text-align:left">绘制一个坐标图</td></tr><tr><td style="text-align:left">plt.boxplot(data,notch,position)</td><td style="text-align:left">绘制一个箱形图</td></tr><tr><td style="text-align:left">plt.bar(left,height,width,bottom)</td><td style="text-align:left">绘制一个条形图</td></tr><tr><td style="text-align:left">plt.barh(width,bottom,left,height)</td><td style="text-align:left">绘制一个横向条形图</td></tr><tr><td style="text-align:left">plt.polar(theta, r)</td><td style="text-align:left">绘制极坐标图</td></tr><tr><td style="text-align:left">plt.pie(data, explode)</td><td style="text-align:left">绘制饼图</td></tr><tr><td style="text-align:left">plt.psd(x,NFFT=256,pad_to,Fs)</td><td style="text-align:left">绘制功率谱密度图</td></tr><tr><td style="text-align:left">plt.specgram(x,NFFT=256,pad_to,F)</td><td style="text-align:left">绘制谱图</td></tr><tr><td style="text-align:left">plt.cohere(x,y,NFFT=256,Fs)</td><td style="text-align:left">绘制X‐Y的相关性函数</td></tr><tr><td style="text-align:left">plt.scatter(x,y)</td><td style="text-align:left">绘制散点图,其中x和y长度相同</td></tr><tr><td style="text-align:left">plt.step(x,y,where)</td><td style="text-align:left">绘制步阶图</td></tr><tr><td style="text-align:left">plt.hist(x,bins,normed)</td><td style="text-align:left">绘制直方图</td></tr><tr><td style="text-align:left">plt.contour(X,Y,Z,N)</td><td style="text-align:left">绘制等值图</td></tr><tr><td style="text-align:left">plt.vlines()</td><td style="text-align:left">绘制垂直图</td></tr><tr><td style="text-align:left">plt.stem(x,y,linefmt,markerfmt)</td><td style="text-align:left">绘制柴火图</td></tr><tr><td style="text-align:left">plt.plot_date()</td><td style="text-align:left">绘制数据日期</td></tr></tbody></table><p>Note:</p><ul><li><code>plt.savefig(fname,dpi)</code> : 将输出图形存储为文件,默认PNG格式,可以通过dpi修改输出质量</li><li><code>plt.show()</code>: 显示绘图</li></ul><h2 id="header-3">plt.plot 坐标图</h2><p><code>plt.plot(x, y, format_string, **kwargs)</code></p><ul><li><code>x</code> : X轴数据,列表或数组,可选(绘制多条曲线时,各条曲线的x不能省略)</li><li><code>y</code> : Y轴数据,列表或数组</li><li><code>format_string</code>: 控制曲线的格式字符串,可选(由颜色字符、风格字符和标记字符组成)</li><li><code>**kwargs</code> : 第二组或更多(x,y,format_string)<ul><li>color : 控制颜色, color=’green’</li><li>linestyle : 线条风格, linestyle=’dashed’</li><li>marker : 标记风格, marker=’o’</li><li>markerfacecolor: 标记颜色, markerfacecolor=’blue’</li><li>markersize : 标记尺寸, markersize=20</li><li>…</li></ul></li></ul><p><strong>Sample:</strong></p><ol><li><p>准备数据</p><pre><code class="lang-python"> # data x=np.linspace(0,10,100) siny=np.sin(x) cosy=np.cos(x)</code></pre></li><li><p>绘制多条曲线</p><pre><code class="lang-python"> # method1: plt.plot(x,siny) plt.plot(x,cosy)  # method2: plt.plot(x,siny,x,cosy)</code></pre></li><li><p>曲线样式设置</p><pre><code class="lang-python"> # method1: plt.plot(x,siny,color=&quot;green&quot;) plt.plot(x,cosy,color=&quot;red&quot;,linestyle=&quot;--&quot;) # &#39;--&#39;:---- , &#39;-.&#39;:--.--.-- , &#39;:&#39;:..... , &#39;-&#39;: ___ # method2: plt.plot(x,siny,&#39;g&#39;,x,cosy,&#39;r--&#39;)</code></pre><p> <img src="/2019/08/21/sin_cos_style.png" alt="sin_cos_style"></p></li><li><p>曲线标签设置</p><pre><code class="lang-python"> plt.plot(x,siny,color=&quot;green&quot;,label=&quot;sin(x)&quot;) plt.plot(x,cosy,color=&quot;red&quot;,label=&quot;cos(x)&quot;)  plt.legend()</code></pre><p> <img src="/2019/08/21/sin_cos_legend.png" alt="sin_cos_legend"></p></li><li><p>坐标轴标签设置</p><pre><code class="lang-python"> plt.plot(x,siny) plt.plot(x,cosy) plt.xlabel(&quot;X axis&quot;) plt.ylabel(&quot;Y axis&quot;)</code></pre><p> <img src="/2019/08/21/sin_cos_xylabel.png" alt="sin_cos_xylabel"></p></li><li><p>坐标轴范围设置</p><pre><code class="lang-python"> plt.plot(x,siny,x,cosy) plt.plot(x,cosy) # method1: plt.xlim(-5,15) plt.ylim(-0.5,1.5) # method2: plt.axis([-1,12,-2,2]) # [x_s,x_e,y_s,y_e]</code></pre><p> <img src="/2019/08/21/sin_cos_axis.png" alt="sin_cos_axis"></p></li><li><p>给图加标题</p><pre><code class="lang-python"> plt.plot(x,siny,x,cosy) plt.title(&quot;Test&quot;)</code></pre></li><li><p>显示绘图</p><pre><code class="lang-python"> plt.show()</code></pre></li></ol><h2 id="header-4">plt.scatter 散点图</h2><p><strong>Sample:</strong></p><pre><code class="lang-python">x=np.linspace(0,10,100)siny=np.sin(x)cosy=np.cos(x)plt.scatter(x,siny,color=&quot;green&quot;)plt.scatter(x,cosy,color=&quot;red&quot;)plt.show()</code></pre><p><img src="/2019/08/21/sin_cos_scatter.png" alt="sin_cos_scatter"></p><pre><code class="lang-python">x1=np.random.normal(0,1,1000)x2=np.random.normal(0,1,1000)plt.scatter(x1,x2,alpha=0.3)plt.show()</code></pre><p><img src="/2019/08/21/x1_x2_scatter.png" alt="x1_x2_scatter"></p><h2 id="header-5">plt.hist 直方图</h2><pre><code class="lang-python">a=np.random.normal(100,20,size=100)plt.hist(a,40,alpha=0.3)       # 40: bin,直方个数plt.show()</code></pre><p><img src="/2019/08/21/normal_hist.png" alt="normal_hist"></p><h2 id="header-6">plt.pie 饼图</h2><pre><code class="lang-python">labels=[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;]sizes=[15,30,45,10]explode=[0,0.1,0,0]plt.pie(sizes,explode=explode,labels=labels,autopct=&quot;%1.1f%%&quot;,shadow=False,startangle=90)plt.show()</code></pre><p><img src="/2019/08/21/pie.png" alt="pie"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;header-1&quot;&gt;Matplotlib&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;第三方可视化库&lt;/li&gt;
&lt;li&gt;由各种可视化类构成,内部结构复杂,受Matlab启发 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;matplotlib.pyplot&lt;/
      
    
    </summary>
    
    
      <category term="Python" scheme="http://sixdegree.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python Numpy</title>
    <link href="http://sixdegree.github.io/2019/08/20/Python-Numpy.html"/>
    <id>http://sixdegree.github.io/2019/08/20/Python-Numpy.html</id>
    <published>2019-08-19T16:00:00.000Z</published>
    <updated>2019-08-23T07:30:55.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>ndarray数组：属性，元素类型，创建</li><li>基础操作：（维度，元素类型）变换，访问（索引，切片），合并，分割</li><li>运算操作：基本运算（作用于数组的每一个元素），线性运算（向量／矩阵 ：逆，乘）</li><li>高级：聚合函数，索引函数，Fancy Indexing(应用：统计判断，方便抽出符合条件的元素)</li><li>文件存取</li></ol><a id="more"></a><h2 id="header-1">Numpy</h2><p>NumPy是一个开源的Python科学计算基础库，包含:</p><ul><li>一个强大的N维数组对象 <code>ndarray</code></li><li>广播功能函数</li><li>整合<code>C</code>/<code>C++</code>/<code>Fortran</code>代码的工具</li><li>线性代数、傅里叶变换、随机数生成等功能</li></ul><p>导入使用：</p><pre><code class="lang-python">import numpy as np</code></pre><h2 id="header-2">N维数组对象:ndarray</h2><p><code>ndarray</code>: 数组（在程序中的别名是:<code>array</code>）</p><ul><li>一个多维数组（注：这里的维度是指数据的组织形式）：<ul><li>1维数组：1层，eg: <code>[]</code>,可用来表示一个向量</li><li>2维数组：2层，eg: <code>[[],[],...,[]]</code>,可用来表示一个矩阵</li><li>N维数组：N层数组，可用来表示多个矩阵</li></ul></li><li>由两部分构成:<ul><li>实际的数据</li><li>描述这些数据的元数据(数据维度、数据类型等)</li></ul></li><li>元素类型:<ul><li>一般要求为相同(同质)类型</li><li>也可以由非同质对象构成，此时元素类型为object，无法有效发挥NumPy优势,尽量避免使用</li></ul></li><li>vs. Python <code>list</code>列表: <ul><li><code>ndarray</code>对象采用相同的数据类型（有助于节省运算和存储空间）</li><li><code>ndarray</code>对象运算更直接高效（如：可去掉元素间运算所需的循环,使一维向量更像单个数据）</li></ul></li></ul><h3 id="header-3">ndarray对象的属性</h3><table class="table"><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>.ndim</code></td><td style="text-align:left">秩(轴数量或维度数量)</td></tr><tr><td style="text-align:left"><code>.shape</code></td><td style="text-align:left">每个维度的尺度,返回一个tuple (eg: <code>(n,)</code>,<code>(n,m)</code>,<code>(a,b,c)</code>)</td></tr><tr><td style="text-align:left"><code>.size</code></td><td style="text-align:left">元素个数(=<code>.shape</code>中<code>n*m*...</code>)</td></tr><tr><td style="text-align:left"><code>.dtype</code></td><td style="text-align:left">元素类型</td></tr><tr><td style="text-align:left"><code>.itemsize</code></td><td style="text-align:left">每个元素的大小,以字节为单位</td></tr></tbody></table><h3 id="header-4">ndarray的元素类型</h3><p>对比Python语法仅支持整数、浮点数和复数3种类型,ndarray支持更多的元素类型，因为：</p><ul><li>科学计算涉及数据较多,对存储和性能都有较高要求</li><li>对元素类型精细定义,有助于NumPy合理使用存储空间并优化性能 </li></ul><table class="table"><thead><tr><th style="text-align:left">数据类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>bool</code></td><td style="text-align:left">布尔类型,<code>True</code>或<code>False</code></td></tr><tr><td style="text-align:left"><code>intc</code></td><td style="text-align:left">与C语言中的int类型一致,一般是<code>int32</code>或<code>int64</code></td></tr><tr><td style="text-align:left"><code>intp</code></td><td style="text-align:left">用于索引的整数,与C语言中<code>ssize_t</code>一致,<code>int32</code>或<code>int64</code> </td></tr><tr><td style="text-align:left"><code>int8</code></td><td style="text-align:left">字节长度的整数,取值:<code>[‐128, 127]</code></td></tr><tr><td style="text-align:left"><code>int16</code></td><td style="text-align:left">16位长度的整数,取值:<code>[‐32768, 32767]</code></td></tr><tr><td style="text-align:left"><code>int32</code></td><td style="text-align:left">32位长度的整数,取值:<code>[‐2^31, 2^31‐1]</code></td></tr><tr><td style="text-align:left"><code>int64</code></td><td style="text-align:left">64位长度的整数,取值:<code>[‐2^63, 2^63‐1]</code></td></tr><tr><td style="text-align:left"><code>uint8</code></td><td style="text-align:left">8位无符号整数,取值:<code>[0, 255]</code></td></tr><tr><td style="text-align:left"><code>uint16</code></td><td style="text-align:left">16位无符号整数,取值:<code>[0, 65535]</code></td></tr><tr><td style="text-align:left"><code>uint32</code></td><td style="text-align:left">32位无符号整数,取值:<code>[0, 2^32‐1]</code></td></tr><tr><td style="text-align:left"><code>uint64</code></td><td style="text-align:left">64位无符号整数,取值:<code>[0, 2^64‐1]</code></td></tr><tr><td style="text-align:left"><code>float16</code></td><td style="text-align:left">16位半精度浮点数:1位符号位,5位指数,10位尾数</td></tr><tr><td style="text-align:left"><code>float32</code></td><td style="text-align:left">32位半精度浮点数:1位符号位,8位指数,23位尾数</td></tr><tr><td style="text-align:left"><code>float64</code></td><td style="text-align:left">64位半精度浮点数:1位符号位,11位指数,52位尾数</td></tr><tr><td style="text-align:left"><code>complex64</code></td><td style="text-align:left">复数类型,实部和虚部都是32位浮点数</td></tr><tr><td style="text-align:left"><code>complex128</code></td><td style="text-align:left">复数类型,实部和虚部都是64位浮点数</td></tr></tbody></table><h3 id="header-5">ndarray数组的创建</h3><table class="table"><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">说明</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>np.array(list/tuple,dtype=None)</code></td><td style="text-align:left">从list/tuple/array等类型创建(不指定<code>dtype</code>时,将根据数据情况自动关联一个<code>dtype</code>类型)</td><td style="text-align:left"><code>np.array([i for i in range(10)])</code></td></tr><tr><td style="text-align:left"><code>np.zeros(shape,dtype=float)</code></td><td style="text-align:left">根据<code>shape</code>生成一个全<code>0</code>数组(<code>shape</code>: int or tuple)</td><td style="text-align:left"><code>np.zeros(shape=(3,5),dtype=int)</code></td></tr><tr><td style="text-align:left"><code>np.ones(shape,dtype=float)</code></td><td style="text-align:left">根据<code>shape</code>生成一个全<code>1</code>数组(<code>shape</code>: int or tuple)</td><td style="text-align:left"><code>np.ones(shape=(3,5),dtype=int)</code></td></tr><tr><td style="text-align:left"><code>np.full(shape,fill_value,dtype=None)</code></td><td style="text-align:left">根据<code>shape</code>生成一个全是<code>fill_value</code>的数组(<code>shape</code>:int or tuple,<code>dtype</code>默认根据<code>fill_value</code>的数据类型)</td><td style="text-align:left"><code>np.full(shape=(3,5),fill_value=6</code></td></tr><tr><td style="text-align:left"><code>np.zeros_like(a,dtype=None)</code></td><td style="text-align:left">根据数组<code>a</code>的形状生成一个全<code>0</code>数组(<code>dtype</code>默认根据<code>a</code>的<code>dtype</code>)</td><td style="text-align:left"><code>np.zeros_like(a)</code></td></tr><tr><td style="text-align:left"><code>np.ones_like(a,dtype=None)</code></td><td style="text-align:left">根据数组<code>a</code>的形状生成一个全<code>1</code>数组(<code>dtype</code>默认根据<code>a</code>的<code>dtype</code>)</td><td style="text-align:left"><code>np.ones_like(a)</code></td></tr><tr><td style="text-align:left"><code>np.full_like(a,val,dtype=None)</code></td><td style="text-align:left">根据数组<code>a</code>的形状生成一个全是<code>val</code>的数组(<code>dtype</code>默认根据<code>a</code>的<code>dtype</code>)</td><td style="text-align:left"><code>np.full_like(a,0.1,dtype=float)</code></td></tr><tr><td style="text-align:left"><code>np.arange([start=0,] stop[, step=1,], dtype=None)</code></td><td style="text-align:left"><code>[start,stop-1]</code>等<code>step</code>间隔形成一维数组（类似<code>range()</code>，但可以是浮点数）</td><td style="text-align:left"><code>np.arange(0,1,0.2)</code></td></tr><tr><td style="text-align:left"><code>np.linspace(start, stop, num=50,endpoint=True,dtype=None)</code></td><td style="text-align:left"><code>[start,stop]</code>等间距提取<code>num</code>个数据形成一维数组(<code>endpoint=True</code>: 默认<code>sample</code>包括<code>stop</code>)</td><td style="text-align:left"><code>np.linspace(0,20,11)</code></td></tr><tr><td style="text-align:left"><code>np.eye(n,dtype=float)</code></td><td style="text-align:left">创建一个正方的<code>n*n</code>单位矩阵(对角线为1,其余为0)</td><td style="text-align:left"><code>np.eye(3)</code></td></tr><tr><td style="text-align:left"><code>np.random.randint([low=0,] high, size=None, dtype=&#39;l&#39;)</code></td><td style="text-align:left"><code>[low,high)</code>随机整数数组（<code>size</code>: int or tuple for output shape），默认生成一个数</td><td style="text-align:left"><code>np.random.randint(5, size=(2, 4))</code></td></tr><tr><td style="text-align:left"><code>np.random.random(size=None)</code></td><td style="text-align:left"><code>[0.0,1.0)</code>随机均匀分布的浮点数数组(<code>size</code>: int or tuple for output shape)，默认生成一个数</td><td style="text-align:left"><code>np.random.random((3, 2))</code></td></tr><tr><td style="text-align:left"><code>np.random.normal(loc=0.0, scale=1.0, size=None)</code></td><td style="text-align:left">生成符合<code>loc</code>均值,<code>scale</code>方差的随机正态分布的浮点数数组(<code>size</code>: int or tuple for output shape)，默认生成一个数</td><td style="text-align:left"><code>np.random.normal(loc=0,scale=10,size=(3,5))</code></td></tr><tr><td style="text-align:left"><code>np.random.shuffle(a)</code></td><td style="text-align:left">根据数组a的0轴进行随排列（行乱序）,改变原数组</td><td style="text-align:left"><code>np.random.shuffle(X)</code></td></tr><tr><td style="text-align:left"><code>np.random.permutation(a)</code></td><td style="text-align:left">根据数组a的0轴进行随排列（行乱序）,生成一个新数组</td><td style="text-align:left"><code>X1=np.random.permutation(X)</code></td></tr><tr><td style="text-align:left"><code>np.random.choice(a, size=None, replace=True, p=None)</code></td><td style="text-align:left">从a(一维数组或int)中以概率p抽取元素,形成size形状新数组 replace表示是否可以重用元素</td><td style="text-align:left"><code>np.random.choice(a)</code></td></tr></tbody></table><h3 id="header-6">Samples</h3><ol><li><p><code>np.array</code></p><pre><code class="lang-python"> x=np.array([i for i in range(10)])  # array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) y=np.array((1.1, 2, 3.5))           # array([1.1, 2. , 3.5]) X=np.array([ [1, 2], [3, 4] ])      # array([[1, 2],[3, 4]])</code></pre></li><li><p><code>.ndim</code>,<code>.shape</code>,<code>.size</code>,<code>.dtype</code>,<code>.itemsize</code></p><pre><code class="lang-python"> # 1, (10,), 10, dtype(&#39;int64&#39;), 8 x.ndim, x.shape, x.size, x.dtype, x.itemsize # 1, (3,), 3, dtype(&#39;float64&#39;), 8 y.ndim, y.shape, y.size, y.dtype, y.itemsize # 2, (2, 2), 4, dtype(&#39;int64&#39;), 8 X.ndim, X.shape, X.size, X.dtype, X.itemsize # 注意: a 与 b 的维度不同 a,b = np.array([1,2,3]), np.array([[1,2,3]]) # 1, (3,), 3 a.ndim,a.shape,a.size  # 2, (1, 3), 3 b.ndim,b.shape,b.size</code></pre></li><li><p><code>np.zeros</code>,<code>np.ones</code>,<code>np.full</code></p><pre><code class="lang-python"> # np.zeros(shape,dtype=float) np.zeros(5)                         # array([0., 0., 0., 0., 0.]) np.zeros(5,dtype=int)               # array([0, 0, 0, 0, 0]) np.zeros(shape=(3,2),dtype=int)     # array([[0, 0], [0, 0], [0, 0]]) # np.ones(shape,dtype=float) np.ones(5)                          # array([1., 1., 1., 1., 1.]) np.ones(5,dtype=int)                # array([1, 1, 1, 1, 1]) np.ones(shape=(3,2),dtype=int)      # array([[1, 1], [1, 1], [1, 1]]) # np.full(shape,fill_value,dtype=None) np.full(5,2)                        # array([2, 2, 2, 2, 2]) np.full((3,2),2.5)                  # array([[2.5, 2.5], [2.5, 2.5], [2.5, 2.5]])</code></pre></li><li><p><code>np.zeros_like</code>,<code>np.ones_like</code>,<code>np.full_like</code></p><pre><code class="lang-python"> X                                   # array([[1, 2], [3, 4]]) # np.zeros_like(a,dtype=None) np.zeros_like(X)                    # array([[0, 0], [0, 0]]) # np.ones_like(a,dtype=None) np.ones_like(X)                     # array([[1, 1], [1, 1]]) # np.full_like(a,val,dtype=None) np.full_like(X,2.5)                 # array([[2, 2],[2, 2]]) np.full_like(X,2.5,dtype=float)     # array([[2.5, 2.5], [2.5, 2.5]])</code></pre></li><li><p><code>np.arange</code>,<code>np.linspace</code></p><pre><code class="lang-python"> # np.arange([start=0,] stop[, step=1,], dtype=None) =&gt; [start,stop-1] np.arange(5)                        # array([0, 1, 2, 3, 4]) np.arange(0,5)                      # array([0, 1, 2, 3, 4]) np.arange(0,10,2)                   # array([0, 2, 4, 6, 8]) np.arange(0,5.0)                    # array([0., 1., 2., 3., 4.]) np.arange(0,1,0.2)                  # array([0. , 0.2, 0.4, 0.6, 0.8]) # np.linspace(start, stop, num=50,endpoint=True,dtype=None) =&gt; [start,stop] np.linspace(0,10,5)                 # array([ 0. ,  2.5,  5. ,  7.5, 10. ]) np.linspace(0,10,6)                 # array([ 0.,  2.,  4.,  6.,  8., 10.]) np.linspace(0,10,5,endpoint=False)  # array([0., 2., 4., 6., 8.])</code></pre></li><li><p><code>np.eye</code></p><pre><code class="lang-python"> # np.eye(n,dtype=float) =&gt; n*n I np.eye(2)                           # array([[1., 0.], [0., 1.]])</code></pre></li><li><p><code>np.random.randint</code>,<code>np.random.random</code>,<code>np.random.normal</code>,<code>np.random.seed</code></p><pre><code class="lang-python"> # np.random.randint([low=0,] high, size=None, dtype=&#39;l&#39;) =&gt; [low, high) 均匀分布的整数 np.random.randint(0,10)             # 7 np.random.randint(0,10,size=5)      # array([6, 3, 9, 5, 4]) np.random.randint(0,10,size=(2,6))  # array([[0, 5, 5, 2, 2, 6], [5, 3, 5, 7, 4, 3]]) # np.random.random(size=None) =&gt; [0.0, 1.0) 均匀分布的浮点数 np.random.random()                  # 0.35112599596274263 np.random.random(size=5)            # array([0.84018916, 0.6768928 , 0.37947955, 0.10752063, 0.42760159]) np.random.random(size=(2,3))        # array([[0.3148762 , 0.87591898, 0.29565754], [0.97317656, 0.58963764, 0.19674398]]) # np.random.normal(loc=0.0, scale=1.0, size=None) ＝&gt; 正态分布的浮点数 np.random.normal()                          # -1.6000374192847393 : 均值为0，方差为1的一个随机浮点数 np.random.normal(10,100)                    # -83.71302590581439  : 均值为10，方差为100的一个随机浮点数 np.random.normal(loc=0,scale=10,size=(2,3)) # array([[-5.43979747, 16.91181992, -4.96602424], [-5.8348921 , -8.60388572, -9.39083007]]) # np.random.seed(seed=None) =&gt; 生成随机数前设置一个随机种子，保证生成的随机数一样 np.random.seed(55) np.random.randint(10)               # 7 np.random.randint(10)               # 8 : 未使用相同的seed,生成的随机数不一样 np.random.seed(55) np.random.randint(10)               # 7 : 使用相同的seed,生成的随机数一样 np.random.seed(55) np.random.randint(10)               # 7 : 使用相同的seed,生成的随机数一样 np.random.seed(55) np.random.randint(100)              # 83 : seed相同，范围不同，生成的随机数不一样</code></pre></li><li><p><code>np.random.shuffle</code>,<code>np.random.permutation</code>,<code>np.random.choice</code></p><pre><code class="lang-python"> &#39;&#39;&#39; X:  array([[ 0,  1,  2,  3,  4],        [ 5,  6,  7,  8,  9],        [10, 11, 12, 13, 14]]) &#39;&#39;&#39; np.random.shuffle(X)        # 根据数组a的0轴进行随排列 =&gt; 行乱序，直接改变原数组 X                           &#39;&#39;&#39;                             array([[10, 11, 12, 13, 14],                                    [ 5,  6,  7,  8,  9],                                    [ 0,  1,  2,  3,  4]])                             &#39;&#39;&#39; Y=np.random.permutation(X)  # 根据数组a的0轴进行随排列 =&gt; 行乱序，不改变原数组                             &#39;&#39;&#39;                             array([[10, 11, 12, 13, 14],                                    [ 0,  1,  2,  3,  4],                                    [ 5,  6,  7,  8,  9]])                             &#39;&#39;&#39; np.random.choice(10,(2,3))  # ＝ np.random.randint(0,10,(2,3))                             &#39;&#39;&#39;                             array([[8, 7, 1],                                    [5, 7, 8]])                             &#39;&#39;&#39; np.random.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])                               &#39;&#39;&#39;                             从 array[0,1,2,3,4] 中按概率p无重复的随机挑出3个（元素1，4取出的概率为0）                             =&gt; array([2, 3, 0])                             &#39;&#39;&#39;</code></pre></li></ol><h2 id="header-7">ndarray数组的基础操作</h2><h3 id="header-8">变换</h3><ul><li><p>维度变换</p><table class="table"><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>.reshape(shape)</code></td><td style="text-align:left">返回一个shape形状的新数组(注：数组元素个数一致)</td></tr><tr><td style="text-align:left"><code>.resize(shape)</code></td><td style="text-align:left">与<code>.reshape(shape)</code>功能一致，但修改原数组</td></tr><tr><td style="text-align:left"><code>.swapaxes(ax1,ax2)</code></td><td style="text-align:left">将数组<code>n</code>个维度中两个维度进行调换,返回一个新数组,原数组不变</td></tr><tr><td style="text-align:left"><code>.flatten()</code></td><td style="text-align:left">对数组进行降维,返回折叠后的一维数组,原数组不变</td></tr></tbody></table></li><li><p>元素类型变换</p><table class="table"><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>dtype=</code></td><td style="text-align:left"><code>np.array(a,dtype=np.int32)</code> 创建时指定</td></tr><tr><td style="text-align:left"><code>astype()</code></td><td style="text-align:left"><code>a.astype(np.float)</code> 返回一个新数组</td></tr></tbody></table></li></ul><p><strong>Sample1:维度变换</strong> </p><pre><code class="lang-python">x=np.arange(10)         # array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</code></pre><pre><code class="lang-python"># 1. reshape(shape) =&gt; 原数组不变x.reshape(2,5)         # array([[0, 1, 2, 3, 4],[5, 6, 7, 8, 9]])                       # =&gt; Note: 原数组x不变 = array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])x.reshape(2,-1)        # array([[0, 1, 2, 3, 4],[5, 6, 7, 8, 9]])                       # =&gt; Note: x.reshape(3,-1)会出错，因为10不能被3整除x.reshape(1,-1)        # array([[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]])                        # =&gt; Note: 生成的是一个新的1*10的二维数组（矩阵）,不是一维数组（向量）</code></pre><pre><code class="lang-python"># 2. resize(shape) =&gt; 原数组改变x.resize(5,2)           # None           x                       # array([[0, 1],[2, 3],[4, 5],[6, 7],[8, 9]])</code></pre><pre><code class="lang-python"># 3. swapaxes(ax1,ax2) =&gt; 原数组不变# 2, (5,2)x.ndim,x.shapex.swapaxes(0,1)         # array([[0, 2, 4, 6, 8],[1, 3, 5, 7, 9]])                        # ＝&gt; 0,1 维度数据交换</code></pre><pre><code class="lang-python"># 4. flatten() =&gt; 原数组不变x.flatten()             # array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])                        # =&gt; 压缩到一维</code></pre><p><strong>Sample2:元素类型变换</strong> </p><pre><code class="lang-python">a                                   # array([1, 2, 3])a.dtype                             # dtype(&#39;int64&#39;)</code></pre><pre><code class="lang-python"># 1. dtype=xxxc = np.array(a,dtype=np.int32)      # array([1, 2, 3], dtype=int32)</code></pre><pre><code class="lang-python"># 2. astype(dtype)d = a.astype(float)                 # array([1., 2., 3.])</code></pre><h3 id="header-9">访问</h3><ul><li>索引: 获取数组中特定位置元素<ul><li>每个维度一个索引值,逗号分割</li></ul></li><li>切片: 获取数组元素子集<ul><li>每个维度一个切片,逗号分割</li><li>一个切片使用3元素冒号分割（<code>起始编号: 终止编号(不含): 步长</code>）</li></ul></li><li>注意：<ul><li>编号<code>0</code>开始从左递增,或<code>‐1</code>开始从右递减</li><li>切片产生的子数组是原数组的引用（创建与原数组无关的新的子数组可以使用<code>.copy()</code>复制一份）</li></ul></li></ul><p><strong>Sample1:索引</strong></p><ol><li><p>一维数组使用索引</p><pre><code class="lang-python"> &#39;&#39;&#39; x = np.arange(10) =&gt; array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) &#39;&#39;&#39; x[2]        # 2 x[-1]       # 9</code></pre><ol><li>二维数组使用索引<pre><code class="lang-python">&#39;&#39;&#39;X = np.arange(10).reshape(3,5)=&gt; array([[ 0,  1,  2,  3,  4],        [ 5,  6,  7,  8,  9],        [10, 11, 12, 13, 14]])&#39;&#39;&#39;X[2][2]     # 12X[(2,2)]    # 12X[2,2]      # 12 &lt;= 推荐方式</code></pre></li></ol></li></ol><p><strong>Sample2:切片</strong></p><ol><li><p>一维数组使用切片</p><pre><code class="lang-python"> &#39;&#39;&#39; x = np.arange(10) =&gt; array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) &#39;&#39;&#39; x[5:9:2]    # [5,9),step:2  =&gt; array([5, 7]) x[5:9]      # [5,9),step:1  =&gt; array([5, 6, 7, 8])  x[:5]       # [s,5),s=0     =&gt; array([0, 1, 2, 3, 4]) x[5:]       # [5,e),e=len   =&gt; array([5, 6, 7, 8, 9]) x[::2]      # step:2        =&gt; array([0, 2, 4, 6, 8]) x[::-1]     # step:-1       =&gt; array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) 倒数</code></pre></li><li><p>二维数组使用切片</p><pre><code class="lang-python"> &#39;&#39;&#39; X = np.arange(10).reshape(3,5) =&gt; array([[ 0,  1,  2,  3,  4],           [ 5,  6,  7,  8,  9],           [10, 11, 12, 13, 14]]) &#39;&#39;&#39; X[0], X[0,:]    # 取第0行 array([0, 1, 2, 3, 4]) X[:,0]          # 取第0列 array([ 0,  5, 10]) X[::-1,::-1]    # 行列都反转                 &#39;&#39;&#39;                 array([[14, 13, 12, 11, 10],                        [ 9,  8,  7,  6,  5],                        [ 4,  3,  2,  1,  0]])                 &#39;&#39;&#39; X[:2,::2]       # 取前2行，列step为2的元素                 &#39;&#39;&#39;                 array([[0, 2, 4],                        [5, 7, 9]])                 &#39;&#39;&#39; X[:2,:3]        # 取前2*3 (注意与X[:2][:3]的区别)                 &#39;&#39;&#39;                 array([[0, 1, 2],                        [5, 6, 7]])                 &#39;&#39;&#39; X[:2][:3]       # X[:2]数组的前3个元素                 &#39;&#39;&#39;                 X[:2]                      array([[0, 1, 2, 3, 4],                            [5, 6, 7, 8, 9]])                 X[:2][:3]                     array([[0, 1, 2, 3, 4],                            [5, 6, 7, 8, 9]])                 &#39;&#39;&#39;</code></pre></li><li><p>切片产生的子数组是原数组的引用</p><pre><code class="lang-python"> subX=X[:2,:3]           # 切片，产生子矩阵数组                         &#39;&#39;&#39;                         array([[0, 1, 2],                                [5, 6, 7]])                         &#39;&#39;&#39; subX[0,0]=100           # 1. 修改子矩阵[0,0]位置的元素值                          &#39;&#39;&#39;                         array([[100,   1,   2],                                 [  5,   6,   7]])                         &#39;&#39;&#39;    X                       # 原数组中[0,0]位置的元素值也改变了                         &#39;&#39;&#39;                         array([[100,   1,   2,   3,   4],                                [  5,   6,   7,   8,   9],                                [ 10,  11,  12,  13,  14]])                         &#39;&#39;&#39;   X[0,0]=50               # 2. 修改原数组[0,0]位置元素值                         &#39;&#39;&#39;                         array([[50,  1,  2,  3,  4],                                [ 5,  6,  7,  8,  9],                                [10, 11, 12, 13, 14]])                         &#39;&#39;&#39;        subX                    # 子数组[0,0]位置的元素值也跟着改变了                         &#39;&#39;&#39;                         array([[50,  1,  2],                                [ 5,  6,  7]])                         &#39;&#39;&#39; subX=X[:2,:3].copy()    # 3. 使用`.copy()`创建与原数组无关的新的子数组                         &#39;&#39;&#39;                         array([[50,  1,  2],                                [ 5,  6,  7]])                         &#39;&#39;&#39; subX[0,0]=20            # 改变子数组[0,0]位置元素值                         &#39;&#39;&#39;                         array([[20,  1,  2],                                [ 5,  6,  7]])                         &#39;&#39;&#39; X                       # 原数组不受影响                         &#39;&#39;&#39;                         array([[50,  1,  2,  3,  4],                                [ 5,  6,  7,  8,  9],                                [10, 11, 12, 13, 14]])                          &#39;&#39;&#39;</code></pre></li></ol><h3 id="header-10">合并</h3><ul><li><code>np.concatenate((a1, a2, ...), axis=0, out=None)</code> <ul><li>同维度数组合并</li><li>不同维度需先<code>reshape</code></li></ul></li><li>more:<ul><li><code>np.stack(arrays, axis=0, out=None)</code> : Join a sequence of arrays along a new axis.</li><li><code>np.vstack(tup)</code> : Stack arrays in sequence vertically (row wise).<ul><li>垂直方向堆叠，水平方向size需相同(即列size需相同)</li><li>内部使用<code>np.concatenate</code></li><li>特：可直接合并一维数组（向量）</li></ul></li><li><code>np.hstack(tup)</code> : Stack arrays in sequence horizontally (column wise).<ul><li>水平方向堆叠，垂直方向size需相同(即行size需相同)</li><li>内部使用<code>np.concatenate</code></li></ul></li><li><code>np.dstack(tup)</code> : Stack arrays in sequence depth wise (along third dimension)</li></ul></li></ul><p><strong>Sample1:<code>np.concatenate</code></strong></p><ol><li><p>一维数组间（向量）合并</p><pre><code class="lang-python"> x=np.array([1,2,3]) y=np.array([3,2,1]) z=np.array([6,6,6]) np.concatenate([x,y,z])     # 组成一个新的一维向量:                              &#39;&#39;&#39;                             array([1, 2, 3, 3, 2, 1, 6, 6, 6])                             &#39;&#39;&#39;</code></pre></li><li><p>二维数组间（矩阵）合并</p><pre><code class="lang-python"> &#39;&#39;&#39; A : 2维矩阵（2*3）     array([[1, 2, 3],            [4, 5, 6]]) &#39;&#39;&#39; np.concatenate([A,A])           # 1. 维度0上合并，组成一个新的4*3矩阵                                  &#39;&#39;&#39;                                 array([[1, 2, 3],                                        [4, 5, 6],                                        [1, 2, 3],                                        [4, 5, 6]])                                 &#39;&#39;&#39; np.concatenate([A,A],axis=1)    # 维度1上合并,组成2*6矩阵                                 &#39;&#39;&#39;                                 array([[1, 2, 3, 1, 2, 3],                                        [4, 5, 6, 4, 5, 6]])                                 &#39;&#39;&#39; np.concatenate([A,A],axis=None) # = flatten 压缩成一维                                 &#39;&#39;&#39;                                 array([1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6])                                 &#39;&#39;&#39;</code></pre></li><li><p>一维数组（向量）合并到二维数组（矩阵）中</p><pre><code class="lang-python"> &#39;&#39;&#39; z : 1维向量     array([6,6,6]) A : 2维矩阵（2*3）     array([[1, 2, 3],            [4, 5, 6]]) &#39;&#39;&#39; np.concatenate([A,z.reshape(1,-1)])     # concatenate只能合并相同维度的数组，z.reshape成2维后再合并                                         &#39;&#39;&#39;                                         array([[1, 2, 3],                                                [4, 5, 6],                                                [6, 6, 6]])                                         &#39;&#39;&#39;</code></pre></li></ol><p><strong>Sample2:<code>np.vstack</code>,<code>np.hstack</code></strong></p><ol><li><p><code>np.vstack</code></p><pre><code class="lang-python"> &#39;&#39;&#39; z : 1维向量     array([6,6,6]) A : 2维矩阵（2*3）     array([[1, 2, 3],            [4, 5, 6]]) B: 2维矩阵（2*2）     array([[1,2],            [3,4]])   &#39;&#39;&#39; # 1. 同维数组堆叠 np.vstack([A,A])    # 垂直方向堆叠 A: 2*3矩阵 &amp; A: 2*3矩阵 =&gt; 4*3矩阵                     &#39;&#39;&#39;                     array([[1, 2, 3],                            [4, 5, 6],                            [1, 2, 3],                            [4, 5, 6]])                     &#39;&#39;&#39; # 2. 不同维数组堆叠 np.vstack([A,z])    # 垂直方向堆叠 A: 2*3矩阵 &amp; z: 1*3向量 =&gt; 3*3矩阵                     &#39;&#39;&#39;                     array([[1, 2, 3],                            [4, 5, 6],                            [6, 6, 6]])                     &#39;&#39;&#39;</code></pre></li><li><p><code>np.hstack</code></p><pre><code class="lang-python"> &#39;&#39;&#39; A : 2维矩阵（2*3）     array([[1, 2, 3],            [4, 5, 6]]) B: 2维矩阵（2*2）     array([[1,2],            [3,4]])     &#39;&#39;&#39;              np.hstack([A,B])    # 水平方向堆叠 =&gt; A: 2*3矩阵 &amp; B: 2*2矩阵 =&gt; 2*5矩阵                     &#39;&#39;&#39;                     array([[1, 2, 3, 1, 2],                            [4, 5, 6, 3, 4]])                     &#39;&#39;&#39;</code></pre></li></ol><h3 id="header-11">分割</h3><ul><li><code>np.split(ary, indices_or_sections, axis=0)</code></li><li>more:<ul><li><code>np.array_split</code> : Split an array into multiple sub-arrays of equal or near-equal size. Does not raise an exception if an equal division cannot be made.</li><li><code>np.hsplit</code> : Split array into multiple sub-arrays horizontally (column-wise).</li><li><code>np.vsplit</code> : Split array into multiple sub-arrays vertically (row wise).</li><li><code>np.dsplit</code> : Split array into multiple sub-arrays along the 3rd axis (depth).</li></ul></li></ul><p><strong>Sample1:<code>np.split</code></strong></p><ol><li><p>一维数组（向量）分割</p><pre><code class="lang-python"> &#39;&#39;&#39; x array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) &#39;&#39;&#39; np.split(x,[3,7]) # 2个分割点：3,7 =&gt; 将数组分割成三段 =&gt; 生成3个数组                   &#39;&#39;&#39;                   [array([0, 1, 2]), array([3, 4, 5, 6]), array([7, 8, 9])]                   &#39;&#39;&#39; np.split(x,[5])   # 1个分割点：5 =&gt; 将数组分割成两段 =&gt; 生成2个数组                   &#39;&#39;&#39;                   [array([0, 1, 2, 3, 4]), array([5, 6, 7, 8, 9])]                   &#39;&#39;&#39;</code></pre></li><li><p>二维数组（矩阵）分割：</p><pre><code class="lang-python"> &#39;&#39;&#39; A array([[ 0,  1,  2,  3],        [ 4,  5,  6,  7],        [ 8,  9, 10, 11],        [12, 13, 14, 15]]) &#39;&#39;&#39; np.split(A,[2])         # 基于维度0，即行，分割 =&gt; 2个2*4数组                         &#39;&#39;&#39;                         [                          array([[0, 1, 2, 3],                                 [4, 5, 6, 7]]),                           array([[ 8,  9, 10, 11],                                 [12, 13, 14, 15]])                         ]                         &#39;&#39;&#39; np.split(A,[2],axis=1)  # 基于维度1，即列，分割 =&gt; 2个4*2数组                         &#39;&#39;&#39;                         [                          array([[ 0,  1],                                 [ 4,  5],                                 [ 8,  9],                                 [12, 13]]),                           array([[ 2,  3],                                 [ 6,  7],                                 [10, 11],                                 [14, 15]])                         ]                         &#39;&#39;&#39;</code></pre></li></ol><p><strong>Sample2:<code>np.vsplit</code>,<code>np.hsplit</code></strong></p><ol><li><p><code>np.vsplit</code></p><pre><code class="lang-python"> &#39;&#39;&#39; A array([[ 0,  1,  2,  3],        [ 4,  5,  6,  7],        [ 8,  9, 10, 11],        [12, 13, 14, 15]]) &#39;&#39;&#39; np.vsplit(A,[2])    # 垂直方向分割，分为上下两部分  =&gt; 2个2*4数组                     &#39;&#39;&#39;                     [                         array([[0, 1, 2, 3],                                [4, 5, 6, 7]]),                         array([[ 8,  9, 10, 11],                                [12, 13, 14, 15]])                     ]</code></pre></li><li><p><code>np.hsplit</code></p><pre><code class="lang-python"> &#39;&#39;&#39; x array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) A array([[ 0,  1,  2,  3],        [ 4,  5,  6,  7],        [ 8,  9, 10, 11],        [12, 13, 14, 15]]) &#39;&#39;&#39; np.hsplit(x,[3,7]) # 水平方向分割,分为三部分部分 =&gt; 3个1维数组                     &#39;&#39;&#39;                     [                         array([0, 1, 2]),                          array([3, 4, 5, 6]),                          array([7, 8, 9])                     ]                     &#39;&#39;&#39; np.hsplit(A,[2])    # 水平方向分割，分为左右两部分 =&gt; 2个4*2数组                     &#39;&#39;&#39;                     [                         array([[ 0,  1],                                 [ 4,  5],                                 [ 8,  9],                                 [12, 13]]),                          array([[ 2,  3],                                 [ 6,  7],                                 [10, 11],                                 [14, 15]])                     ]                     &#39;&#39;&#39;</code></pre></li></ol><p><strong>Sample3:应用</strong></p><pre><code class="lang-python">&#39;&#39;&#39;data : 4*4矩阵        array([[ 0,  1,  2,  3],               [ 4,  5,  6,  7],               [ 8,  9, 10, 11],               [12, 13, 14, 15]])&#39;&#39;&#39;X,Y=np.hsplit(data,[-1])    # 分割出最后一列                              &#39;&#39;&#39;                               X: 4*3矩阵                                 array([[ 0,  1,  2],                                       [ 4,  5,  6],                                       [ 8,  9, 10],                                       [12, 13, 14]])                               Y: 4*1矩阵                                 array([[ 3],                                       [ 7],                                       [11],                                       [15]])                              &#39;&#39;&#39;y=Y[:,0]                    # 取列(Y的子集，是Y的引用) =&gt; 1*4向量                                &#39;&#39;&#39;                                 array([ 3,  7, 11, 15])                                &#39;&#39;&#39;</code></pre><h2 id="header-12">运算</h2><p>作用于数组的每一个元素</p><ul><li><p>基本操作符: </p><ul><li><code>+</code>,<code>-</code>,<code>*</code>,<code>/</code>,<code>//</code>,<code>%</code>,<code>**</code></li><li><code>&gt;</code>,<code>&lt;</code>,<code>&gt;=</code>,<code>&lt;=</code>,<code>==</code>,<code>!=</code></li></ul></li><li><p>一元函数: 数组中各元素进行对应运算</p><table class="table"><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>np.abs(x)</code> <code>np.fabs(x)</code></td><td style="text-align:left">计算数组各元素的绝对值</td></tr><tr><td style="text-align:left"><code>np.sqrt(x)</code></td><td style="text-align:left">计算数组各元素的平方根</td></tr><tr><td style="text-align:left"><code>np.square(x)</code></td><td style="text-align:left">计算数组各元素的平方</td></tr><tr><td style="text-align:left"><code>np.log(x)</code> <code>np.log10(x)</code> <code>np.log2(x)</code></td><td style="text-align:left">计算数组各元素的自然对数、10底对数和2底对数</td></tr><tr><td style="text-align:left"><code>np.ceil(x)</code> <code>np.floor(x)</code></td><td style="text-align:left">计算数组各元素的ceiling值、floor值</td></tr><tr><td style="text-align:left"><code>np.rint(x)</code></td><td style="text-align:left">计算数组各元素的四舍五入值</td></tr><tr><td style="text-align:left"><code>np.modf(x)</code></td><td style="text-align:left">将数组各元素的小数和整数部分以两个独立数组形式返回</td></tr><tr><td style="text-align:left"><code>np.cos(x)</code> <code>np.cosh(x)</code> <code>np.sin(x)</code> <code>np.sinh(x)</code> <code>np.tan(x)</code> <code>np.tanh(x)</code></td><td style="text-align:left">计算数组各元素的普通型和双曲型三角函数</td></tr><tr><td style="text-align:left"><code>np.exp(x)</code></td><td style="text-align:left">计算数组各元素的指数值</td></tr><tr><td style="text-align:left"><code>np.sign(x)</code></td><td style="text-align:left">计算数组各元素的符号值,<code>1(+)</code>, <code>0</code>, <code>‐1(‐)</code></td></tr></tbody></table></li><li><p>二元函数: 两个数组各元素进行对应运算</p><table class="table"><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>np.maximum(x,y)</code> <code>np.fmax()</code> <code>np.minimum(x,y)</code> <code>np.fmin()</code></td><td style="text-align:left">元素级的最大值/最小值计算</td></tr><tr><td style="text-align:left"><code>np.mod(x,y)</code></td><td style="text-align:left">元素级的模运算</td></tr><tr><td style="text-align:left"><code>np.copysign(x,y)</code></td><td style="text-align:left">将数组y中各元素值的符号赋值给数组x对应元素</td></tr></tbody></table></li></ul><h3 id="header-13">基本运算</h3><ul><li><code>+</code>,<code>-</code>,<code>*</code>,<code>/</code>,<code>//</code>,<code>%</code>,<code>**</code></li><li><code>&gt;</code>,<code>&lt;</code>,<code>&gt;=</code>,<code>&lt;=</code>,<code>==</code>,<code>!=</code> (得到bool数组)</li></ul><p>作用于数组的每一个元素（与python的list不同）</p><ol><li><p>与标量</p><pre><code class="lang-python"> &#39;&#39;&#39; X: 3*5 矩阵     array([[ 1,  2,  3,  4,  5],            [ 6,  7,  8,  9, 10],            [11, 12, 13, 14, 15]]) &#39;&#39;&#39; X+2         &#39;&#39;&#39;             array([[ 3,  4,  5,  6,  7],                [ 8,  9, 10, 11, 12],                [13, 14, 15, 16, 17]])             &#39;&#39;&#39; X-2         &#39;&#39;&#39;             array([[-1,  0,  1,  2,  3],                    [ 4,  5,  6,  7,  8],                    [ 9, 10, 11, 12, 13]])             &#39;&#39;&#39; X*2         &#39;&#39;&#39;             array([[ 2,  4,  6,  8, 10],                    [12, 14, 16, 18, 20],                    [22, 24, 26, 28, 30]])             &#39;&#39;&#39;             X/2         &#39;&#39;&#39;             array([[0, 1, 1, 2, 2],                    [3, 3, 4, 4, 5],                    [5, 6, 6, 7, 7]])             &#39;&#39;&#39; X//2        &#39;&#39;&#39;             array([[0, 1, 1, 2, 2],                    [3, 3, 4, 4, 5],                    [5, 6, 6, 7, 7]])             &#39;&#39;&#39; X%2         &#39;&#39;&#39;             array([[1, 0, 1, 0, 1],                    [0, 1, 0, 1, 0],                    [1, 0, 1, 0, 1]])             &#39;&#39;&#39; 1/X         &#39;&#39;&#39;             array([[1.        , 0.5       , 0.33333333, 0.25      , 0.2       ],                    [0.16666667, 0.14285714, 0.125     , 0.11111111, 0.1       ],                    [0.09090909, 0.08333333, 0.07692308, 0.07142857, 0.06666667]])             &#39;&#39;&#39; X&gt;5         &#39;&#39;&#39;             array([[False, False, False, False, False],                    [False,  True,  True,  True,  True],                    [ True,  True,  True,  True,  True]])             &#39;&#39;&#39;</code></pre></li><li><p>数组与数组</p><pre><code class="lang-python"> &#39;&#39;&#39; A: 2*2 矩阵     array([[0, 1],            [2, 3]]) B: 2*2 矩阵     array([[10, 10],            [10, 10]]) &#39;&#39;&#39; A+B     &#39;&#39;&#39;         array([[10, 11],                [12, 13]])         &#39;&#39;&#39; A-B     &#39;&#39;&#39;         array([[-10,  -9],                [ -8,  -7]])         &#39;&#39;&#39; A*B     &#39;&#39;&#39;         array([[ 0, 10],                [20, 30]])         &#39;&#39;&#39; A/B     &#39;&#39;&#39;         array([[0. , 0.1],                [0.2, 0.3]])         &#39;&#39;&#39; A&gt;B    &#39;&#39;&#39;        array([[False, False],               [False, False]])        &#39;&#39;&#39;</code></pre></li><li><p>矩阵和向量: 向量和矩阵每一行做运算</p><pre><code class="lang-python"> &#39;&#39;&#39; v: 一维向量     array([1, 2]) A: 2*2 矩阵     array([[0, 1],            [2, 3]]) &#39;&#39;&#39; v+A     &#39;&#39;&#39;         array([[1, 3],                [3, 5]])         &#39;&#39;&#39; v-A     &#39;&#39;&#39;         array([[ 1,  1],                [-1, -1]])         &#39;&#39;&#39; v*A     &#39;&#39;&#39;         array([[0, 2],                [2, 6]])         &#39;&#39;&#39; A/v     &#39;&#39;&#39;         array([[0. , 0.5],                [2. , 1.5]])         &#39;&#39;&#39; v&gt;A     &#39;&#39;&#39;         array([[ True,  True],                [False, False]])         &#39;&#39;&#39; np.vstack([v]*A.shape[0])+A     # = `v+A`                                 &#39;&#39;&#39;                                 A.shape                   : (2,2)                                 [v]*A.shape[0]            : [array([1, 2]), array([1, 2])]                                 np.vstack([v]*A.shape[0]) : 垂直方向上堆叠2个v，生成2*2的矩阵                                                             array([[1, 2],                                                                    [1, 2]])                                 =&gt;                                     array([[1, 3],                                            [3, 5]])                                 &#39;&#39;&#39; np.tile(v,(2,1))+A              # = `v+A`                                 &#39;&#39;&#39;                                 `np.tile(A,repeats)`                                 np.tile(v,(2,1)) : 将v，行方向上重复2次，列方向上重复1次，形成2*2矩阵                                                     array([[1, 2],                                                            [1, 2]])                                 =&gt;                                      array([[1, 3],                                         [3, 5]])                                 &#39;&#39;&#39;</code></pre></li></ol><h3 id="header-14">常用运算函数</h3><ol><li><p>一元函数</p><pre><code class="lang-python"> &#39;&#39;&#39; X: 3*5 矩阵     array([[ 1,  2,  3,  4,  5],            [ 6,  7,  8,  9, 10],            [11, 12, 13, 14, 15]]) &#39;&#39;&#39; np.sin(X)       &#39;&#39;&#39;                 array([[ 0.84147098,  0.90929743,  0.14112001, -0.7568025 , -0.95892427],                        [-0.2794155 ,  0.6569866 ,  0.98935825,  0.41211849, -0.54402111],                        [-0.99999021, -0.53657292,  0.42016704,  0.99060736,  0.65028784]])                 &#39;&#39;&#39; np.power(3,X)   # 3^x , 同 3**X                 &#39;&#39;&#39;                 array([[       3,        9,       27,       81,      243],                        [     729,     2187,     6561,    19683,    59049],                        [  177147,   531441,  1594323,  4782969, 14348907]])                 &#39;&#39;&#39; np.exp(X)       # e^x                 &#39;&#39;&#39;                 array([[2.71828183e+00, 7.38905610e+00, 2.00855369e+01, 5.45981500e+01, 1.48413159e+02],                        [4.03428793e+02, 1.09663316e+03, 2.98095799e+03, 8.10308393e+03, 2.20264658e+04],                        [5.98741417e+04, 1.62754791e+05, 4.42413392e+05, 1.20260428e+06, 3.26901737e+06]])                 &#39;&#39;&#39; np.log(X)       # ln(X)                 &#39;&#39;&#39;                 array([[0.        , 0.69314718, 1.09861229, 1.38629436, 1.60943791],                        [1.79175947, 1.94591015, 2.07944154, 2.19722458, 2.30258509],                        [2.39789527, 2.48490665, 2.56494936, 2.63905733, 2.7080502 ]])                 &#39;&#39;&#39; np.log2(X)      # log2(X)                 &#39;&#39;&#39;                 array([[0.        , 1.        , 1.5849625 , 2.        , 2.32192809],                        [2.5849625 , 2.80735492, 3.        , 3.169925  , 3.32192809],                        [3.45943162, 3.5849625 , 3.70043972, 3.80735492, 3.9068906 ]])                 &#39;&#39;&#39; np.log10(X)     # log10(X)                 &#39;&#39;&#39;                 array([[0.        , 0.30103   , 0.47712125, 0.60205999, 0.69897   ],                        [0.77815125, 0.84509804, 0.90308999, 0.95424251, 1.        ],                        [1.04139269, 1.07918125, 1.11394335, 1.14612804, 1.17609126]])                   &#39;&#39;&#39; np.sign(X)      &#39;&#39;&#39;                 array([[0, 1, 1, 1, 1],                        [1, 1, 1, 1, 1],                        [1, 1, 1, 1, 1]])                 &#39;&#39;&#39;</code></pre></li><li><p>二元函数</p><pre><code class="lang-python"> &#39;&#39;&#39; A: 2*2 矩阵     array([[0, 1],            [2, 3]]) B: 2*2 矩阵     array([[10.0, 10.0],            [10.0, 10.0]]) v: 一维向量     array([1, 2]) &#39;&#39;&#39; np.minimum(A,B)     &#39;&#39;&#39;                     B是浮点数，所以运算结果为浮点数                     array([[0., 1.],                            [2., 3.]])                     &#39;&#39;&#39; np.maximum(A,v)     &#39;&#39;&#39;                     array([[1, 2],                            [2, 3]])                     &#39;&#39;&#39; np.mod(A,B)         &#39;&#39;&#39;                     = A%B                     array([[0., 1.],                            [2., 3.]])                     &#39;&#39;&#39; np.mode(A,v)        &#39;&#39;&#39;                     = A%v                     array([[0, 1],                            [0, 1]])                     &#39;&#39;&#39;</code></pre></li></ol><h3 id="header-15">线性运算</h3><ol><li><p>向量</p><pre><code class="lang-python"> &#39;&#39;&#39; v: array([1, 2]) w: array([2, 3]) &#39;&#39;&#39; v.T         # 1. 转置：还是1维行向量，无变化 =&gt; array([1,2]) v.dot(w)    # 2. 点积（v·w）： 结果是一个标量(对应元素相乘后相加) 1*2+2*3 =&gt; 8</code></pre></li><li><p>矩阵</p><pre><code class="lang-python"> &#39;&#39;&#39; A: 2*2 矩阵     array([[0, 1],            [2, 3]]) B: 2*3 矩阵     array([[0, 1, 2],            [3, 4, 5]]) &#39;&#39;&#39; A.T                         # 1. 转置: 行列交换                             &#39;&#39;&#39;                             array([[0, 2],                                    [1, 3]])                             &#39;&#39;&#39; invA = np.linalg.inv(A)     # 2. 逆                             &#39;&#39;&#39;                             array([[-1.5,  0.5],                                    [ 1. ,  0. ]])                             &#39;&#39;&#39; pinvB = np.linalg.pinv(B)   # 3. 伪逆： 方阵才有逆，非方阵可使用伪逆（近似逆）                             &#39;&#39;&#39;                             array([[-0.77777778,  0.27777778],                                    [-0.11111111,  0.11111111],                                    [ 0.55555556, -0.05555556]])                             &#39;&#39;&#39; A.dot(B)                    # 4. 矩阵乘法（A·B）：2*2 · 2*3 =&gt; 2*3                             &#39;&#39;&#39;                             array([[ 3,  4,  5],                                    [ 9, 14, 19]])                             &#39;&#39;&#39; A.dot(invA)                 # 5. A · invA  =&gt; 单位矩阵                             &#39;&#39;&#39;                             array([[1., 0.],                                    [0., 1.]])                             &#39;&#39;&#39; B.dot(pinvB)                # 6. B · pinvB =&gt; 近似单位矩阵：主对角线为1，次对角线几乎为0（浮点误差造成）                             &#39;&#39;&#39;                             array([[ 1.00000000e+00, -1.11022302e-16],                                    [ 2.66453526e-15,  1.00000000e+00]])                             &#39;&#39;&#39;</code></pre></li><li><p>向量 &amp; 矩阵</p><pre><code class="lang-python"> &#39;&#39;&#39; v: array([1, 2]) A: 2*2 矩阵     array([[0, 1],            [2, 3]]) &#39;&#39;&#39; v.dot(A)                &#39;&#39;&#39;                         v:1*2 · A:2*2 : 1*2                          =&gt; auto transfer to vector, 1 dim                         =&gt; array([4, 7])                         &#39;&#39;&#39; A.dot(v)                &#39;&#39;&#39;                         A:2*2 · v:1*2 (auto treat as 2*1) : 2*1                          =&gt; auto transfer to vector, 1 dim                         =&gt; array([2, 8])</code></pre></li></ol><h2 id="header-16">高级</h2><h3 id="header-17">聚合(统计函数)</h3><table class="table"><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>sum(a, axis=None)</code></td><td style="text-align:left">元素之和</td></tr><tr><td style="text-align:left"><code>min(a, axis=None)</code> <code>max(a, axis=None)</code></td><td style="text-align:left">最小值、最大值</td></tr><tr><td style="text-align:left"><code>average(a, axis=None,weights=None)</code></td><td style="text-align:left">加权平均值（expection）</td></tr><tr><td style="text-align:left"><code>ptp(a, axis=None)</code></td><td style="text-align:left">元素最大值与最小值的差</td></tr><tr><td style="text-align:left"><code>median(a, axis=None)</code></td><td style="text-align:left">中位数(中值)</td></tr><tr><td style="text-align:left"><code>mean(a, axis=None)</code></td><td style="text-align:left">均值</td></tr><tr><td style="text-align:left"><code>std(a, axis=None)</code></td><td style="text-align:left">标准差</td></tr><tr><td style="text-align:left"><code>var(a, axis=None)</code></td><td style="text-align:left">方差</td></tr><tr><td style="text-align:left"><code>percentile(a,q, axis=None)</code></td><td style="text-align:left">百分位</td></tr><tr><td style="text-align:left"><code>prod(a, axis=None)</code></td><td style="text-align:left">元素乘积</td></tr></tbody></table><p>Note: <code>axis=None</code> 是统计函数的标配参数</p><p><strong>Sample</strong></p><pre><code class="lang-python">&#39;&#39;&#39;X=np.arange(16).reshape(4,-1)=&gt;    array([[ 0,  1,  2,  3],           [ 4,  5,  6,  7],           [ 8,  9, 10, 11],           [12, 13, 14, 15]])&#39;&#39;&#39;np.sum(X)                                   # 120np.sum(X,axis=0)                            # 维度0上聚合（压缩维度0，即行）=&gt; 每列的和 =&gt; array([24, 28, 32, 36])np.sum(X,axis=1)                            # 维度1上聚合（压缩维度1，即列）=&gt; 每行的和 =&gt; array([ 6, 22, 38, 54])np.max(X)                                   # 15np.max(X,aixs=0)                            # 维度0上聚合 =&gt; 每列最大值 =&gt; array([12, 13, 14, 15])np.max(X,axis=1)                            # 维度1上聚合 =&gt; 每行最大值 =&gt; array([12, 13, 14, 15])np.mean(X)                                  # 7.5np.mean(X,axis=0)                           # 维度0上聚合 =&gt; 每列均值 =&gt; array([6., 7., 8., 9.])np.mean(X,axis=1)                           # 维度1上聚合 =&gt; 每行均值 =&gt; array([ 1.5,  5.5,  9.5, 13.5])np.average(X)                               # 7.5np.average(X,axis=0)                        # 维度0上聚合 =&gt; 每列平均值 =&gt; array([6., 7., 8., 9.])np.average(X,axis=0,,weights=[10,5,1,4])    # 维度0上聚合 =&gt; 每列加权平均值 =&gt; array([3.8, 4.8, 5.8, 6.8])np.percentile(X,q=25)                       # 百分位, 25%的元素都是小于等于的值 =&gt; 3.75np.percentile(X,q=50)                       # = np.median(X) =&gt; 7.5np.percentile(X,q=0)                        # = np.min(X)    =&gt; 0.0np.percentile(X,q=100)                      # = np.max(X)    =&gt; 15.0np.percentile(X,q=[0,25,50,100])            # array([ 0.  ,  3.75,  7.5 , 15.  ])np.percentile(X,q=50,axis=0)                # 维度0上聚合 =&gt; array([6., 7., 8., 9.])np.percentile(X,q=50,axis=1)                # 维度0上聚合 =&gt; array([ 1.5,  5.5,  9.5, 13.5])np.prod(X)                                  # 0np.prod(X,axis=0)                           # 维度0上聚合 =&gt; array([   0,  585, 1680, 3465])np.prod(X,axis=1)                           # 维度1上聚合 =&gt; array([    0,   840,  7920, 32760])x=np.random.normal(0,1,size=1000000)        #［0,1) 正态分布随机浮点一维数组np.mean(x)                                  # -0.00019733605984642867 &lt;= 均值，非常趋近0np.std(x)                                   # 1.0001027608240785      &lt;= 标准差，非常趋近1np.var(x)                                   # 1.000205532207944       &lt;= 方差，非常趋近1</code></pre><h3 id="header-18">索引函数</h3><table class="table"><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>argmin(a, axis=None)</code> <code>argmax(a, axis=None)</code></td><td style="text-align:left">计算数组a中元素最小值、最大值所在的索引</td></tr><tr><td style="text-align:left"><code>unravel_index(index, shape)</code></td><td style="text-align:left">将一维索引重塑成多维索引</td></tr><tr><td style="text-align:left"><code>argsort(a, axis=-1, kind=&#39;quicksort&#39;, order=None)</code></td><td style="text-align:left">元素排好序，对应的索引组成的数组</td></tr><tr><td style="text-align:left"><code>argpartition(a, kth, axis=-1, kind=&#39;introselect&#39;, order=None)</code></td><td style="text-align:left">元素分区后，对应的索引组成的数组</td></tr></tbody></table><pre><code class="lang-python">&#39;&#39;&#39;Xarray([[ 0,  1,  2,  3],       [ 4,  5,  6,  7],       [ 8,  9, 10, 11],       [12, 13, 14, 15]])&#39;&#39;&#39;np.argmin(X)                        # 扁平化后的，最小值的下标 =&gt; 0np.argmax(X)                        # 扁平化后的，最大值的下标 =&gt; 15np.argmin(X,axis=0)                 # 维度0上聚合 =&gt; 每列最小值所在的下标 =&gt; array([0, 0, 0, 0])np.unravel_index(12,shape=(4,4))    # (3, 0) &lt;= 将12重塑成多维下标</code></pre><pre><code class="lang-python">np.random.shuffle(X)                # 对X进行乱序处理X                                   &#39;&#39;&#39;                                    array([[ 0,  1,  2,  3],                                           [ 8,  9, 10, 11],                                           [12, 13, 14, 15],                                           [ 4,  5,  6,  7]])                                    &#39;&#39;&#39;np.argsort(x,axis=0)                &#39;&#39;&#39;                                    array([[0, 0, 0, 0],                                           [3, 3, 3, 3],                                           [1, 1, 1, 1],                                           [2, 2, 2, 2]])                                    &#39;&#39;&#39;np.sort(x,axis=0)                   &#39;&#39;&#39;                                    array([[ 0,  1,  2,  3],                                           [ 4,  5,  6,  7],                                           [ 8,  9, 10, 11],                                           [12, 13, 14, 15]])                                    &#39;&#39;&#39;</code></pre><pre><code class="lang-python">x=np.arange(10)                     # array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9])np.random.shuffle(x)                # 对x进行乱序处理x                                   # array([3, 5, 2, 7, 6, 0, 8, 1, 9, 4])np.argpartition(x,5)                # &lt;5,=5,&gt;5 =&gt; array([5, 0, 2, 7, 9, 1, 4, 6, 8, 3])np.partition(x,3)                   # &lt;5,=5,&gt;5 =&gt; array([0, 3, 2, 1, 4, 5, 6, 8, 9, 7])np.argpartition(x,[3,7])            # array([5, 7, 2, 0, 9, 1, 4, 3, 8, 6])np.partition(x,[3,7])               # array([0, 1, 2, 3, 4, 5, 6, 7, 9, 8])</code></pre><h3 id="header-19">Fancy Indexing</h3><p>应用：统计判断，方便抽出符合条件的元素 (且返回的数组维度可控）</p><ol><li><p>使用索引数组</p><pre><code class="lang-python"> &#39;&#39;&#39; x = np.arange(16)                      array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15]) &#39;&#39;&#39; x_inds=[1,3,7,12]               x[x_inds]                       # array([ 1,  3,  7, 12]) x_inds=np.array([[0,2],[1,3]]) x[x_inds]                       &#39;&#39;&#39;                                 array([[0, 2],                                        [1, 3]])                                 &#39;&#39;&#39; &#39;&#39;&#39; X=x.reshape(4,-1)     array([[ 0,  1,  2,  3],            [ 4,  5,  6,  7],            [ 8,  9, 10, 11],            [12, 13, 14, 15]]) &#39;&#39;&#39; row_inds = np.array([0,1,2]) col_inds = np.array([1,2,3]) X[row_inds,0]                   # array([0, 4, 8]) X[0,col_inds]                   # array([1, 2, 3]) X[row_inds,col_inds]            # array([ 1,  6, 11]) &lt;= nodes [0,1],[1,2],[2,3]</code></pre></li><li><p>使用bool值数组（array中的元素进行批量比较，得到bool值数组）<br> ```python<br> ‘’’<br> x = np.arange(5)                 </p><pre><code> array([ 0,  1,  2,  3,  4 ])</code></pre><p> ‘’’<br> x&lt;3                         # array([ True,  True,  True, False, False])<br> x[x&lt;3]                      # array([0, 1, 2])</p><p> 2<em>x == 24-4</em>x               # array([False, False, False, False,  True])<br> x[2<em>x == 24-4</em>x]            # array([4])</p><p> x%2==0                      # array([ True, False,  True, False,  True])<br> x[x%2==0]                   # array([0, 2, 4])</p><p> np.sum(x&lt;3)                 # 3<br> np.count_nonzero(x&lt;3)       # 3</p><p> np.sum((x&gt;2)&amp;(x<4)) 1="" #="" <="多个条件，使用位运算符" np.sum((x%2="=0)|(x">3))      # 3<br> np.sum(~(x==0))             # 4</4))></p><p> np.any(x==0)                # True<br> np.any(x<0) #="" false="" np.all(x="">=0)                # True</0)></p></li></ol><pre><code>&#39;&#39;&#39;X=x.reshape(4,-1)    array([[ 0,  1,  2,  3],           [ 4,  5,  6,  7],           [ 8,  9, 10, 11],           [12, 13, 14, 15]])&#39;&#39;&#39;X&lt;6                         &#39;&#39;&#39;                            array([[ True,  True,  True,  True],                                   [ True,  True, False, False],                                   [False, False, False, False],                                   [False, False, False, False]])                            &#39;&#39;&#39;X[X&lt;6]                      # array([0, 1, 2, 3, 4, 5])X[:,3]%3==0                 # array([ True, False, False,  True]) &lt;= 每行最后一个元素能否被3整除X[X[:,3]%3==0,:]            # 选出最后一个元素可被3整除的行                            &#39;&#39;&#39;                            array([[ 0,  1,  2,  3],                                   [12, 13, 14, 15]])                            &#39;&#39;&#39;np.sum(X%2==0)              # 8                     &lt;= 统计偶数个数np.sum(X%2==0,axis=0)       # array([4, 0, 4, 0])   &lt;= 每列有多少偶数（行方向上压缩）np.sum(X%2==0,axis=1)       # array([2, 2, 2, 2])   &lt;= 每行有多少偶数（列方向上压缩））np.all(X&gt;3,axis=0)          # array([False, False, False, False]) &lt;= 每列（行方向上判断）np.all(X&gt;3,axis=1)          # array([False,  True,  True,  True]) &lt;= 每行（列方向上判断）```</code></pre><h2 id="header-20">文件存取</h2><h3 id="header-21">CSV文件存取</h3><ul><li><p><code>np.savetxt(fname,X,fmt=&#39;%.18e&#39;,delimiter=&#39; &#39;,newline=&#39;\n&#39;,header=&#39;&#39;,footer=&#39;&#39;,comments=&#39;# &#39;,encoding=None,)</code></p><ul><li><code>frame</code> : 文件、字符串或产生器,可以是<code>.gz</code>或<code>.bz2</code>的压缩文件 </li><li><code>array</code> : 存入文件的数组</li><li><code>fmt</code> : 写入文件的格式,例如:<code>%d</code> <code>%.2f</code> <code>%.18e</code></li><li><code>delimiter</code> : 分割字符串,默认是任何空格</li></ul></li><li><p><code>np.loadtxt(fname,dtype=&lt;class &#39;float&#39;&gt;,comments=&#39;#&#39;,delimiter=None,converters=None,skiprows=0,usecols=None,unpack=False,ndmin=0,encoding=&#39;bytes&#39;,max_rows=None,)</code></p><ul><li><code>frame</code> : 文件、字符串或产生器,可以是<code>.gz</code>或<code>.bz2</code>的压缩文件     </li><li><code>dtype</code> : 数据类型,可选</li><li><code>delimiter</code> : 分割字符串,默认是任何空格</li><li><code>unpack</code> : 如果<code>True</code>,读入属性将分别写入不同变量</li></ul></li><li><p>局限：只能有效存储一维和二维数组 </p></li></ul><pre><code class="lang-python">X=np.arange(100).reshape(5,20)np.savetxt(&quot;a.csv&quot;,X,fmt=&#39;%d&#39;,delimiter=&quot;,&quot;)&#39;&#39;&#39;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,1920,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,3940,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,5960,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,7980,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99&#39;&#39;&#39;Y=np.loadtxt(&quot;a.csv&quot;,delimiter=&quot;,&quot;)&#39;&#39;&#39;array([[ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11., 12.,        13., 14., 15., 16., 17., 18., 19.],       [20., 21., 22., 23., 24., 25., 26., 27., 28., 29., 30., 31., 32.,        33., 34., 35., 36., 37., 38., 39.],       [40., 41., 42., 43., 44., 45., 46., 47., 48., 49., 50., 51., 52.,        53., 54., 55., 56., 57., 58., 59.],       [60., 61., 62., 63., 64., 65., 66., 67., 68., 69., 70., 71., 72.,        73., 74., 75., 76., 77., 78., 79.],       [80., 81., 82., 83., 84., 85., 86., 87., 88., 89., 90., 91., 92.,        93., 94., 95., 96., 97., 98., 99.]])&#39;&#39;&#39;</code></pre><h3 id="header-22">多维数据的存取</h3><ul><li><p><code>a.tofile(frame, sep=&#39;&#39;, format=&#39;%s&#39;)</code></p><ul><li><code>frame</code> : 文件、字符串</li><li><code>sep</code> : 数据分割字符串,如果是空串,写入文件为二进制 </li><li><code>format</code> : 写入数据的格式</li></ul></li><li><p><code>np.fromfile(frame, dtype=float, count=‐1, sep=&#39;&#39;)</code></p><ul><li><code>frame</code> : 文件、字符串</li><li><code>dtype</code> : 读取的数据类型</li><li><code>count</code> : 读入元素个数,<code>‐1</code>表示读入整个文件</li><li><code>sep</code> : 数据分割字符串,如果是空串,写入文件为二进制</li></ul></li><li>注：tofile将array按一维存储，所以读取到后需reshape恢复（可以通过元数据文件来存储数组相关的额外信息）</li></ul><pre><code class="lang-python">X=np.arange(100).reshape(2,10,5)    # 2*10*5&#39;&#39;&#39;array([[[ 0,  1,  2,  3,  4],        [ 5,  6,  7,  8,  9],        [10, 11, 12, 13, 14],        [15, 16, 17, 18, 19],        [20, 21, 22, 23, 24],        [25, 26, 27, 28, 29],        [30, 31, 32, 33, 34],        [35, 36, 37, 38, 39],        [40, 41, 42, 43, 44],        [45, 46, 47, 48, 49]],       [[50, 51, 52, 53, 54],        [55, 56, 57, 58, 59],        [60, 61, 62, 63, 64],        [65, 66, 67, 68, 69],        [70, 71, 72, 73, 74],        [75, 76, 77, 78, 79],        [80, 81, 82, 83, 84],        [85, 86, 87, 88, 89],        [90, 91, 92, 93, 94],        [95, 96, 97, 98, 99]]])&#39;&#39;&#39;X.tofile(&quot;b.txt&quot;,sep=&quot;,&quot;,format=&quot;%d&quot;)   # =&gt; 扁平化存储（1维）&#39;&#39;&#39;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99&#39;&#39;&#39;Y=np.fromfile(&quot;b.txt&quot;,sep=&quot;,&quot;)&#39;&#39;&#39;array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11., 12.,       13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25.,       26., 27., 28., 29., 30., 31., 32., 33., 34., 35., 36., 37., 38.,       39., 40., 41., 42., 43., 44., 45., 46., 47., 48., 49., 50., 51.,       52., 53., 54., 55., 56., 57., 58., 59., 60., 61., 62., 63., 64.,       65., 66., 67., 68., 69., 70., 71., 72., 73., 74., 75., 76., 77.,       78., 79., 80., 81., 82., 83., 84., 85., 86., 87., 88., 89., 90.,       91., 92., 93., 94., 95., 96., 97., 98., 99.])&#39;&#39;&#39;Y.reshape(2,10,5)                   # reshape回原维度</code></pre><h3 id="header-23">便捷存取</h3><ul><li><code>np.save(fname, array, allow_pickle=True, fix_imports=True)</code> , <code>np.savez(fname, array)</code><ul><li><code>fname</code> : 文件名,以<code>.npy</code>为扩展名,压缩扩展名为<code>.npz</code></li><li><code>array</code> : 数组变量</li></ul></li><li><code>np.load(fname,mmap_mode=None,allow_pickle=True,fix_imports=True,encoding=&#39;ASCII&#39;)</code><ul><li><code>fname</code> : 文件名,以<code>.npy</code>为扩展名,压缩扩展名为<code>.npz</code></li></ul></li></ul><pre><code class="lang-python">X=np.arange(100).reshape(2,10,5)    # 2*10*5np.save(&quot;c.npy&quot;,X)                  # 二进制，包含数组元信息Y=np.load(&quot;c.npy&quot;)                  # 可直接恢复成原数组&#39;&#39;&#39;array([[[ 0,  1,  2,  3,  4],        [ 5,  6,  7,  8,  9],        [10, 11, 12, 13, 14],        [15, 16, 17, 18, 19],        [20, 21, 22, 23, 24],        [25, 26, 27, 28, 29],        [30, 31, 32, 33, 34],        [35, 36, 37, 38, 39],        [40, 41, 42, 43, 44],        [45, 46, 47, 48, 49]],       [[50, 51, 52, 53, 54],        [55, 56, 57, 58, 59],        [60, 61, 62, 63, 64],        [65, 66, 67, 68, 69],        [70, 71, 72, 73, 74],        [75, 76, 77, 78, 79],        [80, 81, 82, 83, 84],        [85, 86, 87, 88, 89],        [90, 91, 92, 93, 94],        [95, 96, 97, 98, 99]]])&#39;&#39;&#39;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;ndarray数组：属性，元素类型，创建&lt;/li&gt;
&lt;li&gt;基础操作：（维度，元素类型）变换，访问（索引，切片），合并，分割&lt;/li&gt;
&lt;li&gt;运算操作：基本运算（作用于数组的每一个元素），线性运算（向量／矩阵 ：逆，乘）&lt;/li&gt;
&lt;li&gt;高级：聚合函数，索引函数，Fancy Indexing(应用：统计判断，方便抽出符合条件的元素)&lt;/li&gt;
&lt;li&gt;文件存取&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://sixdegree.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>React Fiber</title>
    <link href="http://sixdegree.github.io/2019/08/15/React-Fiber.html"/>
    <id>http://sixdegree.github.io/2019/08/15/React-Fiber.html</id>
    <published>2019-08-14T16:00:00.000Z</published>
    <updated>2019-10-07T15:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>create-react-app</li><li>new features</li><li>CSS</li><li>Redux</li><li>Router</li><li>More: react-loadable,Next.js,Jest,re-organize by features</li></ol><a id="more"></a><h2 id="header-1">Starter</h2><p><strong>React：</strong></p><ul><li>声明式开发（操作Data，自动根据Data构建Dom，注：JQuery是命令式开发，直接操作Dom）</li><li>可以与其他框架并存</li><li>组件化 (Component)</li><li>单向数据流（子组件可使用父组件传递过来的值，但子组件不能直接改变这个值）</li><li>视图层框架（对于大型项目，组件间传值时，可借助其他数据层框架，如redux,flux）</li><li>函数式编程（更方便前端自动化测试）</li></ul><p><strong>React Fiber:</strong></p><ul><li>React Version &gt;16（eg:16.4）</li><li>底层核心算法改良，引入优先级，分片等概念</li></ul><p><strong>注：</strong></p><ul><li>React: UI</li><li>Redux: State</li><li>Router: route</li><li>babel: JavaScript compiler (ES6-&gt;ES5)</li><li>webpack: A module bundler</li><li>ESLint: 语法规则和代码风格的检查工具</li></ul><h3 id="header-2">开发环境搭建</h3><ol><li><p>方式一：直接引入<code>.js</code>文件</p></li><li><p>方式二：使用脚手架工具，eg: grunt,gulp,webpack =&gt; 官方提供：<code>create-react-app</code></p><pre><code class="lang-bash"> $ npm install -g create-react-app $ create-react-app todolist   # or use `npx create-react-app todolist` if npm 5.2.0+ $ cd todoList $ npm start                   # or use `yarn start`</code></pre></li><li><p>其它工具平台：</p><ul><li>Rekit (React专属IDE和工具集, 基于最佳实践生成代码和管理项目)<ul><li>以feature方式组织代码</li><li>拆分component,action,reducer</li><li>拆分route配置</li><li>通过代码自动生成保持代码一致性：文件夹结构，文件名，变量名，代码逻辑的一致性</li><li>集成单元测试，单元测试覆盖率</li><li>可视化关系，图表</li></ul></li><li>codesandbox (online)</li></ul></li></ol><h3 id="header-3">开发调试工具</h3><ul><li><p>ESLint </p><ul><li>代码格式检查，使用<code>.eslintrc</code>进行规则配置</li><li>例如配置使用<code>airbnb</code>的javascript代码风格</li></ul></li><li><p>Prettier</p><ul><li>代码格式化神器，使用<code>.prettierrc</code>进行规则配置</li><li>保证更容易写出风格一直的代码(保存时会自动格式化修正)</li></ul></li><li><p>Chrom 插件</p><ul><li>React DevTool: 可以React组件树的方式观察组件结构,props,state<ul><li>离线下载安装 Issue: <code>程序包无效:&quot;CRX_HEADER_INVALID&quot;</code> =&gt; 将下载的<code>react-developer-tools.ctx</code>重命名为<code>react-developer-tools.zip</code>压缩包再拖拽到<code>chrome://extensions/</code>即可</li></ul></li><li>Redux DevTool: 可监控查看Redux中store,action等，可自动生成测试</li></ul></li></ul><h3 id="header-4">打包和部署</h3><ul><li><code>npm run build</code> : 打包<code>create-react-app</code>创建的项目到项目的build文件夹下</li><li>webpack<ul><li>编译ES6语法特性，编译JSX</li><li>整合资源，如图片，Less/Sass</li><li>优化代码体积</li></ul></li><li>注意：<ul><li>设置nodejs环境为production</li><li>禁用开发时的专用代码，如logger</li><li>设置应用根路径</li></ul></li></ul><h3 id="header-5">JSX</h3><blockquote><p>JSX：在JS文件中直接写HTML或自定义的组件标签（不用字符串包裹）<br>是 <code>HTML</code> 和 <code>JavaScript</code> 的混合，当遇到 <code>&lt;</code> 时，当作 <code>HTML</code> 解析，遇到 <code>{</code> 时，当作 <code>JS</code> 解析<br><code>{}</code>内可使用表达式<br>本质: 不是模版引擎，而是语法糖</p></blockquote><pre><code class="lang-javascript">// JSX: 动态创建组件的语法糖const name = &quot;Hello&quot;const element = &lt;h1&gt;Hello,{name}&lt;/h1&gt;;// 等价于：const name = &quot;Hello&quot;const element = React.createElement(&#39;h1&#39;,null,&#39;Hello,&#39;,name); // (tag,attrs,child1,child2,...)</code></pre><p><strong>使用:</strong></p><ol><li><p>import</p><pre><code class="lang-javascript"> // 使用JSX语法，必需引入： import React from &#39;react&#39;;</code></pre></li><li><p>添加注释：</p><pre><code class="lang-javascript"> &lt;div&gt;     { /* 块注释 */ }     {       // 行注释     } &lt;/div&gt;</code></pre></li><li><p>表达式：</p><pre><code class="lang-javascript"> // JSX本身也是表达式 const element = &lt;h1&gt;Hello,World!&lt;/h1&gt;; // 属性中使用表达式 &lt;MyComponent foo = {1+2+3+4} /&gt; // 延展属性 const props = {firstName: &#39;Ben&#39;,lastName: &#39;Hector&#39;}; const greeting = &lt;Greeting {...props} /&gt;; // 表达式作子元素 const element = &lt;li&gt;{props.msg}&lt;/li&gt;;</code></pre></li><li><p>标签上添加css class，不能使用<code>class</code>（关键字冲突），需使用<code>className</code></p><pre><code class="lang-javascript"> &lt;input className=&quot;input&quot; /&gt;</code></pre></li><li><p>光标自动聚焦，不能使用<code>for</code>（关键字冲突），需使用<code>htmlFor</code></p><pre><code class="lang-javascript"> &lt;!-- 点击此label时，光标自动聚焦到input --&gt; &lt;label htmlFor=&quot;insertArea&quot;&gt;Input&lt;/label&gt; &lt;input id=&quot;insertArea&quot;/&gt;</code></pre></li><li><p>dangerouslySetInnerHTML</p><ul><li><p>直接添加<code>{}</code>的内容会自动转义，eg: 内容为<code>&lt;h1&gt;Hello&lt;/h1&gt;</code> =&gt; 会转换为字符串显示</p><pre><code class="lang-javascript">  return (      &lt;ul&gt;          {              this.state.list.map((item,index)=&gt;{                  return &lt;li key={index}                       onClick={this.handleItemDelete.bind(this,index)}                      &gt;{item}&lt;/li&gt;              })          }      &lt;/ul&gt;  )</code></pre></li><li><p>使用<code>dangerouslySetInnerHTML</code>添加的内容不转义，eg: 内容为<code>&lt;h1&gt;Hello&lt;/h1&gt;</code> =&gt; 会直接作为HTML渲染显示</p><pre><code class="lang-javascript">  return(      &lt;ul&gt;          {              this.state.list.map((item,index)=&gt;{                  return &lt;li key={index}                       onClick={this.handleItemDelete.bind(this,index)}                      // 配置dangerouslySetInnerHTML属性等于一个json对象：`{__html:item}`                      dangerouslySetInnerHTML={{__html:item}}                      &gt;&lt;/li&gt;              })          }      &lt;/ul&gt;  )</code></pre></li></ul></li></ol><p><strong>约定:</strong></p><ul><li>React认为小写的tag是原生Dom节点，如<code>div</code></li><li>大写字母开头为自定义组件</li><li>JSX标记可以直接使用属性语法，如<code>&lt;menu.Item /&gt;</code></li></ul><h2 id="header-6">Component</h2><p>React以组件方式考虑UI的构建:</p><ul><li>一般不提供其它操作方法，而是某种状态机，可理解为一个纯函数</li><li>单向数据绑定</li></ul><pre><code>    props       +       state           =&gt;      View(外部传来的属性)       (内部维护的状态)</code></pre><ol><li>响应式设计：通过监听Data(即组件的<code>status</code>属性)操作，而传统方式是通过Dom操作</li><li>父子组件通讯：通过组件的<code>props</code>属性<ul><li>父组件：子组件标签上添加标签属性</li><li>子组件：通过<code>props</code>属性获取调用时设置的标签属性</li><li>注：子组件可使用父组件传递过来的值，但子组件不能直接改变这个值（单向数据流）</li></ul></li><li>使用原则:<ul><li>何时创建组件：单一职责原则<ul><li>每一个组件只做一件事</li><li>如果组件变得复杂，则应拆分成小组件</li></ul></li><li>数据状态管理：DRY原则<ul><li>能计算得到的状态就不要单独存储</li><li>组件尽量无状态，所需数据通过<code>props</code>获取</li></ul></li></ul></li></ol><h3 id="header-7">自定义组件</h3><pre><code class="lang-jsx">import React,{ Component } from &#39;react&#39;;// 等价于：import React from &#39;react&#39;const Component=React.Component// 自定义组件class App extends Component{    render(){        // JSX        return &lt;div&gt;Hello world&lt;/div&gt;;    }}export default App;</code></pre><p><strong>注：</strong></p><ul><li>首字母必需大些</li><li>render返回的内容必需整体包含在一个大的元素中</li></ul><h3 id="header-8">state</h3><p>组件中的<code>state</code>属性不允许直接做任何改变(即<code>Immutable</code>不可变数据)，需通过<code>setState</code>方法</p><pre><code class="lang-javascript">handleItemDelete(index,event){    const lst=[...this.state.list]    lst.splice(index,1)    this.setState({        list:lst      // list: this.state.list.splice(index,1) -- not recommend    })}</code></pre><h3 id="header-9">props</h3><ul><li><code>props</code> : 接收从父组件传递过来的属性</li><li><code>defaultProps</code> : 给组件设置默认属性值</li><li><code>propTypes</code> : 对接收的属性进行校验（不通过时，<code>console</code>会有个<code>warning</code>）</li></ul><pre><code class="lang-javascript">import PropTypes from &#39;prop-types&#39;// Typechecking with PropTypesTodoItem.propTypes = {    item: PropTypes.string.isRequired    ,index: PropTypes.oneOfType([PropTypes.number,PropTypes.string])    ,deleteItem: PropTypes.func}TodoItem.defaultProps={    item: &#39;Hello World&#39;}</code></pre><h3 id="header-10">Sample: TodoList</h3><pre><code class="lang-javascript">import React,{Component,Fragment} from &#39;react&#39;;import &#39;./style.css&#39;class TodoList extends Component{    constructor(props){        super(props);        this.state={            inputValue:&#39;&#39;,            list:[                &#39;Learn English&#39;                ,&#39;Learn React&#39;            ]        }    }    render(){        return (            &lt;Fragment&gt;                 &lt;label htmlFor=&quot;insertArea&quot;&gt;Input&lt;/label&gt; {/*点击此label时，光标自动聚焦到input*/}                &lt;input id=&quot;insertArea&quot;                    className=&quot;input&quot;                    value={this.state.inputValue}                    onChange={this.handleInputChange.bind(this)} // bind this: TodoList inst!!                /&gt;&lt;button onClick={this.handleBtnClick.bind(this)}&gt;Submit&lt;/button&gt;                &lt;ul&gt;                    {                        this.state.list.map((item,index)=&gt;{                            // return &lt;li key={index}                             //     onClick={this.handleItemDelete.bind(this,index)}                              //     &gt;{item}&lt;/li&gt;                            return &lt;li key={index}                                 onClick={this.handleItemDelete.bind(this,index)}                                  dangerouslySetInnerHTML={{__html:item}}                                &gt;&lt;/li&gt;                        })                    }                &lt;/ul&gt;            &lt;/Fragment&gt;        )    }    handleInputChange(event){        // console.log(event.target) // event.target = dom: input        // console.log(this)         // undefined !! ,need to bind when call        // this.state.inputValue=event.target.value // need to use setState!!        this.setState({            inputValue:event.target.value        })    }    handleBtnClick(event){        this.setState({            list:[...this.state.list,this.state.inputValue]            ,inputValue:&#39;&#39;        })    }    handleItemDelete(index,event){        const lst=[...this.state.list]        lst.splice(index,1)        this.setState({            list:lst      // list: this.state.list.splice(index,1) -- not recommend        })    }}export default TodoList;</code></pre><h3 id="header-11">组件拆分：父子组件</h3><p>注：可通过组件的<code>props</code>属性实现父子组件通讯</p><ol><li><p>TodoList.js: <code>import TodoItem from &#39;./TodoItem&#39;</code></p><pre><code class="lang-java"> render(){     return (         &lt;Fragment&gt;              &lt;label htmlFor=&quot;insertArea&quot;&gt;Input&lt;/label&gt; {/*点击此label时，光标自动聚焦到input*/}             &lt;input id=&quot;insertArea&quot;                 className=&quot;input&quot;                 value={this.state.inputValue}                 onChange={this.handleInputChange.bind(this)} // bind this: TodoList inst!!             /&gt;&lt;button onClick={this.handleBtnClick.bind(this)}&gt;Submit&lt;/button&gt;             &lt;ul&gt;                 {                     this.state.list.map((item,index)=&gt;{                         // return &lt;li key={index}                          //     onClick={this.handleItemDelete.bind(this,index)}                           //     &gt;{item}&lt;/li&gt;                         // return &lt;li key={index}                          //     onClick={this.handleItemDelete.bind(this,index)}                           //     dangerouslySetInnerHTML={{__html:item}}                         //     &gt;&lt;/li&gt;                         return &lt;TodoItem                             key={index} item={item} index={index}                             deleteItem={this.handleItemDelete.bind(this)}                             //onClick={this.handleItemDelete.bind(this,index)}                              /&gt;                     })                 }             &lt;/ul&gt;         &lt;/Fragment&gt;     ) }</code></pre></li><li><p>TodoItem.js:</p><pre><code class="lang-javascript"> import React,{Component} from &#39;react&#39; class TodoItem extends Component{     constructor(props){         super(props);         this.handleClick=this.handleClick.bind(this) // recommend! 节约性能     }     render(){         return &lt;li onClick={this.handleClick}&gt;{this.props.item}&lt;/li&gt;     }     handleClick(){         // 调用传过来的父组件方法修改父组件status（即仍然是使用父组件的方法维护父组件状态）         // console.log(this.props);         this.props.deleteItem(this.props.index)      } } export default TodoItem</code></pre></li></ol><h3 id="header-12">组件拆分: UI &amp; Container</h3><p>拆分成UI组件和Container组件：</p><ul><li>UI组件负责渲染部分 =&gt; 无状态组件(一个只有render函数的组件) =&gt; 可直接用一个函数定义, 性能高</li><li>Container组件负责逻辑部分</li></ul><p><strong>Sample:</strong></p><ol><li><p>AntTodoList.js : Container组件</p><pre><code class="lang-javascript"> import React,{ Component } from &#39;react&#39;; import store from &#39;./store/index&#39; import * as actionCreator from &#39;./store/actionCreator&#39; import TodoListUI from &#39;./TodoListUI&#39; class AntdTodoList extends Component {     render(){         return &lt;TodoListUI                      inputValue={this.state.inputValue}                     handleInputChange={this.handleInputChange}                     handleBtnClick={this.handleBtnClick}                     list={this.state.list}                     handleItemDelete={this.handleItemDelete}                 /&gt;     }     // 其他不变 .... }</code></pre></li><li><p>TodoListUI.js : UI组件</p><pre><code class="lang-java"> import React,{ Component } from &#39;react&#39;; import &#39;antd/dist/antd.css&#39;; import { Input,Button,List,Icon } from &#39;antd&#39;; /* class TodoListUI extends Component{     render(){         return (             &lt;div style={{margin:'20px auto',maxWidth:'600px'}}&gt;                 &lt;div style={{padding:'20px 0px',textAlign:'center'}}&gt;                     &lt;h2&gt;TodoList(with Antd UI):&lt;/h2&gt;                     &lt;Input                          placeholder=&#39;Enter todo item here&#39;                          style={{width:'500px',marginRight:'10px'}}                         value={this.props.inputValue}                         onChange={this.props.handleInputChange}                     /&gt;                     &lt;Button type=&quot;primary&quot; onClick={this.props.handleBtnClick}&gt;Submit&lt;/Button&gt;                 &lt;/div&gt;                 &lt;List                    bordered                    dataSource={this.props.list}                   renderItem={(item,index) =&gt; (                     &lt;List.Item                          actions={[                             &lt;Icon                                  type=&quot;delete&quot; theme=&quot;filled&quot;                                  // onClick={this.props.handleItemDelete.bind(this,index)}                                 onClick={()=&gt;{                                     // console.log(&quot;del:&quot;,index,this.props.list[index])                                     this.props.handleItemDelete(index)                                 }}                             /&gt;                         ]}                     &gt;                         {item}                     &lt;/List.Item&gt;                   )}                 /&gt;             &lt;/div&gt;         )     } }*/ // 无状态组件(一个只有render函数的组件) =&gt; 可直接用一个函数定义, 性能高 const TodoListUI = (props)=&gt;{     return (         &lt;div style={{margin:'20px auto',maxWidth:'600px'}}&gt;             &lt;div style={{padding:'20px 0px',textAlign:'center'}}&gt;                 &lt;h2&gt;TodoList(with Antd UI):&lt;/h2&gt;                 &lt;Input                      placeholder=&#39;Enter todo item here&#39;                      style={{width:'500px',marginRight:'10px'}}                     value={props.inputValue}                     onChange={props.handleInputChange}                 /&gt;                 &lt;Button type=&quot;primary&quot; onClick={props.handleBtnClick}&gt;Submit&lt;/Button&gt;             &lt;/div&gt;             &lt;List                bordered                dataSource={props.list}               renderItem={(item,index) =&gt; (                 &lt;List.Item                      actions={[                         &lt;Icon                              type=&quot;delete&quot; theme=&quot;filled&quot;                              onClick={()=&gt;{                                 // console.log(&quot;del:&quot;,index,props.list[index])                                 props.handleItemDelete(index)                             }}                         /&gt;                     ]}                 &gt;                     {item}                 &lt;/List.Item&gt;               )}             /&gt;         &lt;/div&gt;     ) } export default TodoListUI;</code></pre></li></ol><h3 id="header-13">受控 &amp; 非受控组件</h3><p>(主要针对表单)</p><ul><li>受控组件：表单元素状态由使用者维护<pre><code class="lang-html">  &lt;input      type=&quot;text&quot;      value={this.state.value}      onChange={ evt =&gt; this.setState({value:evt.target.value})}  /&gt;</code></pre></li><li>非受控组件：表单元素状态由DOM自身维护<pre><code class="lang-html">  &lt;input      type=&quot;text&quot;      ref={ node =&gt; this.input=node }  /&gt;</code></pre></li></ul><h3 id="header-14">组件复用(设计模式)</h3><ul><li><p>高阶组件（HOC）: 一个函数，接收组件作为参数，返回新的组件</p><pre><code class="lang-java">  export default function withTimer(WrappedComponent) {    return class extends Component {      state = { time: new Date() };      componentDidMount() {        this.timerID = setInterval(() =&gt; this.tick(), 1000);      }      componentWillUnmount() {        clearInterval(this.timerID);      }      tick() {        this.setState({          time: new Date()        });      }      render() {        return &lt;WrappedComponent time={this.state.time} {...this.props} /&gt;;      }    };  }</code></pre><pre><code class="lang-java">  class App extends Component {      render(){          return (              &lt;div&gt;                  &lt;h1&gt;Hello World!&lt;/h1&gt;                  // 使用withTimer封装后，可直接使用传递进来的time属性                  &lt;h2&gt;{this.props.time.toLocaleString()}&lt;/h2&gt;              &lt;/div&gt;          )      }  }  export default withTimer(App);  // 返回封装后的新组件</code></pre></li><li><p>函数作为子组件：外部使用一个函数作为组件的children =&gt; 组件如何render内容，由调用方决定</p><pre><code class="lang-java">  class MyComponent extends Component{      render(){          return (              // 传进来的children是个函数              &lt;ul&gt;{this.props.children(&#39;Susan&#39;)}&lt;/ul&gt;          )      }  }</code></pre><pre><code class="lang-java">  &lt;MyComponent&gt;{ (name) =&gt; (&lt;li&gt;{name}&lt;/li&gt;) }&lt;/MyComponent&gt;</code></pre></li><li><p><strong>注：</strong>是一种设计模式，自己可实现更多场景的组件复用</p></li></ul><h2 id="header-15">高阶</h2><h3 id="header-16">this</h3><ul><li>this : 一般指向该方法运行时所在的环境 <a href="https://sixdegree.github.io/2018/10/15/ES6.html#header-37">ES6 this</a></li><li>注：在箭头函数中，<code>this</code>指向是固定的，为定义时所在的对象，不是使用时所在的对象（因为箭头函数没有自己的this，只能使用外层代码块的this）</li></ul><pre><code class="lang-javascript">render(){    return &lt;input id=&quot;insertArea&quot;            className=&quot;input&quot;            value={this.state.inputValue}            onChange={this.handleInputChange.bind(this)} // bind this: TodoList inst!!}handleInputChange(event){    // console.log(event.target) // event.target = dom: input    // console.log(this)         // undefined !! ,need to bind when call    // this.state.inputValue=event.target.value // need to use setState!!    this.setState({        inputValue:event.target.value    })}</code></pre><p>=&gt; 优化：</p><pre><code class="lang-javascript">constructor(props){    super(props);    this.state={        inputValue:&#39;&#39;,        list:[]    };    this.handleInputChange=this.handleInputChange.bind(this) // 在这里bind this: TodoList inst!! 性能更优}render(){    return &lt;input id=&quot;insertArea&quot;            className=&quot;input&quot;            value={this.state.inputValue}            onChange={this.handleInputChange} // constructor时已经绑定好了，可直接使用}</code></pre><h3 id="header-17">ref</h3><p>可用于直接定位到真实Dom（但不推荐直接操作Dom）</p><pre><code class="lang-java">render(){    return (        &lt;Fragment&gt;             &lt;label htmlFor=&quot;insertArea&quot;&gt;Input&lt;/label&gt; {/*点击此label时，光标自动聚焦到input*/}            &lt;input id=&quot;insertArea&quot;                className=&quot;input&quot;                value={this.state.inputValue}                onChange={this.handleInputChange.bind(this)} // bind this: TodoList inst!!                ref={(input)=&gt;{this.input=input}}            /&gt;            &lt;button onClick={this.handleBtnClick.bind(this)}&gt;Submit&lt;/button&gt;            &lt;ul ref={(ul)=&gt;{this.ul=ul}}&gt;                {this.getTodoItem()}            &lt;/ul&gt;        &lt;/Fragment&gt;    )}handleInputChange(event){    // 异步函数式：    // const val=event.target.value    const val=this.input.value //  使用了ref后，也可这样定位到input dom节点 - 不推荐    this.setState(        ()=&gt;({inputValue:val})    );}handleBtnClick(event){    this.setState(        (preState)=&gt;({      // preState = this.state            list:[...preState.list,preState.inputValue]            ,inputValue:&#39;&#39;        }),()=&gt;{ // callback func            // 使用了ref后,可直接定位到ul dom节点，对dom进行操作 - 不推荐            console.log(this.ul.querySelectorAll(&#39;li&#39;).length)        }    );}</code></pre><h3 id="header-18">Fragment</h3><p>Fragment占位符，本质也是个组件</p><p><strong>Sample:</strong></p><pre><code class="lang-javascript">import React,{Component} from &#39;react&#39;;class TodoList extends Component{    render(){        return (            &lt;div&gt;                 &lt;input/&gt;&lt;button&gt;Submit&lt;/button&gt;                &lt;ul&gt;                    &lt;li&gt;Learn English&lt;/li&gt;                    &lt;li&gt;Learn React&lt;/li&gt;                &lt;/ul&gt;            &lt;/div&gt;        )    }}export default TodoList;</code></pre><p>=&gt; 将返回的<code>&lt;div&gt;</code>标签插入到目标节点</p><pre><code class="lang-javascript">import React,{Component,Fragment} from &#39;react&#39;;class TodoList extends Component{    render(){        return (            &lt;Fragment&gt;                 &lt;input/&gt;&lt;button&gt;Submit&lt;/button&gt;                &lt;ul&gt;                    &lt;li&gt;Learn English&lt;/li&gt;                    &lt;li&gt;Learn React&lt;/li&gt;                &lt;/ul&gt;            &lt;/Fragment&gt;        )    }}export default TodoList;</code></pre><p>=&gt; 将Fragment下的内容插入到目标节点</p><h3 id="header-19">结构化赋值</h3><pre><code class="lang-javascript">import React,{Component} from &#39;react&#39;class TodoItem extends Component{    constructor(props){        super(props);        this.handleClick=this.handleClick.bind(this) // recommend! 节约性能    }    render(){        // return &lt;li onClick={this.handleClick}&gt;{this.props.item}&lt;/li&gt;        const {item} = this.props;  // 等同于 const item = this.props.item        return &lt;li onClick={this.handleClick}&gt;{item}&lt;/li&gt;    }    handleClick(){        // console.log(this.props);        // this.props.deleteItem(this.props.index);        const {deleteItem,index}=this.props;        deleteItem(index);    }}export default TodoItem</code></pre><h3 id="header-20">函数式编程</h3><pre><code class="lang-javascript">handleInputChange(event){    // console.log(event.target);                 // event.target = dom: input    // console.log(this);                         // undefined !! , need to bind when call    // this.state.inputValue=event.target.value;  // need to use setState!!    // 1. 老式写法：    // this.setState({    //     inputValue:event.target.value    // });    // 2. 函数式：    // this.setState(()=&gt;{    //     return {    //         inputValue:event.target.value    //     }    // });    // 3. 异步函数式：    const val=event.target.value    this.setState(        ()=&gt;({inputValue:val})    );}</code></pre><pre><code class="lang-javascript">handleBtnClick(event){    // this.setState({    //     list:[...this.state.list,this.state.inputValue]    //     ,inputValue:&#39;&#39;    // })    this.setState(        (preState)=&gt;({      // preState = this.state            list:[...preState.list,preState.inputValue]            ,inputValue:&#39;&#39;        })    );}</code></pre><pre><code class="lang-javascript">handleItemDelete(index,event){    // const lst=[...this.state.list]    // lst.splice(index,1)    // this.setState({    //     list:lst      // list: this.state.list.splice(index,1) -- not recommend    // });    this.setState(        (preState)=&gt;{            const list=[...preState.list]            list.splice(index,1)            return {list}   // 等同：return {list:list}        }    );}</code></pre><h3 id="header-21">Immutable data</h3><p><strong>不可变数据</strong></p><p><img src="http://arqex.com/wp-content/uploads/2015/02/trees-300x150.png" alt="immutable data"></p><blockquote><p>Instead of updating the node, Freezer creates a new data tree starting from the top.<br>The nodes in the update path are new, but the rest are reused</p><p><a href="http://arqex.com/991/json-editor-react-immutable-data" target="_blank" rel="noopener">Refer: A JSON editor with React and Immutable data</a></p></blockquote><ol><li><p>为何需要不可变数据：性能优化, 易于调试和跟踪, 易于推测</p><ul><li>所有的变化都是由action触发，action触发在旧的state上，形成一个新的state，新旧state是两个不同的对象，这样很容易知道state发生了变化</li><li>（不需要进行深层次的遍历和比较值，只需比较两个state的引用是否一致，即可知道是否发生了变化）</li></ul></li><li><p>如何操作不可变数据：</p><ul><li><p>原生写法: <code>{...}</code>, <code>Object.assign</code></p><pre><code class="lang-javascript">  const state = {filter:&#39;completed&#39;,todos:[&#39;Learn React&#39;]};  // {}写法  const newState = {...state,todos:[...state.todos,&#39;Learn English&#39;]};  // Object.assign写法  const newState2 = object.assign({},state,{todos:[...state.todos,&#39;Learn English&#39;]});</code></pre></li><li>使用工具类: <a href="https://github.com/kolodny/immutability-helper" target="_blank" rel="noopener">immutability-helper</a><pre><code class="lang-javascript">  import update from &#39;immutability-helper&#39;;  const state = {filter:&#39;completed&#39;,todos:[&#39;Learn React&#39;]};  const newState = update(state,{todos:{$push:[&#39;Learn English&#39;]}})</code></pre></li><li><p>使用工具类: <a href="https://github.com/immerjs/immer" target="_blank" rel="noopener">immer</a></p><pre><code class="lang-javascript">  import produce from &#39;immer&#39;;  const state = {filter:&#39;completed&#39;,todos:[&#39;Learn React&#39;]};  const newState = produce(state,draftState =&gt; {      draftState.todos.push(&#39;Learn English&#39;)  })</code></pre></li><li>使用工具类: <a href="https://github.com/immutable-js/immutable-js" target="_blank" rel="noopener">immutable-js</a> (install: <code>yarn add immutable</code>)<ul><li><code>fromJS(jsObj)</code>: 将一个JS对象变成一个immutable(不可变)对象</li><li><code>immuObj.toJS()</code>: 将一个immutable对象转换回JS对象</li><li><code>immuObj.get(fieldName)</code>: 获取immutable对象里的数据</li><li><code>immuObj.set(fieldName,value)</code>/<code>immuObj.merge({k:v,k,v})</code>: 根据原始值和新值，返回一个全新的immutable对象</li></ul></li></ul></li></ol><p><strong>Sample:使用<code>immutable-js</code>维护redux store中的state对象</strong></p><ol><li><p>src/common/header/store/reducer.js: </p><pre><code class="lang-javascript"> import * as actionType from &#39;./actionType&#39;; import { fromJS } from &#39;immutable&#39;; // const defaultState={ //     focused: false // }; const defaultState = fromJS({               // 将一个JS对象变成一个immutable(不可变)对象     focused: false,     list: []                                // Note: 这里list也会转变为immutable(不可变)对象，更新数据时要注意 }) export default (state=defaultState,action)=&gt;{     if (action.type==actionType.HeaderSearchFocus){         // return { focused:true}         return state.set(&#39;focused&#39;,true)  // immutable对象的set方法，会根据原始值和新值，返回一个全新的对象     }     if (action.type==actionType.HeaderSearchBlur){         // return {focused:false}         return state.set(&#39;focused&#39;,false) // 同 return state.merge({focused:false}), merge方式合并多个更新值，再返回新的对象     }     return state; }</code></pre></li><li><p>src/common/header/index.js</p><pre><code class="lang-javascript"> const mapStateToProps=(state)=&gt;{     return {         // focused: state.focused         // focused: state.header.focused         focused: state.header.get(&#39;focused&#39;) // Note：这里state.header是一个immutable对象     } }</code></pre></li></ol><h3 id="header-22">PureComponent</h3><p>PureComponent + immutable.js</p><p>提供了一个具有浅比较的<code>shouldComponentUpdate</code>方法 =&gt; 对<code>props</code>和<code>state</code>进行浅比较，不变则不重新渲染 =&gt; 更具性能</p><pre><code class="lang-java">// import React, { Component } from &#39;react&#39;;import React, { PureComponent } from &#39;react&#39;;// class Home extends Component{//     shouldComponentUpdate(nextProps,nextState){//         if(nextProps.title!==this.props.title){//             return true//         }//         return false//     }//     return (//         &lt;div&gt;Home&lt;/div&gt;//     )// }class Home extends PureComponent{    return (        &lt;div&gt;Home&lt;/div&gt;    )}const mapStateToProps=(state)=&gt;{    return {        title: state.home.title    }}export default connect(mapStateToProps,null)(Home);</code></pre><h3 id="header-23">Context API</h3><ul><li>React 16.3公布的新特性（实际早就存在且应用了，如redux）</li><li>可用于解决组件间通讯问题 </li><li><a href="https://reactjs.org/docs/context.html#when-to-use-context" target="_blank" rel="noopener">when to use context</a></li></ul><p><strong>使用：</strong></p><ul><li><code>React.createContext</code><pre><code class="lang-javascript">  const MyContext = React.createContext(defaultValue);</code></pre></li><li><code>Context.Provider</code><pre><code class="lang-javascript">  &lt;MyContext.Provider value={/* some value */}&gt;</code></pre></li><li><code>Context.Consumer</code><pre><code class="lang-javascript">  &lt;MyContext.Consumer&gt;    {value =&gt; /* render something based on the context value */}  &lt;/MyContext.Consumer&gt;</code></pre></li></ul><p><strong>Sample:</strong></p><pre><code class="lang-java">const TheamContext = React.createContext(&#39;light&#39;);class App extends Component{    render(){        &lt;ThemeContext.Provider value=&#39;dark&#39;&gt;            &lt;ThemedButton/&gt;        &lt;/ThemeContext.Provider&gt;    }}class ThemedButton extends Component{    render(){        &lt;ThemeContext.Consumer&gt;            { (theme) =&gt; (&lt;button&gt;{theme}&lt;/button&gt;) }        &lt;/ThemeContext.Consumer&gt;    }}</code></pre><p>=&gt; <code>&lt;button&gt;dark&lt;/button&gt;</code></p><h3 id="header-24">Virtual Dom</h3><ul><li>JSX的运行基础，本质为JS对象（eg:<code>[tag,props,children]</code>），用来描述真实Dom</li><li><p><code>JSX</code> =&gt; <code>React.createElement</code> =&gt; <code>虚拟Dom</code> =&gt; <code>真实Dom</code></p><pre><code class="lang-javascript">  // JSX:  &lt;div id=&#39;abc&#39;&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;/div&gt;  // 等价于：  span=React.createElement(&#39;span&#39;,{},&#39;Hello World&#39;)  div=React.createElement(&#39;div&#39;,{&#39;id&#39;:&#39;abc&#39;},span)</code></pre></li><li>虚拟DOM树，计算<code>Diff</code>：<ul><li>两个假设前提：<ul><li>组件的DOM结构是相对稳定的</li><li>类型相同的兄弟节点可以被唯一标识</li></ul></li><li><code>Diff</code>算法：<ul><li>广度优先分层比较新旧虚拟Dom树</li><li>节点的key属性，作为唯一标识，用于定位比较新旧虚拟Dom树节点</li><li>同层，节点顺序变化，则交换位置</li><li>同层，节点类型变化，则删除该节点和其子节点，重新创建</li></ul></li><li>总体平均算法复杂度可达到: <code>O(n)</code></li></ul></li><li>优点：<ul><li>性能提升<ul><li>减少了真实Dom的创建和对比，使用虚拟Dom（即JS对象）创建和对比损耗小的多</li><li>逐（同）层比对发现节点类型不同时，则不会再往下比对，直接废弃掉，用重新生成的替换掉它，减少比对</li><li><code>setState</code>是异步的，可方便将多次间隔短的<code>setState</code>合并到一次，减少虚拟Dom比对的次数</li></ul></li><li>使得跨端应用得以实现，eg:<ul><li>React: 虚拟Dom -&gt; 浏览器真实Dom</li><li>React Native： 虚拟Dom -&gt; 原生应用的组件 </li></ul></li></ul></li><li>注：节点通过key定位比对，所以尽量保证用稳定的值作为key，不推荐使用index作为key</li></ul><p><strong>引入虚拟Dom性能提升分析</strong></p><ul><li>不使用<code>Virtual Dom</code>的处理过程:<ol><li>数据 state ＋ 模版 jsx =&gt; 生成真实Dom，渲染显示</li><li>数据 state 发生改变</li><li>数据 state ＋ 模版 jsx =&gt; 生成真实Dom，替换原来的Dom，渲染显示</li></ol></li><li>＝&gt; 缺陷：<ul><li>第一次生成了一个完整的Dom片段</li><li>第二次生成了一个完整的Dom片段</li><li>第二次的Dom替换第一次的Dom</li><li>-&gt; 耗性能</li></ul></li><li>=&gt; 改良：<ul><li>第一次：数据 ＋ 模版 =&gt; 生成真实Dom</li><li>第二次：数据 ＋ 模版 =&gt; 生成真实Dom，不直接替换原始Dom，而是和原来的Dom进行<code>Diff</code>比对，找出变化元素，替换变化元素</li><li>-&gt; 性能提升不明显</li></ul></li><li>=&gt; 进一步，引入<code>Virtual Dom</code>, eg:<ul><li>真实Dom: <code>&lt;div id=&#39;abc&#39;&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;/div&gt;</code></li><li>虚拟Dom(本质是JS对象): <code>[&#39;div&#39;,{&#39;id&#39;:&#39;abc&#39;},[&#39;span&#39;,{},&#39;Hello World&#39;]]</code></li><li>第一次：数据 ＋ 模版 =&gt; 生成虚拟Dom，用虚拟Dom的结构生成真实Dom</li><li>第二次：数据 ＋ 模版 =&gt; 生成新的虚拟Dom，与原来的虚拟Dom进行<code>Diff</code>比对，找出变化部分，改变真实Dom对应的内容</li><li>-&gt; 极大的提升了性能：减少了真实Dom的创建和对比，而使用虚拟Dom（即JS对象）创建和对比损耗小的多</li></ul></li></ul><h3 id="header-25">组件生命周期</h3><p><a href="https://reactjs.org/docs/react-component.html" target="_blank" rel="noopener">React Component Doc</a></p><p><img src="/2019/08/15/component-lifecycle.jpg" alt="Component Lifecycle"><br>(source: <a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a>)</p><p><code>react-async-component-lifecycle-hooks</code>: 在某一时刻，组件会自动调用执行的函数</p><p><strong>Mounting生命周期：</strong></p><ol><li><code>constructor()</code><ul><li>用于初始化内部状态(Initialization: setup props and states)</li><li>唯一可以直接修改state的地方(其他地方一般需使用<code>this.setState</code>方法)</li></ul></li><li><code>componentDidMount()</code><ul><li>组件创建渲染完成后调用</li><li>只执行一次</li><li>典型场景：获取外部资源</li></ul></li><li><code>componentWillUnMount()</code><ul><li>组件移除时被调用</li><li>典型场景：资源释放</li></ul></li></ol><p><strong>Updation生命周期</strong></p><ol><li><code>static getDerivedStateFromProps(props, state)</code><ul><li>React 16.3新引入，取代原<code>componentWillReceiveProps</code>应用场景</li><li>用于从props获取值给state</li><li>尽量不要使用：维护两者状态一致性会增加复杂度</li><li>典型场景：表单控件获取默认值</li></ul></li><li><code>shouldComponentUpdate(nextProps, nextState)</code> =&gt; return true/false<ul><li>决定<code>Virtual Dom</code>是否要重绘（是否继续执行后面的Updation生命周期）</li><li>一般可由<code>PureComponent</code>自动实现</li><li>典型场景：性能优化</li></ul></li><li><code>render()</code></li><li><code>getSnapshotBeforeUpdate(prevProps, prevState)</code> =&gt; 返回值会传递给<code>componentDidUpdate</code><ul><li>React 16.3新引入，取代原<code>componentWillUpdate</code>应用场景</li><li>在组件state已更新，React更新D­O­M和refs前被调用</li><li>典型场景：获取更新前DOM状态</li></ul></li><li><code>componentDidUpdate(prevProps, prevState, snapshot)</code><ul><li>React更新D­O­M和refs完成后调用</li><li>典型场景：页面需要根据props变化重新获取数据</li></ul></li></ol><p><strong>Sample:</strong></p><ul><li>props change （父组件重新render时，传递给子组件的属性发生了变化，触发子组件Updation周期）: <ul><li><code>getDerivedStateFromProps</code> </li><li><code>shouldComponentUpdate</code> -&gt; return true/false to continue</li><li><code>render</code><ul><li><code>getSnapshotBeforeUpdate</code></li><li>React 更新 ­D­O­M 和 refs</li><li><code>componentDidUpdate</code></li></ul></li></ul></li><li>states change（组件state发生改变，触发组件Updation周期）:<ul><li><code>shouldComponentUpdate</code> -&gt; return true/false to continue</li><li><code>render</code><ul><li><code>getSnapshotBeforeUpdate</code></li><li>React 更新 ­D­O­M 和 refs</li><li><code>componentDidUpdate</code></li></ul></li></ul></li></ul><h2 id="header-26">样式</h2><h3 id="header-27">CSS3过渡动画</h3><pre><code class="lang-java">import React,{Component,Fragment} from &#39;react&#39;import &#39;./style.css&#39;class ToggleButton extends Component{    constructor(props){        super(props)        this.state={            show:false        }        this.handleToggleBtnClick=this.handleToggleBtnClick.bind(this)    }    render(){        return (            &lt;Fragment&gt;                &lt;div className={this.state.show?&#39;hideArea&#39;:&#39;showArea&#39;}&gt;Hello World&lt;/div&gt;                &lt;button onClick={this.handleToggleBtnClick}&gt;Toggle&lt;/button&gt;            &lt;/Fragment&gt;        )    }    handleToggleBtnClick(){        this.setState(            (preState)=&gt;({                show:!preState.show            })        );    }}export default ToggleButton</code></pre><pre><code class="lang-css">.hideArea{    opacity: 0;    color: red;    transition: all 1s ease-in;}.showArea{    opacity: 1;    color: green;    transition: all 1s ease-in;}</code></pre><p>or</p><pre><code class="lang-css">.hideArea{    /*opacity: 0;    color: red;    transition: all 1s ease-in;*/    animation: hide-item 2s ease-in forwards;}.showArea{    /*opacity: 1;    color: green;    transition: all 1s ease-in;*/    animation: show-item 2s ease-in forwards;}@keyframes hide-item{    0% {        opacity: 1;        color: red;    }    50% {        opacity: 0.5;        color: green;    }    100% {        opacity: 0;        color: blue;    }}@keyframes show-item{    0% {        opacity: 0;        color: blue;    }    50% {        opacity: 0.5;        color: green;    }    100% {        opacity: 1;        color: red;    }}</code></pre><h3 id="header-28">react-transition-group</h3><p>使用第三方模块<code>react-transition-group</code>，方便实现更复杂动画</p><p><a href="https://github.com/reactjs/react-transition-group" target="_blank" rel="noopener">Github</a> | <a href="https://reactcommunity.org/react-transition-group/" target="_blank" rel="noopener">Doc</a></p><ol><li><p>install:</p><pre><code class="lang-bash"> # npm $ npm install react-transition-group --save # yarn $ yarn add react-transition-group</code></pre></li><li><p>CSSTransaction</p><pre><code class="lang-java"> import React,{Component,Fragment} from &#39;react&#39; import { CSSTransition } from &#39;react-transition-group&#39; import &#39;./style.css&#39; class ToggleButtonCSSTransition extends Component{     constructor(props){         super(props)         this.state={             show:true         }         this.handleToggleBtnClick=this.handleToggleBtnClick.bind(this)     }     render(){         return (             &lt;Fragment&gt;                 &lt;button onClick={this.handleToggleBtnClick}&gt;CSSTransition&lt;/button&gt;                 &lt;CSSTransition                     in={this.state.show}                     timeout={1000}                     classNames=&#39;node&#39;   // note: It&#39;s `classNames`,not `className`, for css style class prefix                     appear={true}        // also use the animation when first load                     unmountOnExit       // if set,the dom will be removed when hide                     onEntered={(el)=&gt;{el.style.color=&#39;blue&#39;}} // hock func, trigger when enter finished                 &gt;                     &lt;div&gt;Hello World&lt;/div&gt;                 &lt;/CSSTransition&gt;             &lt;/Fragment&gt;         )     }     handleToggleBtnClick(){         this.setState(             (preState)=&gt;({                 show:!preState.show             })         );     } } export default ToggleButtonCSSTransition</code></pre></li><li><p>TransactionGroup (for batch components)</p><pre><code class="lang-java"> import React,{Component,Fragment} from &#39;react&#39; import { CSSTransition,TransitionGroup } from &#39;react-transition-group&#39; import &#39;./style.css&#39; class ToggleButtonTransitionGroup extends Component{     constructor(props){         super(props)         this.state={             list:[&#39;Hello&#39;]         }         this.handleToggleBtnClick=this.handleToggleBtnClick.bind(this)     }     render(){         return (             &lt;Fragment&gt;                 &lt;button onClick={this.handleToggleBtnClick}&gt;TransitionGroup&lt;/button&gt;                 &lt;TransitionGroup&gt;                     {                         this.state.list.map((item,index)=&gt;{                             return (                                 &lt;CSSTransition key={index}                                      timeout={1000}                                      classNames=&#39;node&#39;                                      appear={true}                                     onEntered={(el)=&gt;{el.style.color=&#39;blue&#39;}}                                 &gt;                                     &lt;div&gt;{item}&lt;/div&gt;                                 &lt;/CSSTransition&gt;                             )                         })                     }                 &lt;/TransitionGroup&gt;             &lt;/Fragment&gt;         )     }     handleToggleBtnClick(){         this.setState(             (preState)=&gt;({                 list:[...preState.list,&quot;item&quot;]             })         );     } } export default ToggleButtonTransitionGroup</code></pre></li><li><p>css style class:</p><pre><code class="lang-css"> /* enter &amp; appear lifecycle*/ .node-enter,.node-appear {     opacity: 0; }  .node-enter-active,.node-appear-active{     opacity: 1;     transition: opacity 1s ease-in; }  .node-enter-done,.node-appear-done {     opacity: 1; }  /* exit lifecycle*/ .node-exit{     opacity: 1; }   .node-exit-active{     opacity: 0;     transition: opacity 1s ease-in; } .node-exit-done {     opacity: 0; }</code></pre></li></ol><h3 id="header-29">styled-components</h3><p>不管是哪个子组件，直接import一个css文件，<br>该文件中的样式会作用于所有组件，即是一个全局的样式，无法区分区别<br>=&gt; <code>styled-components</code>库：css模块化（css =&gt; js）</p><p><a href="https://github.com/styled-components/styled-components" target="_blank" rel="noopener">Github</a><br><a href="https://www.styled-components.com/docs" target="_blank" rel="noopener">Docs</a></p><p>install： <code>yarn add styled-components</code></p><p><strong>Sample: 全局Style</strong></p><ol><li><p>style.js</p><pre><code class="lang-javascript"> import { createGlobalStyle } from &#39;styled-components&#39;; // 全局样式 const GlobalStyle = createGlobalStyle`     // reset.css: 让各标签的默认样式在所有浏览器上的显示统一     html, body, div, span, applet, object, iframe,     h1, h2, h3, h4, h5, h6, p, blockquote, pre,     a, abbr, acronym, address, big, cite, code,     del, dfn, em, img, ins, kbd, q, s, samp,     small, strike, strong, sub, sup, tt, var,     b, u, i, center,     dl, dt, dd, ol, ul, li,     fieldset, form, label, legend,     table, caption, tbody, tfoot, thead, tr, th, td,     article, aside, canvas, details, embed,      figure, figcaption, footer, header, hgroup,      menu, nav, output, ruby, section, summary,     time, mark, audio, video {         margin: 0;         padding: 0;         border: 0;         font-size: 100%;         font: inherit;         vertical-align: baseline;     }     /* HTML5 display-role reset for older browsers */     article, aside, details, figcaption, figure,      footer, header, hgroup, menu, nav, section {         display: block;     }     body {         line-height: 1;     }     ol, ul {         list-style: none;     }     blockquote, q {         quotes: none;     }     blockquote:before, blockquote:after,     q:before, q:after {         content: &#39;&#39;;         content: none;     }     table {         border-collapse: collapse;         border-spacing: 0;     } `; export { GlobalStyle }</code></pre></li><li><p>App.js</p><pre><code class="lang-java"> import React, { Fragment } from &#39;react&#39;; import { GlobalStyle } from &#39;./style.js&#39;; function App() {   return (     &lt;Fragment&gt;         &lt;GlobalStyle/&gt;         &lt;div&gt; Hello World &lt;/div&gt;     &lt;/Fragment&gt;   ); } export default App;</code></pre></li></ol><p><strong>Sample:局部style</strong></p><ol><li><p>style.js</p><pre><code class="lang-javascript"> import styled from &#39;styled-components&#39;; import logoPic from &#39;../../statics/logo.png&#39;  // import pic! export const HeaderWrapper = styled.div`     height: 58px;     border-bottom: 1px solid #f0f0f0; ` // export const Logo = styled.a.attrs({ href:&#39;/&#39; })` export const Logo = styled.a`     position: absolute;     top: 0;     left: 0;     display: block;     width: 100px;     height: 56px;     background: url(${logoPic});    // use imported pic !     background-size: contain; ` export const NavItem = styled.div`     line-height: 56px;     padding: 0 15px;     font-size: 17px;     &amp;.left{         float: left;     }     &amp;.active{         color: #ea6f5a;     } `</code></pre></li><li><p>SimpleHeader.js:</p><pre><code class="lang-java"> import React from &#39;react&#39;; import { HeaderWrapper,Logo,NavItem} from &#39;./style&#39;; const SimpleHeader=(props)=&gt;{     return (         &lt;HeaderWrapper&gt;             &lt;Logo href=&#39;/&#39;/&gt;                 &lt;NavItem className=&quot;right&quot;&gt;登陆&lt;/NavItem&gt;                 &lt;NavItem className=&quot;right&quot;&gt;注册&lt;/NavItem&gt;         &lt;/HeaderWrapper&gt;     ) }; export default SimpleHeader;</code></pre></li></ol><h3 id="header-30">iconfont</h3><p>素材下载：<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">阿里</a></p><p>使用<code>styled-components</code> ＋ <code>iconfont</code>:</p><ol><li><p>全局样式IconGlobalStyle: src/statics/iconfont/icon.js</p><pre><code class="lang-javascript"> import { createGlobalStyle } from &#39;styled-components&#39;; const IconGlobalStyle = createGlobalStyle`   @font-face {font-family: &quot;iconfont&quot;;     /* Note: 更新路径 */     src: url(&#39;./iconfont.eot?t=1566970427492&#39;); /* IE9 */     src: url(&#39;./iconfont.eot?t=1566970427492#iefix&#39;) format(&#39;embedded-opentype&#39;), /* IE6-IE8 */     url(&#39;data:application/x-font-woff2;charset=utf-8;base64,d09GMgABAAAAAAR4AAsAAAAACVAAAAQsAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHEIGVgCDMgqFaIUsATYCJAMUCwwABCAFhG0HTxs/CMieA25rTF6pQqUmQ7qib3Y+H2JT/x0HLTummpp7ks1pcmQ0QkeY2VezifsXsfBQ3f5te5NlgQR6wAF+gaIoSjALwJIwcMixXU7QlltiNehs8L+LS9PU8YDVtbOIZSIe0Fq6FcoEsBWgWKyVLx2/U2nA//rC9sPYTcRhXA8EwNikImN9ay9kIrCJAMihe1TIMS2xpJCQEWE5xxaQGxK5uVHYDbjd/X3yoYYMCKQE2Nm517lR+cZ+btA1oTWYRVHg9WcGIJ0EUEAqQARy5lp9qB9NRTFjvqgSwMgEQl/T8j8v+9wITShckZzBf3gAQQlEIC2AdCiHr4yJ8HksRoDA5/kIUPi8DAEBPjf4N0YqcesZoBlwFkhllLF9zqBEFV14uDIMME+WxynkZWKW37Q90XK6Fr/8Njl69OolzKGgJNbGM0+fo9ResXZdwZYjwxOuo0eXY8fWI0fmw4cnCbN9dpyd89BLb0q2v7R23c1JfS+u+WQEsw/tZV5l+oz7bOyRiU71Y+VmgAVbz27aS9Y6HGvdP17a984LWDPl5k2ELFcA40tQ7nmO9W3KOXq4Z6UO4ds5Xt+UcP7LTZl5zxHH84cyjh6uMU2x23laTm12dm1Gvv2WWFIza2Z0T9ydUTk5UXc+9bTzsXGVD61b99Zrba3fv/ba98KFpyrr6kQdG0ufpieOJyE8deKEiIpsVvR0is2mLBeeflpYBkVP+w66jMosfuHUGNvEkdu3R3pMxijn7aOxXms4kFh7gA8P1aMD5R19QnW/Xn5M/IegtaUwg0hV6UaSXR82W2mpLL48x2HtmjTun8lxP8XZQP/YAL1pNn6ig2LYCt9NW3bDtj7npDF/9Ix8SKla/EnX9JEVZo3gZiNj1pR1DOUflt8w6dRyZ0LpW8miN+qa+L//+KJ31MNDsd+3DEl30CYgVK6jlUDoPAUQgp6n836yVdgul1bNHVH6m6xc3b4Tt+SUuO4QIupJ8afIUJv3S/Fq1ommAOikoldjrp4rUVXAi+H/PRU/knO0s/3Ix9XOBwjZuBAE4aYBJYtFi/hUkChyIYysApgUDScrxjBRpAwBkOxaBoiRXgfBcOuAGmkPWsSfAcl430GYkUGBsceYcyriQ2c1Jlct7o7sXxqpu4yAhgwW8wq7uWehTzWjApdo52ZQD0RmpWcmEw08wM0+9gQXebItS4vUTMMfWc/cjPt8RuSgaQxwl5U+37IGizMytLxnSncZfjA1TJzKwrlF6rdUJJ2LIUCjzS0s9fPdOI+FfFRmSU2D1o4zBemTR8qSLrMGukEaqFVzLvODFvHIZrFo/DqNyeAXqZ41cz4YNUQazF82gHOxpJvfIjyoWAbXSKsrTR9f7r/GYwAMWCyFQCgRiUTCoOz8ziC3MrNyCpimBjxudUCni4QqVVqwUPf5AA==&#39;) format(&#39;woff2&#39;),     url(&#39;./iconfont.woff?t=1566970427492&#39;) format(&#39;woff&#39;),     url(&#39;./iconfont.ttf?t=1566970427492&#39;) format(&#39;truetype&#39;), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */     url(&#39;./iconfont.svg?t=1566970427492#iconfont&#39;) format(&#39;svg&#39;); /* iOS 4.1- */   }   .iconfont {     font-family: &quot;iconfont&quot; !important;     font-size: 16px;     font-style: normal;     -webkit-font-smoothing: antialiased;     -moz-osx-font-smoothing: grayscale;   } ` export { IconGlobalStyle }</code></pre></li><li><p>App.js导入IconGlobalStyle</p><pre><code class="lang-java"> import React, { Fragment } from &#39;react&#39;; import { IconGlobalStyle } from &#39;./statics/iconfont/icon.js&#39; function App() {   return (     &lt;Fragment&gt;         &lt;IconGlobalStyle/&gt;         &lt;SimpleHeader/&gt;       &lt;/Fragment&gt;   ); } export default App;</code></pre></li><li><p>SimpleHeader.js使用icon</p><pre><code class="lang-java"> import React from &#39;react&#39;; const SimpleHeader=(props)=&gt;{     return (         &lt;div&gt;             &lt;a href=&quot;#&quot;&gt;&lt;span className=&quot;iconfont&quot;&gt;&amp;#xe66f;&lt;/span&gt;写文章&lt;/a&gt;         &lt;/div&gt;     ) }; export default SimpleHeader;</code></pre></li></ol><h3 id="header-31">UI组件库</h3><ul><li>AntD(Ant Design): React UI 组件库 =&gt; recommend!</li><li>Material UI</li><li>Semantic UI</li></ul><p><strong>Sample:AntD</strong></p><p><code>yarn add antd</code></p><pre><code class="lang-java">import React,{ Component } from &#39;react&#39;;import &#39;antd/dist/antd.css&#39;;import { Input,Button,List,Icon } from &#39;antd&#39;;class AntdTodoList extends Component {    render(){        return (            &lt;div style={{margin:'20px auto',maxWidth:'600px'}}&gt;                &lt;div style={{padding:'20px 0px',textAlign:'center'}}&gt;                    &lt;h2&gt;TodoList(with Antd UI):&lt;/h2&gt;                    &lt;Input                         placeholder=&#39;Enter todo item here&#39;                         style={{width:'500px',marginRight:'10px'}}                    /&gt;                    &lt;Button type=&quot;primary&quot;}&gt;Submit&lt;/Button&gt;                &lt;/div&gt;                &lt;List                   bordered                   dataSource={this.state.list}                  renderItem={(item,index) =&gt; (                    &lt;List.Item&gt;{item}&lt;/List.Item&gt;                  )}                /&gt;            &lt;/div&gt;        )    }}</code></pre><h2 id="header-32">Redux</h2><blockquote><p>独立于UI框架的通用JS状态管理框架，即数据层框架</p><p>不依赖于React，可单独使用:</p><p>  React: 本身实际上只是个视图层框架;<br>  Redux = Reducer + Flux</p><p><a href="https://css-tricks.com/learning-react-redux/" target="_blank" rel="noopener">Refer: Leveling Up with React: Redux</a>  </p></blockquote><pre><code>Flux架构（单项数据流）：Action -&gt; Store -&gt; View  ^                 |  |_________________|</code></pre><p><strong>Redux特性：</strong></p><ul><li>所有状态放在唯一的一个Store中（Single Source of Truth）</li><li>可预测性（state &amp; action =&gt; new state）</li><li>纯函数更新Store（reducer函数）</li></ul><p><img src="https://css-tricks.com/wp-content/uploads/2016/03/redux-article-3-03.svg" alt="without and with redux"></p><h3 id="header-33">使用</h3><ul><li>安装：<code>yarn add redux</code></li><li>Chrome 辅助调试插件：redux Devtools</li><li>设计理念<ul><li>将组件中的数据都放到一个公用的存储区Store存储管理</li><li>当某个组件改变数据，其他组件会感知到Store中数据的变化，从而进行更新，以此实现组件间的数据传递问题</li><li><img src="/2019/08/15/redux_flow.jpg" alt="Redux Flow"></li></ul></li><li>核心API:<ul><li>创建 store: <ul><li><code>import { createStore } from &#39;redux&#39;;</code></li><li><code>export default createStore(reducer)</code></li></ul></li><li>创建reducer: <ul><li><code>export default (state=defaultState,action) =&gt; { /* ... */ return state}</code></li></ul></li><li>组件中使用:<ul><li>获取store中数据: <code>store.getState()</code></li><li>派发action给store: <code>store.dispatch(action)</code></li><li>订阅store的改变，触发回调函数: <code>store.subscribe(callbackFunc)</code></li></ul></li></ul></li><li>注意：<ul><li>整个应用<code>store</code>是唯一的</li><li>只有<code>store</code>能改变自己的内容(即state),<code>reducer</code>只是返回一个state给store，最终由store来更新</li><li><code>reducer</code>必须是一个纯函数(确定的输入输出，即没有跟时间有关的操作／异步操作等；且不会有任何副作用，如不会对接收的参数做修改)</li></ul></li></ul><h3 id="header-34">Sample:TodoList</h3><ol><li><p>Store (store/index.js)</p><pre><code class="lang-javascript"> import { createStore } from &#39;redux&#39;; import reducer from &#39;./reducer&#39;; const store = createStore(reducer); export default store;</code></pre></li><li><p>Reducer (store/reducer.js)</p><pre><code class="lang-javascript"> const defaultState={     inputValue: &#39;&#39;,     list: [] } export default (state=defaultState,action) =&gt; {     // console.log(state,action)     if (action.type === &#39;change_input_value&#39;){         /*              reducer可以接收state，但不可以修改state，所以深拷贝了一份             将新的state返回给Store，由Store更新Store中的state         */         const newState = JSON.parse(JSON.stringify(state));         newState.inputValue = action.value;         return newState;     }     if (action.type === &#39;submit_input_value&#39;){         const newState = JSON.parse(JSON.stringify(state));         newState.list.push(newState.inputValue);         newState.inputValue=&#39;&#39;;         return newState     }     if (action.type === &#39;delete_list_item&#39;){         const newState = JSON.parse(JSON.stringify(state));         newState.list.splice(action.value,1);         return newState     }     return state; }</code></pre></li><li><p>Component (AntdTodoList.js)</p><pre><code class="lang-java"> import React,{ Component } from &#39;react&#39;; import &#39;antd/dist/antd.css&#39;; import { Input,Button,List,Icon } from &#39;antd&#39;; import store from &#39;./store/index&#39; class AntdTodoList extends Component {     constructor(props){         super(props);         this.state=store.getState();         // this.handleInputChange=this.handleInputChange.bind(this);         // this.handleBtnClick=this.handleBtnClick.bind(this);         this.handleStoreChange=this.handleStoreChange.bind(this);         store.subscribe(this.handleStoreChange);     }     render(){         return (             &lt;div style={{margin:'20px auto',maxWidth:'600px'}}&gt;                 &lt;div style={{padding:'20px 0px',textAlign:'center'}}&gt;                     &lt;h2&gt;TodoList(with Antd UI):&lt;/h2&gt;                     &lt;Input                          placeholder=&#39;Enter todo item here&#39;                          style={{width:'500px',marginRight:'10px'}}                         value={this.state.inputValue}                         onChange={this.handleInputChange}                     /&gt;                     &lt;Button type=&quot;primary&quot; onClick={this.handleBtnClick}&gt;Submit&lt;/Button&gt;                 &lt;/div&gt;                 &lt;List                    bordered                    dataSource={this.state.list}                   renderItem={(item,index) =&gt; (                     &lt;List.Item                          actions={[                             &lt;Icon type=&quot;delete&quot; theme=&quot;filled&quot;                              onClick={this.handleItemDelete.bind(this,index)}/&gt;                         ]}                     &gt;                         {item}                     &lt;/List.Item&gt;                   )}                 /&gt;             &lt;/div&gt;         )     }     handleInputChange(e){         // console.log(e.target.value)         const action = {             type: &#39;change_input_value&#39;,             value: e.target.value         }         store.dispatch(action)     }     handleBtnClick(){         const action = {             type: &#39;submit_input_value&#39;         }         store.dispatch(action)     }     handleItemDelete(index){         // console.log(index)         const action = {             type: &#39;delete_list_item&#39;,             value: index         }         store.dispatch(action)     }     handleStoreChange(){         // console.log(&#39;store state changed&#39;)         this.setState(store.getState())     } } export default AntdTodoList;</code></pre></li></ol><h3 id="header-35">Sample改进：封装action</h3><ol><li><p>src/actionCreator.js 统一创建action</p><pre><code class="lang-javascript"> import * as actionType from &#39;./actionType&#39; const changeInputValueAction = (value) =&gt; ({     // type: &quot;change_input_value&quot;,     type: actionType.ChangeInputValue,     value: value }); const submitInputValueAction = () =&gt; ({     // type: &quot;submit_input_value&quot;     type: actionType.SubmitInputValue }); const deleteListItemAction = (value) =&gt; ({     // type: &quot;delete_list_item&quot;,     type: actionType.DeleteListItem,     value: value }); export {changeInputValueAction,submitInputValueAction,deleteListItemAction}</code></pre></li><li><p>src/actionType.js</p><pre><code class="lang-javascript"> const ChangeInputValue=&quot;change_input_value&quot;; const SubmitInputValue=&quot;submit_input_value&quot;; const DeleteListItem=&quot;delete_list_item&quot;; export {ChangeInputValue,SubmitInputValue,DeleteListItem}</code></pre></li><li><p>Reducer update: src/reducer.js</p><pre><code class="lang-javascript"> import * as actionType from &#39;./actionType&#39; const defaultState={     inputValue: &#39;&#39;,     list: [] } export default (state=defaultState,action) =&gt; {     //if (action.type === &#39;change_input_value&#39;){     if (action.type === actionType.ChangeInputValue){             const newState = JSON.parse(JSON.stringify(state));             newState.inputValue = action.value;             return newState;         }         // if (action.type === &#39;submit_input_value&#39;){         if (action.type === actionType.SubmitInputValue){             const newState = JSON.parse(JSON.stringify(state));             newState.list.push(newState.inputValue);             newState.inputValue=&#39;&#39;;             return newState         }         // if (action.type === &#39;delete_list_item&#39;){         if (action.type === actionType.DeleteListItem){             const newState = JSON.parse(JSON.stringify(state));             newState.list.splice(action.value,1);             return newState         }         return state;     }</code></pre></li><li><p>Component update: AntdTodoList.js</p><pre><code class="lang-java"> handleInputChange(e){     // console.log(e.target.value)     // const action = {     //     type: &#39;change_input_value&#39;,     //     value: e.target.value     // }     const action = actionCreator.changeInputValueAction(e.target.value)      store.dispatch(action) } handleBtnClick(){     // const action = {     //     type: &#39;submit_input_value&#39;     // }     const action = actionCreator.submitInputValueAction()     store.dispatch(action) } handleItemDelete(index){     // console.log(index)     // const action = {     //     type: &#39;delete_list_item&#39;,     //     value: index     // }     const action = actionCreator.deleteListItemAction(index)     store.dispatch(action) }</code></pre></li></ol><h3 id="header-36">Reducer拆分组合</h3><p>使用<code>redux</code>的<code>combineReducers</code>：组合多个<code>reducer</code>,形成一个组合的<code>state</code><br>(注：<code>dispatch</code>一个<code>action</code>时，所有<code>reducer</code>都会收到)</p><p><strong>Sample:</strong></p><ol><li><p>src/common/header/store/reducer.js:</p><pre><code class="lang-javascript"> const defaultState={     focused: false }; export default (state=defaultState,action)=&gt;{     if (action.type==&#39;HeaderSearchFocus&#39;){         return { focused:true}     }     if (action.type==&#39;HeaderSearchBlur&#39;){         return {focused:false}     }     return state; }</code></pre></li><li><p>src/store/reducer.js:</p><pre><code class="lang-javascript"> import { combineReducers } from &#39;redux&#39;; import headerReducer from &#39;../common/header/store/reducer&#39;; export default combineReducers({     header: headerReducer           // 组合多个reducer })</code></pre></li><li><p>src/common/header/index.js:</p><pre><code class="lang-javascript"> const mapStateToProps=(state)=&gt;{     return {         // focused: state.focused         focused: state.header.focused   // Note!     } }</code></pre></li></ol><h3 id="header-37">Redux中间件: Redux-thunk</h3><ul><li>Redux中间件(Middleware)：在action与store中间，对Dispatch做了一个升级封装<ul><li>在dispatcher中截获action做特殊处理后，再发送出去</li><li>即截获action &amp; 发出action</li></ul></li><li><a href="https://github.com/reduxjs/redux-thunk" target="_blank" rel="noopener">redux-thunk</a>: <ul><li>将异步请求或复杂逻辑放到action中处理</li><li>(原本action是一个具体对象，使用thunk后，action还可以是一个函数，然后在这个函数中发送异步请求 =&gt; 异步action)</li><li>install: <code>yarn add redux-thunk</code></li></ul></li></ul><p><strong>Sample:组件获取初始化数据（componentDidMount时触发）</strong></p><ul><li><p>不使用redux-thunk：直接发送异步请求，响应后再发送action给store通知进行后续处理</p><pre><code class="lang-javascript">  // 1. src/actionCreator.js  const initialListItemAction = (value) =&gt; ({      type: actionType.InitialListItem,      value: value  })  // 2. src/actionType.js  const InitialListItem=&quot;initialListItem&quot;;  export {ChangeInputValue,SubmitInputValue,DeleteListItem,InitialListItem}  // 3. src/reducer.js  // ...  if (action.type === actionType.InitialListItem){      const newState = JSON.parse(JSON.stringify(state));      newState.list=action.value;      return newState;  }  // ...  // 4. AntdTodoList.js  import axios from &#39;axios&#39;  // ...  componentDidMount(){      // axios.get(&#39;/todoItems.json&#39;).then((response)=&gt;{      axios.get(&#39;/api/todoItems.json&#39;).then((response)=&gt;{          const data = response.data;          const action = actionCreator.initialListItemAction(data);          store.dispatch(action)      });  }</code></pre></li><li><p>使用redux-thunk: 发送异步action，响应后再发送一个action给store通知进行后续处理</p><pre><code class="lang-javascript">  // 1. store中增加这个中间件: src/index.js  import { createStore, applyMiddleware } from &#39;redux&#39;;  import reducer from &#39;./reducer&#39;;  import thunk from &#39;redux-thunk&#39;;  const store = createStore(reducer,applyMiddleware(thunk));  export default store;  // 2. src/actionCreator.js  import axios from &#39;axios&#39;  const initialListItemAction = (value) =&gt; ({      type: actionType.InitialListItem,      value: value  })  const getListItems = ()=&gt;{      return (dispatch)=&gt;{          // axios.get(&#39;/todoItems.json&#39;).then((response)=&gt;{          axios.get(&#39;/api/todoItems.json&#39;).then((response)=&gt;{                  const data=response.data;              // console.log(data);              const action=initialListItem(data);              dispatch(action);          }).catch((err)=&gt;{              // console.log(err);              const data=[&quot;Load Initial Items Fail!:&quot;+err]              const action=initialListItemAction(data);              dispatch(action);          })      }  }  export {changeInputValueAction,submitInputValueAction,deleteListItemAction,      initialListItemAction,getListItems}  // 3. src/actionType.js &amp; src/reducer.js 同上  // 4. AntdTodoList.js  componentDidMount(){      // axios.get(&#39;/todoItems.json&#39;).then((response)=&gt;{      // axios.get(&#39;/api/todoItems.json&#39;).then((response)=&gt;{      //     const data = response.data;      //     const action = actionCreator.initialListItemAction(data);      //     store.dispatch(action)      // });      const action = actionCreator.getListItems();      store.dispatch(action)  }</code></pre></li></ul><p><strong>注：</strong></p><p>测试时，对于通过<code>create-react-app</code>创建启动的项目，可临时在项目的<code>public</code>目录下临时做个可访问数据,<br>例如：<code>public/api/todoItems.json</code>，可通过<code>http://localhost:3000/api/todoItems.json</code>直接访问文件内容</p><pre><code class="lang-json">[&quot;Reading&quot;,&quot;Watching&quot;]</code></pre><p>也可使用Charles实现本地数据mock</p><h3 id="header-38">Redux中间件: Redux-saga</h3><p><a href="https://github.com/redux-saga/redux-saga" target="_blank" rel="noopener">redux-saga</a></p><ul><li>也是做异步代码拆分的一个中间件，可代替<code>redux-thunk</code></li><li>相较于<code>redux-thunk</code>要复杂的多，有较多的API，可将异步代码完全的拆分到一个单独的文件中，在处理大型项目中，可能要优于<code>redux-thunk</code> (redux-thunk要简单的多，只是让action不仅仅是一个对象，还可以是一个函数)</li><li>install: <code>yarn add redux-saga</code></li></ul><p><strong>Sample:</strong></p><ol><li><p>store中增加这个中间件: src/index.js</p><pre><code class="lang-javascript"> import { createStore, applyMiddleware } from &#39;redux&#39;; import reducer from &#39;./reducer&#39;; import createSagaMiddleware from &#39;redux-saga&#39; import sagas from &#39;./sagas&#39; const sagaMiddleware = createSagaMiddleware() const store = createStore(reducer,applyMiddleware(sagaMiddleware)); sagaMiddleware.run(sagas) export default store;</code></pre></li><li><p>src/sagas.js: 截获指定action，发送异步请求，有响应后再发送action给store通知处理 &lt;= generator &amp; yield （协程）</p><pre><code class="lang-javascript"> import { takeEvery,put } from &#39;redux-saga/effects&#39; import * as actionType from &#39;./actionType&#39; import * as actionCreator from &#39;./actionCreator&#39; import axios from &#39;axios&#39; // 注：必须是generator函数 function* mySaga() {          yield takeEvery(actionType.GetSagaListItems, getListItems); } function* getListItems(){     console.log(&quot;saga: getListItems&quot;)     try{         // const response = yield axios.get(&#39;/todoItems.json&#39;);         const response = yield axios.get(&#39;/api/todoItems.json&#39;);         const data = response.data;         const action=actionCreator.initialListItemAction(data);         yield put(action);     }catch(err){         const data=[&quot;Load Initial Items Fail!:&quot;+err]         const action=actionCreator.initialListItemAction(data);         yield put(action);     } } export default mySaga;</code></pre></li><li>AntTodoList.js : 发送一个action给store（会被中间件saga截获到处理）<pre><code class="lang-javascript"> componentDidMount(){     const action = actionCreator.getSagaListItems();     store.dispatch(action) }</code></pre></li><li><p>src/actionCreator.js</p><pre><code class="lang-javascript"> const initialListItemAction = (value) =&gt; ({     type: actionType.InitialListItem,     value: value || [] }) const getSagaListItems=() =&gt; ({     type: actionType.GetSagaListItems }); export {changeInputValueAction,submitInputValueAction,deleteListItemAction,     initialListItemAction, getSagaListItems}</code></pre></li><li><p>src/actionType.js</p><pre><code class="lang-javascript"> const GetSagaListItems=&quot;getSagaListItems&quot;;    // for redux-saga export {ChangeInputValue,SubmitInputValue,DeleteListItem,         InitialListItem,GetSagaListItems}</code></pre></li></ol><h3 id="header-39">React-redux</h3><p>React中使用Redux</p><ul><li>一个第三方模块(帮助在react中更加方便地使用redux),内部使用了<code>React</code>的<code>Context API</code></li><li><code>Provider</code>(使用<code>Context.Provider</code>): 将store提供给Provider下的所有组件</li><li><code>connect</code>(使用<code>Context.Consumer</code>): 连接作用，映射store信息给Component，工作原理：高阶组件，重新封装返回新的Component</li><li>( <code>Component</code> + <code>store</code> =&gt; <code>new Component</code> )</li></ul><p><strong>Sample：分离业务逻辑和组件</strong></p><ul><li>通过<code>react-redux</code>的<code>Provider</code>传递<code>store</code>给Component</li><li>将TodoList优化为UI Component </li><li>定义store的state和dispatch映射组件props的规则</li><li>通过<code>react-redux</code>的<code>connect</code>, 获取<code>store</code>, 结合定义的连接规则，封装组件和业务逻辑，返回一个新的组件</li><li>(<code>UI Component</code> + <code>mapStateToProps,mapDispatchToProps</code> =&gt; <code>Container Component</code>)</li></ul><ol><li><p><code>Provider</code>提供器: 将store提供给Provider下的所有组件</p><pre><code class="lang-java"> import { Provider } from &#39;react-redux&#39; import store from &#39;./store/index&#39; import TodoListRd from &#39;./TodoListRd&#39; function App() {     return (         {/* store和Provider做了关联，则Provider下的组件都有能力获取到store */}         &lt;Provider store={store}&gt;             &lt;TodoListRd/&gt;         &lt;/Provider&gt;     ) }</code></pre></li><li><p>TodoList优化为UI Component </p><pre><code class="lang-javascript"> import React,{Component} from &#39;react&#39; import &#39;antd/dist/antd.css&#39;; import { Input,Button,List,Icon } from &#39;antd&#39;; // UI组件： const TodoListRd = (props)=&gt;{     const { inputValue, list, handleInputChange, handleBtnClick, handleItemDelete } = props;     return (         &lt;div style={{margin:'20px auto',maxWidth:'600px'}}&gt;             &lt;div style={{padding:'20px 0px',textAlign:'center'}}&gt;                 &lt;h2&gt;TodoList(with Antd UI):&lt;/h2&gt;                 &lt;Input                      placeholder=&#39;Enter todo item here&#39;                      style={{width:'500px',marginRight:'10px'}}                     value={inputValue}                     onChange={handleInputChange}                 /&gt;                 &lt;Button type=&quot;primary&quot; onClick={handleBtnClick}&gt;Submit&lt;/Button&gt;             &lt;/div&gt;             &lt;List                bordered                dataSource={list}               renderItem={(item,index) =&gt; (                 &lt;List.Item                      actions={[                         &lt;Icon                              type=&quot;delete&quot; theme=&quot;filled&quot;                              onClick={()=&gt;{                                 // console.log(&quot;del:&quot;,index,list[index])                                 handleItemDelete(index)                             }}                         /&gt;                     ]}                 &gt;                     {item}                 &lt;/List.Item&gt;               )}             /&gt;         &lt;/div&gt;     ) }</code></pre></li><li><p>定义连接规则，使用<code>connect</code>将UI组件与业务逻辑相结合，返回一个<code>Container</code>组件</p><pre><code class="lang-javascript"> import { connect } from &#39;react-redux&#39; import * as actionCreator from &#39;./store/actionCreator&#39; // 定义连接规则 // 规则1: Map store state to Component props (将store的state映射给组件的props) const mapStateToProps=(state)=&gt;{     return {         inputValue: state.inputValue,         list: state.list     } } // 规则2: Map store dispatch to Component props (将store的dispatch方法挂载给组件的props) const mapDispatchToProps=(dispatch)=&gt;{     return {         handleInputChange(e){             const action = actionCreator.changeInputValueAction(e.target.value)              dispatch(action)         },         handleBtnClick(){             const action = actionCreator.submitInputValueAction()             dispatch(action)         },         handleItemDelete(index){             const action = actionCreator.deleteListItemAction(index)             dispatch(action)         }     } } // 使用connect将UI组件与业务逻辑相结合，返回一个Container组件 export default connect(mapStateToProps,mapDispatchToProps)(TodoList)</code></pre></li></ol><h3 id="header-40">redux-immutable</h3><ul><li>统一数据格式</li><li>install: <code>yarn add redux-immutable</code></li><li>使用<code>redux-immutable</code>中的<code>combineReducers</code>组合reducer =&gt; 将store的state变成immutable对象</li></ul><p><strong>Sample</strong></p><ol><li><p>src/store/index.js</p><pre><code class="lang-javascript"> // import { combineReducers } from &#39;redux&#39;; import { combineReducers } from &#39;redux-immutable&#39;; // 使用redux-immutable中的combineReducers,会将state封装成immutable对象 // import headerReducer from &#39;../common/header/store/reducer&#39;; import { reducer as headerReducer} from &#39;../common/header/store&#39;; export default combineReducers({     header: headerReducer })</code></pre></li><li><p>src/common/header/index.js</p><pre><code class="lang-javascript"> const mapStateToProps=(state)=&gt;{     return {         // focused: state.focused         // focused: state.header.focused         // focused: state.header.get(&#39;focused&#39;)     // Note：这里state.header是一个immutable对象         focused: state.get(&quot;header&quot;).get(&#39;focused&#39;) // Note: 这里state就是一个immutable对象，也可写成 state.getIn([&#39;header&#39;,&#39;focused&#39;])     } }</code></pre></li></ol><h3 id="header-41">组织Action和Reducer</h3><ul><li><p>标准方式：action和reducer分开</p><ul><li>同类action放在一个文件，会无限扩展</li><li>action和reducer分开，实现业务逻辑时需来回切换</li><li>系统有哪些action不够直观</li></ul></li><li><p>新的方式：单个action和reducer放在同一个文件</p><ul><li>以action命名 =&gt; 更直观</li><li>每个action文件都很小，只包括一个action和reducer =&gt; 不用在action和reducer间来回切换，易维护</li></ul></li></ul><p><strong>Sample:Counter</strong></p><ol><li><p>reducer.js &amp; actionCreator.js &amp; store.js:</p><ul><li><code>const store = createStore(reducer)</code> 创建store</li><li><code>.getState()</code> 获取store中state数据</li><li><code>.dispatch(action)</code> 将action分发给reducers</li><li><p><code>.subscribe(callbackListener)</code> 监听store变化，触发回调函数</p><pre><code class="lang-javascript">// 1. reducer: const counter = (state={count:0},action)=&gt;{  switch(action.type){      case &quot;PLUS_ONE&quot;:          return {count:state.count+1}      case &quot;MINUS_ONE&quot;:          return {count:state.count-1}      default:          break;  }  return state;};// 2. actionCreator,return an action objfunction plusCnt(){  return {      type: &#39;PLUS_ONE&#39;  }};function minusOne(){  return {      type: &#39;MINUS_ONE&#39;  }}// 3. storeconst store = createStore(counter)// usage sample:// store.subscribe(//     ()=&gt;{console.log(store.getState())}// )// store.dispatch(plusOne())</code></pre></li></ul></li><li><p>改进：使用工具函数 <code>combineReducers</code>: 组合多个reducer,形成一个组合的state (注：dispatch一个action时，所有reducer都会收到)</p><pre><code class="lang-javascript"> // reducer: import {combineReducers} from &#39;redux&#39;; const counter = (state={count:0},action)=&gt;{     switch(action.type){         case &quot;PLUS_ONE&quot;:             return {count:state.count+1}         case &quot;MINUS_ONE&quot;:             return {count:state.count-1}         default:             break;     }     return state; }; const todos = (state={},action)=&gt;{     return state; }; // store: // const store = createStore(counter) const store = createStore(     combineReducers({         counter,         todos     }) ) // =&gt; state: { //     counter: {count:1}, //     todos:{} // }</code></pre></li><li><p>改进：使用工具函数 <code>bindActionCreators</code>: 重新封装actionCreator，自动调用dispatch</p><pre><code class="lang-javascript"> // action: import {bindActionCreators} from &#39;redux&#39;; // action creator function, return an action obj function plusOne(){     return {         type: &#39;PLUS_ONE&#39;     } }; // bindActionCreators: ()=&gt;{ store.dispatch(plusOne()) } plusOne = bindActionCreators(plusOne,store.dispatch); // previous usage: dispatch(plusOne());  // now could directly use:  // plusOne();</code></pre></li><li><p>App.js &amp; Counter.js: 使用<code>react-redux</code>分离UI&amp;逻辑</p><pre><code class="lang-java"> // 1. App.js: import React,{Component} from &#39;react&#39; import { Provider } from &#39;react-redux&#39; import Counter from &#39;./Counter&#39; export default class CounterSample extends Component {   render() {     return (       &lt;Provider store={store}&gt;         &lt;Counter /&gt;       &lt;/Provider&gt;     );   }</code></pre><pre><code class="lang-java"> // 2. Counter.js: import { connect } from &#39;react-redux&#39;; class Counter extends Component{     render(){         const {count,plusOne,minusOne} = this.props;         return (             &lt;div&gt;                 &lt;div&gt;{count}&lt;/div&gt;                 &lt;button onClick={plusOne}&gt;Plus&lt;/button&gt;                 &lt;button onClick={minusOne}&gt;Minus&lt;/button&gt;             &lt;/div&gt;         )     } } const mapStateToProps=(state)=&gt;{     return {         count: state.count     } }; const mapDispatchToProps=(dispatch)=&gt;{     // return {     //     plusOne     //     ,minusOne     // }     return bindActionCreators({ plusOne, minusOne }, dispatch); }; export default connect(mapStateToProps,mapDispatchToProps)(Counter);</code></pre></li></ol><p><strong>使用新的组织方式组织action &amp; reducer(一个action文件中包括一个action &amp; reducer)</strong></p><ol><li><p>actions/counterPlusOne.js</p><pre><code class="lang-javascript"> // action creator export const counterPlusOne = ()=&gt;{     return {         type: &#39;COUNTER_PLUS_ONE&#39;     } }; // reducer export const reducer = (state,action)=&gt;{     switch(action.type){         case:&#39;COUNTER_PLUS_ONE&#39;:             return {count:state.count+1};         default:             return state;     } }</code></pre></li><li><p>actions/counterMinusOne.js</p><pre><code class="lang-javascript"> // action creator export const counterMinusOne = ()=&gt;{     return {         type: &#39;COUNTER_MINUS_ONE&#39;     } }; // reducer export const reducer = (state,action)=&gt;{     switch(action.type){         case:&#39;COUNTER_MINUS_ONE&#39;:             return {count:state.count-1};         default:             return state;     } }</code></pre></li><li>actions.js<pre><code class="lang-javascript"> export {counterPlusOne} from &#39;./counterPlusOne&#39; export {counterMinusOne} from &#39;./counterMinusOne&#39;</code></pre></li><li>reducer.js<pre><code class="lang-javascript"> export {reducer as counterPlusOneReducer} from &#39;./counterPlusOne&#39; export {reducer as counterMinusOneReducer} from &#39;./counterMinusOne&#39;</code></pre></li></ol><h2 id="header-42">React Router</h2><ul><li>install: <code>yarn add react-router-dom</code></li><li>特性：<ul><li>声明式的路由定义（React组件，可像Tag一样去定义使用）</li><li>动态路由（页面render时实时解析）</li><li>基于路由配置进行资源组织<ul><li>实现业务逻辑的松耦合</li><li>易于扩展，重构和维护</li><li>路由层面实现Lazy Load</li></ul></li></ul></li><li>注：路由不只是页面切换，更是代码组织方式<ul><li>单页应用也需要进行页面切换</li><li>通过URL可以定位到页面</li><li>更有语义的组织资源</li></ul></li><li>应用：管理登录和授权（区分受保护路由和公开路由，访问未授权路由时重定向到登录页面）</li></ul><h3 id="header-43">路由</h3><ul><li><code>Link</code> : 普通链接，不会出发浏览器刷新(用a标签的话，浏览器会刷新)<pre><code class="lang-javascript">  &lt;Link to=&#39;/home&#39;&gt;Home&lt;/Link&gt;</code></pre></li><li><code>NavLink</code> : 类似Link，但是会添加当前选中状态(多了一个css样式设置)<pre><code class="lang-html">  &lt;NavLink to=&quot;/faq&quot; activeClassName=&quot;selected&quot;&gt; FAQs&lt;/NavLink&gt;</code></pre></li><li><code>Prompt</code> : 满足条件时提示用户是否里来当前页面<pre><code class="lang-html">  &lt;Prompt when={formIsHalfFilledOut} message=&quot;Are you sure you want to leave?&quot; /&gt;</code></pre></li><li><code>Redirect</code> : 重定向当前页面，例如：登录判断<pre><code class="lang-html">  &lt;Route exact path=&quot;/&quot; render={()=&gt;(      loggedIn? (&lt;Redirect to=&#39;/dashboard&#39;/&gt;):(&lt;LoginPage/&gt;)  )} /&gt;</code></pre></li><li><code>Route</code> : 路由配置的核心标记，路径匹配时显示对应组件(不排他，多个匹配，则显示多个)<pre><code class="lang-html">  &lt;Route exact path=&quot;/home&quot; component={Home}/&gt;</code></pre></li><li><code>Switch</code> : 只显示第一个匹配的路由(排他，只显示第一个匹配的)<pre><code class="lang-html">  &lt;Switch&gt;      &lt;Route exact path=&quot;/&quot; component={Home}/&gt;      &lt;Route exact path=&quot;/about&quot; component={About}/&gt;      &lt;Route exact path=&quot;/:user&quot; component={User}/&gt;      &lt;Route component={NoMatch}/&gt;  &lt;/Switch&gt;</code></pre></li></ul><h3 id="header-44">路由容器</h3><ul><li><code>BrowserRouter</code> : 使用URL路径 <code>/xxx</code> </li><li><code>HashRouter</code> : 使用Hash路由 <code>#xxx</code></li><li><code>MemoryRouter</code> : 内存路由, 不会反应到URL上</li></ul><pre><code class="lang-java">import React from &#39;react&#39;;import {Route,Link} from &#39;react-router-dom&#39;;import {BrowserRouter as Router} from &#39;react-router-dom&#39;; // import {HashRouter as Router} from &#39;react-router-dom&#39;;// import {MemoryRouter as Router} from &#39;react-router&#39;;     // 与dom无关const RouterSample=(props)=&gt;{    return (        &lt;Router&gt;            &lt;div&gt;                &lt;ul id=&quot;menu&quot;&gt;                    &lt;li&gt;&lt;Link to=&#39;/home&#39;&gt;Home&lt;/Link&gt;&lt;/li&gt;                    &lt;li&gt;&lt;Link to=&#39;/hello&#39;&gt;Home&lt;/Link&gt;&lt;/li&gt;                    &lt;li&gt;&lt;Link to=&#39;/about&#39;&gt;Home&lt;/Link&gt;&lt;/li&gt;                &lt;/ur&gt;            &lt;/div&gt;            &lt;div&gt;                &lt;ul id=&quot;page-container&quot;&gt;                    &lt;Route path=&quot;/home&quot; component={Home}/&gt;                    &lt;Route path=&quot;/hello&quot; component={Hello}/&gt;                    &lt;Route path=&quot;/about&quot; component={About}/&gt;                &lt;/ur&gt;            &lt;/div&gt;        &lt;/Router&gt;    )};export default RouterSample;</code></pre><h3 id="header-45">参数传递</h3><p>通过URL传递参数:</p><ul><li>rule: <code>&lt;Route path=&quot;/topic/:id&quot; component={Topic} /&gt;</code> (<a href="https://github.com/pillarjs/path-to-regexp" target="_blank" rel="noopener">More path rules</a>)</li><li>trigger: <code>&lt;Link to=&quot;/topic/15&gt;Topic_15&lt;/Link&gt;</code></li><li>get params(in the Topic Component): <code>this.props.match.params</code></li><li>注：页面状态尽量通过URL参数传递</li></ul><h3 id="header-46">嵌套路由</h3><p>嵌套路由：每个React组件都可以是路由容器，声明式语法可以很方便的定义嵌套路由</p><pre><code class="lang-java">import { BrowserRouter as Router, Route, Link } from &quot;react-router-dom&quot;;const Category = (props)=&gt; {    return (      &lt;Router&gt;        &lt;div&gt;          &lt;ul id=&quot;menu&quot;&gt;            &lt;li&gt;&lt;Link to=&quot;/category/1&quot;&gt;Category 1&lt;/Link&gt;&lt;/li&gt;            &lt;li&gt;&lt;Link to=&quot;/category/2&quot;&gt;Category 2&lt;/Link&gt;&lt;/li&gt;            &lt;li&gt;&lt;Link to=&quot;/category/3&quot;&gt;Category 3&lt;/Link&gt;&lt;/li&gt;          &lt;/ul&gt;          &lt;div id=&quot;page-container&quot;&gt;            &lt;Route path=&quot;/category/:id&quot; component={SubCategory}/&gt;          &lt;/div&gt;        &lt;/div&gt;      &lt;/Router&gt;    )};const SubCategory = (props)=&gt;{    const categoryId=props.match.params.id    return (        &lt;div&gt;            &lt;h1&gt;Category {categoryId}&lt;/h1&gt;            &lt;ul id=&quot;menu&quot;&gt;              &lt;li&gt;&lt;Link to={`/category/${categoryId}/1`}&gt;Sub Category 1&lt;/Link&gt;&lt;/li&gt;              &lt;li&gt;&lt;Link to={`/category/${categoryId}/2`}&gt;Sub Category 2&lt;/Link&gt;&lt;/li&gt;            &lt;/ul&gt;            &lt;div id=&quot;page-container-2&quot;&gt;              &lt;Route path=&quot;/category/:id/:subId&quot; component={Detail}/&gt;            &lt;/div&gt;          &lt;/div&gt;    )}const Detail = (props) =&gt; (  &lt;h1&gt;Sub Category {props.match.params.subId} Detail&lt;/h1&gt;);export default Category;</code></pre><p><strong>注：</strong></p><pre><code class="lang-java">// 没有使用exact精确匹配// =&gt; Link `/category` 时     , 显示 Category// =&gt; Link `/category/1` 时   , 显示 SubCategory// =&gt; Link `/category/1/2` 时 , 显示Category,SubCategory,Detail&lt;Route path=&quot;/category/:id&quot; component={SubCategory}/&gt;&lt;Route path=&quot;/category/:id/:subId&quot; component={Detail}/&gt;</code></pre><h3 id="header-47">Sample</h3><ol><li><p>App:</p><pre><code class="lang-java"> import React, { Fragment } from &#39;react&#39;; import { BrowserRouter, Route } from &#39;react-router-dom&#39;; import Header from &#39;./common/header&#39;; import Home from &#39;./pages/home&#39;; import Detail from &#39;./pages/detail&#39;; function App() {   return (     &lt;Fragment&gt;          &lt;Header/&gt;         {/*         &lt;BrowserRouter&gt;           &lt;Route path=&#39;/&#39; exact render={()=&gt;(&lt;div&gt;Home&lt;/div&gt;)}&gt;&lt;/Route&gt;           &lt;Route path=&#39;/detail&#39; exact render={()=&gt;(&lt;div&gt;Detail&lt;/div&gt;)}&gt;&lt;/Route&gt;         &lt;/BrowserRouter&gt;         */}         &lt;BrowserRouter&gt;           &lt;Route path=&#39;/&#39; exact component={Home}&gt;&lt;/Route&gt;           &lt;Route path=&#39;/detail/:id&#39; exact component={Detail}&gt;&lt;/Route&gt;         &lt;/BrowserRouter&gt;     &lt;/Fragment&gt;   ); } export default App;</code></pre></li><li><p>Home:</p><pre><code class="lang-java"> import React from &#39;react&#39;; import {Link} from &#39;react-router-dom&#39;; const Home = (props) =&gt; {     return (         &lt;div&gt;             &lt;h1&gt;Home&lt;/h1&gt;             {/*&lt;a href=&quot;/detail&quot;&gt;Detail&lt;/a&gt;*/}             &lt;ul&gt;                 &lt;li&gt;&lt;Link to=&quot;/detail/1&quot;&gt;Go Detail_1&lt;/Link&gt;&lt;/li&gt;                 &lt;li&gt;&lt;Link to=&quot;/detail/2&quot;&gt;Go Detail_2&lt;/Link&gt;&lt;/li&gt;                 &lt;li&gt;&lt;Link to=&quot;/detail/3&quot;&gt;Go Detail_3&lt;/Link&gt;&lt;/li&gt;             &lt;/ul&gt;         &lt;/div&gt;     ) } export default Home;</code></pre></li><li><p>Detail:</p><pre><code class="lang-java"> import React from &#39;react&#39;; import { Link } from &#39;react-router-dom&#39;; const Detail=(props)=&gt;{     // console.log(&quot;props.match&quot;,&quot;eg: /details/1&quot;,props.match)  // props.match.params     // console.log(&quot;props.location&quot;,&quot;eg: /details?id=1&quot;,props.location) // props.location.search     return (         &lt;div&gt;             &lt;h1&gt;Detail:{props.match.params.id}&lt;/h1&gt;             {/*&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;*/}             &lt;Link to=&quot;/&quot;&gt;Back Home&lt;/Link&gt;         &lt;/div&gt;     ) } export default Detail;</code></pre></li></ol><h2 id="header-48">More</h2><h3 id="header-49">react-loadable</h3><p><a href="https://github.com/jamiebuilds/react-loadable" target="_blank" rel="noopener">react-loadable</a> 异步加载组件</p><ul><li>原本一个<code>bundle.js</code>大包了所有组件，第一次加载会比较慢</li><li><code>react-loadable</code>使用时再加载对应组件js =&gt; <code>1.chunk.js</code>,<code>2.chunk.js</code>,…</li><li>install <code>yarn add react-loadable</code></li></ul><p><strong>Sample:</strong></p><ol><li><p>App:</p><pre><code class="lang-java"> import React, { Fragment } from &#39;react&#39;; import { BrowserRouter, Route } from &#39;react-router-dom&#39;; import Header from &#39;./common/header&#39;; import Home from &#39;./pages/home&#39;; // import Detail from &#39;./pages/detail&#39;; import Detail from &#39;./pages/detail/loadable&#39;;  // 使用loadable.js封装的Detail组件 function App() {   return (     &lt;Fragment&gt;          &lt;Header/&gt;         {/*         &lt;BrowserRouter&gt;           &lt;Route path=&#39;/&#39; exact render={()=&gt;(&lt;div&gt;Home&lt;/div&gt;)}&gt;&lt;/Route&gt;           &lt;Route path=&#39;/detail&#39; exact render={()=&gt;(&lt;div&gt;Detail&lt;/div&gt;)}&gt;&lt;/Route&gt;         &lt;/BrowserRouter&gt;         */}         &lt;BrowserRouter&gt;           &lt;Route path=&#39;/&#39; exact component={Home}&gt;&lt;/Route&gt;           &lt;Route path=&#39;/detail/:id&#39; exact component={Detail}&gt;&lt;/Route&gt;         &lt;/BrowserRouter&gt;     &lt;/Fragment&gt;   ); } export default App;</code></pre></li><li><p>Detail组件：</p><pre><code class="lang-java"> import React from &#39;react&#39;; import { Link, withRouter } from &#39;react-router-dom&#39;; const Detail=(props)=&gt;{     return (         &lt;div&gt;             &lt;h1&gt;Detail:{props.match.params.id}&lt;/h1&gt;             {/*&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;*/}             &lt;Link to=&quot;/&quot;&gt;Back Home&lt;/Link&gt;         &lt;/div&gt;     ) } export default withRouter(Detail); // 使用withRouter，否则props.match无法获取到值</code></pre></li><li><p>封装Detail组件：detail/loadable.js</p><pre><code class="lang-java"> import React from &#39;react&#39;; import Loadable from &#39;react-loadable&#39;; const LoadableComponent = Loadable({   loader: () =&gt; import(&#39;./&#39;),           // import component: `Detail`   loading: ()=&gt; &lt;div&gt;Loading...&lt;/div&gt;  // loading component  }); export default ()=&gt;{ return (&lt;LoadableComponent/&gt;) } // 直接返回一个无状态组件</code></pre></li></ol><p><strong>注:<code>react-loadable</code>会使用已经被重命名的react方法<code>componentWillMount</code></strong></p><p>Warning: componentWillMount has been renamed, and is not recommended for use.<br>See <a href="https://fb.me/react-async-component-lifecycle-hooks" target="_blank" rel="noopener">https://fb.me/react-async-component-lifecycle-hooks</a> for details.</p><ul><li>Move code with side effects to componentDidMount, and set initial state in the constructor.</li><li>Rename componentWillMount to UNSAFE<em>componentWillMount to suppress this warning in non-strict mode. In React 17.x, only the UNSAFE</em> name will work. To rename all deprecated lifecycles to their new names, you can run <code>npx react-codemod rename-unsafe-lifecycles</code> in your project source folder.</li></ul><p>Please update the following components: LoadableComponent</p><h3 id="header-50">Next.js 创建同构应用</h3><ol><li><p>同构应用</p><ul><li>第一次发送请求，服务端渲染，返回页面给客户端呈现（客户端不需要再花时间执行js渲染页面)</li><li>后续仍由客户端执行操作</li></ul></li><li><p>使用 Next.js 实现服务器端渲染（无缝同步到客户端）</p><ul><li>install: <code>npm install --save next react react-dom</code></li><li><code>package.json</code>: add cmd<pre><code class="lang-json">  {      &quot;scripts&quot;:{          &quot;dev&quot;:&quot;next&quot;,          &quot;build&quot;:&quot;next build&quot;,          &quot;start&quot;:&quot;next start&quot;      }  }</code></pre></li><li>run: <code>npm run dev</code></li><li>visit: <code>http://localhost:3000</code></li><li>注：<ul><li><code>pages</code>目录: <ul><li>每个文件对应页面路由导航，文件中可定义使用组件</li><li>页面也是标准的node模块，可使用其他React组件</li><li>页面会针对性打包，仅包含其引入的组件</li><li>page具有特殊静态方法<code>getInitialProps</code></li></ul></li><li><code>static</code>目录: 映射静态文件</li></ul></li></ul></li><li><p>使用<code>next/link</code>实现同构路由</p><ul><li><code>next/link</code>定义的链接，点击时页面不会刷新</li><li><code>prefetch</code>属性: 预加载目标资源(但不会加载服务器端API数据)</li><li><p><code>replace</code>属性: 替换URL(配置后当前链接不会包含在浏览器的history中，即无法后退到当前页面)</p><pre><code class="lang-java">import Link from &#39;next/link&#39;;export default ()=&gt;(  &lt;div&gt;      &lt;Link href=&#39;/hello&#39;&gt;&lt;a&gt;Hello&lt;/a&gt;&lt;/Link&gt;      &lt;Link href=&#39;/about&#39; prefetch&gt;&lt;a&gt;About&lt;/a&gt;&lt;/Link&gt;  &lt;/div&gt;)</code></pre></li></ul></li><li><p>使用<code>next/dynamic</code>实现动态加载页面（Lazy Load）</p><pre><code class="lang-java"> import dynamic from &#39;next/dynamic&#39;; const DynamicHello = dynamic(     import(&#39;../components/hello&#39;),{loading:()=&gt;(&lt;p&gt;...&lt;/p&gt;)} ) export default () =&gt; (     &lt;div&gt;         &lt;Header/&gt;         &lt;DynamicHello /&gt;         &lt;p&gt; Home Page &lt;/p&gt;     &lt;/div&gt; )</code></pre></li></ol><h3 id="header-51">单元测试工具</h3><ul><li><p>React让前端单元测试变的容易：</p><ul><li>React应用很少需要访问浏览器API</li><li>虚拟Dom可以再NodeJS环境运行和测试</li><li>Redux隔离了状态管理，纯数据层单元测试</li></ul></li><li><p>单元测试涉及的工具：</p><ul><li><code>Jest</code>: Facebook开源的JS单元测试框架</li><li><code>JS Dom</code>: NodeJS环境中模拟浏览器API</li><li><code>Enzyme</code>: React组件渲染和测试（可直接在NodeJS环境中渲染虚拟Dom和测试）</li><li><code>nock</code>: 模拟HTTP请求</li><li><code>sinon</code>: 函数模拟和调用跟踪</li><li><code>Istanbul</code>: 单元测试覆盖率</li></ul></li></ul><p><strong>Sample: Jest + Enzme</strong></p><pre><code class="lang-javascript">import React from &#39;react&#39;import { shallow } from &#39;enzyme&#39;import CommentItem from &#39;./commentItem&#39;describe(&#39;测试评论列表项组件&#39;, () =&gt; {  // 这是mocha的玩法，jest可以直接兼容  it(&#39;测试评论内容小于等于200时不出现展开收起按钮&#39;, () =&gt; {    const propsData = {      name: &#39;hj&#39;,      content: &#39;测试标题&#39;    }    const item = shallow(&lt;CommentItem {...propsData} /&gt;)    // 这里的断言实际上和chai的expect是很像的    expect(item.find(&#39;.btn-expand&#39;).length).toBe(0);  })  // 这是jest的玩法，推荐用这种  test(&#39;两数相加结果为两个数字的和&#39;, () =&gt; {    expect(3).toBe(3);  });}</code></pre><h3 id="header-52">拆分复杂度: 按领域模型(feature)组织代码</h3><ul><li>按业务逻辑拆分成高内聚松耦合的模块<ul><li>按feature组织component,action,reducer</li><li>使用root loader加载feature下的各个资源</li></ul></li><li>文件夹结构<ul><li>按feature组织源文件</li><li>组件和样式文件同一级</li><li>Redux单独文件夹</li><li>单元测试保持同样目录结构，放在tests文件夹</li></ul></li><li>在每个feature中单独定义自己的路由<ul><li>使用JSON定义顶层路由</li><li>解析JSON配置到React Router语法</li></ul></li></ul><p><strong>Sample:</strong></p><pre><code class="lang-javascript">\src    \commons        configStore.js        rootReducer.js              // combine all features reducers        routeConfig.js                   \features        \commons        \home            \redux                actions.js          // export all below reducers                reducer.js          // export all below actions                constances.js       // export all below constances (use feature name as prefix,eg: HOME_xxx)                counterPlusOne.js   // name as action, include one action,one reducer                counterMinusOne.js            index.js                // export all below components            route.js            style.css               // import all below css            PageNotFound.js            PageNotFound.css            SidePanel.js            SidePanel.css            Counter.js            Counter.css        \about        \article    index.js    logo.svg\tests    \features        \commons        \home        \about        \article</code></pre>]]></content>
    
    <summary type="html">
    
      ReactJS 16
    
    </summary>
    
    
      <category term="ReactJs" scheme="http://sixdegree.github.io/tags/ReactJs/"/>
    
  </entry>
  
  <entry>
    <title>Datastructure &amp; Algorithm (Python)</title>
    <link href="http://sixdegree.github.io/2019/07/20/python-algorithm.html"/>
    <id>http://sixdegree.github.io/2019/07/20/python-algorithm.html</id>
    <published>2019-07-19T16:00:00.000Z</published>
    <updated>2019-10-07T14:36:47.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>算法效率衡量</li><li>顺序表／链表，队列／栈，树，图</li><li>排序，堆，二分搜索，并查集，最小生成树，最短路径</li></ol><a id="more"></a><h2 id="header-1">程序 = 数据结构 + 算法</h2><ul><li>算法: 为了解决实际问题而设计</li><li>数据结构: 算法需要处理的问题载体<ul><li>抽象数据类型(Abstract Data Type)，数据类型和其上的运算捆在一起，进行封装（类）</li><li>Python内置的常用数据结构（非基础数据类型：int,float,str）：tuple, list, dict, set</li><li>常用的数据运算: 插入, 删除, 修改, 查找, 排序</li></ul></li></ul><h2 id="header-2">算法效率衡量</h2><h3 id="header-3">时间复杂度</h3><blockquote><p>程序的运行的计算机环境会影响程序运行的速度并反应在程序的执行时间上,<br>假定计算机执行一个基本操作的时间是固定的(一个时间单位),<br>则可忽略机器环境的影响，用程序运行的基本操作数量客观的反应算法的时间效率,<br>（有多少个基本操作就代表会花费多少时间单位）</p></blockquote><ol><li><p>算法A处理规模为n的问题:</p><ul><li>统计基本操作数量 =&gt; 时间规模函数<code>T(n)</code> </li><li>将时间规模函数<code>T(n)</code>简化为一个数量级（忽略常数因子）=&gt; 数量级函数<code>g(n)</code> =&gt; 渐进时间复杂度,大O记法：<code>O(g(n))</code>（简称时间复杂度）</li><li>注：在没有特殊说明时，分析的算法的时间复杂度都是指<code>最坏时间复杂度</code></li></ul></li><li><p><code>T(n</code>统计规则：</p><ul><li>顺序结构 =&gt; 加法</li><li>循环结构 =&gt; 乘法</li><li>分支结构 =&gt; 取最大值</li></ul></li><li><p><code>T(n)</code> =&gt; <code>O(g(n))</code>规则：</p><ul><li>常数量级(即只有常数项),则用数1表示，eg: <code>T(n)=2 =&gt; g(n)=1 =&gt; O(1)</code></li><li>只需要关注操作数量的最高次项，其它次要项和常数项可以忽略，eg: <code>T(n)=5n^2+3n+2 =&gt; g(n)=n^2 =&gt; O(n^2)</code> </li></ul></li><li><p>常见时间复杂度与比较:</p><table class="table"><thead><tr><th style="text-align:left">T(n)</th><th style="text-align:left">O(n)</th></tr></thead><tbody><tr><td style="text-align:left">12</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">2n+3</td><td style="text-align:left">O(n)</td></tr><tr><td style="text-align:left">3n^2+2n+1</td><td style="text-align:left">O(n^2)</td></tr><tr><td style="text-align:left">5logn+20</td><td style="text-align:left">O(logn)</td></tr><tr><td style="text-align:left">2n+3nlogn+19</td><td style="text-align:left">O(nlogn)</td></tr><tr><td style="text-align:left">6n^3+2n^2+3n+4</td><td style="text-align:left">O(n^3)</td></tr><tr><td style="text-align:left">2^n</td><td style="text-align:left">O(2^n)</td></tr></tbody></table><ul><li>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)<br><img src="/2019/07/20/O.png" alt="时间复杂度比较"></li></ul></li></ol><h3 id="header-4">python性能分析工具</h3><p><code>timeit</code>模块的<code>Timer</code>类:</p><ul><li>测量小段代码的执行速度</li><li>创建：<code>class timeit.Timer(stmt=&#39;pass&#39;, setup=&#39;pass&#39;, timer=&lt;timer function&gt;)</code><ul><li>stmt: 要测试的代码语句</li><li>setup: 运行代码时需要的设置；</li><li>timer: 一个定时器函数，与平台有关</li></ul></li><li>测试：<code>.timeit(number=1000000)</code><ul><li>number: 测试次数(默认100w)</li><li>返回：执行代码的平均耗时（秒数，float类型）</li></ul></li><li>Demo: <a href="https://github.com/sixDegree/python-algorithm/blob/master/1.list-timeit-demo.py" target="_blank" rel="noopener">list timeit</a></li></ul><p><strong>Sample:</strong></p><pre><code class="lang-python">from timeit import Timerdef test_gen1():   l = [i for i in range(1000)]if __name__==&#39;__main__&#39;:    # class timeit.Timer(stmt=&#39;pass&#39;, setup=&#39;pass&#39;, timer=&lt;timer function&gt;)    # timeit.Timer.timeit(number=1000000)    t1=Timer(&quot;test_gen1()&quot;,&quot;from __main__ import test_gen1&quot;)    r1=t1.timeit(number=1000)    print(&quot;test_gen1 : [i for i in range(...)]   =&gt; cost: %.5fs&quot; % r1)    # Run Result:    # test_gen1 : [i for i in range(...)]   =&gt; cost: 0.04163s</code></pre><h2 id="header-5">存储方式</h2><ul><li>顺序存储：元素顺序地存放在一块连续的存储空间中 =&gt; 连续</li><li>链式存储：元素存放在通过链接构造起来的一系列存储空间中 =&gt; 离散</li></ul><h3 id="header-6">顺序存储</h3><p><img src="/2019/07/20/list.png" alt="顺序表"></p><ul><li>存储结构: <ul><li>表头区：存储容量，已使用量等信息</li><li>数据区：存储实际数据元素或元素的地址信息（即链接，指向实际存储的数据元素）</li><li>一体式结构<ul><li>表头区与数据区在一块连续的存储区</li><li>满了，再添加元素时，整体搬迁（整个地址变了）</li></ul></li><li>分离式结构<ul><li>表头区与数据区在二块存储区，通过链接关联</li><li>满了，再添加元素时，数据区搬迁，表头区修改链接指向新的地址</li></ul></li></ul></li><li>添加元素：<ul><li>未满时，不需要进行数据的搬迁</li><li>满时，需进行扩充搬迁，每次扩充可增加固定数目或以倍数增加存储空间</li></ul></li><li>遍历元素：基于下标（逻辑地址，表示相对于表头地址的偏移数量）遍历</li><li>eg：<code>list</code> (python中的顺序表)<ul><li>存储结构: 分离式结构 + 元素外置</li><li>扩充策略：4倍增，到阈值50000时，一倍增</li></ul></li></ul><h3 id="header-7">链式存储</h3><p><img src="/2019/07/20/link.png" alt="链表"></p><ul><li>存储结构: 每个节点（数据区：存储具体的数据 ＋ 链接区：指向下一个节点），节点间通过链接关联起来<ul><li>节点们线性串联：<ul><li>单向链表，单向循环链表</li><li>双向链表，双向循环链表</li></ul></li><li>节点们非线性串联：<ul><li>树</li><li>图</li></ul></li></ul></li><li>添加元素：不需要进行数据的搬迁，可利用任意空闲的内存空间，创建一个节点，通过链接关联</li><li>遍历元素：基于链接关系遍历</li></ul><h2 id="header-8">数据结构（抽象数据类型）</h2><ul><li>列表(顺序存储结构)/链表(链式存储结构)<ul><li>Demo: <a href="https://github.com/sixDegree/python-algorithm/blob/master/2.link-demo.py" target="_blank" rel="noopener">SingleLinkList</a></li></ul></li><li>栈/队列<ul><li>Demo: <a href="https://github.com/sixDegree/python-algorithm/blob/master/3.stack-queue-demo.py" target="_blank" rel="noopener">Stack &amp; Queue</a></li><li>可用顺序／链式存储结构</li><li>栈: 先进后出</li><li>队列: 先进先出</li></ul></li><li>树<ul><li>Demo: <a href="https://github.com/sixDegree/python-algorithm/blob/master/4.tree-demo.py" target="_blank" rel="noopener">Binary Tree</a></li><li>遍历：<ul><li>广度搜索遍历：队列(先进先出) = 层级遍历</li><li>深度搜索遍历：堆栈(先进后出) = 先序遍历</li><li>先序遍历：根 -&gt; 左 -&gt; 右</li><li>中序遍历：左 -&gt; 根 -&gt; 右</li><li>后序遍历：左 -&gt; 右 -&gt; 根</li></ul></li><li>结构: <ul><li>堆：<a href="https://github.com/sixDegree/python-algorithm/blob/master/binaryHeap.py" target="_blank" rel="noopener">Binary Heap</a>,<a href="https://github.com/sixDegree/python-algorithm/blob/master/binaryIndexHeap.py" target="_blank" rel="noopener">Binary Index Heap</a>, d-ary Heap</li><li>搜索树: <a href="https://github.com/sixDegree/python-algorithm/blob/master/binarySearchTree.py" target="_blank" rel="noopener">Binary Search Tree</a></li><li>平衡树：红黑树(B Tree)，2-3 Tree, AVL Tree, Splay Tree</li><li>字典树：Trie Tree</li><li>树堆：Treap（平衡二叉树与堆的结合）</li><li>并查集：Disjoint-set(Union &amp; Find)</li></ul></li></ul></li><li>图<ul><li>Demo: <a href="https://github.com/sixDegree/python-algorithm/blob/master/graph.py" target="_blank" rel="noopener">Graph</a></li><li>点和边组成的数学模型（Vertex &amp; Edge)</li><li>分类：<ul><li>无向图(Undirected) &amp; 有向图(Directed)</li><li>无权图(UnWeighted) &amp; 有权图(Weighted)</li></ul></li><li>存储<ul><li>邻接矩阵 Adjacency Matrix =&gt; 适合表示稠密图(Dense Graph)</li><li>邻接表 Adjacency List =&gt; 适合表示稀疏图(Sparse Graph)</li></ul></li><li>遍历(Travel)：图 =&gt; 树／森林<ul><li>DFS 深度优先遍历（递归,注意记录每个节点是否已遍历）</li><li>BFS 广度优先遍历（非递归,借助队列）</li></ul></li><li>应用：<ul><li>连接问题：连通 =&gt; 判断：两个节点是否连通，是否形成环；统计：区块内节点数量，统计区块数量</li><li>路径问题：寻路 =&gt; 最小生成树(Minimum Span Tree), 最短路径(Shortest Path Tree)</li></ul></li></ul></li></ul><h3 id="header-9">Sample: 单向链表</h3><pre><code class="lang-python">class LinkNode:    def __init__(self,elem=None):        self.elem=elem        self.next=None    def __str__(self):        return self.elem</code></pre><pre><code class="lang-python">class SingleLinkList:    def __init__(self,node=None):        self.head=node        self.count=0    def append(self,item):        node=LinkNode(item)        if self.head is None:            self.head=node        else:            cur=self.head            while cur.next!=None:                cur=cur.next            cur.next=node        self.count+=1        return node    # pop cases:    # --------------------------------------------    # none    # ^         : pos=0,cnt=0 return None    # --------------------------------------------    # A    # 0    # ^         : pos=0,cnt=1 =&gt; head=None,return A    # --------------------------------------------    # A B C D    # 0 1 2 3    # ^         : pos=0,cnt=4 =&gt; head=B,return A    # --------------------------------------------    # A B C D    # 0 1 2 3    #     ^     : pos=2,cnt=4 =&gt; A,B,D, return C    # --------------------------------------------    # A B C D    # 0 1 2 3    #       ^   pos=3,cnt=4 =&gt; A,B,C, return D    # --------------------------------------------    def pop(self,pos=-1):        if pos&lt;0:            pos+=self.count        if pos&gt;=self.count:            return        cur,pre,i=self.head,None,0        while cur.next!=None and i&lt;pos:            pre=cur             cur=cur.next            i+=1        if pre is None:            self.head=cur.next        else:            pre.next=cur.next        self.count-=1        return cur    # insert cases:    # --------------------------------------------    # none    # ^         : pos=0,cnt=0,head=None =&gt; head=H    # --------------------------------------------    # A    # 0    # ^         : pos=0,cnt=1,head=A =&gt; head=H,A    # --------------------------------------------    # A B C D    # 0 1 2 3    # ^         : pos=0,cnt=4,head=A =&gt; head=H,A,B,C,D    # --------------------------------------------    # A B C D    # 0 1 2 3    #     ^     : pos=2,cnt=4,head=A =&gt; A,B,H,C,D    # --------------------------------------------    # A B C D    # 0 1 2 3    #       ^   : pos=3,cnt=4,head=A =&gt; A,B,C,H,D    # --------------------------------------------    # A B C D    # 0 1 2 3    #         ^ : pos=4,cnt=4,head=A =&gt; A,B,C,D,H    # --------------------------------------------    def insert(self,item,pos=0):        if pos&lt;0:            pos+=self.count        if pos&gt;self.count:            return        # if pos==self.count:        #     return self.append(item)        node=LinkNode(item)        if self.head is None:            self.head=node        else:            cur,pre,i=self.head,None,0            while cur.next!=None and i&lt;pos:                pre=cur                cur=cur.next                i+=1            if pre is None:                self.head=node                node.next=cur            elif i&lt;pos:                cur.next=node            else:                pre.next=node                node.next=cur        self.count+=1        return node    def remove(self,item):        cur,pre=self.head,None        while cur!=None:            if cur.elem==item:                if pre is None:                    self.head=cur.next                else:                    pre.next=cur.next                self.count-=1                return cur            pre=cur            cur=cur.next    def travel(self):        result=[]        cur=self.head        while cur!=None:            # print(cur.item,end=&quot; &quot;)            result.append(cur.elem)            cur=cur.next        return result    def is_empty(self):        return self.head is None    def size(self):        return self.count    def clear(self):        self.head=None        self.count=0</code></pre><h3 id="header-10">Sample:栈(使用list模拟)</h3><pre><code class="lang-python"># Stack: 先进后出(可用顺序表或链表实现)class Stack:    def __init__(self):        self.__items=[]    def push(self,item):        self.__items.append(item)   # 尾部插入        return item    def pop(self):        return self.__items.pop()   # 尾部弹出    def is_empty(self):        return len(self.__items)==0    def size(self):        return len(self.__items)</code></pre><h3 id="header-11">Sample: 队列(使用list模拟)</h3><pre><code class="lang-python"># Queue: 先进先出(可用顺序表或链表实现)class Queue:    def __init__(self):        self.__items=[]    def push(self,item):        self.__items.append(item)       # 尾部插入        return item    def pop(self):        return self.__items.pop(0)      # 头部弹出    def is_empty(self):        return len(self.__items)==0    def size(self):        return len(self.__items)</code></pre><h3 id="header-12">Sample: 二叉树</h3><pre><code class="lang-python">class TreeNode:    def __init__(self,elem=None,lchild=None,rchild=None):        self.elem=elem        self.lchild=lchild        self.rchild=rchildclass Tree:    def __init__(self,root=None):        self.root=root    def append(self,elem):        node=TreeNode(elem)        q=[self.root]        while q:            cur=q.pop(0)            if cur is None:                self.root=node                return node            elif cur.lchild is None:                cur.lchild=node                return node            elif cur.rchild is None:                cur.rchild=node                return node            else:                q.extend([cur.lchild,cur.rchild])    def extend(self,elems):        for i in elems:            self.append(i)    # 广度搜索遍历：队列(先进先出),层级遍历    def breadth_travel(self):        result=[]        q=[self.root]        while q:            cur=q.pop(0)        # 头部出            if cur is None:                break            #print(cur.elem,end=&quot; &quot;)            result.append(cur.elem)            if cur.lchild is not None:                q.append(cur.lchild)            if cur.rchild is not None:                q.append(cur.rchild)        return result    # 深度搜索遍历：堆栈(先进后出) = 先序遍历    def deepth_travel(self):        result=[]        q=[self.root]        while q:            cur=q.pop()        # 尾部出            if cur is None:                break;            #print(cur.elem,end=&quot; &quot;)            result.append(cur.elem)            if cur.rchild is not None:                q.append(cur.rchild)            if cur.lchild is not None:                q.append(cur.lchild)        return result    # 先序：根 -&gt; 左 -&gt; 右    def preorder_travel(self,node=None,result=[]):        if node is None and self.root is not None:            node=self.root        #print(node.elem,end=&quot; &quot;)        result.append(node.elem)        if node.lchild is not None:            self.preorder_travel(node.lchild)        if node.rchild is not None:            self.preorder_travel(node.rchild)        return result    # 中序：左 -&gt; 根 -&gt; 右    def inorder_travel(self,node=None,result=[]):        if node is None and self.root is not None:            node=self.root        if node.lchild is not None:            self.inorder_travel(node.lchild)        #print(node.elem,end=&quot; &quot;)        result.append(node.elem)        if node.rchild is not None:            self.inorder_travel(node.rchild)        return result    # 后序：左 -&gt; 右 -&gt; 根    def postorder_travel(self,node=None,result=[]):        if node is None and self.root is not None:            node=self.root        if node.lchild is not None:            self.postorder_travel(node.lchild)        if node.rchild is not None:            self.postorder_travel(node.rchild)        #print(node.elem,end=&quot; &quot;)        result.append(node.elem)        return result</code></pre><p>Test:</p><pre><code class="lang-python">def test_tree():    print(&quot;Test Tree:&quot;)    t=Tree()    t.extend([&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;])    print(r&#39;&#39;&#39;            A        /        \       B          C     /   \       /     D     E    F      &#39;&#39;&#39;)    print(&quot;广度（＝层级）:&quot;, t.breadth_travel())    print(&quot;深度（＝先序）:&quot;, t.deepth_travel())    print(&quot;先序(＝根左右):&quot;, t.preorder_travel())    print(&quot;中序(＝左根右):&quot;, t.inorder_travel())    print(&quot;后序(＝左右根):&quot;, t.postorder_travel())</code></pre><p>Run Result:</p><pre><code class="lang-bash">Test Tree:            A        /        \       B          C     /   \       /    D     E    F广度（＝层级）: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;]深度（＝先序）: [&#39;A&#39;, &#39;B&#39;, &#39;D&#39;, &#39;E&#39;, &#39;C&#39;, &#39;F&#39;]先序(＝根左右): [&#39;A&#39;, &#39;B&#39;, &#39;D&#39;, &#39;E&#39;, &#39;C&#39;, &#39;F&#39;]中序(＝左根右): [&#39;D&#39;, &#39;B&#39;, &#39;E&#39;, &#39;A&#39;, &#39;F&#39;, &#39;C&#39;]后序(＝左右根): [&#39;D&#39;, &#39;E&#39;, &#39;B&#39;, &#39;F&#39;, &#39;C&#39;, &#39;A&#39;]</code></pre><h3 id="header-13">Sample: 稠密图(使用邻接矩阵存储)</h3><pre><code class="lang-python"># n*n matrix, store edge weightclass DenseGraph:    def __init__(self,n,directed=False):        self.n=n        self.directed=directed        self.g=[ [ 0 for i in range(0,n)] for i in range(0,n)]        self.m=0    def addEdge(self,x,y,weight=1):        if self.hasEdge(x,y):            return False        self.g[x][y]=weight        if not self.directed:            self.g[y][x]=weight        self.m+=1        return True    def hasEdge(self,x,y):        assert(x&gt;=0 and x&lt;self.n and y&gt;=0 and y&lt;self.n)        return self.g[x][y]!=0    def getWeight(self,x,y):        assert(x&gt;=0 and x&lt;self.n and y&gt;=0 and y&lt;self.n)        return self.g[x][y]    def getOutNodes(self,x):        assert(x&gt;=0 and x&lt;self.n)        nodes=[]        for i in range(0,self.n):            if self.g[x][i]!=0:                nodes.push(i)        return nodes    def getInNodes(self,x):        assert(x&gt;=0 and x&lt;self.n)        if not self.directed:            return self.g[x]        nodes=[]        for i in range(0,self.n):            if self.g[i][x]!=0:                nodes.push(i)        return nodes    def nextNodeIter(self,x):        assert(x&gt;=0 and x&lt;self.n)        for i in range(0,self.n):            if self.g[x][i]!=0:                yield i    def show(self):        print(&quot;n * m = %d * %d&quot; % (self.n,self.m))        print(&quot;     &quot;,end=&quot;&quot;)        for i in range(0,self.n):            print(&quot;%3s&quot; % i,end=&quot; &quot;)        print(&quot;&quot;)        for i in range(0,self.n):            #print(i,&quot;:&quot;,self.g[i])            print(i,&quot;: &quot;,end=&quot; &quot;)            for j in range(0,self.n):                if self.g[i][j]!=0:                    print(&quot;%3s&quot; % self.g[i][j],end=&quot; &quot;)                else:                    print(&quot;%3s&quot; % &quot;.&quot;,end=&quot; &quot;)            print(&quot;&quot;)</code></pre><h3 id="header-14">Sample: 稀疏图(使用邻接表存储)</h3><pre><code class="lang-python"># n dicts, store linked nodesclass SparseGraph:    def __init__(self,n,directed=False):        self.n=n        self.directed=directed        self.g=[ {} for i in range(0,n)]        self.m=0    def addEdge(self,x,y,weight):        if self.hasEdge(x,y):            return False        self.g[x][y]=weight        if not self.directed and x!=y:            self.g[y][x]=weight        self.m+=1        return True    def hasEdge(self,x,y):        assert(x&gt;=0 and x&lt;self.n and y&gt;=0 and y&lt;self.n)        return self.g[x].get(y) is not None    def getOutNodes(self,x):        assert(x&gt;=0 and x&lt;self.n)        return self.g[x].keys()    def getInNodes(self,x):        assert(x&gt;=0 and x&lt;self.n)        if not self.directed:            return self.g[x]        nodes=[]        for i in range(0,self.n):            if self.hasEdge(i,x):                nodes.push(i)        return nodes    def getWeight(self,x,y):        assert(x&gt;=0 and x&lt;self.n and y&gt;=0 and y&lt;self.n)        assert(self.g[x].get(y) is not None)        return self.g[x][y]    def nextNodeIter(self,x):        assert(x&gt;=0 and x&lt;self.n)        return iter(self.g[x])    def show(self):        print(&quot;n * m = %d * %d&quot; % (self.n,self.m))        for i in range(0,self.n):            print(i,&quot;:&quot;,self.g[i])</code></pre><h3 id="header-15">Sample: 遍历图</h3><pre><code class="lang-python">import randomimport timeimport heapqimport mathclass GraphTestHelper:    def generateRandomGraph(self,n,m,graph,weighted=False,isPrint=False): # n=node numbers; m=edge numbers        i=0        while i&lt;m:            x=random.randrange(0,n)            y=random.randrange(0,n)            if weighted:                w=round(random.random()*100) # round(random.random(),2)            else:                w=1            if x==y or not graph.addEdge(x,y,w):                continue            i+=1        if isPrint:            graph.show()    # 遍历    def travel(self,graph):        visited=[False for i in range(0,graph.n)]        roots=[i for i in range(0,graph.n)]        parents=[-1 for i in range(0,graph.n)]        set_size=[-1 for i in range(0,graph.n)]        conn_grp_cnt=0        for i in range(0,graph.n):            if not visited[i]:                cnt=self.dfs(graph,i,visited,roots,i,parents)                # cnt=self.bfs(graph,i,visited,roots,parents)                set_size[i]=cnt                conn_grp_cnt+=1        print(&quot;nodes     :&quot;,[i for i in range(0,graph.n)])        print(&quot;visited   :&quot;,[i and 1 or 0 for i in visited])        print(&quot;roots     :&quot;,roots)        print(&quot;parents   :&quot;,parents)        print(&quot;set_size  :&quot;,set_size)        print(&quot;conn_grps :&quot;,conn_grp_cnt)        print(&quot;---&quot;*10)    # 深度优先遍历（递归）    def dfs(self,graph,x,visited,roots,r,parents):        cnt=1        visited[x]=True        for i in graph.nextNodeIter(x):            if not visited[i]:                visited[i]=True                roots[i]=r                parents[i]=x                cnt+=self.dfs(graph,i,visited,roots,r,parents)        return cnt    # 广度优先遍历（非递归）    def bfs(self,graph,x,visited,roots,parents):        queue=[x]        cnt=0        while queue:            p=queue.pop(0)            if visited[p]:                continue            visited[p]=True            roots[p]=x            cnt+=1            for i in graph.nextNodeIter(p):                if not visited[i]:                    queue.append(i)                    parents[i]=p        return cnt</code></pre><p>Test</p><pre><code class="lang-python">if __name__ == &#39;__main__&#39;:    testHelper=GraphTestHelper()    # n,m=5,4    # graph=DenseGraph(n,directed=False)    # testHelper.generateRandomGraph(n,m,graph,weighted=True,isPrint=True)    # testHelper.travel(graph)    n=6    graph=SparseGraph(n,directed=False) # graph=DenseGraph(n,directed=False)    graph.addEdge(0,1,5)    graph.addEdge(0,2,1)    graph.addEdge(1,2,2)    graph.addEdge(1,3,1)    graph.addEdge(2,3,4)    graph.addEdge(2,4,8)    graph.addEdge(3,4,3)    graph.addEdge(3,5,6)    graph.show()    testHelper.travel(graph)</code></pre><pre><code>(0) --5-- (1) --1-- (3) --6--(5)|          /        /\1         /        /  \|        2        4    3(2)-----/        /      \|---------------/       (4)</code></pre><p>Sparse Graph Run Result:</p><pre><code>n * m = 6 * 80 : {1: 5, 2: 1}1 : {0: 5, 2: 2, 3: 1}2 : {0: 1, 1: 2, 3: 4, 4: 8}3 : {1: 1, 2: 4, 4: 3, 5: 6}4 : {2: 8, 3: 3}5 : {3: 6}nodes     : [0, 1, 2, 3, 4, 5]visited   : [1, 1, 1, 1, 1, 1]roots     : [0, 0, 0, 0, 0, 0]parents   : [-1, 0, 1, 2, 3, 3]set_size  : [6, -1, -1, -1, -1, -1]conn_grps : 1</code></pre><p>Dense Graph Run Result: </p><pre><code>n * m = 6 * 8       0   1   2   3   4   50 :    .   5   1   .   .   .1 :    5   .   2   1   .   .2 :    1   2   .   4   8   .3 :    .   1   4   .   3   64 :    .   .   8   3   .   .5 :    .   .   .   6   .   .nodes     : [0, 1, 2, 3, 4, 5]visited   : [1, 1, 1, 1, 1, 1]roots     : [0, 0, 0, 0, 0, 0]parents   : [-1, 0, 1, 2, 3, 3]set_size  : [6, -1, -1, -1, -1, -1]conn_grps : 1</code></pre><h2 id="header-16">算法: 排序</h2><ul><li><p>基础排序(<a href="https://github.com/sixDegree/python-algorithm/blob/master/sortBasic.py" target="_blank" rel="noopener">Demo</a>) =&gt; 平均时间复杂度：O(N^2)</p><ul><li>选择排序 Selection Sort</li><li>插入排序 Insertion Sort -&gt; 希尔排序 Shell Sort</li><li>冒泡排序 Bubble Sort</li></ul></li><li><p>高级排序(<a href="https://github.com/sixDegree/python-algorithm/blob/master/sortAdvance.py" target="_blank" rel="noopener">Demo</a>) =&gt; 平均时间复杂度：O(N*logN)</p><ul><li>归并排序 Merge Sort</li><li>快速排序 Quick Sort</li><li>堆排序 Heap Sort</li><li>注：Merge Sort &amp; Quick Sort本质就是一颗二叉树的深度搜索(先序／后序)</li></ul></li><li><p>O(N*logN) 比 O(N^2) 快多少：</p><table class="table"><thead><tr><th style="text-align:left">N</th><th style="text-align:left">N^2</th><th style="text-align:left">N*logN</th><th style="text-align:left">差倍数</th></tr></thead><tbody><tr><td style="text-align:left">10</td><td style="text-align:left">10^2</td><td style="text-align:left">33</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">10^2</td><td style="text-align:left">10^4</td><td style="text-align:left">664</td><td style="text-align:left">15</td></tr><tr><td style="text-align:left">10^3</td><td style="text-align:left">10^6</td><td style="text-align:left">9966</td><td style="text-align:left">100</td></tr><tr><td style="text-align:left">10^4</td><td style="text-align:left">10^8</td><td style="text-align:left">132877</td><td style="text-align:left">753</td></tr><tr><td style="text-align:left">10^5</td><td style="text-align:left">10^10</td><td style="text-align:left">1660964</td><td style="text-align:left">6020</td></tr></tbody></table></li><li><p>排序算法的稳定性：</p><ul><li>稳定排序算法会让原本有相等键值的记录维持相对次序</li><li>eg: <code>[(4, 1),(3, 1),(3, 7),(5, 6)]</code> 按tuple的第一个元素排序<ul><li>=&gt; <code>[(3, 1),(3, 7),(4, 1),(5, 6)]</code> =&gt; <code>(3, 1)</code>和<code>(3, 7)</code>维持次序 =&gt; 稳定</li><li>=&gt; <code>[(3, 7),(3, 1),(4, 1),(5, 6)]</code> =&gt; <code>(3, 1)</code>和<code>(3, 7)</code>次序改变 =&gt; 不稳定</li></ul></li></ul></li><li><p>算法比较：</p><table class="table"><thead><tr><th style="text-align:left">Sort</th><th style="text-align:left">平均时间复杂度</th><th style="text-align:left">原地</th><th style="text-align:left">额外空间复杂度</th><th style="text-align:left">稳定</th></tr></thead><tbody><tr><td style="text-align:left">Insertion Sort</td><td style="text-align:left">O(N^2)</td><td style="text-align:left">Y</td><td style="text-align:left">O(1)</td><td style="text-align:left">Y</td></tr><tr><td style="text-align:left">Merge Sort</td><td style="text-align:left">O(N*logN)</td><td style="text-align:left">N</td><td style="text-align:left">O(N+logN)</td><td style="text-align:left">Y</td></tr><tr><td style="text-align:left">Quick Sort</td><td style="text-align:left">O(N*logN)</td><td style="text-align:left">Y</td><td style="text-align:left">O(logN)</td><td style="text-align:left">N</td></tr><tr><td style="text-align:left">Heap Sort</td><td style="text-align:left">O(N*logN)</td><td style="text-align:left">Y</td><td style="text-align:left">O(1)</td><td style="text-align:left">N</td></tr></tbody></table></li><li><p>其它：不基于比较的排序(<a href="https://github.com/sixDegree/python-algorithm/blob/master/6.sort-nocompare.py" target="_blank" rel="noopener">Demo</a>) =&gt; 时间复杂度: <code>O(N)</code>,空间复杂度: <code>O(M)</code> （思想来自桶排序，M＝桶数）</p><ul><li>桶排序 bucket sort</li><li>计数排序 Counting Sort</li><li>基数排序 Radix Sort</li></ul></li><li><p>算法选择：</p><ul><li>大量重复元素：3路快排</li><li>近乎有序：插入排序</li><li>取值范围有限：计数排序</li><li>要稳定：归并排序</li><li>链表存储：归并排序</li><li>大数据，无法一次性装入内存：外排序</li></ul></li></ul><h3 id="header-17">基础: 选择排序(Selection)</h3><ul><li><code>[min,...,max ^ | ...min...]</code><ul><li>列表看成两段(<code>[0,j] &amp; [j+1,n-2],i:[j+1 -&gt; n-1]</code>)，前段的尾部，每轮增加下一个有序元素</li><li>每轮循环，通过比较，记录最大／最小元素的索引，与后段第一个元素交换位置，作为前段尾部新元素（列表前段是排好序的）</li></ul></li><li>时间复杂度: <code>O(N^2)</code></li><li>空间复杂度: <code>O(1)</code></li><li>算法稳定性: <code>不稳定</code></li></ul><pre><code class="lang-python">. initial(n=9):           [^|54,26,93,17,77,31,44,55,20]. 1st (54 &lt;-&gt; 17) result: [17,| 26,93,54,77,31,44,55,20]. 2nd (26 &lt;-&gt; 26) result: [17,20,| 93,54,77,31,44,55,26]. 3rd (93 &lt;-&gt; 20) result: [17,20,26,| 54,77,31,44,55,93]. 4th (54 &lt;-&gt; 31) result: [17,20,26,31,| 77,54,44,55,93]. 5th (77 &lt;-&gt; 44) result: [17,26,20,31,44,| 54,77,55,93]. 6th (54 &lt;-&gt; 54) result: [17,26,20,31,44,54,| 77,55,93]. 7th (77 &lt;-&gt; 55) result: [17,26,20,31,44,54,55,| 77,93]. 8th (77 &lt;-&gt; 77) result: [17,26,20,31,44,54,55,77,| 93]. =&gt; Final: [17,20,16,31,44,54,55,77,93]</code></pre><pre><code class="lang-python">def selection_sort(a,n):    &#39;&#39;&#39;    2层循环都必须执行完成，时间复杂度为O(N^2)    &#39;&#39;&#39;    for j in range(0,n-1):              # j: [0,n-2]        min_index=j        for i in range(j+1,n):          # i: [j+1,n-1]            if a[min_index]&gt;a[i]:                min_index=i        a[j],a[min_index]=a[min_index],a[j]        #print(&quot;j = %d, a = %s&quot; % (j,a))    #print(&quot;Final: a =&quot;,a)</code></pre><h3 id="header-18">基础: 插入排序(Insertion)</h3><ul><li><code>[min,...,max &lt;-&gt; | &lt;=,....]</code><ul><li>列表看成两段(<code>[0,j] &amp; [j+1,n-1],i:[1&lt;-j]</code>)，前段是有序的，后段是未排序的，每轮前段中插入一个元素</li><li>每轮循环，取后段第一个元素，与前段元素从后往前依次比较交换位置，直到插到正确位置</li><li>优化：1次交换，相当于3次赋值（temp暂存）=&gt; 使用赋值来代替交换</li></ul></li><li>时间复杂度：<code>O(N)</code>:已有序 ~ <code>O(N^2)</code> ~ <code>O(N^2)</code></li><li>空间复杂度: <code>O(1)</code></li><li>算法稳定性：<code>稳定</code></li></ul><pre><code class="lang-python">. initial(n=9): [54,| 26,93,17,77,31,44,55,20]. 1nd result:   [26,54,| 93,17,77,31,44,55,20]. 2rd result:   [26,54,93,| 17,77,31,44,55,20]. 3th result:   [17,26,54,93,| 77,31,44,55,20]. 4th result:   [17,26,54,77,93,| 31,44,55,20]. 5th result:   [17,26,31,54,77,93,| 44,55,20]. 6th result:   [17,26,31,44,54,77,93,| 55,20]. 7th result:   [17,26,31,44,54,55,77,93,| 20]. 8th result:   [17,20,26,31,44,54,55,77,93,|]. =&gt; Final: [17,20,16,31,44,54,55,77,93]</code></pre><pre><code class="lang-python">def insertion_sort(a,n):    &#39;&#39;&#39;    似打牌时整理牌    2层循环，内层循环可提前终止，对近乎有序的效率更高    时间复杂度：O(N^2), 有序时近乎 O(N) -- 内层循环很快退出    &#39;&#39;&#39;    # for j in range(1,n):    #     i=j    #     # 从第i个元素开始向前比较，如果小于前一个元素，交换位置    #     while i&gt;=1:    #         if a[i]&lt;a[i-1]:    #             a[i],a[i-1]=a[i-1],a[i]    #             i-=1    #         else:    #             break    #     print(&quot;j = %d, a = %s&quot; % (j,a))    for j in range(1,n):                # j: [1,n-1]        for i in range(j,0,-1):         # i: [j,1]            if a[i]&lt;a[i-1]:                a[i],a[i-1]=a[i-1],a[i]            else:                break</code></pre><pre><code class="lang-python">def insertion_sort_optimize(a,l,r):         # [l,r-1] &lt;= l=0,r=n    &#39;&#39;&#39;    1次交换，相当于3次赋值（temp暂存）－－ 优化：使用赋值来代替交换    &#39;&#39;&#39;    for j in range(l+1,r):                # j: [l+1,r-1]        t=a[j]        i=j                             # i: [j,l+1]        while i&gt;l and a[i-1]&gt;t:            a[i]=a[i-1]            i-=1        a[i]=t</code></pre><h3 id="header-19">基础: 希尔排序(Shell)</h3><ul><li><code>[min,...,,max| &lt;=...]</code><ul><li>按一定步长进行插入排序(改进版插入排序)</li><li>每次都和之前第step个元素比较, step逐渐缩小到1，一步一步地将无序数组变成近乎有序地数组</li><li>step为1时，则为普通的插入排序，排完，则得到最终有序数组</li><li>有序性强的数组，使用插入排序法，更快</li></ul></li><li>时间复杂度：<code>O(N*logN)</code> ～ <code>O(N^1.5)</code> ～ <code>O(N^2)</code></li><li>空间复杂度: <code>O(1)</code></li><li>算法稳定性: <code>不稳定</code></li></ul><pre><code class="lang-python">. initial(n=21): [ 13,14,94,33,82,25,59,94,65,23,45,27,73,25,39,10 ]. 1nd(step=5) : [ 13,14,94,33,82,| 25,59,94,65,23,| 45,27,73,25,39,| 10 ]    : 13,               |25,                     45,                 10    :    14,            |    59,                     27,    :       94,         |        94,                     73,    :          33,      |            65,                     25,    :             82    |                23,                     39    =&gt; result: [10,14,73,25,25,| 13,27,94,33,39,| 25,59,94,65,82,| 45]. 2nd(step=3): [10,14,73,| 25,25,13,| 27,94,33,| 39,25,59,| 94,65,82,| 45]    10,         |25,         27,         39,         94,         45        14,     |    25,         94,         25,         65,            73, |        13,         33,         59,         82,    =&gt; result: [10,14,13,| 25,25,33,| 27,25,59,| 39,65,73,| 45,94,82,| 94]. 3nd(step=1):     =&gt; result: [10,13,14,25,25,25,27,33,39,45,59,65,73,82,94,94]</code></pre><pre><code class="lang-python">def shell_sort(a,n):    &#39;&#39;&#39;    升级版的插入排序    时间复杂度：O(N*logN)~O(N^2)，根据step不同而不同，统计平均：O(N^1.5)    每次都和之前第step个元素比较    step逐渐缩小到1，一步一步地将无序数组变成近乎有序地数组    step为1时，则为普通的插入排序，排完，则得到最终有序数组    （有序性强的数组，使用插入排序法，更快）    &#39;&#39;&#39;    step=n//2    while step!=0:        # 按步长进行插入排序        for j in range(step,n):             # j: [step,n-1]            t=a[j]            i=j            while i&gt;=step and a[i-step]&gt;t:  # i:[j,1]                a[i]=a[i-step]                i-=step            a[i]=t        step=step//2</code></pre><h3 id="header-20">基础: 冒泡排序(Bubble)</h3><ul><li><code>[&lt;=&gt; |-&gt;,max]</code><ul><li>列表看成两段([0,j-1] &amp; [j,n-1],i:[0 -&gt; j-1])，后段头部，每轮增加下一个有序元素</li><li>每轮循环，通过交换移动最大／最小元素到前段最后，作为后段头部新元素 (列表后段是排好序的)</li><li>优化：若遍历一次发现没有任何可以交换的元素，则排序结束</li></ul></li><li>时间复杂度：<code>O(N)</code> ~ <code>O(N^2)</code> ~ <code>O(N^2)</code></li><li>空间复杂度 <code>O(1)</code></li><li>算法稳定性：<code>稳定</code></li></ul><pre><code class="lang-python">. initial(n=9): [54,26,93,17,77,31,44,55,20|^]. 1st result:   [26,54,17,77,31,44,55,20,| 93]. 2nd result:   [26,17,54,31,44,55,20,| 77,93]. 3rd result:   [17,26,31,44,54,20,| 55,77,93]. 4th result:   [17,26,31,44,20,| 54,55,77,93]. 5th result:   [17,26,31,20,| 44,54,55,77,93]. 6th result:   [17,26,20,| 31,44,54,55,77,93]. 7th result:   [17,20,| 26,31,44,54,55,77,93]. 8th result:   [17,| 20,26,31,44,54,55,77,93] . =&gt; Final: [17,20,16,31,44,54,55,77,93]</code></pre><pre><code class="lang-python">def bubble_sort(a,n):    # for j in range(n-1,0,-1):                # j: [n-1,1]    #     for i in range(0,j):                 # i: [0,j-1]    #         if a[i]&gt;a[i+1]:    #             a[i],a[i+1]=a[i+1],a[i]    for j in range(n-1,0,-1):                # j: [n-1,1]        swap_cnt=0        for i in range(0,j):                 # i: [0,j-1]            if a[i]&gt;a[i+1]:                a[i],a[i+1]=a[i+1],a[i]                swap_cnt+=1        if swap_cnt==0:            break</code></pre><h3 id="header-21">高级: 归并排序(Merge)</h3><p><code>[ | ] =&gt;  [][]|[][] =&gt; []</code> </p><pre><code>+ 分治法: 不断递归分解为两半，分别排序后，归并到一个有序序列+ 执行顺序似后序（左右根）遍历树+ 优化（非数量级上的优化，但让性能更优）    * 序列分到比较小时，近乎有序的概率比较大，使用插入排序更优    * 前后段已经有序，可直接合并返回</code></pre><ul><li>时间复杂度：<code>O(N*logN)</code></li><li>空间复杂度：<code>O(N)</code></li><li>算法稳定性: <code>稳定</code></li></ul><pre><code class="lang-python">. initial(n=9): [54,26,93,17,77,31,44,55,20]. part1:     54, 26,   93, 17, 77, 31, 44, 55, 20                     ^    54, 26,   93, 17 |  77, 31,   44, 55, 20            ^                   ^    54, 26, |  93, 17   77, 31, | 44, 55, 20        ^          ^        ^         ^    54,| 26    93,| 17  77,| 31,  44,| 55, 20                                          ^                                       55 | 20. part2:    [54] [26] =&gt; [26, 54]    [93] [17] =&gt; [17, 93]    [26, 54] [17, 93] =&gt; [17, 26, 54, 93]    [77] [31] =&gt; [31, 77]    [55] [20] =&gt; [20, 55]    [44] [20, 55] =&gt; [20, 44, 55]    [31, 77] [20, 44, 55] =&gt; [20, 31, 44, 55, 77]    [17, 26, 54, 93] [20, 31, 44, 55, 77] =&gt; [17, 20, 26, 31, 44, 54, 55, 77, 93]</code></pre><pre><code class="lang-python">def merge_sort_optimize(a,n):    &#39;&#39;&#39;    归并排序 -- 递归实现    优化（非数量级上的优化，但让性能更优）：        1. 序列分到比较小时，近乎有序的概率比较大，使用插入排序更优            插入排序：O(n^2); 归并排序：O(n*logn)             插入排序的O(n^2)系数比归并排序的O(n*logn)小            n 小到一定程度时，插入排序比较快        2. 前后段已经有序，可直接合并返回（对完全随机的序列效果不是很明显）    &#39;&#39;&#39;    if n&lt;=1:        return a    # optimize1: 序列分到比较小时，近乎有序的概率比较大，使用插入排序    if n&lt;=10:        sortBasic.insertion_sort_optimize(a,0,n)        return a    # 1. 分    mid=n//2    # print(&quot;p_left=&quot;,a[:mid],&quot;, p_right=&quot;,a[mid:])    a_left=merge_sort_optimize(a[:mid],mid)         # [0,mid)    a_right=merge_sort_optimize(a[mid:],n-mid)      # [mid,n)    # print(&quot;n_left=&quot;,a_left,&quot;, n_right=&quot;,a_right)    # 2. 合    i,left_len=0,len(a_left)    j,right_len=0,len(a_right)    # optimize2: 前后段已经有序，可直接合并返回    if a_left[mid-1]&lt;=a_right[0]:        a[0:]=a_left+a_right        return a    for k in range(0,n):        if i&gt;=left_len:            a[k:]=a_right[j:]            break        elif j&gt;=right_len:            a[k:]=a_left[i:]            break        if a_left[i]&lt;a_right[j]:            a[k]=a_left[i]            i+=1        else:            a[k]=a_right[j]            j+=1    # print(&quot;a=&quot;,a)    return a</code></pre><h3 id="header-22">高级: 快速排序(Quick)</h3><ul><li><p>划分交换排序</p><ul><li><p>1路快排：<code>{base}[lt][ge][...]</code></p><pre><code class="lang-bash">  －－－－－－－－－－－－－－－－－  |v|  &lt;v  |   &gt;=v   |e      |  －－－－－－－－－－－－－－－－－   l      j j+1       i       r  for i in [l+1,r-1]:      a[i]&lt;v =&gt; a[j+1]&lt;-&gt;a[i],j++      a[i]&gt;=v =&gt; /  =&gt; j: 指向小于v的最后一个元素  =&gt; a[l]&lt;-&gt;a[j] =&gt; a[j]: 等于v  =&gt; 返回分界点: j</code></pre></li><li><p>2路快排：<code>{base}[le][...][ge]</code> (等于base的分散在左右两侧，左右i,j两指针)</p><pre><code class="lang-bash">  －－－－－－－－－－－－－－－－－------  |v|    &lt;=v    |e|      |    &gt;=v  |  －－－－－－－－－－－－－－－－－------   l             i      j j+1       r  while True:      &#39;&#39;&#39;      注：不使用等号 a[i]&lt;v,a[j]&gt;v      eg: [5,3,2,5,5,5,7,8] 有多个连续相同的值          多了等号会将这些值归到其中一边，造成两颗子树不平衡 =&gt; [3,2]5[5,5,7,8]          不使用等号，分到中间，两颗子树更平衡 =&gt; [3,2,5]5[5,5,7,8]      &#39;&#39;&#39;      while i&lt;r and a[i]&lt;v : i++      while j&gt;l and a[j]&lt;v : j--      if i&gt;=j:          break      a[i]&lt;-&gt;a[j],i++,j--  =&gt; j: 指向小于v的最后一个元素  =&gt; a[l]&lt;-&gt;a[j] =&gt; a[j]: 等于v  =&gt; 返回分界点: j</code></pre></li><li><p>3路快排：<code>{base}[lt][eq][...][gt]</code></p><pre><code class="lang-bash">  －－－－－－－－－－－－－－－－－-------------  |v|    &lt;v    |   =v   |e|      |    &gt;v  |  －－－－－－－－－－－－－－－－－-------------   l         lt          i        gt       r  a[l+1,lt], a[lt+1,i-1], a[i,gt-1], a[gt,r-1]      &lt;v          =v         e         &gt;v  lt: 指向小于v的最后一个元素  gt: 指向大于v的第一个元素  for i in [l+1,r-1]:      a[i]&lt;v      =&gt;  a[i]&lt;-&gt;a[lt], lt++, i++      a[i]==v     =&gt;  i++      a[i]&gt;v      =&gt;  a[i]&lt;-&gt;a[gt], gt--, /      i==gt       =&gt;  break  =&gt; lt,gt  =&gt; a[l]&lt;-&gt;a[lt]  =&gt; 返回分界点: lt,gt</code></pre></li></ul></li><li>时间复杂度：<code>O(N*logN)</code> ～ <code>O(N*logN)</code> ～ <code>O(N^2)</code></li><li>空间复杂度：<code>O(logN)</code> ~ <code>O(N)</code></li><li>算法稳定性：<code>不稳定</code></li><li>优化：<ul><li>小序列时，采用插入排序</li><li>快爬无法保证partition可以对分，时间复杂度无法保证为<code>O(N*logN)</code><ul><li>近乎有序数组时，树的平衡度很差，无法保证树高度为<code>logN</code></li><li>极端情况下，有序数组，则树的一边高度即为N，时间复杂度退化到<code>O(N^2)</code>比归并排序<code>O(N*logN)</code>慢的多</li><li>solution: 随机选择标定元素，交换到数组头(<code>a[l]</code>)后再进行partition =&gt; 退化到O(N^2)的概率降低了很多</li></ul></li><li>对于有很多重复元素的序列<ul><li>可使用2路快排（重复元素分散到左右子树）</li><li>或进一步3路快排（划分出相等的元素块，不用对重复元素做重复操作）</li></ul></li><li>使用赋值操作减少交换操作</li></ul></li></ul><p><strong>Sample: one partition</strong></p><pre><code class="lang-python">def quick_sort_one_partition(a,n):    def one_partition(a,l,r):        v=a[l]        j=l        for i in range(l+1,r):            if a[i]&lt;v:                a[j+1],a[i]=a[i],a[j+1]                j+=1        a[l],a[j]=a[j],a[l]        return j    def do_quick_sort(a,l,r):        if l&gt;=r-1:            return        j=one_partition(a,l,r)        do_quick_sort(a,l,j)        do_quick_sort(a,j+1,r)    do_quick_sort(a,0,n)</code></pre><p><strong>Sample: two partition</strong></p><pre><code class="lang-python">def quick_sort_two_partition(a,n):    def two_partition(a,l,r):        v=a[l]        i,j=l+1,r-1        while True:            while i&lt;r and a[i]&lt;v:                i+=1            while j&gt;l and a[j]&gt;v:                j-=1            if i&gt;=j:                break            a[i],a[j]=a[j],a[i]            i+=1            j-=1        a[l],a[j]=a[j],a[l]        return j    def do_quick_sort(a,l,r):        if l&gt;=r-1:            return        j=two_partition(a,l,r)        # print(a[l:j],a[j],a[j+1:r])        do_quick_sort(a,l,j)        do_quick_sort(a,j+1,r)    do_quick_sort(a,0,n)</code></pre><p><strong>Sample: three partition</strong></p><pre><code class="lang-python">def quick_sort_three_partition(a,n):    def three_partition(a,l,r):        v=a[l]        lt,gt=l,r        i=l+1        while i&lt;r:            if a[i]&lt;v:                a[i],a[lt+1]=a[lt+1],a[i]                lt+=1                i+=1            elif a[i]&gt;v:                a[i],a[gt-1]=a[gt-1],a[i]                gt-=1            else:                i+=1            if i&gt;=gt:                break        a[l],a[lt]=a[lt],a[l]        return lt,gt    def do_quick_sort(a,l,r):        if l&gt;=r-1:            return        lt,gt=three_partition(a,l,r)        # print(a[l:lt],a[lt:gt],a[gt:r])        do_quick_sort(a,l,lt)         # [l,lt-1]        do_quick_sort(a,gt,r)         # [gt,r-1]    do_quick_sort(a,0,n)</code></pre><p><strong>Sample: 优化</strong></p><pre><code class="lang-python">def quick_sort_optimize(a,n):    def two_partition(a,l,r):        # optimize2: 随机选择标定元素(对于近乎有序数组，平衡左右子树，减少到退化到O(N^2)的概率)        # i=random.randint(l,r-1)   # 耗时!        i=(l+r)//2        a[i],a[l]=a[l],a[i]        v=a[l]        &#39;&#39;&#39;        # optimize: 等于v的分散在左右两侧        &#39;&#39;&#39;        i,j=l+1,r-1        while True:            while i&lt;r and a[i]&lt;v:                i+=1            while j&gt;l and a[j]&gt;v:                j-=1            if i&gt;=j:                break            a[i],a[j]=a[j],a[i]            i+=1            j-=1        a[l],a[j]=a[j],a[l]        &#39;&#39;&#39;        optimize: 使用赋值操作减少交换操作            尾部指针，从后往前，找到比基准小的值，拷贝数据到头指位置            头部指针，从前往后，找到比基准大的值，拷贝数据到尾指位置            头尾部指针交替运行，直到相遇，拷贝基准值到该位置        =&gt; 等于v的会集中在某一侧        =&gt; 注：有大量重复元素时，不推荐        &#39;&#39;&#39;        # i,j=l,r-1        # while i&lt;j:        #     while j&gt;i and a[j]&gt;=v:        #         j-=1        #     a[i]=a[j]        #     while i&lt;j and a[i]&lt;v:        #         i+=1        #     a[j]=a[i]        # a[j]=v        return j    def do_quick_sort(a,l,r):        if l&gt;=r-1:            return        # optimize1: 使用插入排序(小序列，近乎有序)        # if r-l&lt;=10:        #     sortBasic.insertion_sort_optimize(a,l,r)        # optimize3: 有大量重复元素，使用2/3路快排        j=two_partition(a,l,r)        #print(a[l:j],a[j],a[j+1:r])        do_quick_sort(a,l,j)        do_quick_sort(a,j+1,r)    do_quick_sort(a,0,n)</code></pre><h3 id="header-23">高级: 堆排序(Heap)</h3><ul><li>堆: 完全二叉树,用数组列表存储元素：<ul><li>从上到下，从左到右，按层序存放</li><li>parent<code>=(i-1)/2</code></li><li>left_child<code>=2i+1</code></li><li>right_child<code>=2i+2</code></li></ul></li><li><p>堆化（Heapify) =&gt; 构建 大根堆(<code>parent&gt;=child</code>) / 小根堆(<code>parent&lt;=child</code>)</p><ul><li>自底向上，找到第一个非叶子节点（即从tree的倒数第二层开始），逐个往前（<code>a[(n-1-1)//2 -&gt; 0]</code>)，每个做<code>shiftDown</code>操作,构建大／小根堆</li><li>第一个非叶子节点 <code>= (last_index-1)//2</code> , 几乎从半数开始，更快</li><li><p>eg: </p><pre><code class="lang-bash">  &#39;&#39;&#39;  heapify node sequence: `10`,`3`,`4`  `10` -&gt; ok  `3` -&gt; ok  `4`:  &#39;&#39;&#39;          4                             10                             10      /       \      4&lt;-&gt;max(10,3)   /       \     4&lt;-&gt;max(5,1)     /       \     10        3          =&gt;        4         3       =&gt;            5       3      /\       /                     /\       /                      /\      /    5  1      2                     5  1     2                     4  1    2  =&gt; done!</code></pre></li></ul></li><li>堆排序 =&gt; 不断弹出根节点，Heapify的过程<pre><code class="lang-bash">  # process:  1. Heapify(a[0~n-1]): 构建大／小根堆  2. a[0] &lt;-&gt; a[n-1] &amp; shiftDown(a[0]) : 通过根节点和最后一个节点交换位置，实现弹出根节点，此时只需再shiftDown根节点即完成Heapify  3. a[0] &lt;-&gt; a[n-2] &amp; shiftDown(a[0])  4. ...  5. a[0] &lt;-&gt; a[1] &amp; shiftDown(a[0])  6. =&gt; 有序列表 a[0~n-1]</code></pre></li><li>时间复杂度：<code>O(N*logN)</code></li><li>空间复杂度 <code>O(1)</code></li><li>算法稳定性：<code>不稳定</code></li><li>注：堆排序没有QuickSort,MergeSort快，一般多用于动态数据的维护，如优先队列</li></ul><pre><code class="lang-python">def heap_sort(a,n):    # 1. build maxHeap    # 自底向上，找到第一个非叶子节点，逐个往前，每个做shiftDown    # 第一个非叶子节点 = (last_index-1)//2, 几乎从半数开始，更快    def heapify(a,n):        p=(n-2)//2        while p&gt;=0:            shiftDown(a,n,p)            p-=1    def shiftDown(a,n,i):        while i&lt;n:            l=2*i+1            r=l+1            max_c=l            if l&gt;=n:                break            if r&lt;n and a[l]&lt;a[r]:                max_c=r            if a[i]&lt;a[max_c]:                a[i],a[max_c]=a[max_c],a[i]                i=max_c            else:                break    # 2. pop max =&gt; sorted    def extractMax(a,n):        for i in range(n-1,0,-1):    # [n-1,1]            a[0],a[i]=a[i],a[0]            shiftDown(a,i,0)    heapify(a,n)    extractMax(a,n)</code></pre><h3 id="header-24">其它：桶排序(Bucket)</h3><pre><code class="lang-python">&#39;&#39;&#39;buckets: 最大最小平均间隔的桶（每个桶表示一个范围）  [min_a,min_a+intervel),[...),[...),...,[max_a]  intervel = (max_a-min_a)//n  count = n+1&#39;&#39;&#39;def bucket_sort(a):    print(&quot;桶排序(bucket Sort)&quot;)    n=len(a)    print(&quot;n = %d, a = %s&quot; % (n,a))    max_a=max(a)    min_a=min(a)    interval=(max_a-min_a)/n    print(&quot;max_a = %d, min_a = %d, interval = %s&quot; % (max_a,min_a,interval))    # buckets use []    buckets=[ [] for i in range(0,n+1)]    for i in range(0,n):        k=int((a[i]-min_a)/interval)        print(&quot;a[%d] = %d, k = %d&quot; % (i,a[i],k))        buckets[k].append(a[i])    print(&quot;buckets:&quot;,buckets,&quot;,len:&quot;,len(buckets))    a.clear()    for i in range(0,n+1):        if buckets[i]:            buckets[i].sort()        a+=buckets[i]    print(&quot;Final: a =&quot;,a)</code></pre><pre><code class="lang-bash">n = 7, a = [7, 9, 3, 4, 2, 1, 8]max_a = 9, min_a = 1, interval = 1.1428571428571428a[0] = 7, k = 5a[1] = 9, k = 7a[2] = 3, k = 1a[3] = 4, k = 2a[4] = 2, k = 0a[5] = 1, k = 0a[6] = 8, k = 6buckets: [[2, 1], [3], [4], [], [], [7], [8], [9]] ,len: 8Final: a = [1, 2, 3, 4, 7, 8, 9]</code></pre><h3 id="header-25">其它：计数排序(Counting)</h3><pre><code class="lang-python">&#39;&#39;&#39;buckets: 从小到大所有数（每个桶为固定的一个数）    [min],[min+1],[min+2],....,[max]    intervel = 1    count = max_a-min_a+1&#39;&#39;&#39; def counting_sort(a):    print(&quot;计数排序(Counting Sort)&quot;)    n=len(a)    print(&quot;n = %d, a = %s&quot; % (n,a))    max_a=max(a)    min_a=min(a)    print(&quot;max_a = %d, min_a = %d&quot; % (max_a,min_a))    # method1: buckets use []    # buckets_cnt=max_a-min_a+1    # buckets=[0]*buckets_cnt    # for i in range(0,n):    #     buckets[a[i]-min_a]+=1    # print(&quot;buckets:&quot;,buckets)    # a.clear()    # for b in range(0,buckets_cnt):    #     a+=[min_a+b]*buckets[b]    # method2: buckets use {}    buckets={ i:0 for i in range(min_a,max_a+1)}    for i in range(0,n):        buckets[a[i]]+=1    print(&quot;buckets:&quot;,buckets,&quot;len:&quot;,len(buckets))    a.clear()    for b in range(min_a,max_a+1):        a+=[b]*buckets[b]    print(&quot;Final: a =&quot;,a)</code></pre><pre><code class="lang-bash">n = 9, a = [54, 26, 93, 17, 77, 31, 44, 55, 20]max_a = 93, min_a = 17buckets: {17: 1, 18: 0, 19: 0, 20: 1, 21: 0, 22: 0, 23: 0, 24: 0, 25: 0, 26: 1, 27: 0, 28: 0, 29: 0, 30: 0, 31: 1, 32: 0, 33: 0, 34: 0, 35: 0, 36: 0, 37: 0, 38: 0, 39: 0, 40: 0, 41: 0, 42: 0, 43: 0, 44: 1, 45: 0, 46: 0, 47: 0, 48: 0, 49: 0, 50: 0, 51: 0, 52: 0, 53: 0, 54: 1, 55: 1, 56: 0, 57: 0, 58: 0, 59: 0, 60: 0, 61: 0, 62: 0, 63: 0, 64: 0, 65: 0, 66: 0, 67: 0, 68: 0, 69: 0, 70: 0, 71: 0, 72: 0, 73: 0, 74: 0, 75: 0, 76: 0, 77: 1, 78: 0, 79: 0, 80: 0, 81: 0, 82: 0, 83: 0, 84: 0, 85: 0, 86: 0, 87: 0, 88: 0, 89: 0, 90: 0, 91: 0, 92: 0, 93: 1} len: 77Final: a = [17, 20, 26, 31, 44, 54, 55, 77, 93]</code></pre><h3 id="header-26">其它：基数排序(Radix)</h3><pre><code class="lang-python">&#39;&#39;&#39;buckets: 0～9余数做桶，逐各个位放入桶排序（循环轮数：最大数的位数）  [0],[1],[2],[3],...,[8],[9]  intervel = 1  count = 10&#39;&#39;&#39;def radix_sort(a):    print(&quot;基数排序(Radix Sort)&quot;)    n=len(a)    print(&quot;n = %d, a = %s&quot; % (n,a))    max_a_len=1    max_a=max(a)    while max_a&gt;10**max_a_len:        max_a_len+=1    print(&quot;max_a = %d, max_a_len = %d&quot; % (max_a,max_a_len))    for k in range(0,max_a_len):        buckets={ i:[] for i in range(0,10) }        for i in range(0,n):            buckets[int(a[i]/(10**k)%10)].append(a[i])        # print(&quot;buckets = %s&quot; % buckets)        a.clear()        for b in range(0,10):            a+=buckets[b]        print(&quot;k = %d, a = %s&quot; % (k,a))    print(&quot;Final: a =&quot;,a)</code></pre><pre><code class="lang-bash">n = 6, a = [23, 1, 101, 72, 84, 11]max_a = 101, max_a_len = 3buckets = {0: [], 1: [1, 101, 11], 2: [72], 3: [23], 4: [84], 5: [], 6: [], 7: [], 8: [], 9: []}k = 0, a = [1, 101, 11, 72, 23, 84]buckets = {0: [1, 101], 1: [11], 2: [23], 3: [], 4: [], 5: [], 6: [], 7: [72], 8: [84], 9: []}k = 1, a = [1, 101, 11, 23, 72, 84]buckets = {0: [1, 11, 23, 72, 84], 1: [101], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: []}k = 2, a = [1, 11, 23, 72, 84, 101]Final: a = [1, 11, 23, 72, 84, 101]</code></pre><h2 id="header-27">算法：树形问题</h2><ul><li>堆（Heap）</li><li>二叉搜索树（BinarySearchTree)</li><li>并查集（Disjoint-set)</li><li>注：递归法即天然的树形性质<ul><li>排序：Merge Sort &amp; Quick Sort =&gt; 像对一课树进行先／后序遍历</li><li>搜索：九宫格，8皇后 =&gt; 决策树</li></ul></li></ul><h3 id="header-28">堆</h3><ul><li>堆 － 树形结构</li><li>应用：<ul><li>优先队列：动态地选择优先级高的任务先执行, 入队／出队 =&gt; <code>O(logN)</code></li><li>N个选择前M个: 构建M个元素的最小堆 =&gt; <code>O(N*logM)</code></li><li>多路归并排序（d叉堆）=&gt; 当d=n时，退化为<code>Merge Sort</code></li></ul></li><li>二叉堆（完全二叉树 ＋ 大／小根堆）<ul><li>完全二叉树（除最后一层可能只有左叶子，其他层都是有左右子节点）</li><li>All Node Value: <code>Parent&gt;=Child</code> =&gt; 最大堆 ／ <code>Parent&lt;=Child</code> =&gt; 最小堆</li><li>存储：可用数组存储二叉堆，从上到下，左到右，按层序存放<ul><li>parent : <code>(i-1)/2</code></li><li>left_child : <code>2*i+1</code></li><li>right_child: <code>2*i+2</code></li></ul></li><li>操作：<ul><li><code>extractMax</code> =&gt; 自顶向下：弹出top, 新的top执行<code>shiftDown</code>实现Heapify</li><li><code>insert</code> =&gt; 自底向上：尾部插入，新节点执行<code>shiftUp</code>实现Heapify</li></ul></li><li>Demo: <a href="https://github.com/sixDegree/python-algorithm/blob/master/binaryHeap.py" target="_blank" rel="noopener">Binary Heap</a></li></ul></li><li>二叉索引堆（二叉堆 ＋ key: index）<ul><li>Demo: <a href="https://github.com/sixDegree/python-algorithm/blob/master/binaryIndexHeap.py" target="_blank" rel="noopener">Binary Index Heap</a></li><li>存储<ul><li><code>data=[]</code> : 保存具体数据，不做改变，用于查询 <code>data[data_index]</code></li><li><code>id=[]</code>   : 保存数据所在的index，即data_index，用于构建堆（比较时，使用<code>id[heap_index]=&gt;data_index</code>, 定位到具体数据<code>data[data_index]</code>进行key比较）</li><li><code>revId={}</code>: 反向索引，用于查询数据在堆中的位置(<code>revId[data_index]=&gt;heap_index</code>,定位到堆元素：<code>id[heap_index]</code>)</li></ul></li><li>应用：辅助Prim最小生成树,Dijkstra最短路径算法实现</li></ul></li><li>Python自带实现：优先队列<code>heapq</code></li></ul><h3 id="header-29">二叉查找树</h3><ul><li>Binary Search Tree =&gt; 插入，删除，查找 时间复杂度 <code>O(logN)</code><ul><li>二叉树（不一定完全）</li><li>左孩子 &lt; parent &lt; 右孩子</li></ul></li><li>经典应用：查找表的实现 =&gt; 优化：Trie字典树</li><li>操作：<ul><li>遍历 O(N)：<ul><li>深度优先遍历（递归，或借助栈，先进后出）：前序，中序（从小到大序列），后序（应用：释放）</li><li>广度优先遍历（借助队列，先进先出）     ：层序</li></ul></li><li>查找（依赖顺序性）：<ul><li>某个key值节点(类似二分查找法) ： search</li><li>最小／大节点            ： minmum,maximum</li><li>某节点的前驱／后驱节点    ： predecessor,successor</li><li>上下最接近或等于某值的节点 ： floor,ceil</li><li>某节点的排名／某排名的节点 ： rank,select （实现思路：每个节点保存以它为根的树的节点总量）</li></ul></li><li>删除<ul><li>删除节点只有一个孩子 =&gt; 直接用孩子顶替</li><li>删除节点有两个孩子 =&gt; 选其右子树的最小值节点(后驱节点:<code>successor(node.rchild)</code>)，或选其左子树的最大值节点(前驱节点:<code>predecessor(node.lchild)</code>)顶替</li></ul></li><li>插入（递归）</li></ul></li><li><p>注：</p><ul><li>要支持重复元素，可通过给每个Node增加一个计数值或添加节点实现</li><li><p>同样的数据可对应不同的二分搜索树（如：插入顺序不同就可能不同），不能保证<code>O(logN)</code></p><pre><code>  3 / \1   4 \  21 \2 \  3   \    4  =&gt; 推化成链表 O(N)=&gt; 优化：平衡二叉树（左右子树高度差不超过1），实现：红黑树，2-3 Tree，AVL Tree，Splay Tree</code></pre></li></ul></li><li>Demo: <a href="https://github.com/sixDegree/python-algorithm/blob/master/binarySearch.py" target="_blank" rel="noopener">Binary Search</a>, <a href="https://github.com/sixDegree/python-algorithm/blob/master/binarySearchTree.py" target="_blank" rel="noopener">Binary Search Tree</a></li></ul><h3 id="header-30">并查集</h3><p>并查集 Disjoint Set</p><ul><li>操作：O(h) h为树的高度<ul><li>查（根）  ：<code>find_root(x)</code></li><li>并（根）  ：<code>union(x,y)</code></li><li>判（集合）：<code>isConnected(x,y)</code></li></ul></li><li>优化：压缩查找路径 (Path Compression)<ul><li><code>find_root</code><ul><li>压缩查找节点到根这条路径上的跳级节点，指向根（压缩一半）</li><li>压缩查找节点到根这条路径上所有节点，都指向根（压缩到底，递归实现）</li></ul></li><li><code>union</code><ul><li>基于size，选择数量多的一边的root作为根节点</li><li>基于rank，选择层数小的一边的root作为根节点</li></ul></li></ul></li><li>应用：连接问题（Connectivity Problem)<ul><li>判断一个图，是否存在环（连通）</li><li>判断网络中节点间的连接状态</li><li>数学中集合类的实现</li></ul></li><li>Demo: <a href="https://github.com/sixDegree/python-algorithm/blob/master/unionFind.py" target="_blank" rel="noopener">Disjoint Set</a></li></ul><p><strong>Sample:</strong></p><pre><code class="lang-python">class UnionFind:    def __init__(self,n):        self.parent=[i for i in range(0,n)] # record each node&#39; parent        self.n=n    &#39;&#39;&#39;    find x&#39;s root    &#39;&#39;&#39;    def find_root(self,x):        assert(x&gt;=0 and x&lt;self.n)        while self.parent[x]!=x:            # move to next            x=self.parent[x]        return x    # if x&#39;s root == y&#39;s root    def isConnected(self,x,y):        return self.find_root(x)==self.find_root(y)    # union x and y    def union(self,x,y):        x_root=self.find_root(x)        y_root=self.find_root(y)        if x_root==y_root:            return False,x_root        self.parent[x_root]=y_root        return True,y_root    def expand(self,size):        self.parent+=[self.n+i for i in range(0,size)]        self.n+=size</code></pre><p><strong>Sample: <code>find_root</code>优化之压缩一半</strong></p><pre><code>          0         /         1       /      2     /    3   /  4   =&gt; find_root(4)      0      /       1        /      2      / \3   4         0  / \1   2       / \  3   4</code></pre><pre><code class="lang-python">&#39;&#39;&#39;find x&#39;s root &amp; optimize: path compression (压缩查找节点到根这条路径上的跳级节点，指向根，可压缩一半)&#39;&#39;&#39;def find_root(self,x):    assert(x&gt;=0 and x&lt;self.n)    while self.parent[x]!=x:        # optimize: path compression        self.parent[x]=self.parent[self.parent[x]]        # move to next        x=self.parent[x]    return x</code></pre><p><strong>Sample: <code>find_root</code>优化之压缩全部</strong></p><pre><code>          0         /         1       /      2     /    3   /  4   =&gt;     0  / | | \ 1  2 3  4</code></pre><pre><code class="lang-python">&#39;&#39;&#39;find x&#39;s root &amp; optimize: path compression（递归实现，压缩查找节点到根这条路径上所有节点，指向根）&#39;&#39;&#39;def find_root(self,x):    assert(x&gt;=0 and x&lt;self.n)    if x!=self.parent[x]:        self.parent[x]=self.find_root2(self.parent[x])    return self.parent[x]</code></pre><p><strong>Sample: <code>union</code>优化之基于size</strong></p><pre><code class="lang-python"># union x and y# 注：初始化时，self.size = [1 for i in range(0,n)]   def union(self,x,y):    x_root=self.find_root(x)    y_root=self.find_root(y)    if x_root==y_root:        return False,x_root    rx_size=self.size[x_root]    ry_size=self.size[y_root]    # 选择元素个数多的作为根节点    if rx_size&lt;=ry_size:                # use y&#39; root as root        self.parent[x_root]=y_root        self.size[y_root]+=rx_size        return True,y_root    else:                               # use x&#39; root as root        self.parent[y_root]=x_root        self.size[x_root]+=ry_size        return True,x_root</code></pre><p><strong>Sample: <code>union</code>优化之基于rank</strong></p><pre><code class="lang-python"># union x and y# 注：#   初始化时，self.rank = [1 for i in range(0,n)] #   用rank[i] 表示以i为根的集合所表示的树的层数(rank只是作为比较的标准，不是真正树的层数值)def union(self,x,y):    x_root=self.find_root(x)    y_root=self.find_root(y)    #print(&quot;x=%d,y=%d,x_root=%d,y_root=%d&quot; % (x,y,x_root,y_root))    if x_root==y_root:        return False,x_root    rx_rank=self.rank[x_root]    ry_rank=self.rank[y_root]    # 选择层数小的作为根节点    if rx_rank==ry_rank:        self.parent[x_root]=y_root        self.rank[y_root]+=1        return True,y_root    elif rx_rank&gt;ry_rank:               # use y&#39; root as root        self.parent[x_root]=y_root        return True,y_root    else:                               # use x&#39; root as root        self.parent[y_root]=x_root        return True,x_root</code></pre><h2 id="header-31">算法： 图论问题</h2><ul><li>连接问题：连通<ul><li>判断：两个节点是否连通，是否形成环</li><li>统计：区块内节点数量，统计区块数量</li></ul></li><li>路径问题：寻路<ul><li>从节点A到节点B的路径</li><li>最小生成树(Minimum Span Tree): <ul><li>找V-1条边连接V个节点，权值和最小，可能存在多个最小生成树（横切边中有权值相等的边）</li><li>使用贪心算法思想实现</li><li>Prim 算法: 使用优先队列（最小堆），每次找关联的weight最小的Vertex,<code>O(ElogE)</code> =&gt; 优化：使用索引堆，<code>O(ElogV)</code></li><li>Kruskal 算法: 每次找weight最小的Edge，且不形成环(使用并查集快速判断是否成环)，<code>O(ElogE)</code></li></ul></li><li>单源最短路径(Single Shortest Path Tree): <ul><li>从指定点A到其它所有点的最短路径</li><li>使用动态规划算法实现：<code>ShortestPath(x)=min(ShortestPath(a)+w(a-&gt;x))</code><ul><li><code>x</code>: 目的节点</li><li><code>a</code>: 直接可以到达<code>x</code>的节点</li><li><code>ShortestPath(x)</code>: <code>start</code>到<code>x</code>的最短路径长度</li><li><code>ShortestPath(a)</code>: <code>start</code>到<code>a</code>的最短路径长度</li><li><code>w(a-&gt;x)</code>: 每个可直接到达x的<code>a</code>节点，<code>a</code>到<code>x</code>的长度（即weight）</li></ul></li><li>Dijkstra 算法: 每次选择还未求到最短路径的节点（贪心），注意不能有负权边存在 =&gt; 借助优先队列 <code>O(ElogE)</code>,使用最小索引堆 <code>O(ElogV)</code></li><li>BellmanFord 算法: 动态规划，可以处理负权边，判别出负权环（通过多做一次松弛操作判别） =&gt; <code>O(EV)</code></li><li>利用拓扑排序：可处理有向无环图（DAG）=&gt; <code>O(V+E)</code></li><li>注：<ul><li>无权图的最短路径可通过BFS广度优先搜索实现 </li><li>拥有负权环的图，没有最短路径（每环一次，负一次，无限环绕，负无限）</li><li>最长路径问题（不能有正权环）：可使用BellmanFord算法实现（正权取反作为负权），注意不能使用Dijkstra算法</li><li>多源最短路径：Floyed算法，处理无负权环的图，<code>O(V^3)</code></li></ul></li></ul></li><li>最小生成树 vs. 最短路径<ul><li>最小生成树：保证连接所有点的权值总和最小</li><li>最短路径(单源）：保证所有点到起始点的距离最小（最短路径树，也是一棵生成树，但不是最小生成树）=&gt; 从一点到其它各个点的最短路径（单源最短路径）</li></ul></li></ul></li></ul><h3 id="header-32">最小生成树：Prim算法</h3><ul><li>找<code>V-1</code>条边连接<code>V</code>个节点 =&gt; 树，且总权值最小</li><li>Lazy Prim：<ul><li>使用优先队列，维护<code>Edge(weight,from,to)</code>,<code>weight</code>作为key构建小根堆</li><li>每次pop出top最短<code>weight</code>的<code>Edge</code>,然后push此<code>Edge</code>的<code>to</code>节点关联的未访问节点的<code>Edge(weight,to,i)</code></li><li>=&gt; <code>O(ElogE)</code></li></ul></li><li>优化：减少重复无用<code>Edge</code>入堆（通过不断更新与节点关联的最小权值）<ul><li>使用索引堆，维护<code>Vertex(to,weight)</code>,<code>weight</code>作为key用于判断构建小根堆；</li><li>每次pop出top最短<code>weight</code>的<code>Vertex</code>,push/update此<code>Vertex</code>的<code>to</code>节点关联的未访问节点<code>Vertex(i,weight)</code>(<code>Vertex</code>在堆中，且<code>weight</code>比原来存储的更小时update)</li><li>=&gt; <code>O(ElogV)</code></li></ul></li></ul><p><strong>Sample: Lazy Prim</strong></p><pre><code class="lang-python">import heapq# O(ElogE)def prim(self,graph):    visited=[False for i in range(0,graph.n)]    edges=[]    x=0    pq=[(0,None,x)]    # (weight,from,to)    while pq:        weight,v,w=heapq.heappop(pq)        if visited[w]:            continue        edges.append((v,w,weight))      # (from,to,weight)        visited[w]=True        for i in graph.nextNodeIter(w):            if not visited[i]:                heapq.heappush(pq,(graph.getWeight(w,i),w,i))    print(&quot;tree :&quot;,edges)</code></pre><p><strong>Sample: 优化</strong></p><pre><code class="lang-python">from binaryIndexHeap import BinaryIndexHeap  # 自定义实现的二叉索引堆# O(ElogV)def prim_opt(self,graph):    visited=[False for i in range(0,graph.n)]    edges=[]    x=0    pq=[(x,0)]    # (to,weight)    indexHeap=BinaryIndexHeap(pq,key=lambda x:x[1],maxHeap=False,heapify=True)    while not indexHeap.empty():        i,(w,weight)=indexHeap.pop()        # print(&quot;pop: w=%d,weight=%d&quot; % (w,weight))        if visited[w]:            continue        edges.append((w,weight))        visited[w]=True        for i in graph.nextNodeIter(w):            if not visited[i]:                item=(i,graph.getWeight(w,i))                if indexHeap.contain(i) and indexHeap.getData(i)[1]&gt;item[1]:                    # print(&quot;update: i=%d,weight=%d&quot; % item)                    indexHeap.update(i,item)                else:                    # print(&quot;push: i=%d,weight=%d&quot; % item)                    indexHeap.push(item)    print(&quot;tree :&quot;,edges)</code></pre><h3 id="header-33">最小生成树：Kruskal算法</h3><ul><li>将所有<code>Edge(weight,from,to)</code>放入优先队列(小根堆:<code>weight</code>作为key)</li><li>从优先队列中弹出<code>V-1</code>条<code>weight</code>最小的且不形成环的<code>Edge</code></li><li>使用并查集快速判断是否成环(近乎<code>O(1)</code>)</li><li>=&gt; <code>O(ElogE)</code></li></ul><pre><code class="lang-python">from unionFind import UnionFind# O(ElogE)def kruskal(self,graph):    uf=UnionFind(graph.n)    edges=[]    pq=[]    for v in range(0,graph.n):        for w in graph.nextNodeIter(v):            heapq.heappush(pq,(graph.getWeight(v,w),v,w))   # (weight,from,to)    while pq and len(edges) &lt; graph.n-1:        weight,v,w=heapq.heappop(pq)        if uf.isConnected(v,w):            continue        edges.append((v,w,weight))      # (from,to,weight)        uf.union(v,w)    print(&quot;tree :&quot;,edges)</code></pre><h3 id="header-34">最短路径: Dijkstra算法</h3><ul><li>贪心算法（贪心算法本身也属于动态规划）=&gt; 不能有负权边</li><li>实现：<ul><li>借助优先队列 ＝&gt; <code>O(ElogE)</code></li><li>借助最小索引堆 =&gt; <code>O(ElogV)</code></li></ul></li></ul><pre><code class="lang-python"># O(ElogE)def dijkstra(self,graph,x):    parent=[i for i in range(0,graph.n)]    distance=[0 for i in range(0,graph.n)]    visited=set()    pq=[]    heapq.heappush(pq,(0,x))     # (distance,w)    while pq:        node=heapq.heappop(pq)        # print(&quot;pop:&quot;,node[0],chr(node[1]+65))        dist=node[0]        w=node[1]        if w in visited:            continue        visited.add(w)        for i in graph.nextNodeIter(w):            if i not in visited:                distance[i]=dist+graph.getWeight(w,i)                heapq.heappush(pq,(distance[i],i))                parent[i]=w    return parent,distance# 优化：贪心，减少入堆数 （ 进一步优化，需使用最小索引堆 =&gt; O(ElogV) )def dijkstra_opt(self,graph,x):    parent=[i for i in range(0,graph.n)]    distance=[i!=x and math.inf or 0 for i in range(0,graph.n)]    visited=set()    pq=[]    heapq.heappush(pq,(0,x))    while pq:        node=heapq.heappop(pq)        # print(&quot;pop:&quot;,node[0],chr(node[1]+65))        dist=node[0]        w=node[1]        if w in visited:            continue        visited.add(w)        for i in graph.nextNodeIter(w):            if i not in visited and dist+graph.getWeight(w,i)&lt;distance[i]:                distance[i]=dist+graph.getWeight(w,i)                heapq.heappush(pq,(distance[i],i))                parent[i]=w    return parent,distance</code></pre><h3 id="header-35">最短路径: BellmanFord算法</h3><ul><li>动态规划思想</li><li>可以处理负权边，判别出负权环（有负权环则无最短路径）=&gt; O(VE)</li><li>判别出负权环:<ul><li>原理：最短路径最多经过所有<code>V</code>个顶点，<code>V-1</code>条边，对所有点进行<code>V-1</code>次松弛操作，理论上就找到了从源点到其它所有点的最短路径，如果还可以继续松弛，则说明图中存在负权环</li><li>实现：通过对所有点多做一次松弛操作（即所有点经过2次松弛操作），发现经过某个点的另外一条距离更短的路径，则表示存在负权环</li></ul></li><li>优化：利用队列</li></ul><pre><code class="lang-python"># V轮对E条边做松弛操作 ＝&gt; O(VE)def bellmanFord(self,graph,s):    dist=[math.inf for i in range(0,graph.n)]    dist[s]=0    edges=[None for i in range(0,graph.n)]    edges[s]=(None,s,0)                # (from,to,weight)    parent=[i for i in range(0,graph.n)]    for i in range(1,graph.n):      # do n-1 times Relaxtion        for j in range(0,graph.n):  # get n-1 edges              for w in graph.nextNodeIter(j):                if not edges[w] or dist[j]+graph.getWeight(j,w)&lt;dist[w]:                    dist[w]=dist[j]+graph.getWeight(j,w)                    edges[w]=(j,w,graph.getWeight(j,w))                    parent[w]=j    print(&quot;edges :&quot;,edges)    # do one more time Relaxtion to distinguish if has Negative cycle    hasNegativeCycle=False    for j in range(0,graph.n):        for w in graph.nextNodeIter(j):            #print(&quot;dist[%d]=%d,weight=%d,dist[%d]=%d&quot; % (j,dist[j],graph.getWeight(j,w),w,dist[w]))            if edges[w] and dist[j]+graph.getWeight(j,w)&lt;dist[w]:                hasNegativeCycle=True                break    print(&quot;hasNegativeCycle:&quot;,hasNegativeCycle)    return parent,dist,hasNegativeCycle</code></pre><h2 id="header-36">Reference</h2><ul><li>Demo: <a href="https://github.com/sixDegree/python-algorithm" target="_blank" rel="noopener">python-algorithm</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;算法效率衡量&lt;/li&gt;
&lt;li&gt;顺序表／链表，队列／栈，树，图&lt;/li&gt;
&lt;li&gt;排序，堆，二分搜索，并查集，最小生成树，最短路径&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://sixdegree.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python Selenium</title>
    <link href="http://sixdegree.github.io/2019/03/25/Python-Selenium.html"/>
    <id>http://sixdegree.github.io/2019/03/25/Python-Selenium.html</id>
    <published>2019-03-24T16:00:00.000Z</published>
    <updated>2019-07-08T12:47:36.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Install: selenium,browser drive</li><li>browser</li><li>查找元素：find_elements/find_elements_by_xxx,find_element/find_element_by_xxx</li><li>交互操作：action(eg: click,key_down,…),action_chains (ActionChains,drag_and_drop)</li><li>执行javascript: execute_script(…)</li><li>切换：switch_to.xxx，back/forward()</li><li>异常处理：selenium.common.exceptions（eg: TimeoutException, NoSuchElementException）</li><li>Cookie: add/get/delete_cookie(…),get_cookies(),delete_all_cookies()</li><li>等待元素: 强制等待 time.sleep(seconds), 隐式等待 browser.implicitly_wait(seconds),显示等待 WebDriverWait,expected_conditions</li></ol><a id="more"></a><h2 id="header-1">Install</h2><ul><li><p>安装<code>selenium</code></p><pre><code class="lang-bash">  $ pip install selenium  # check:  $ python3  &gt;&gt;&gt; from selenium import webdriver  &gt;&gt;&gt; help(webdriver)</code></pre></li><li><p>安装browser驱动程序,eg: chrome的<code>chromedrive</code></p><ul><li><a href="http://chromedriver.chromium.org/" target="_blank" rel="noopener">download</a></li><li>copy to path,eg: mac <code>/usr/local/bin</code></li><li>check: <code>chromedriver -v</code></li></ul></li></ul><h2 id="header-2">browser</h2><pre><code class="lang-python">def get_browser(slience=False):    if not slience:        return webdriver.Chrome()                           # 会弹出一个 chrome 浏览器    else:        chrome_options=Options()        chrome_options.add_argument(&#39;--headless&#39;)         chrome_options.add_argument(&#39;--disable-gpu&#39;)        browser=webdriver.Chrome(options=chrome_options)    # 创建的chrome浏览器是不可见的        return browserdef test_browser(slience=False):    browser=get_browser(slience)    browser.get(&#39;http://www.baidu.com&#39;)    print(browser.page_source)    browser.close()if __name__==&#39;__main__&#39;:    test_browser()    # test_browser(slience=True)</code></pre><h2 id="header-3">查找元素</h2><ul><li><code>find_element_by_xxx(...)</code>,<code>find_element(By.xxx,xxx)</code>: 返回匹配的第一个元素（<code>WebElement</code>类型对象），找不到则抛出异常</li><li><code>find_elements_by_xxx(...)</code>,<code>find_elements(By.xxx,xxx)</code>: 返回所有匹配的元素列表，找不到则返回空列表</li><li>eg: <code>find_elements(By.CSS_SELECTOR,&#39;.service-bd li&#39;)</code> = <code>find_elements_by_css_selector(&quot;.service-bd li&quot;)</code></li><li><code>WebElement</code>类型对象：<ul><li><code>.text</code> 获取文本值（它与它的所有子孙节点的文字的组合，无则返回空字符串）</li><li><code>.id</code></li><li><code>.tag_name</code></li><li><code>.location</code></li><li><code>.size</code></li><li><code>.get_attribute(attrName)</code> 获取属性值（无则返回None）</li><li><code>find_element_by_xxx / find_elements_by_xxx(...)</code></li><li><code>find_element / find_elements(By.xxx,xxx)</code></li></ul></li><li>使用:<ul><li>XPath<ul><li><code>find_element_by_xpath / find_elements_by_xpath(xpath)</code></li><li>eg: <code>find_element_by_xpath(&quot;//div[@class=&#39;detail&#39;]/a&quot;)</code></li></ul></li><li>CSS Selector<ul><li><code>find_element_by_css_selector / find_elements_by_css_selector(css)</code></li><li>eg: <code>find_element_by_css_selector(&quot;div[class=&#39;detail&#39;] &gt; div span&quot;)</code></li></ul></li><li>Tag<ul><li><code>find_element_by_id(id)</code>: 一个或异常</li><li><code>find_element_by_tag_name / find_elements_by_tag_name(tagName)</code></li><li><code>find_element_by_class_name / find_elements_by_class_name(classValue)</code>: 使用元素的class值查找元素</li><li><code>find_element_by_name / find_elements_by_name(name)</code>: 通过<code>name</code>属性查找</li><li><code>find_element_by_link_text / find_elements_by_link_text(linkText)</code>: 文本值为linkText的超级链接元素<code>&lt;a&gt;</code></li><li><code>find_element_by_partial_link_text / find_elements_by_partial_link_text(linkText)</code>: 文本值包含linkText的超级链接元素<code>&lt;a&gt;</code></li><li>eg: <code>find_element_by_class_name(&quot;p1&quot;)</code> = <code>find_elements_by_xpath(&quot;//*[@class=&#39;p1&#39;]&quot;)</code> = <code>find_elements_by_css_selector(&quot;*[class=&#39;p1&#39;]&quot;)</code></li></ul></li></ul></li></ul><pre><code class="lang-python">def test_element():    browser=get_browser(slience=True)    browser.get(&#39;http://www.baidu.com&#39;)    print(&#39;--- input ---&#39;)    input= browser.find_element_by_id(&#39;kw&#39;)    print_element(input)    print(&#39;--- searchBtn ---&#39;)    #searchBtn = browser.find_element_by_id(&#39;su&#39;)    searchBtn=browser.find_element(By.ID,&#39;su&#39;)    print_element(searchBtn)def print_element(ele):    print(&quot;id:&quot;,ele.id)    print(&quot;tag_name:&quot;,ele.tag_name)    print(&quot;location:&quot;,ele.location)    print(&quot;size:&quot;,ele.size)    print(&quot;text:&quot;,ele.text)    print(&quot;class:&quot;,ele.get_attribute(&quot;class&quot;))    print(&quot;name:&quot;,ele.get_attribute(&quot;name&quot;))    print(&quot;type:&quot;,ele.get_attribute(&quot;type&quot;))    print(&quot;value:&quot;,ele.get_attribute(&quot;value&quot;))    print(&quot;id:&quot;,ele.get_attribute(&quot;id&quot;))</code></pre><h2 id="header-4">交互操作</h2><p><a href="https://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.common.action_chains" target="_blank" rel="noopener">Refer to Action Chains</a></p><ul><li>click,click_and_hold,double_click,context_click</li><li>drag_and_drop,drag_and_drop_by_offset</li><li>key_down,key_up</li><li>move_by_offset,move_to_element,move_to_element_with_offset</li><li>pause,perform,release,reset_actions</li><li>send_keys,send_keys_to_element</li></ul><p><strong> Sample1: action </strong></p><pre><code class="lang-python">browser=webdriver.Chrome()input= browser.find_element_by_id(&#39;kw&#39;)input.send_keys(&quot;MakBook&quot;)searchBtn = browser.find_element_by_id(&#39;su&#39;)searchBtn.click()time.sleep(2)input.clear()input.send_keys(&quot;ipad&quot;)</code></pre><p><strong> Sample2: action_chains </strong></p><pre><code class="lang-python">from selenium.webdriver import ActionChainsbrowser=webdriver.Chrome()browser.get(&quot;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&quot;)time.sleep(1)browser.switch_to.frame(&#39;iframeResult&#39;)source = browser.find_element_by_css_selector(&#39;#draggable&#39;)target = browser.find_element_by_css_selector(&#39;#droppable&#39;)actions = ActionChains(browser)actions.drag_and_drop(source, target)actions.perform()time.sleep(1)</code></pre><h2 id="header-5">执行Javascript</h2><p><code>execute_script(script)</code></p><pre><code class="lang-python">browser=webdriver.Chrome()browser.execute_script(&#39;window.scrollTo(0, document.body.scrollHeight)&#39;)browser.execute_script(&#39;alert(&quot;To Bottom&quot;)&#39;)</code></pre><h2 id="header-6">切换</h2><ul><li><code>switch_to.xxx</code><ul><li><code>window(windowName)</code></li><li><code>frame(frameName)</code></li><li><code>parent_frame()</code></li><li><code>active_element()</code></li><li><code>default_content()</code></li><li><code>alert()</code></li></ul></li><li><code>back()</code>,<code>forward()</code></li></ul><p><strong> Sample1: window tab切换 </strong></p><pre><code class="lang-python"># 1. window tab切换：# 执行js命令`window.open()`打开选项卡# 不同的选项卡是存在`browser.window_handles`列表中# eg: 通过`browser.window_handles[0]`可以操作第一个选项卡def test_window():    browser=get_browser()    browser.get(&#39;https://www.baidu.com&#39;)    browser.execute_script(&#39;window.open()&#39;)    print(browser.window_handles)    browser.switch_to.window(browser.window_handles[1])    browser.get(&#39;https://www.douban.com/&#39;)    time.sleep(1)    browser.switch_to.window(browser.window_handles[0])    browser.get(&#39;https://python.org&#39;)    time.sleep(1)    # 浏览器的前进和后退: back(),forward()    browser.back()    time.sleep(1)    browser.forward()    time.sleep(1)    browser.close()</code></pre><p><strong> Sample2: frame切换 </strong></p><pre><code class="lang-python">def test_frame():    browser=get_browser(slience=True)    browser.get(&#39;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&#39;)    browser.switch_to.frame(&#39;iframeResult&#39;)    source = browser.find_element_by_css_selector(&#39;div#draggable&#39;)    print(source)    print(source.text)    try:        logo = browser.find_element_by_class_name(&#39;logo&#39;)    except NoSuchElementException:        print(&#39;NO LOGO&#39;)    browser.switch_to.parent_frame()    logo = browser.find_element_by_class_name(&#39;logo&#39;)    print(logo)    print(logo.text)</code></pre><h2 id="header-7">异常处理</h2><p><code>selenium.common.exceptions</code></p><pre><code class="lang-python">from selenium import webdriverfrom selenium.common.exceptions import TimeoutException, NoSuchElementExceptionbrowser=webdriver.Chrome()try:    browser.get(&#39;http://www.baidu.com&#39;)    input= browser.find_element_by_id(&#39;kw&#39;)    input.send_keys(&quot;MakBook&quot;)    searchBtn = browser.find_element_by_id(&#39;su&#39;)    searchBtn.click()    print(&quot;clicked!&quot;)    span=browser.find_element_by_xpath(&quot;//div[@id=&#39;container&#39;]//div[@class=&#39;nums&#39;]/span[@class=&#39;nums_text&#39;]&quot;)    print(&quot;result:&quot;,span.text)except (TimeoutException,NoSuchElementException) as e:    print(&quot;Occur Exception:&quot;,e)except Exception as e:    print(&quot;Unknow Exception:&quot;,type(e),e)finally:    print(&quot;close!&quot;)    browser.close()</code></pre><h2 id="header-8">Cookie</h2><ul><li><code>get_cookie(name)</code></li><li><code>add_cookie(dict)</code>: required keys “name” and “value”</li><li><code>delete_cookie(name)</code></li><li><code>get_cookies()</code></li><li><code>delete_all_cookes()</code></li></ul><pre><code class="lang-python">def test_cookie():    browser=get_browser(slience=True)    browser.get(&#39;http://www.baidu.com&#39;)    cookies=browser.get_cookies()    print(cookies)    browser.add_cookie({&#39;name&#39;:&#39;user&#39;,&#39;value&#39;:&#39;Tom&#39;})    print(browser.get_cookie(&#39;user&#39;))</code></pre><h2 id="header-9">等待元素</h2><ul><li>强制等待 <code>time.sleep(seconds)</code></li><li><p>隐式等待 <code>browser.implicitly_wait(seconds)</code></p><pre><code class="lang-python">  browser=get_browser()  browser.get(&#39;http://www.baidu.com&#39;)  input= browser.find_element_by_id(&#39;kw&#39;)  input.send_keys(&quot;MakBook&quot;)  searchBtn = browser.find_element_by_id(&#39;su&#39;)  searchBtn.click()  browser.implicitly_wait(3)  span=browser.find_element_by_xpath(&quot;//div[@id=&#39;container&#39;]//div[@class=&#39;nums&#39;]/span[@class=&#39;nums_text&#39;]&quot;)  print(span.text)  browser.close()</code></pre></li><li><p>显示等待</p><pre><code class="lang-python">  from selenium.webdriver.support.wait import WebDriverWait  from selenium.webdriver.support import expected_conditions as EC  browser=get_browser()  browser.get(&#39;http://www.baidu.com&#39;)  input= browser.find_element_by_id(&#39;kw&#39;)  input.send_keys(&quot;MakBook&quot;)  searchBtn = browser.find_element_by_id(&#39;su&#39;)  searchBtn.click()  wait=WebDriverWait(browser,10, 0.5)  optionLocator = (By.XPATH, &quot;//select/option&quot;)  option=wait.until(EC.presence_of_element_located(optionLocator))  print(option)  btnLocator=(By.CSS_SELECTOR, &#39;.btn-search&#39;)  btn=wait.until(EC.element_to_be_clickable(btnLocator))  print(btn)  browser.close()</code></pre><ul><li>EC 常用的判断条件：<ul><li><code>title_is</code> : 标题是某内容</li><li><code>title_contains</code> : 标题包含某内容</li><li><code>visibility_of</code> : 可见，传入元素对象</li><li><code>staleness_of</code> : 判断一个元素是否仍在DOM，可判断页面是否已经刷新</li><li><code>alert_is_present</code> : 是否出现Alert</li><li><code>frame_to_be_available_and_switch_to_it</code> : frame加载并切换</li><li><code>element_selection_state_to_be</code> : 传入元素对象以及状态，相等返回True，否则返回False</li><li><code>element_located_selection_state_to_be</code> : 传入定位元组以及状态，相等返回True，否则返回False</li><li><code>presence_of_element_located(locator)</code> : 指定元素出现，传入定位元组，如(By.ID, ‘p’)</li><li><code>presence_of_all_elements_located(locator)</code></li><li><code>invisibility/visibility_of_element_located(locator)</code>: 指定元素不可见／可见</li><li><code>element_to_be_clickable(locator)</code> : 指定元素可点击</li><li><code>element_located_to_be_selected(locator)</code> : 指定元素可选择</li><li><code>element_to_be_selected(element)</code></li><li><code>text_to_be_present_in_element(locator,text)</code> : 指定元素的文本包含指定文本</li><li><code>text_to_be_present_in_element_value(locator,text)</code> : 指定元素值包含某文字</li></ul></li></ul></li></ul><h2 id="header-10">Reference</h2><ul><li><a href="https://github.com/sixDegree/python-basic-demo" target="_blank" rel="noopener">My Demo</a></li><li><a href="https://selenium-python.readthedocs.io/" target="_blank" rel="noopener">Selenium Doc</a></li><li><a href="https://www.cnblogs.com/zhaof/p/6953241.html" target="_blank" rel="noopener">python爬虫从入门到放弃（八）之 Selenium库的使用</a></li><li><a href="https://www.cnblogs.com/LOVEYU/p/8392269.html" target="_blank" rel="noopener">selenium+python自动化测试系列(一)：登录</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Install: selenium,browser drive&lt;/li&gt;
&lt;li&gt;browser&lt;/li&gt;
&lt;li&gt;查找元素：find_elements/find_elements_by_xxx,find_element/find_element_by_xxx&lt;/li&gt;
&lt;li&gt;交互操作：action(eg: click,key_down,…),action_chains (ActionChains,drag_and_drop)&lt;/li&gt;
&lt;li&gt;执行javascript: execute_script(…)&lt;/li&gt;
&lt;li&gt;切换：switch_to.xxx，back/forward()&lt;/li&gt;
&lt;li&gt;异常处理：selenium.common.exceptions（eg: TimeoutException, NoSuchElementException）&lt;/li&gt;
&lt;li&gt;Cookie: add/get/delete_cookie(…),get_cookies(),delete_all_cookies()&lt;/li&gt;
&lt;li&gt;等待元素: 强制等待 time.sleep(seconds), 隐式等待 browser.implicitly_wait(seconds),显示等待 WebDriverWait,expected_conditions&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://sixdegree.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
