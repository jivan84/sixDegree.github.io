<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Zookeeper</title>
  
  <!-- Meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="zookeeper,curator,znode,lock,queue">
  
  
    <meta name="description" content="Zookeeper Introduce">
  

  <!-- Feed -->
  
    <link rel="alternative" href="/atom.xml" title="SixDegree" type="application/atom+xml">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/bootstrap/dist/css/bootstrap.css">
  
    <link rel="stylesheet" href="/highlight/demo/styles/tomorrow-night-bright.css">
  
  <link rel="stylesheet" href="/css/fontello.css">
  <link rel="stylesheet" href="/css/style.css">

  <!-- Site Analyse -->
  
	<script>
	var userID='2bbb83cc0f781dd7502e9d5e19661866';
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?"+userID;
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>


</head>

<body data-spy="scroll" data-target="#nav-catalog">
  <div id="top-push"></div>
<a href="#top-push" id="go-top">
	<span class="glyphicon glyphicon-chevron-up"></span>
</a>
  <aside id="sidebar">
    <section class="sidebar-header">Catalog</section>
     <nav id="nav-catalog">
        <ol class="sidebar-nav nav"><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-1"><span class="sidebar-nav nav-text">Starter</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-2"><span class="sidebar-nav nav-text">安装</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-3"><span class="sidebar-nav nav-text">数据模型</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-4"><span class="sidebar-nav nav-text">Cmd</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-5"><span class="sidebar-nav nav-text">Java API</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-6"><span class="sidebar-nav nav-text">Curator</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-7"><span class="sidebar-nav nav-text">应用场景</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-8"><span class="sidebar-nav nav-text">统一命名服务</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-9"><span class="sidebar-nav nav-text">配置管理</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-10"><span class="sidebar-nav nav-text">集群管理</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-11"><span class="sidebar-nav nav-text">共享锁</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-12"><span class="sidebar-nav nav-text">队列管理</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-13"><span class="sidebar-nav nav-text">Reference</span></a></li></ol>
    </nav>
  </aside>
  <span id="sidebar-ctrl" class="glyphicon glyphicon-list-alt circle"></span>
  <div id="wrapper">
    <header>
  <nav class="navbar navbar-default">
    <div class="container-fluid">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#nav-menu" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/">SixDegree</a>
      </div>
      <div class="collapse navbar-collapse" id="nav-menu">
        <ul class="nav navbar-nav navbar-right">
          
              <li  >
                <a href="/">Blogs</a>
              </li>
          
              <li  >
                <a href="/tags.html">Tags</a>
              </li>
          
              <li  >
                <a href="/about.html">About</a>
              </li>
          
          
              <li>
                <a href="/atom.xml" target="_blank">
                  <span class="icon-rss"></span>
                </a>
              </li>
          
              <li>
                <a href="http://github.com/sixdegree" target="_blank">
                  <span class="icon-github"></span>
                </a>
              </li>
          
        </ul>
      </div>
    </div>
  </nav>
</header>



    <div class="container">
      <article class="detail" role="main">
  <section class="post-header">
    <h1 class="post-title">Zookeeper</h1>
    <ul class="post-meta">
      <li>
        <span class="glyphicon glyphicon-calendar"></span>
        <time datetime="2015-10-31T16:00:00.000Z">2015-11-01</time>
      </li>
      
        <li>
         <span class="glyphicon glyphicon-tags"></span>
          
            <a href="/tags.html#tag-BigData">BigData</a>
          
        </li>
      
    </ul>
  </section>
  <section class="post-content">
    <h2 id="header-1">Starter</h2>
<p>Zookeeper 分布式服务框架是 Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题</p>
<p>特性：</p>
<ul>
<li>是一个开源共享资源库</li>
<li>具有fast fail特性</li>
<li>Master/Slave模式，运行于一组机器上</li>
<li>不超过半数Server 挂掉不影响服务</li>
<li>无中心，Leader故障，自动重新选举Leader，不存在单点故障</li>
</ul>
<p>基于观察者模式设计的分布式服务管理：</p>
<ul>
<li>负责存储和管理大家都关心的数据</li>
<li>接受观察者的注册</li>
<li>数据的状态发生变化，Zookeeper会通知注册的观察者</li>
<li>实现集群中类似 Master/Slave 管理模式</li>
</ul>
<h3 id="header-2">安装</h3>
<p>直接下载解压即可用</p>
<ol>
<li><p>安装配置Zookeeper节点：</p>
<pre><code> &gt; cd /user/local/zookeeper-3.4.6
 &gt; cp conf/zoo-sample.conf conf/zoo.conf
 &gt; vi zoo.conf

 tickTime=2000
 dataDir=/home/zkdata
 clientPort=2181
 initLimit=5
 syncLimit=2 
 server.1=192.168.211.1:2888:3888
 server.2=192.168.211.2:2888:3888
 server.3=193.168.211.3:2888:3888
</code></pre><p> 配置说明：</p>
<ul>
<li><code>dataDir</code> 指定Zookeeper的数据文件目录；</li>
<li><code>server.id=host:port1:port2</code><ul>
<li>id：各个Zookeeper节点的编号，保存在dataDir目录下的myid文件中</li>
<li>host：各个Zookeeper节点的host</li>
<li>port1：用于连接leader的端口</li>
<li>port2：用于leader选举的端口</li>
</ul>
</li>
</ul>
</li>
<li><p>复制此Zookeeper到其他Server</p>
<pre><code> &gt; cd /usr/local
 &gt; scp -rp zookeeper-3.4.6 root@192.168.211.2:/usr/local
 &gt; scp -rp zookeeper-3.4.6 root@192.168.211.3:/usr/local
</code></pre></li>
<li><p>配置各个Zookeeper节点的编号</p>
<ul>
<li><p>192.168.211.1:</p>
<pre><code>&gt; mkdir /home/zkdata
&gt; echo 1 &gt; /home/zkdata/myid
</code></pre></li>
<li><p>192.168.211.2:</p>
<pre><code>&gt; mkdir /home/zkdata
&gt; echo 2 &gt; /home/zkdata/myid
</code></pre></li>
<li><p>193.168.211.3</p>
<pre><code>&gt; mkdir /home/zkdata
&gt; echo 3 &gt; /home/zkdata/myid
</code></pre></li>
</ul>
</li>
<li><p>启动Zookeeper服务：</p>
<pre><code> &gt; /usr/local/zookeeper-3.4.6/bin/zkServer.sh start
</code></pre></li>
<li><p>通过Zookeeper客户端测试服务是否可用：</p>
<pre><code> &gt; /usr/local/zookeeper-3.4.6/bin/zkCli.sh -server 127.0.0.1:2181
</code></pre><pre><code> &gt; /usr/local/zookeeper-3.4.6/bin/zkServer.sh status
 &gt; jps
 &gt; /usr/local/zookeeper-3.4.6/bin/zkServer.sh stop
</code></pre></li>
</ol>
<p>注意事项：</p>
<ol>
<li>最好能通过监控程序将Zookeeper管理起来，保证Zookeeper退出后能被自动重启<ul>
<li>Zookeeper是快速失败（fail-fast)</li>
<li>遇到任何错误情况，进程均会退出</li>
</ul>
</li>
<li>定期清除没用的日志和快照文件<ul>
<li>Zookeeper运行过程中会在dataDir目录下生成很多日志和快照文件</li>
<li>导致占用大量磁盘空间</li>
<li>可通过cron等方式定期清除没用的日志和快照文件<pre><code>java -cp zookeeper.jar:log4j.jar:conf org.apache.zookeeper.server.PurgeTxnLog &lt;dataDir&gt; &lt;snapDir&gt; -n &lt;count&gt;
</code></pre></li>
</ul>
</li>
</ol>
<h3 id="header-3">数据模型</h3>
<p>Zookeeper 会维护一个具有层次关系的目录树的数据结构，类似于一个标准的文件系统<br>通过对树中的节点（ZNode）进行有效管理，可以设计出多种多样的分布式的数据管理模型</p>
<p><img src="/2015/11/01/struct.png" alt=""></p>
<p>znode</p>
<ul>
<li>路径唯一标识<ul>
<li>每个子目录项都被称作为 znode，被它所在的路径唯一标识</li>
<li>如： Server1 这个 znode 的标识为 <code>/NameService/Server1</code></li>
</ul>
</li>
<li>可以存储数据，ACL访问控制<ul>
<li>注意：Zookeeper 并不是用来专门存储数据的，它的作用主要是用来维护和监控存储的数据的状态变化</li>
</ul>
</li>
<li>有版本<ul>
<li>每个 znode 中存储的数据可以有多个版本（也就是一个访问路径中可以存储多份数据）</li>
<li>节点数据内容改变 =&gt; 多一个版本号</li>
</ul>
</li>
<li>类型：<ul>
<li><code>EPHEMERAL</code>：临时目录节点，与服务器session失效则删除，不能有子节点目录</li>
<li><code>PERSISTENT</code>：持久化目录节点</li>
<li><code>EPHEMERAL_SEQUENTIAL</code>：临时目录节点，可以自动编号</li>
<li><code>PERSISTENT_SEQUENTIAL</code>： 持久化目录节点，可以自动编号</li>
</ul>
</li>
<li>znode 可以被监控<ul>
<li>一旦变化（这个目录节点中存储的数据修改，子节点目录变化等）通知设置监控的客户端</li>
<li>CRUD znode =&gt; trigger watch event （watch 通知订阅的 clients）</li>
<li>watch event<ul>
<li>异步发送至观察者watcher</li>
<li>一次性触发器，触发后需重新设置</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="header-4">Cmd</h3>
<p>Server：</p>
<ol>
<li>启动ZK服务:        <code>bin/zkServer.sh start</code></li>
<li>查看ZK服务状态:  <code>bin/zkServer.sh status</code></li>
<li>停止ZK服务:        <code>bin/zkServer.sh stop</code></li>
<li>重启ZK服务:        <code>bin/zkServer.sh restart</code></li>
</ol>
<p>Client：</p>
<ol>
<li>连接到zookeeper server <code>bin/zkCli.sh -server 127.0.0.1:2181</code></li>
<li>查看 zookeeper目录结构 <code>ls /</code></li>
<li>创建 znode <code>create /zk testData</code></li>
<li>查看znode data <code>get /zk</code></li>
<li>更新znode data <code>set /zk testData2</code></li>
<li>删除znode <code>delete /zk</code></li>
</ol>
<p>常用四字命令：<br>（用来获取 ZooKeeper 服务的当前状态及相关信息，在客户端可以通过 telnet 或 nc 向 ZooKeeper 提交相应的命令）</p>
<ul>
<li><code>cons</code> <ul>
<li>列出连接到服务器的所有客户端详细信息(连接，会话)。</li>
<li>包括“接收/发送”的包数量，会话id，操作延迟等</li>
</ul>
</li>
<li><code>conf</code><ul>
<li>输出服务的配置详细信息</li>
</ul>
</li>
<li><code>envi</code><ul>
<li>输出服务环境的详细信息,和java环境</li>
</ul>
</li>
<li><code>dump</code><ul>
<li>输出未经处理的会话和临时节点</li>
</ul>
</li>
<li><code>reqs</code><ul>
<li>列出未经处理的请求</li>
</ul>
</li>
<li><code>stat</code><ul>
<li>输出服务的状态，和简要的客户端信息</li>
</ul>
</li>
<li><code>ruok</code><ul>
<li>测试服务端是否处于正常状态</li>
<li>正常返回”imok”</li>
</ul>
</li>
<li><code>wchs</code><ul>
<li>列出服务器watch的详细信息</li>
</ul>
</li>
<li><code>wchc</code><ul>
<li>通过 session 列出服务器 watch 的详细信息</li>
<li>它的输出是一个与 watch 相关的会话的列表</li>
</ul>
</li>
<li><code>wchp</code><ul>
<li>通过路径列出服务器watch的详细信息</li>
<li>输出一个与session相关的路径</li>
</ul>
</li>
</ul>
<p>eg:</p>
<pre><code>&gt; echo stat|nc localhost 2181
&gt; echo ruok|nc localhost 2181
</code></pre><h3 id="header-5">Java API</h3>
<p>依赖包</p>
<pre><code class="nullxml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${zookeeper.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<table class="table">
<thead>
<tr>
<th>方法名</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>String create(String path, byte[] data, List&lt;ACL&gt; acl, CreateMode createMode)</code></td>
<td>创建一个给定的目录节点 path  <br> CreateMode:<br>  PERSISTENT <br> PERSISTENT_SEQUENTIAL <br> EPHEMERAL <br> EPHEMERAL_SEQUENTIAL</td>
</tr>
<tr>
<td><code>Stat exists(String path, boolean watch)</code></td>
<td>判断某个 path 是否存在，可设置是否监控这个目录节点 <br> （这里的 watcher 是在创建 ZooKeeper 实例时指定的 watcher）</td>
</tr>
<tr>
<td><code>Stat exists(String path, Watcher watcher)</code></td>
<td>判断某个 path 是否存在，并设置监控  <br> （当这个znode节点被改变时，将会触发当前Watcher）</td>
</tr>
<tr>
<td><code>void delete(String path, int version)</code></td>
<td>删除 path 对应的目录节点 <br> （version 为 -1 可以匹配任何版本）</td>
</tr>
<tr>
<td><code>Stat setData(String path, byte[] data, int version)</code></td>
<td>给 path 设置数据 <br> （version 为 -1 可以匹配任何版本）</td>
</tr>
<tr>
<td><code>byte[] getData(String path, boolean watch, Stat stat)</code></td>
<td>获取这个 path 对应的目录节点存储的数据   <br> （版本等信息可以通过 stat 来指定）</td>
</tr>
<tr>
<td><code>void addAuthInfo(String scheme, byte[] auth)</code></td>
<td>客户端将自己的授权信息提交给服务器 <br> 服务器将根据这个授权信息验证客户端的访问权限</td>
</tr>
<tr>
<td><code>Stat setACL(String path, List&lt;ACL&gt; acl, int version)</code></td>
<td>给某个目录节点重新设置访问权限  <br> （注意：Zookeeper ACL不具有传递性）</td>
</tr>
<tr>
<td><code>List&lt;ACL&gt; getACL(String path, Stat stat)</code></td>
<td>获取某个目录节点的访问权限列表</td>
</tr>
</tbody>
</table>
<p>还有其他方法可以参考 <code>org.apache.zookeeper.ZooKeeper</code></p>
<pre><code class="nulljava"><span class="hljs-comment">// 创建一个与服务器的连接</span>
ZooKeeper zk=<span class="hljs-keyword">new</span> ZooKeeper(ZkServerConfig.ConnectString, ZkServerConfig.SessionTimeout, <span class="hljs-keyword">new</span> Watcher(){
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent event)</span> </span>{
        System.out.println(event.getPath()+<span class="hljs-string">" 触发了 "</span> + event.getType() + <span class="hljs-string">" event , status:"</span>+event.getState());
    }
});

<span class="hljs-comment">// 创建znode</span>
String rootPath=zk.create(RootPath, <span class="hljs-string">"testRootData"</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
         System.out.println(<span class="hljs-string">"创建了路径："</span>+rootPath);

String childOneAPath=zk.create(RootPath+<span class="hljs-string">"/testChildOne"</span>,<span class="hljs-string">"testChildOneData"</span>.getBytes(),Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
         System.out.println(<span class="hljs-string">"创建了路径："</span>+childOnePath);

<span class="hljs-comment">// 读取znode 数据</span>
<span class="hljs-keyword">byte</span>[] data=zk.getData(RootPath, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);
System.out.println(<span class="hljs-string">"目录节点数据："</span>+<span class="hljs-keyword">new</span> String(data));

<span class="hljs-comment">// 更改znode 数据</span>
 zk.setData(RootPath,<span class="hljs-string">"modifyRootData"</span>.getBytes(),-<span class="hljs-number">1</span>);

<span class="hljs-comment">// 查看znode状态</span>
System.out.println(<span class="hljs-string">"目录节点状态：["</span>+zk.exists(RootPath,<span class="hljs-keyword">false</span>)+<span class="hljs-string">"]"</span>); 


<span class="hljs-comment">// 获取所有子节点</span>
List&lt;String&gt; children=zk.getChildren(RootPath,<span class="hljs-keyword">false</span>);
System.out.println(<span class="hljs-string">"目录节点子节点："</span>+children);

<span class="hljs-comment">// 删除znode</span>
zk.delete(childOneAPath,-<span class="hljs-number">1</span>);

<span class="hljs-comment">// 关闭连接</span>
zk.close();
</code></pre>
<h3 id="header-6">Curator</h3>
<p>Curator：Zookeeper开源客户端框架</p>
<ul>
<li>封装ZooKeeper client与ZooKeeper server之间的连接处理</li>
<li>提供了一套Fluent风格的操作API</li>
<li>提供ZooKeeper各种应用场景(recipe, 比如共享锁服务, 集群领导选举机制)的抽象封装</li>
</ul>
<p>依赖包：</p>
<pre><code class="nullxml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${curator.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${curator.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p>Curator几个组成部分 :</p>
<ul>
<li><code>Client</code></li>
<li><code>Framework</code>：对zookeeper的一些基本命令的封装，比如增删改查</li>
<li><code>Recipes</code>：高级特性，主要有Elections(选举)，Locks（锁），Barriers（关卡），Queues等</li>
<li><code>Utilities</code></li>
<li><code>Errors</code></li>
<li><code>Extensions</code> ( recipe扩展 )</li>
</ul>
<p>framework 基础示例：</p>
<pre><code class="nulljava">ExponentialBackoffRetry retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);

<span class="hljs-comment">//client=CuratorFrameworkFactory.newClient(ZkServerConfig.ConnectString, retryPolicy);</span>
client=CuratorFrameworkFactory.builder()
        .connectString(ZkServerConfig.ConnectString)
        .retryPolicy(retryPolicy)
        .connectionTimeoutMs(<span class="hljs-number">1000</span>)
        .sessionTimeoutMs(<span class="hljs-number">1000</span>)
        .build();
client.start();
...
CloseableUtils.closeQuietly(client);
</code></pre>
<pre><code class="nulljava">client.create().forPath(<span class="hljs-string">"/head"</span>, <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">0</span>]);  
client.delete().inBackground().forPath(<span class="hljs-string">"/head"</span>);  
client.create().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(<span class="hljs-string">"/head/child"</span>, <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">0</span>]);  
client.getData().watched().inBackground().forPath(<span class="hljs-string">"/test"</span>);
</code></pre>
<pre><code class="nulljava">CuratorTransaction transaction = client.inTransaction();
Collection&lt;CuratorTransactionResult&gt; results=transaction
        .create().forPath(root+<span class="hljs-string">"/Three"</span>,<span class="hljs-string">"Three test data"</span>.getBytes())
        .and()
        .create().forPath(root+<span class="hljs-string">"/Three/E"</span>,<span class="hljs-string">"E test data"</span>.getBytes())
        .and()
        .create().forPath(root+<span class="hljs-string">"/Three/F"</span>,<span class="hljs-string">"F test data"</span>.getBytes())
        .and()
        .setData().forPath(root+<span class="hljs-string">"/Three/E"</span>,<span class="hljs-string">"Modify E data"</span>.getBytes())
        .and()
        .delete().forPath(root+<span class="hljs-string">"/Three/G"</span>)
        .and().commit();

<span class="hljs-keyword">for</span> (CuratorTransactionResult result : results) {  
    System.out.println(result.getForPath() + <span class="hljs-string">" - "</span> + result.getType());  
}
</code></pre>
<p>说明：</p>
<ul>
<li><code>CuratorFrameworkFactory</code>创建CuratorFramework（即client）<ul>
<li>工厂方法newClient（创建一个默认的实例）</li>
<li>构建方法build（可对实例进行定制）</li>
</ul>
</li>
<li><code>RetryPolicy</code> 连接重试策略<ul>
<li><code>ExponentialBackoffRetry</code>:重试指定的次数, 且每一次重试之间停顿的时间逐渐增加.</li>
<li><code>RetryNTimes</code>:指定最大重试次数的重试策略</li>
<li><code>RetryOneTime</code>:仅重试一次</li>
<li><code>RetryUntilElapsed</code>:一直重试直到达到规定的时间</li>
</ul>
</li>
<li><code>CuratorFramework</code><ul>
<li>常用接口：（线程安全，返回构建器）以<code>forpath()</code>结尾，辅以<code>watch</code>(监听)，<code>withMode</code>（指定模式），<code>inBackground</code>（后台运行）等方法来使用<ul>
<li>create()</li>
<li>delete()</li>
<li>checkExists()</li>
<li>getData()</li>
<li>setData()</li>
<li>getChildren()</li>
</ul>
</li>
<li>还支持事务，一组crud操作同生同灭：<ul>
<li>inTransaction: 发起一个ZooKeeper事务,通过commit() 提交</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Receipt之互斥锁使用示例：</p>
<pre><code class="nulljava">String path = <span class="hljs-string">"/lock"</span>;  
InterProcessLock lock1 = <span class="hljs-keyword">new</span> InterProcessMutex(client, path);
InterProcessLock lock2 = <span class="hljs-keyword">new</span> InterProcessMutex(client, path);
lock1.acquire();
<span class="hljs-keyword">boolean</span> result = lock2.acquire(<span class="hljs-number">10</span>, TimeUnit.SECONDS);
assertFalse(result);
lock1.release();
result = lock2.acquire(<span class="hljs-number">10</span>, TimeUnit.SECONDS);
assertTrue(result);
</code></pre>
<p>说明：</p>
<ul>
<li>acquire() 获得锁</li>
<li>release() 释放锁</li>
</ul>
<p>curator还提供了很多其他的实现，具体参考<a href="https://github.com/Netflix/curator/wiki/Recipes" target="_blank" rel="noopener">Netflix/curator</a></p>
<h2 id="header-7">应用场景</h2>
<h3 id="header-8">统一命名服务</h3>
<p>特点：</p>
<ul>
<li>唯一的名称</li>
<li>可关联到一定资源上</li>
</ul>
<p><strong>PS：</strong> Name Service  已经是 Zookeeper 内置的功能，只要调用 Zookeeper 的 API 就能实现（znode name =&gt; 全局唯一的path，调用zk的create node api很容易创建）</p>
<h3 id="header-9">配置管理</h3>
<p>Configuration Management</p>
<p>发布与订阅 =&gt; 集中式管理，动态更新（各Node动态获取更新）</p>
<ul>
<li>将Config Data保存在 Zookeeper 的某个znode中</li>
<li>所有需要修改的应用机器Clients监控此znode的状态</li>
</ul>
<p><img src="/2015/11/01/config.png" alt="Configuration Mgt"></p>
<h3 id="header-10">集群管理</h3>
<p>Group Membership</p>
<p>Leader选举 （eg: HBase,Storm中）</p>
<p><img src="/2015/11/01/group.png" alt="Group Mgt"></p>
<h3 id="header-11">共享锁</h3>
<p>Locks</p>
<p>在跨进程或者在不同 Server 之间实现同步</p>
<p>保证数据的强一致性（保证zk集群中任意node上的同一znode的数据是相同的）<br>锁：保持独占，时序控制</p>
<p>利用临时顺序节点来实现分布式锁机制（其实就是一种按照创建顺序排队的实现）</p>
<ul>
<li>假设锁存放在znode：<code>/locks</code>下</li>
<li>Client连入，创建<code>EPHEMERAL_SEQUENTIAL</code>类型znode，返回创建的znode路径</li>
<li>通过<code>getChildren(&quot;/locks&quot;,false)</code>获取<code>/locks</code>下所有节点，取得最小的znode路径<ul>
<li>若正是自己创建，则获得锁</li>
<li>若不是，则通过<code>exists(&quot;/locks/xxx&quot;,true)</code>监控比自己创建的路径小一个的值，进入等待</li>
</ul>
</li>
</ul>
<p><img src="/2015/11/01/lock.png" alt="lock"></p>
<h3 id="header-12">队列管理</h3>
<p>先进先出（分布式锁）、队列成员聚齐后统一执行</p>
<p>Zookeeper 可以处理两种类型的队列：</p>
<ul>
<li><p>同步队列（队列成员聚齐后统一执行）</p>
<ul>
<li>创建一个父目录 <code>/synchronizing</code>，每个成员都监控标志（Set Watch）位目录 <code>/synchronizing/start</code> 是否存在</li>
<li>通过创建 <code>/synchronizing/member_i</code> 的临时目录节点加入队列</li>
<li>判断<code>member_i</code>的i 的值是否已经是成员的个数，相等就创建 <code>/synchronizing/start</code>，小于则等待<br><img src="/2015/11/01/queue.png" alt="queue"></li>
</ul>
</li>
<li><p>先进先出（分布式锁）</p>
<ul>
<li>在特定的目录下创建 <code>SEQUENTIAL</code> 类型的子目录 <code>/queue_i</code></li>
<li>出队时通过 <code>getChildren</code> 方法返回当前所有的队列中的元素，消费其中最小的一个</li>
</ul>
</li>
</ul>
<h2 id="header-13">Reference</h2>
<ul>
<li><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/" target="_blank" rel="noopener">分布式服务框架 Zookeeper – 管理分布式环境中的数据</a></li>
<li><a href="http://cailin.iteye.com/blog/2014486" target="_blank" rel="noopener">zookeeper原理</a></li>
</ul>
  </section>
</article>

      <hr/>
      
<section class="post-comment">
	
		<div id="gitment_container"></div>

<link rel="stylesheet" href="/gitment/default.css">
<script src="/gitment/gitment.browser.js"></script>


<script type="text/javascript">
	var gitment = new Gitment({
	  id: document.location.pathname,
	  owner: 'chenjin-zero',
	  repo: 'blogComment',
	  oauth: {
	    client_id: '36a09bb7399efe69c6ce',
	    client_secret: 'ad9ad546b23b708c71d92e513dc36e0486179dea',
	  }
	})

    // var gitment = new Gitment({
    //   id: 'gitment-introduction',
    //   title: 'Gitment：使用 GitHub Issues 搭建评论系统',
    //   owner: 'imsun',
    //   repo: 'imsun.net',
    //   oauth: {
    //     client_id: '4ce2737289ce197769a1',
    //     client_secret: '3731a9d6ff407355af912ea7a86dd0dd772ca84d',
    //   },
    // })
      
	gitment.render('gitment_container')
</script>
	
</section>

    </div>
  </div>
</body>

<script src="/jquery/dist/jquery.min.js"></script>
<script src="/bootstrap/dist/js/bootstrap.min.js"></script>
<script src="/highlight/highlight.pack.js"></script>
<script type="text/javascript">
  hljs.initHighlightingOnLoad();
  
  $(document).ready(function(){
    var sidebarCtrl=$("#sidebar-ctrl");
    var sidebar=$("#sidebar");
    var wrapper=$("#wrapper");
    sidebarCtrl.on("click",function(event){
        //alert("click");
        sidebar.toggleClass("sidebar-toggle");
        wrapper.toggleClass("sidebar-toggle");
        sidebarCtrl.toggleClass("sidebar-toggle");
        sidebarCtrl.toggleClass("active");
    })
  });
</script>


</html>
