<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Linux</title>
  
  <!-- Meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="linux,pipe,vi,shell,cmd,mount,xargs,awk,find,cut,crontab">
  
  
    <meta name="description" content="Linux and Shell Introduce">
  

  <!-- Feed -->
  
    <link rel="alternative" href="/atom.xml" title="SixDegree" type="application/atom+xml">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/bootstrap/dist/css/bootstrap.css">
  
	
		<link rel="stylesheet" href="/highlight/demo/styles/tomorrow-night-bright.css">
	
    
  
  <link rel="stylesheet" href="/css/fontello.css">
  <link rel="stylesheet" href="/css/style.css">

  <!-- Site Analyse -->
  
	<script>
	var userID='2bbb83cc0f781dd7502e9d5e19661866';
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?"+userID;
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>


</head>

<body data-spy="scroll" data-target="#nav-catalog">
  <div id="top-push"></div>
<a href="#top-push" id="go-top">
	<span class="glyphicon glyphicon-chevron-up"></span>
</a>
  <aside id="sidebar">
    <section class="sidebar-header">Catalog</section>
     <nav id="nav-catalog">
        <ol class="sidebar-nav nav"><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-1"><span class="sidebar-nav nav-text">Starter</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-2"><span class="sidebar-nav nav-text">特点</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-3"><span class="sidebar-nav nav-text">历史</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-4"><span class="sidebar-nav nav-text">运行级别</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-5"><span class="sidebar-nav nav-text">分区</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-6"><span class="sidebar-nav nav-text">文件系统</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-7"><span class="sidebar-nav nav-text">管道</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-8"><span class="sidebar-nav nav-text">环境变量</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-9"><span class="sidebar-nav nav-text">vi 编辑器</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-10"><span class="sidebar-nav nav-text">Shell</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-11"><span class="sidebar-nav nav-text">常用命令</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-12"><span class="sidebar-nav nav-text">ls mv rm</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-13"><span class="sidebar-nav nav-text">tar,gzip,zip</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-14"><span class="sidebar-nav nav-text">ps,kill</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-15"><span class="sidebar-nav nav-text">jobs,fg,bg</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-16"><span class="sidebar-nav nav-text">du,mount</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-17"><span class="sidebar-nav nav-text">重执行命令</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-18"><span class="sidebar-nav nav-text">cut</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-19"><span class="sidebar-nav nav-text">find</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-20"><span class="sidebar-nav nav-text">xargs</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-21"><span class="sidebar-nav nav-text">awk</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-22"><span class="sidebar-nav nav-text">sed</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-23"><span class="sidebar-nav nav-text">uniq</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-24"><span class="sidebar-nav nav-text">curl</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-25"><span class="sidebar-nav nav-text">crontab</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-26"><span class="sidebar-nav nav-text">Shell</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-27"><span class="sidebar-nav nav-text">C Shell</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-28"><span class="sidebar-nav nav-text">K Shell</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-29"><span class="sidebar-nav nav-text">B Shell</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-30"><span class="sidebar-nav nav-text">注意</span></a></li></ol></li></ol>
    </nav>
  </aside>
  <span id="sidebar-ctrl" class="glyphicon glyphicon-list-alt circle"></span>
  <div id="wrapper">
    <header>
  <nav class="navbar navbar-default">
    <div class="container-fluid">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#nav-menu" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/">SixDegree</a>
      </div>
      <div class="collapse navbar-collapse" id="nav-menu">
        <ul class="nav navbar-nav navbar-right">
          
              <li  >
                <a href="/">Blogs</a>
              </li>
          
              <li  >
                <a href="/tags.html">Tags</a>
              </li>
          
              <li  >
                <a href="/about.html">About</a>
              </li>
          
          
              <li>
                <a href="/atom.xml" target="_blank">
                  <span class="icon-rss"></span>
                </a>
              </li>
          
              <li>
                <a href="http://github.com/sixdegree" target="_blank">
                  <span class="icon-github"></span>
                </a>
              </li>
          
        </ul>
      </div>
    </div>
  </nav>
</header>



    <div class="container">
      <article class="detail" role="main">
  <section class="post-header">
    <h1 class="post-title">Linux</h1>
    <ul class="post-meta">
      <li>
        <span class="glyphicon glyphicon-calendar"></span>
        <time datetime="2014-06-30T16:00:00.000Z">2014-07-01</time>
      </li>
      
        <li>
         <span class="glyphicon glyphicon-tags"></span>
          
            <a href="/tags.html#tag-Linux">Linux</a>
          
        </li>
      
    </ul>
  </section>
  <section class="post-content">
    <h2 id="header-1">Starter</h2>
<h3 id="header-2">特点</h3>
<ul>
<li>优点：<ul>
<li>免费，开源</li>
<li>支持多线程，多用户</li>
<li>安全性好</li>
<li>对内存和文件管理优越</li>
<li>linux 最小只需 4M    =&gt; 嵌入式开发</li>
</ul>
</li>
<li>缺点：<ul>
<li>操作相对困难</li>
</ul>
</li>
</ul>
<h3 id="header-3">历史</h3>
<ol>
<li>1960 麻省理工学院 30 个人同时使用</li>
<li>1965 mit,ge,bell 30 =&gt;300 个人分时操作，multis计划【火星计划】</li>
<li>1969 火星计划失败，ken开发了一个file server system【文件系统】</li>
<li>1973 unix诞生 开源<ul>
<li>IBM：        aix</li>
<li>Sun：         solaris</li>
<li>Hp：         hp-Unix</li>
<li>伯克利分校： bsd</li>
</ul>
</li>
<li>minix系统</li>
<li>linus 芬兰 PC386 =&gt; 将minix移植到PC,1991=&gt; 1994(1.0) linux[linus is not unix]</li>
<li>RedHat红帽子公司<ul>
<li>s.u.s.e</li>
<li>红旗linux</li>
<li>Ubuntu</li>
</ul>
</li>
</ol>
<h3 id="header-4">运行级别</h3>
<ul>
<li>运行级别：<ul>
<li>0    关机</li>
<li>1    单用户</li>
<li>2    多用户，无网络服务</li>
<li>3    多用户，有网络服务</li>
<li>4    系统未使用，保留给用户</li>
<li>5    图形界面</li>
<li>6    系统重启</li>
</ul>
</li>
<li>常用运行级别 3/5</li>
<li><code>init[0123456]</code> 启动</li>
<li>修改运行级别 <code>/etc/inittab</code> =&gt; <code>id:5:initdefault</code> 修改这行中的数字</li>
<li>解决错误配置后无法启动：<ul>
<li>在进入grub引导程序时，按e</li>
<li>选择第二行，输入e</li>
<li>在最后输入 1 回车，代表单用户级别（ 因为单用户模式不读取 <code>/etc/inittab</code>文件 ）</li>
<li>按 b ，重新启动进入了单用户模式，再修改该配置文件</li>
</ul>
</li>
</ul>
<h3 id="header-5">分区</h3>
<ul>
<li>基本分区（Primary Partion）<ul>
<li>可以马上使用，单不能在分区</li>
</ul>
</li>
<li>扩展分区（Extension Partion）<ul>
<li>需进行二次分区后才可使用</li>
<li>即逻辑分区（Logical Partion），且无数量限制</li>
</ul>
</li>
<li>硬盘<ul>
<li>一块硬盘上： 基本分区（主分区）+扩展分区个数&lt;=4</li>
<li>硬盘分两种：IDE/SCSI （”sdx~” / “hdx~”）<ul>
<li><code>sd</code> :SCSI硬盘(较好)</li>
<li><code>hd</code> :IDE硬盘</li>
<li><code>x</code>  :盘号 (a 基本盘，b基本从属盘，c铺助盘，d铺助从属盘 )</li>
<li><code>~</code>  :分区 ( 1-4 主分区或扩展盘 ,5 开始为逻辑分区 )</li>
</ul>
</li>
</ul>
</li>
<li>相关命令：<ul>
<li><code>mount [-参数] [设备名称] [挂载点]</code></li>
<li><code>umount [设备名称]</code></li>
<li><code>df</code>           【查看磁盘使用情况】</li>
<li><code>df -l</code>        【查看某个目录在哪个分区】</li>
<li><code>df -h</code></li>
<li><code>fdisk -l</code>    【查看linux系统分区具体情况】</li>
</ul>
</li>
</ul>
<h3 id="header-6">文件系统</h3>
<p>级层式的树状目录结构，根目录 <code>/</code></p>
<ul>
<li><code>root</code> 【存放root用户的相关文件】</li>
<li><code>home</code> 【存放普通用户的相关文件】</li>
<li><code>bin</code> 【存放常用命令】</li>
<li><code>sbin</code> 【存放需具有一定权限才可使用的命令】</li>
<li><code>mnt</code>     【默认挂载软驱，光驱的目录】</li>
<li><code>etc</code>     【存放系统配置与管理的相关文件】</li>
<li><code>var</code> 【存放经常变化的文件，具有变动性质的相关程序目录】</li>
<li><code>boot</code> 【存放系统启动时的引导文件】</li>
<li><code>usr</code>     【程序默认安装处】</li>
<li><code>dev</code>     【接口设备文件目录，如had表示硬盘】</li>
<li><code>proc</code> 【目前系统核心与程序执行的信息】</li>
</ul>
<pre><code class="lang-bash">&gt; ls -l
-rw-r--r--| 1 | tom | policeman  |    11 |  Dec 9 09:32   | myTest.java
</code></pre>
<ul>
<li><code>-|rw-|r--|r--</code> 文件类型及权限<ul>
<li>文件类型<ul>
<li><code>-</code>代表普通文件</li>
<li><code>d</code>代表文件夹 (其实也是个文件)</li>
<li><code>l</code>代表链接</li>
</ul>
</li>
<li>文件的所有者对该文件的权限</li>
<li>文件所在组的其他用户对该文件的权限</li>
<li>其他组的用户对该文件的权限</li>
</ul>
</li>
<li><code>1</code><ul>
<li>若myTest.java是个文件，则为 1</li>
<li>若myTest.java是个文件夹，则表示次文件夹下有多少个文件</li>
</ul>
</li>
<li><code>tom</code> 文件所有者</li>
<li><code>policeman</code> 文件所在组</li>
<li><code>11</code> 文件大小</li>
<li><code>Dec 9 09:32</code> 最后修改日期</li>
<li><code>myTest.java</code> 文件名</li>
</ul>
<p>文件使用：</p>
<ol>
<li><p>组</p>
<ul>
<li><code>groupadd policeman</code>        【添加组】</li>
<li><code>cat /etc/group | more</code>    【查看所有linux中所有组信息】</li>
<li>eg：<code>policeman:x:503</code><ul>
<li>x   ：密码（加密了）</li>
<li>503 ：代表policeman这个组的id</li>
</ul>
</li>
</ul>
</li>
<li><p>用户</p>
<ul>
<li><code>useradd -g 组名 用户名</code> 【创建用户，并将该用户分配到指定组中】</li>
<li><code>passwd xxxxx</code>                【设置密码】</li>
<li><code>usermod -g 组名 用户名</code> 【改变某个用户所在组（root才可操作）】</li>
<li><code>userdel 用户名</code>    【删除用户】</li>
<li><code>userdel -r tom</code>        【删除用户以及该用户主目录】</li>
<li><p>eg：</p>
<pre><code class="lang-bash">&gt; useradd -g policeman tom`
&gt; cat /ect/password | more

tom:x:503:503::/home/tom:/bin/bash
(用户名):(密码):(用户ID):(用户所在组ID)::(用户主目录):(此用户使用的Shell解析器)
</code></pre>
</li>
</ul>
</li>
<li><p>文件owner</p>
<ul>
<li><code>chown 用户名 文件名</code>【修改文件的所有者】</li>
<li><code>chgrp 组名 文件名</code>    【修改文件的所在组】<br>+<code>ls -ahl</code>     【查看文件的所有者】</li>
<li><code>who am i</code>【查看当前用户】</li>
<li>eg:<pre><code class="lang-bash">&gt; chown wang myTest.java
&gt; chown root ./tom
&gt; chown -R root ./tom    【改变tom这个目录及其下所有文件和目录的所有者为root】
</code></pre>
</li>
</ul>
</li>
<li><p>文件访问权限（只有 root 和此文件的所有者可修改）</p>
<ul>
<li>权限分三组：<ul>
<li>文件所有者(o)</li>
<li>同组用户(g)</li>
<li>其余用户(a)</li>
</ul>
</li>
<li>每组权限分为3位：<ul>
<li>r(read) 可读，用 4 表示</li>
<li>w(write) 可写，用 2 表示</li>
<li>x(execute) 可执行，用 1 表示</li>
</ul>
</li>
<li>权限是相加的，例如：<ul>
<li>rwx是7</li>
<li>rw是6</li>
</ul>
</li>
<li>当对文件进行访问时，内核就检查进程关联的ID和该ID对应的权限位是否符合要求</li>
<li>操作与权限<table class="table">
<thead>
<tr>
<th>操作</th>
<th>需要的权限</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建/删除/改名 文件</td>
<td>对父目录的w和x权限，以及所有祖先目录的x权限</td>
</tr>
<tr>
<td>修改文件权限</td>
<td>有效用户ID是文件所有者，或者拥有root权限</td>
</tr>
<tr>
<td>修改文件内容</td>
<td>对父目录的x权限，以及所有祖先目录的x权限</td>
</tr>
<tr>
<td>列出目录的文件列表</td>
<td>对父目录的rx权限，以及所有祖先目录的x权限</td>
</tr>
<tr>
<td>修改文件的所有者</td>
<td>拥有root权限</td>
</tr>
</tbody>
</table>
</li>
<li>对于目录文件(文件夹)<ul>
<li>读取权限：列出文件夹里文件列表的权限</li>
<li>写入权限：修改文件夹里的文件的名字的权限</li>
<li>执行权限：进入文件夹的权限</li>
</ul>
</li>
<li>eg:<pre><code class="lang-bash">&gt; chmod 777 tom
&gt; chmod 770 tom
&gt; chmod u=rwx,g=rx,o=rx tom
&gt; chmod u-x,g+w tom
&gt; chmod a+r tom
</code></pre>
</li>
<li>注意：修改某文件夹的权限，不代表该文件夹下的文件的权限也跟着修改</li>
</ul>
</li>
<li><p>文件三个主要的变动时间：</p>
<ul>
<li>modification time (mtime)：<ul>
<li>当该文件的『内容数据』变更时，就会升级这个时间</li>
<li>内容数据指的是文件的内容，而不是文件的属性或权限</li>
</ul>
</li>
<li>status time (ctime)：<ul>
<li>当该文件的『状态 (status)』改变时，就会升级这个时间</li>
<li>举例来说，像是权限与属性被更改了，都会升级这个时间</li>
</ul>
</li>
<li>access time (atime)：<ul>
<li>当『该文件的内容被取用』时，就会升级这个读取时间 (access)</li>
<li>举例来说，我们使用 cat 去读取 /etc/man.config，就会升级该文件的 atime</li>
</ul>
</li>
<li>示例:<pre><code class="lang-bash">&gt; ls -l /etc/man.config
-rw-r--r-- 1 root root 4617 Jan  6  2007 /etc/man.config
&gt; ls -l --time=atime /etc/man.config
-rw-r--r-- 1 root root 4617 Sep 25 17:54 /etc/man.config
&gt; ls -l --time=ctime /etc/man.config
-rw-r--r-- 1 root root 4617 Sep  4 18:03 /etc/man.config
</code></pre>
</li>
</ul>
</li>
<li><p>修改文件时间或建置新档： <code>touch</code></p>
</li>
<li><p>共享</p>
<ul>
<li>windows &lt;=&gt; windows 使用网络邻居实现文件共享</li>
<li>windows &lt;=&gt; linux 使用samba服务</li>
</ul>
</li>
</ol>
<h3 id="header-7">管道</h3>
<ul>
<li><code>stdin(fd=0)</code> 标准输入 （文件描述符为0）</li>
<li><code>stdout(fd=1)</code> 标准输出（文件描述符为1）</li>
<li><code>stderr(fd=2)</code> 标准错误输出 （文件描述符为2）</li>
<li><code>&gt;</code> 将stdout定向输出到文件<ul>
<li>如果文件不存在，就创建文件；</li>
<li>如果文件存在，就将其清空；</li>
<li>相当于 <code>1&gt;</code>，不包括stderr</li>
<li><code>&gt;&amp;</code> 将stdout与stderr一起导向</li>
<li><code>(command &gt; stdout_file) &gt; &amp;stderr_file</code> 把stderr和stdout分开导向<pre><code>2 &gt; file.txt    # 将文件句柄2(即stderr)重定向到文件file.txt中
2 &gt; &amp;1          # 将文件句柄2(即stderr)重定向到文件句柄1(即stdout)指向的文件中
test.sh &gt; /tmp/test.log 2&gt;&amp;1
</code></pre></li>
</ul>
</li>
<li><code>&gt;&gt;</code> 将stdout追加到目标文件中<ul>
<li>如果文件不存在，就创建文件；</li>
<li>如果文件存在，则将新的内容追加到那个文件的末尾</li>
</ul>
</li>
<li><code>|</code> 管道，连结上个指令的标准输出，做为下个指令的标准输入<ul>
<li><code>cmd1 | cmd2</code> 将cmd1 的 stdout 作为 cmd2 的 stdin</li>
<li><code>cmd1 | &amp; cmd2</code> stderr合并到stdout, 然后管道到下一条命令</li>
</ul>
</li>
</ul>
<h3 id="header-8">环境变量</h3>
<pre><code class="lang-bash"># 查看环境变量
&gt; env

# 查看某个环境变量
&gt; echo 变量名

# 设置一个新变量
&gt; export 变量名=变量值

# 在原变量值得基础上更新
&gt; export 变量名=$变量名:xxx

# 清除某环境变量
&gt; unset 变量名
</code></pre>
<p>例如：</p>
<pre><code class="lang-bash">export TEST=&quot;test&quot;      # 增加一个变量
env|grep TEST           # 输出结果:   TEST=test
unset TEST              # 删除
env|grepTEST            # 没有输出,证明变量TEST已不存在
</code></pre>
<ul>
<li><code>/etc/profile</code> 全局的环境变量文件，只要登陆系统的用户都会执行里面的ENV环境变量设置</li>
<li><code>～/.profile</code>     用户环境变量<ul>
<li>在用户主目录下</li>
<li>用户登陆时会执行此文件里的ENV环境变量设置</li>
<li>执行<code>. ~/.profile</code>立即生效</li>
</ul>
</li>
<li><code>~/.kshrc</code>，<code>~/.bshrc</code>,<code>~/.cshrc</code> shell环境变量<ul>
<li>在用户主目录下</li>
<li>执行对应Shell下面的子shell时会执行此文件里的ENV环境变量设置</li>
<li>执行<code>. ~/.kshrc</code>/<code>~/.bshrc</code>/<code>~/.cshrc</code>立即生效</li>
</ul>
</li>
<li>注意<ul>
<li>root用户的环境变量在<code>/etc/profile</code>下</li>
<li>从普通用户su到root时，环境变量设置可能不生效，需<code>su - root</code></li>
<li>处理直接执行配置文件外，也可使用<code>source</code>命令使配置生效</li>
</ul>
</li>
</ul>
<h3 id="header-9">vi 编辑器</h3>
<ol>
<li><code>vi Hello.java</code></li>
<li><code>i</code>                    【进入到插入模式insert】</li>
<li><code>esc</code>键                 【命令模式切换】</li>
<li>输入冒号 <code>：</code></li>
<li><code>wq</code>        【保存退出】; <code>q!</code>       【退出不保存】</li>
</ol>
<p>说明：</p>
<ul>
<li><code>w</code>         【写入保存】</li>
<li><code>q</code>         【退出，若内容修改，vi会报错】 </li>
<li><code>q!</code>        【强制离开vi，并不保存文件】</li>
<li><code>wq</code>        【保存并退出vi】</li>
<li><code>set nu</code>     【在文件每行行处加入行号】</li>
<li><code>set nonu</code>     【取消行号】</li>
<li>输入数字，再按<code>esc</code>键 【将光标移至该行行首】</li>
<li><code>/字符串</code>     【查找字符串，按n键往下继续查找】</li>
<li><code>?字符串</code>     【查找字符串，按n键往上继续查找】</li>
</ul>
<h3 id="header-10">Shell</h3>
<table class="table">
<thead>
<tr>
<th>Shell名称</th>
<th>开发者</th>
<th>命令名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bourne</td>
<td>S.R.Bourne</td>
<td>/bin/bash</td>
</tr>
<tr>
<td>C</td>
<td>Bill Joy</td>
<td>/bin/csh</td>
</tr>
<tr>
<td>Kom</td>
<td>David</td>
<td>/bin/ksh</td>
</tr>
</tbody>
</table>
<ul>
<li><code>env</code>            【显示当前操作系统的环境变量】</li>
<li><code>chsh -s 新的shell</code>    【修改当前使用的shell】<ul>
<li>eg: <code>chsh -s /bin/csh</code> (生效需注销重新登录下)</li>
</ul>
</li>
<li>修改User的默认shell,有两种方式:<ul>
<li>直接修改 <code>/etc/passwd</code> 文件（eg： <code>/sbin/sh</code> =&gt; <code>/bin/bsh</code>）</li>
<li><code>usermod -s /usr/bin/bash root</code></li>
</ul>
</li>
<li>shell 解释为内核可执行的代码<ul>
<li>命令(eg:cp,mkdir)  &lt;=&gt; Shell  &lt;=&gt;linux内核</li>
</ul>
</li>
</ul>
<h2 id="header-11">常用命令</h2>
<pre><code class="lang-bash">shutdown -h now     立即进行关机
shutdown -r now     现在重新启动计算机
reboot            现在重新启动计算机
startx             进入图形界面

su -         切换用户
logout    用户注销
tab 快捷键，自动补全

man         【相当于help】
dir
ls -a         【显示隐藏文件】
ls -l         【显示长列表格式】
cd          【改变目录】
pwd       【显示当前工作目录】
mkdir     【建立目录】
rmdir     【删除空目录】
touch     【建立空文件】
more         【分页显示，上一页ctrl+pageUp】

cp              【复制命令】    
cp -r dir1 dir2     【递归复制命令】    eg:  cp a.out /home/tom/

mv
rm 
rm -rf             【删除所有内容，r表示递归，f表示强制】

ln                 【建立符合连接】
ln -s 源目标
ln -s /etc/inittab inittab 【inittab 指向实际文件 /etc/inittab】

find 目录 -name aaa.java
find 目录 -amin -10 【 10分钟内存取的文件或目录 atime小时】
find 目录 -cmin -10 【 10分钟内更改的文件或目录 ctime小时 +表示前】
find 目录 -size +10k【 大小为10k的文件 】

shell history 查阅历史记录命令
history 5 【 显示最近使用的5个命令 】
!5          【 执行历史编号为5的命令 】
!ls          【 执行最后一次以ls开头的命令 】
</code></pre>
<pre><code class="lang-bash">&gt; uname
SunOS

&gt; uname -n
SZ1SA006

&gt; hostname
SZ1SA006

&gt; logname
cim1tdtp

&gt; echo $LOGNAME
cim1tdtp

&gt; whoami     # 显示有效的当前用户
cim1tdtp
</code></pre>
<h3 id="header-12">ls mv rm</h3>
<ol>
<li><p><code>ls</code>列出文件 / 文件夾  ls</p>
<pre><code class="lang-bash"> # 列出文件夾個數
 ls -l | grep ^d | wc -l

 # 列出非文件夾個數
 ls -l | grep -v ^d | wc -l

 # ls -F: 把文件按照类型归类（会在末尾加上/ *等符号标识）
 # grep /$ 挑出以/结尾的行 ；PS:/标识是目录
 ls -F | grep /$
</code></pre>
</li>
<li><p><code>mv</code> 移动/重命名</p>
<pre><code class="lang-bash"> mv MCK9[1-3]* 2009\.
 cat temp.txt | xargs -n1 -i mv {} 2011/
</code></pre>
</li>
<li><p><code>rm</code> 刪除文件或目錄</p>
<pre><code class="lang-bash"> rm [-dfirv][--help][--version][文件或目录...]
</code></pre>
</li>
</ol>
<ul>
<li><code>-d</code>,<code>--directory</code>  删除目录。</li>
<li><code>-f</code>,<code>--force</code>    强制删除文件或目录（即使原档案属性设为唯读，也直接删除，无需逐一确认）</li>
<li><code>-i</code>，<code>--interactive</code>    删除前逐一询问确认。</li>
<li><code>-r</code>,<code>-R</code>,<code>--recursive</code>  递归处理，将指定目录下的所有文件及子目录一并处理。</li>
<li><code>-v</code>,<code>--verbose</code> 显示指令执行过程。</li>
<li><code>--help</code>  在线帮助。</li>
<li><code>--version</code> 显示版本信息</li>
<li><p>注意：删除目录必须加上参数<code>-r</code>，否则预设仅会删除文件</p>
<pre><code class="lang-bash">  #刪除文件
  rm file

  #删除所有C语言程式档；删除前逐一询问确认
  rm -i *.c

  #刪除文件夾
  rm -r dir

  #批量刪除符合條件的文件
  ls -d * | grep -v tar | xargs -n5 rm -r
</code></pre>
</li>
</ul>
<h3 id="header-13">tar,gzip,zip</h3>
<pre><code class="lang-bash">ls -d * | xargs -n5 -i tar -cf {}.tar {}
ls -d * | xargs -n5 -i zip -r &quot;{}.zip&quot; {}
</code></pre>
<ol>
<li><p>tar</p>
<ul>
<li>参数：<ul>
<li><code>-c</code>   创建一个新归档</li>
<li><code>-x</code>   从归档中抽取文件</li>
<li><code>-f</code><ul>
<li>与 <code>-c</code> 选项一起使用时，创建的 tar 文件使用该选项指定的文件名；</li>
<li>与<code>-x</code>选项一起使用时，则解除该选项指定的归档</li>
</ul>
</li>
<li><code>-t</code>   显示包括在 tar 文件中的文件列表</li>
<li><code>-v</code>   显示文件的归档进度</li>
<li><code>-z</code>   使用 gzip 来压缩 tar 文件</li>
<li><code>-j</code>   使用 bzip2 来压缩 tar 文件</li>
</ul>
</li>
<li>包 (.tar文件)<ul>
<li>打包： <code>tar cvf FileName.tar DirName</code></li>
<li>解包： <code>tar xvf FileName.tar</code></li>
<li>注：tar是打包，不是压缩！</li>
</ul>
</li>
<li>压缩包 (.tar.Z)<ul>
<li>解压：<code>tar Zxvf FileName.tar.Z</code></li>
<li>压缩：<code>tar Zcvf FileName.tar.Z DirName</code></li>
</ul>
</li>
<li><p>示例：</p>
<pre><code class="lang-bash"># 将test文件夹打包为test.tar
tar cvf test.tar test                #將test文件夾打包為test.tar
# 将test.tar包进行压缩为test.tar.Z文件
compress test.tar

# 解压FileName.Z文件
uncompress FileName.Z

# 一步到位，直接解压解包
uncompress &lt; test.tar.Z | tar xf
</code></pre>
</li>
</ul>
</li>
<li><p>gzip</p>
<ul>
<li>参数：<ul>
<li><code>-c</code> 将输出写到标准输出上，并保留原有文件。</li>
<li><code>-d</code> 将压缩文件解压。</li>
<li><code>-l</code> 对每个压缩文件，显示下列字段：</li>
<li><code>-r</code> 递归式地查找指定目录并压缩其中的所有文件或者是解压缩。</li>
<li><code>-t</code> 测试，检查压缩文件是否完整。</li>
<li><code>-v</code> 对每一个压缩和解压的文件，显示文件名和压缩比。</li>
<li><code>-num</code> 用指定的数字num调整压缩的速度<ul>
<li><code>-1</code>或<code>--fast</code>表示最快压缩方法（低压缩比）</li>
<li><code>-9</code>或<code>--best</code>表示最慢压缩方法（高压缩比）</li>
<li>系统缺省值为6</li>
</ul>
</li>
</ul>
</li>
<li><p>示例：</p>
<pre><code class="lang-bash"># 压缩
gzip FileName

# 解压缩
gzip -dv FileName
</code></pre>
</li>
</ul>
</li>
<li><p>zip/unzip</p>
<pre><code class="lang-bash">zip [参数] [打包后的文件名] [打包的目录路径]
</code></pre>
</li>
</ol>
<ul>
<li>参数：<ul>
<li><code>-a</code>     将文件转成ASCII模式</li>
<li><code>-F</code>     尝试修复损坏的压缩文件</li>
<li><code>-h</code>     显示帮助界面</li>
<li><code>-m</code>     将文件压缩之后，删除源文件</li>
<li><code>-n</code> 特定字符串    不压缩具有特定字尾字符串的文件</li>
<li><code>-o</code>     将压缩文件内的所有文件的最新变动时间设为压缩时候的时间</li>
<li><code>-q</code>     安静模式，在压缩的时候不显示指令的执行过程</li>
<li><code>-r</code>     将指定的目录下的所有子目录以及文件一起处理</li>
<li><code>-S</code>     包含系统文件和隐含文件（S是大写）</li>
</ul>
</li>
<li><p>示例</p>
<pre><code class="lang-bash">  #压缩文件夹
  zip -r test.zip test

  #解压
  unzip test.zip
</code></pre>
</li>
<li>更多<a href="http://www.cnblogs.com/say0507/archive/2011/03/31/2001459.html" target="_blank" rel="noopener">参考</a></li>
</ul>
<h3 id="header-14">ps,kill</h3>
<p>查杀进程</p>
<pre><code class="lang-bash">ps -ef | grep nationz | grep &quot;sh -c&quot; | awk &#39;{print $2}&#39; | xargs -i kill -9 {}
ps -e -o pid -o comm
ps -ax -o pid -o comm | grep oic
ps -ax -o pid -o comm | grep oic
ps -e -o pid -o comm | grep oic | awk &#39;{print $1}&#39; | xargs -n2 -i kill -9 {}
kill -9 `ps -a -o pid -o comm | grep oic | awk &#39;{print $1}&#39;`
</code></pre>
<h3 id="header-15">jobs,fg,bg</h3>
<pre><code class="lang-bash">&gt; sleep 15 &amp;
[1] 2706

#列出当前活动作业
&gt; jobs
[1]  + Running              sleep 15

# 显示作业号，PID
# jobs -l
[1]  +  2706 Running              sleep 15

&gt; jobs
[1]    Done                 sleep 15

&gt; sleep 15            #按^Z停止sleep命令（sleep没有使用CPU但被挂起在后台）
^Z
Stopped (user)

&gt; bg                #使最后一个后台作业在后台开始执行
[1]  + sleep 15 &amp;
&gt; jobs
[1]  + Running              sleep 15

&gt; fg %1            #将编号为[1]的作业拿到前台
sleep 15
</code></pre>
<h3 id="header-16">du,mount</h3>
<ol>
<li><p><code>du</code> 查看文件或者目录大小</p>
<ul>
<li><code>-a</code>：显示全部目录和其次目录下的每个档案所占的磁盘空间 </li>
<li><code>-b</code>：大小用bytes来表示 (默认值为k bytes) </li>
<li><code>-c</code>：最后再加上总计 (默认值) </li>
<li><code>-s</code>：只显示各档案大小的总合 (summarize) </li>
<li><code>-x</code>：只计算同属同一个档案系统的档案 </li>
<li><code>-L</code>：计算所有的档案大小</li>
<li>常用：<code>du -sm</code>，<code>du -sh</code>. 查询档案或目录的磁盘使用空间</li>
<li><code>fdisk</code>: 查看硬件分区的大小的<ul>
<li>一般使用：<code>fdisk -l</code></li>
<li>如果挂载了多块硬盘，每个硬盘有多个分区，就是用fdisk</li>
</ul>
</li>
<li>eg:<pre><code class="lang-bash">du -a
du -h | awk &#39;$1 ~ /G/&#39;
du -h | awk &#39;$1 ~ /M/&#39;
du -ks /tmp
df -k
</code></pre>
</li>
</ul>
</li>
<li><p>装载 mount</p>
<pre><code class="lang-bash"> # 装载
 mount [-t vfstype] [-o options] device dir

 # 卸载
 umount dir
</code></pre>
</li>
</ol>
<ul>
<li><code>-a</code> 将 <code>/etc/fstab</code> 中定义的所有档案系统挂上</li>
<li><code>-f</code>伪装mount，作出检查设备和目录的样子，但并不真正挂载文件系统。</li>
<li><code>-n</code> 不把安装记录在/etc/mtab 文件中。</li>
<li><code>-r</code> 讲文件系统安装为只读。</li>
<li><code>-v</code> 详细显示安装信息。</li>
<li><code>-w</code> 将文件系统安装为可写，为命令默认情况。</li>
<li><code>-t</code>  指定设备的文件系统类型<ul>
<li><code>ext2</code>  linux目前常用的文件系统 </li>
<li><code>msdos</code>  MS-DOS的fat，就是fat16 </li>
<li><code>vfat</code>  windows98常用的fat32 </li>
<li><code>nfs</code>  网络文件系统 </li>
<li><code>iso9660</code>  CD-ROM光盘标准文件系统 </li>
<li><code>ntfs</code>  windows NT/2000/XP的文件系统 </li>
<li><code>auto</code> 自动检测文件系统 </li>
</ul>
</li>
<li><p><code>-o</code>  指定挂载文件系统时的选项，有些也可写到在/etc/fstab中</p>
<ul>
<li><code>defaults</code> 使用所有选项的默认值（auto、nouser、rw、suid）</li>
<li><code>auto</code>/<code>noauto</code> 允许/不允许以 –a选项进行安装</li>
<li><code>dev</code>/<code>nodev</code> 对/不对文件系统上的特殊设备进行解释</li>
<li><code>exec</code>/<code>noexe</code>c 允许/不允许执行二进制代码</li>
<li><code>suid</code>/<code>nosuid</code> 确认/不确认suid和sgid位</li>
<li><code>user</code> /<code>nouser</code> 允许/不允许一般用户挂载</li>
<li><code>codepage=XXX</code> 代码页 </li>
<li><code>iocharset=XXX</code> 字符集 </li>
<li><code>ro</code> 以只读方式挂载 </li>
<li><code>rw</code> 以读写方式挂载 </li>
<li><code>remount</code> 重新安装已经安装了的文件系统</li>
</ul>
</li>
<li><p>例如：</p>
<pre><code class="lang-bash">  mount 10.7.33.25:/cim1_release /cim
  umount /cim
</code></pre>
</li>
<li><p>注意：</p>
<ul>
<li>挂载点(dir)：必须是一个已经存在的目录（目录可以不为空，但挂载后原内容将不可用，umount后恢复正常）</li>
<li>开机重启后自动挂载，需将挂载设置在<code>/etc/vfstab</code>文件中<ul>
<li>例如：将<code>10.7.33.25:/cim1_release/ - /cim nfs - yes bg,soft</code>添加到文件中</li>
</ul>
</li>
</ul>
</li>
<li><p>更多<a href="http://www.cnblogs.com/xd502djj/p/3809375.html" target="_blank" rel="noopener">参考</a></p>
</li>
</ul>
<h3 id="header-17">重执行命令</h3>
<ul>
<li><p><code>!</code>  执行来自历史清单的一个命令</p>
<ul>
<li><code>!^</code> 取得第1个变元</li>
<li><code>!$</code> 取得最后一个变元</li>
<li><code>!*</code> 取得所有变元</li>
<li><p><code>!:2</code> 取得第2个变元</p>
<pre><code class="lang-bash">cat file1 file2 file3
( 0     1        2     3   )

ls !:2    # ls file2
ls !^    # ls file1
ls !$    # ls file3
ls !*    # ls file1 file2 file3
!!:p        # ls file1 file2 file3     (打印但不执行历史清单中的最后一个命令，更新历史清单)
</code></pre>
<pre><code class="lang-bash"># 从历史清单中取得最后一个命令重新执行
!!

# 重新执行历史清单中的第三个命令
!3

# 重新执行历史清单中以d开头的最后一个命令
!d
</code></pre>
</li>
</ul>
</li>
<li><code>^</code> 编辑前一个命令的一种快捷方法<pre><code class="lang-bash"># 替换历史清单中最后一个命令中的字母
# 用一个t取得第一次出现的r
^r^t
</code></pre>
</li>
</ul>
<h3 id="header-18">cut</h3>
<pre><code class="lang-bash">cut -b|c|f list [-d delim][-s][file ...]
</code></pre>
<p>从指定的范围中提取信息</p>
<ul>
<li><p>提取形式：</p>
<ul>
<li><code>-b</code>    表示字节，即byte</li>
<li><code>-c</code>    表示字符，即character</li>
<li><code>-f</code>     表示字段，即field</li>
</ul>
</li>
<li><p>提取范围（具体数字，从1开始计数）：</p>
<ul>
<li><code>m</code> 第m个字节或字符或字段</li>
<li><code>m-</code> 从第m个字节或字符或字段到文件结束</li>
<li><code>m-n</code> 从第m个到第n个字节或字符或字段</li>
<li><code>-n</code> 从第1个到第n个字节或字符或字段</li>
</ul>
</li>
<li><p>提取设置：</p>
<ul>
<li><code>-d</code> 用来定义分隔符(delimiter)，默认为tab键</li>
<li><code>-s</code> 表示不包括哪些不含分隔符的行（有利于去掉注释和标题）</li>
</ul>
</li>
</ul>
<p>示例：</p>
<pre><code class="lang-bash">cut -c 1-5,10-14 test
cut -f 1,3 test
cut -d&#39;|&#39; -f2  1.test &gt; 2.test
cut -d&#39;:&#39; -f1,2  1.test &gt; 2.test 
cut -d&#39;:&#39; -f1-4 /etc/passwd | head -10
cut -d&#39;:&#39; -f 1-4 /etc/passwd | head -10
</code></pre>
<h3 id="header-19">find</h3>
<pre><code class="lang-bash">find  path  -option  [  -print ]  [ -exec|-ok  command ]  {} \;
</code></pre>
<ul>
<li><p><code>path</code>:     查找目录</p>
<ul>
<li><code>~</code>表示<code>$HOME</code>目录</li>
<li><code>.</code> 当前目录</li>
<li><code>/</code> 根目录</li>
</ul>
</li>
<li><p><code>-option</code>：命令选项</p>
<ul>
<li><code>-name xxx</code> 使用某种文件名模式来匹配文件<ul>
<li><code>find . -name &quot;[A-Z]*&quot; -print</code></li>
</ul>
</li>
<li><code>-type b|d|c|p|l|f</code> 查找某一类型的文件(块设备、目录、字符设备、管道、符号链接、普通文件)<ul>
<li><code>find /etc -type d -print</code> 在/etc目录下查找所有的目录</li>
<li><code>find . ! -type d -print</code>    在当前目录下查找除目录以外的所有类型的文件</li>
<li><code>find /etc -type l -print</code> 在/etc目录下查找所有的符号链接文件</li>
</ul>
</li>
<li><code>-size  n[c]</code>  按照文件长度来查找文件查<ul>
<li>这里所指的文件长度既可以用块（block）或字节（byte）来计量</li>
<li>在按照文件长度查找文件时，一般使用以字节表示文件长度</li>
<li>在查看文件系统的大小时，一般使用块来计量</li>
<li><code>find . -size +1000000c -print</code> 在当前目录下查找文件长度大于1 M字节的文件</li>
<li><code>find /home/apache -size 100c -print</code>  在/home/apache目录下查找文件长度恰好为100字节的文件</li>
<li><code>find . -size +10 -print</code>    在当前目录下查找长度超过10块的文件（一块等于512字节）</li>
</ul>
</li>
<li><code>-perm</code> 按照文件执行权限查找<ul>
<li><code>-perm mode</code>:文件许可正好符合mode</li>
<li><code>-perm +mode</code>:文件许可部分符合mode</li>
<li><code>-perm -mode</code>: 文件许可完全符合mode</li>
<li>eg: <code>find . -perm 755 -print</code></li>
</ul>
</li>
<li><code>-prune</code> 指出需要忽略的目录<ul>
<li>如果同时使用<code>-depth</code>选项，那么<code>-prune</code>将被忽略</li>
<li><code>find [-path ..] [expression]</code> （表达式按顺序求值）</li>
<li>eg：在<code>/apps</code>目录下查找不在<code>bin</code>子目录之内的所有文件</li>
<li><code>find /apps -path &quot;/apps/bin&quot; -prune -o -print</code> 与 <code>find /apps -path &quot;/apps/bin&quot; -a -prune -o -print</code>等同</li>
<li><code>-a</code> 和 <code>-o</code> 都是短路求值，与 shell 的 <code>&amp;&amp;</code> (and)和 <code>||</code> (or)类似</li>
<li>伪码相当于: <code>if -path &quot;/usr/sam&quot;  then    -prune    else    -print</code></li>
<li><code>find /usr/sam  \(-path /usr/sam/dir1 -o -path /usr/sam/file1 \) -prune -o -name &quot;temp&quot; -print</code> 避开多个文件夹，<code>-name</code>在<code>-o</code>之后</li>
</ul>
</li>
<li><code>-depth</code>   首先匹配所有的文件然后再进入子目录中查找<ul>
<li>默认find将遍历所有子目录</li>
<li>如果只想搜索当前目录，可以添加 <code>-maxdepth 0</code> 表示只检验命令行给定的文件</li>
</ul>
</li>
<li><code>-follow</code> 跟踪符号链接所指向的文件</li>
<li><code>-mount</code>   查文件时不跨越文件系统mount点<ul>
<li><code>find . -name &quot;*.XC&quot; -mount -print</code>    从当前目录开始查找位于本文件系统中文件名以XC结尾的文件</li>
</ul>
</li>
<li><code>-newer</code>    查找比某个文件新或旧的文件<ul>
<li><code>-newer  f1 !f2</code>      #查更改时间比f1新但比f2旧的文件</li>
</ul>
</li>
<li><code>-ctime</code>,<code>-atime</code>,<code>-mtime</code> 按文件 创建|访问|更改 时间来查找文件<ul>
<li><code>-n</code>指n天以内</li>
<li><code>+n</code>指n天以前</li>
</ul>
</li>
<li><code>-user xxx</code>,<code>nouser</code>    按照文件属主来查找文件<ul>
<li><code>find ~ -user sam -print</code></li>
<li><code>find /etc -user uucp -print</code>    在/etc目录下查找文件属主为uucp的文件</li>
<li><code>find /home -nouser -print</code> 查找属主帐户已经被删除的文件（即找到那些属主在/etc/passwd文件中没有有效帐户的文件）</li>
</ul>
</li>
<li><code>-group xxx</code>,<code>nogroup</code> 按文件所属于的用户组查找文件<ul>
<li><code>find /apps -group gem -print</code></li>
<li><code>find / -nogroup -print</code> 查找无有效所属组的文件（即该文件所属的组在/etc/groups中不存在）</li>
</ul>
</li>
</ul>
</li>
<li><p><code>-print</code>:    将匹配的文件输出到标准输出</p>
<ul>
<li>只会输出从当前路径起的相对路径及文件名</li>
</ul>
</li>
<li><code>-exec</code>，<code>-ok</code>:    执行shell命令，参数为匹配的文件<ul>
<li><code>-exec  command  {} \;</code>：将查到的文件执行command操作</li>
<li><code>-ok  command  {} \;</code>: 与<code>-exec</code>一样，不过执行操作前会询问</li>
<li>注意：必须要使用<code>-print</code>选项；<code>{}</code>和<code>\</code> 间有空格</li>
<li><code>find logs -type f -mtime +5 -exec rm {  } \;</code> 在/logs目录中查找更改时间在5日以前的文件并删除它们</li>
</ul>
</li>
</ul>
<p>注意：</p>
<p>使用<code>-exec</code>时，find命令将所有匹配到的文件一起传递给exec执行<br>可能会出现溢出错误（参数列太长”，“参数列溢出”，…）<br>可能会出现进程过多，系统性能下降的问题（有些系统中会为处理每一个匹配到的文件而发起一个相应的进程）<br>建议使用<code>xargs</code>分批获取和传入参数，且只有一个进程，eg：</p>
<pre><code class="lang-bash"># 查找系统中的每一个普通文件，然后使用xargs命令来测试它们分别属于哪类文件
&gt; find . -type f -print | xargs file
./.kde/Autostart/Autorun.desktop: UTF-8 Unicode English text
./.kde/Autostart/.directory:      ISO-8859 text\
......
</code></pre>
<p>使用示例：</p>
<pre><code class="lang-bash"># 当前目录下查找所有用户具有读、写和执行权限的文件，并收回相应的写权限
find . -perm -7 -print | xargs chmod o-w

# 用grep命令在所有的普通文件中搜索hostname这个词
find . -type f -print | xargs grep &quot;hostname&quot;    

# 查找系统中所有文件长度为0的普通文件，并列出它们的完整路径
find / -type f -size 0 -exec ls -l {  } \;

# 让当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件
find . -type f -perm 644 -exec ls -l {  } \;

# 查找/var/logs目录中更改时间在7日以前的普通文件，并在删除之前询问它们
find /var/logs -type f -mtime +7 -ok rm {  } \;    

#查找系统中所有属于root组的文件
find . -group root -exec ls -l {  } \;

# 删除当目录中访问时间在7日以来、含有数字后缀的admin.log文件
find . -name &quot;admin.log[0-9][0-9][0-9]&quot; -atime -7  -ok rm {  } \;

#查找当前文件系统中的所有目录并排序
find . -type d | sort

# 从当前目录开始，向下扫描查找类型是普通文件的所有.html文件
find -name &quot;*.html&quot; -type f    

# 返回文件权限和时间信息(-iname：表示区分大小写)
find -user chen -iname &quot;*.html&quot; -ls

# 在/logos 下查找5天内修改的普通日志文件并删除
find /logos -type f -mtime -5 -exec rm {} /;

#查找2004-11-30 16:36:37时更改过的文件
find ./ -name &quot;*php&quot; |  ls -l --full-time $A 2&gt;/dev/null | grep &quot;2004-11-30 16:36:37&quot;

# 文件查找

find . -ctime +365  -type d -exec ls -ld {} \; &gt;test.txt
find . -ctime +365  -type d -exec ls -ld {} \; &gt;test.txt

find . -name &quot;*.txt&quot; -print 
find . -name *.* -ctime -365 -type d -exec mv {} temp/ \;
find . -name *.* -ctime -365 -type d -exec mv {} temp/ \;
find . -name *.gz -ctime -365 -exec ls -l {} \

find .  -type d -exec ls -ld {} \; &gt;test.txt
find .  -type d -exec ls -ld {} \; &gt;test.txt
</code></pre>
<h3 id="header-20">xargs</h3>
<p><code>xargs [-0epns] [ command [initial-arguments] ]</code></p>
<blockquote>
<p>build and execute command lines from standard input</p>
</blockquote>
<ul>
<li>字面意义上：x 是乘号，args 是 arguments (参数) ，则xargs的意思就是产生某个指令的参数</li>
<li>xargs 可读入 stdin 的资料，以空白字元或断行字元作分辨，将 stdin 的资料分隔成 args<ul>
<li>使用其他某个命令并将前一个命令的输出作为参数</li>
<li>将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题</li>
</ul>
</li>
<li>xargs本身虽然没有多大用处，但在与其他命令相结合时，它的功能非常强大</li>
<li>注意：因为是以空白字元作为分隔，所以如果有一些档名或者是其他意义的名词内含有空白字元的时候，xargs 可能会误判</li>
</ul>
<p>參數：</p>
<ol>
<li><p><code>-i</code> 选项告诉xargs用每项的名称替换<code>{}</code></p>
<pre><code class="lang-bash"> find ./ -type f -print | xargs -i mv -f {} ./newdir
</code></pre>
</li>
<li><p><code>-t</code>选项指示xargs先打印要运行的命令，然后再执行</p>
<pre><code class="lang-bash">  ls | xargs -t -i mv {} {}.bak
  cat listFile | xargs -t -i ls ~/re-extract/&quot;{}&quot;
</code></pre>
</li>
<li><p><code>-0</code> 将输入的特殊字元（例如<code>,</code>, <code>\</code>, 空白键等）还原成一般字元，可用于正确地处理了新行和空格</p>
<pre><code class="lang-bash"> # 查找tmp目录下以core命名的文件，然后删除

 # 如果文件名字包含新行或者空格的话，这条命令将会被错误操作
  &gt; find /tmp -name core -type f -print | xargs /bin/rm -f

 # 这条命令就正确地处理了新行和空格，有可能带来的错误
 &gt; find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f
</code></pre>
</li>
<li><p><code>-p</code> 它使操作具有可交互性，在执行每个指令的 argument 时，都会询问使用者的意思：</p>
<pre><code class="lang-bash"># xarg要求在运行每个命令之前进行确认，按下&quot;y&quot;，则执行
file * | grep ASCII | cut -d&quot;:&quot; -f1 | xargs -p vi 
vi alert_DBA102.log dba102_cjq0_14493.trc dba102_mmnl_14497.trc dba102_reco_14491.trc dba102_rvwr_14518.trc ?...
</code></pre>
</li>
<li><p><code>-r</code> 如果没有要运行的内容，该命令退出：</p>
<pre><code class="lang-bash">file * | grep SSSSSS | cut -d&quot;:&quot; -f1 | xargs -t -r wc -l $
</code></pre>
</li>
<li><p><code>-n</code> 指定每次从输入源中取几行数据（限制单个命令行的参数个数）：</p>
<pre><code class="lang-bash"> # 限制每个命令行仅使用两个参数
 file * | grep ASCII | cut -d&quot;:&quot; -f1 | xargs -t -n2 ls -ltr
</code></pre>
</li>
<li><p><code>-e</code>  : EOF (end of file) 后面可接一个字串，代表结束标识（当 xargs 分析到这个字串时，就会停止继续工作）</p>
<pre><code class="lang-bash"># 当分析到 lp 就结束这串指令 (注意 -e&#39;lp&#39; 是连在一起的，中间没有空白键)
cut -d&#39;:&#39; -f1 &lt; /etc/passwd | xargs -e&#39;lp&#39; finger
</code></pre>
</li>
<li><p><code>-s</code> : 每次的输出的最大bytes</p>
</li>
</ol>
<p>示例：</p>
<ol>
<li><p>将 <code>/etc/passwd</code> 的第一栏取出，仅取三行，使用 <code>finger</code> 这个指令秀出每个帐号内容</p>
<ul>
<li>由 finger account 可以取得该帐号的相关说明内容</li>
<li>利用 cut 取出帐号名称</li>
<li>用 head 取出三个帐号</li>
<li><p>由 xargs 将三个帐号的名称变成 finger 后面需要的参数</p>
<pre><code class="lang-bash">&gt; cut -d &#39;:&#39; -f1 &lt; /etc/passwd | head -n 3 | xargs finger    

Login name: root                        In real life: Super-User
Directory: /                            Shell: /sbin/sh
Last login Thu Jan  5 08:44 on pts/2 from 10.7.82.110
New mail received Sun Feb  5 14:00:26 2012;
unread since Thu Feb 21 11:53:16 2008
No Plan.

Login name: daemon
Directory: /
Never logged in.
No unread mail
No Plan.

Login name: bin
Directory: /usr/bin
Never logged in.
No unread mail
No Plan.
</code></pre>
</li>
</ul>
</li>
<li><p>删除数量比较多的文件</p>
<ul>
<li><code>ls</code> 输出所有的文件名(用空格分割) </li>
<li><code>xargs</code>将ls的输出，每20个为一组(以空格为分隔符)，作为<code>rm -rf</code>的参数</li>
<li>即将所有文件名20个为一组，由<code>rm -rf</code>删除，这样就不会超过命令行的长度了<pre><code class="lang-bash">ls | xargs -n 20 rm -fr
</code></pre>
</li>
</ul>
</li>
<li><p>迁移文件</p>
<pre><code class="lang-bash"> cat temp.txt | xargs -n1 -i mv {} bak/
 ls *100[9]* | xargs -t -i mv {} &quot;/db/data/autoftp/sent/tsmc/stdfbak/&quot;
 ls *100[7]*.gz | xargs -t -i -n1  mv {} &quot;/db/data/autoftp/sent/tsmc/stdfbak/&quot;{}
</code></pre>
</li>
<li><p><code>xargs</code>与<code>grep</code>使用比较</p>
<ul>
<li><code>XXX | grep –i ‘hello’</code>        <ul>
<li>grep通过管道读取XXX的输出结果，并在该结果中搜索hello</li>
</ul>
</li>
<li><code>XXX | xargs grep –i ‘hello’</code><ul>
<li>xargs通过管道读取XXX的输出结果，并将该结果作为grep的最后的FILE参数</li>
<li><code>grep –i ‘hello’</code> 组合成完整的命令（如 <code>grep –i ‘hello’ stdio.h stdlib.h</code>）后，执行</li>
<li>例如：<code>find . -name &quot;*.foo&quot; | xargs grep bar</code>大体等价于<code>grep bar `find . -name &quot;*.foo&quot;` </code></li>
</ul>
</li>
<li>两者对于管道的输出作不同的处理:<ul>
<li>前者是grep直接从stdin中读取管道数据，并搜索。</li>
<li>后者是xargs直接从stdin中读取管道数据，并和<code>grep –i ‘hello’</code>组合，然后调用<code>exec</code>执行该命令</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="header-21">awk</h3>
<p>文本分析工具</p>
<pre><code class="lang-bash">nawk &#39;/pattern/{action}&#39; filename
cmd | nawk &#39;/pattern/{action}&#39; filename
</code></pre>
<ul>
<li>把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理</li>
<li><code>pattern</code> 表示 AWK 在数据中查找的内容，可使用正则表达式（正则表达式需用斜杠括起来）</li>
<li><code>action</code> 是在找到匹配内容时所执行的一系列命令</li>
<li><code>-F</code> 域分隔符，默认是空格</li>
<li><p>内置变量：</p>
<ul>
<li><code>ARGC</code>               命令行参数个数</li>
<li><code>ARGV</code>              命令行参数数组</li>
<li><code>ENVIRON</code>         支持队列中系统环境变量的使用</li>
<li><code>FILENAME</code>       awk浏览的文件名</li>
<li><code>FNR</code>                浏览文件的记录数</li>
<li><code>NF</code>                当前记录中的字段数（记录域个数）</li>
<li><code>NR</code>                当前已读的记录数</li>
<li><code>OFS</code> 设置输出域分隔符，默认为空格</li>
<li><code>FS</code>   设置输入域分隔符，默认为空格，/,跳個符（等价于命令行 <code>-F</code>选项）</li>
<li><code>ORS</code>  输入记录分隔符</li>
<li><code>RS</code>     输出记录分隔符</li>
<li><code>OFMT</code>    控制打印數，默認為 <code>%.6g</code>(打印精確到小數點后6位)</li>
<li><code>$0</code>        整條記錄</li>
<li><code>$1</code> 表示当前行的第一个域</li>
</ul>
</li>
<li><p>內置函数</p>
<ul>
<li>sub,gsub,length,match,split</li>
<li>算数运算函数：int,log,sin,sqrt,rand,srand</li>
<li>打印输出函数：print，printf<ul>
<li><code>print \b,\f,\n,\r,\t,\c</code></li>
<li><code>printf %c,%d,%e,%f,%o,%s,%x</code> 格式化特制的輸出</li>
<li>eg:<pre><code class="lang-bash">{print &quot;\t\tHave a nice day,&quot; $1,$2 &quot;\!&quot;}
{printf &quot;%The name is: -15s ;ID is %8d\n&quot;,$1,$3}
</code></pre>
</li>
</ul>
</li>
<li>用户自定义函数</li>
</ul>
</li>
<li><p>示例：</p>
<pre><code class="lang-bash">  # pattern
  nawk &#39;/Mary/&#39; file1.txt
  nawk &#39;$1 ~ /[Bb]ill/&#39; file2.txt

  # action：print
  nawk &#39;{print $1,$2}&#39; file1.txt
  nawk  &#39;/^[A-Z][a-z]+/{print &quot;Hello &quot;$0}&#39; file1.txt

  # -F
  nawk -F: &#39;/Tom Jones/{print $0,NF}&#39; file1.txt
  nawk -F&#39;[ :\t]&#39; &#39;/Tom Jones/{print $0,NF}&#39; file1.txt

  # argv
  nawk &#39;BEGIN{print substr(ARGV[1],11,1)}&#39; $argv[2]

  # cmd | awk
  ps -ef | grep ftp | grep Feb | awk &#39;{print $11}&#39; | uniq | more

  # 批量重命名
  ls *.tar | awk -F&quot;.&quot; &#39;{print $1&quot;.&quot;$2&quot;.&quot;$3&quot;.&quot;$4,$1&quot;.&quot;$2&quot;.&quot;$3&quot;.1&quot;}&#39;| xargs -n2 mv
  ls * | awk -F&quot;.&quot; &#39;{print $1&quot;.&quot;$2&quot;.&quot;$3,$1&quot;.&quot;$2}&#39; | xargs -n2 mv
  ls * | awk -F&quot;.&quot; &#39;{print $1&quot;.&quot;$2&quot;.&quot;$3,$1&quot;.&quot;$2&quot;.&quot;$3&quot;.1&quot;}&#39; | xargs -n2 mv
</code></pre>
</li>
</ul>
<p><strong> 示例：</strong></p>
<ol>
<li><p>解析文档（关联数组，统计，printf，算数运算，sort应用）</p>
<pre><code class="lang-bash"> #! /bin/csh
  echo Begin
  set resultFile = myResult.txt
  # get head 
  #head -8 Testdata.log | awk -F, &#39;{print $1&quot;:&quot;$2}&#39;     &gt; $resultFile
  awk -F, &#39;NR==1 {print $1&quot;:&quot;$2 }&#39; Testdata.log    &gt; $resultFile
  nawk -F, &#39;NR==2 {print $1&quot;:&quot;tolower($2) }&#39; Testdata.log &gt;&gt; $resultFile
  awk -F, &#39;NR==3,NR==8 {print $1&quot;:&quot;$2 }&#39; Testdata.log &gt;&gt; $resultFile

  echo StartDate:`awk -F, &#39;NR==9{print $2}&#39; Testdata.log | cut -c1-8`  &gt;&gt; $resultFile
  echo StartTime:`awk -F, &#39;NR==9{print $2}&#39; Testdata.log | cut -c9-14` &gt;&gt; $resultFile

 # get Passdie,Grossdie,Yeild
 awk -F, &#39;NR&gt;10 { grossdie++;if($5==&quot;P&quot;) count++}END
 {printf(&quot;Passdie:%d\nGrossdie:%d\nYield:%.2f\n\n&quot;,count,grossdie,count/grossdie*100)} &#39; Testdata.log     &gt;&gt;$resultFile

 # get x,y,bin,site,status,[ bin Summary ]
 awk -F, &#39;NR&gt;10{print &quot;x=&quot;$1,&quot;y=&quot;$2,&quot;bin=&quot;$3,&quot;site=&quot;$4,&quot;status=&quot;$5}&#39; Testdata.log &gt;&gt; $resultFile
 echo &gt;&gt; $resultFile
 echo &quot;[bin summary]&quot; &gt;&gt; $resultFile
 echo &gt;&gt; $resultFile
 awk -F, &#39;NR&gt;10{count[$3]++;}END{for(i in count){print &quot;bin&quot;i&quot;:&quot;count[i] | &quot;sort -t: +0.3n&quot;}}&#39; Testdata.log      &gt;&gt; $resultFile
 echo End\!
 exit
</code></pre>
<pre><code class="lang-bash"> awk -F, &#39;NR&gt;10{count[$3]++; print &quot;x=&quot;$1,&quot;y=&quot;$2,&quot;bin=&quot;$3,&quot;site=&quot;$4,&quot;status=&quot;$5 }END{ printf(&quot;\n[bin     summary]\n&quot;); for(i in count){print &quot;bin&quot;i&quot;:&quot;count[i] | &quot;sort -t: +0.3n&quot; };Close &quot;sort -t: +0.3n&quot;}&#39; Testdata.log
</code></pre>
</li>
<li><p>根据传入参数去除重复行</p>
<ul>
<li><p>输入源</p>
<pre><code class="lang-bash">  &gt; cat uniqueTest.txt

  222|15|2401668|3273877|4114|1|
  222|15|2401444|3273847|3274|1|
  222|15|2401444|32722200|4124|1|
  222|15|2401474|32253847|7419|1|
</code></pre>
</li>
<li><p>去除重复的行</p>
<pre><code class="lang-bash">  # 根据第三列判断重复行
  &gt; awk -F&quot;|&quot; &#39;{a[$3]=$0}END{for (i in a) print a[i]}&#39;  uniqueTest.txt

  222|15|2401444|32722200|4124|1|
  222|15|2401474|32253847|7419|1|
  222|15|2401668|3273877|4114|1|

  # 根据第三第四列组合判断重复行
  &gt; awk -F&quot;|&quot; &#39;{a[$3$4]=$0;b[$3$4]=NR}END{for (i in a) print b[i] &quot; &quot; a[i]}&#39;  uniqueTest.txt

  3 222|15|2401444|32722200|4124|1|
  2 222|15|2401444|3273847|3274|1|
  4 222|15|2401474|32253847|7419|1|
  1 222|15|2401668|3273877|4114|1|
</code></pre>
</li>
<li>传入参数<pre><code class="lang-bash">  &gt; set xField = 3
  &gt; set yField=4
  &gt; awk -F&quot;|&quot; &#39;{a[$x$y]=$0;b[$x$y]=NR}END{for (i in a) print b[i] &quot; &quot; a[i]}&#39; x=&quot;$xField&quot; y=&quot;$yField&quot; uniqueTest.txt
</code></pre>
</li>
</ul>
</li>
<li><p>BEGIN/END</p>
<ul>
<li>测试数据：<pre><code class="lang-bash">  docker@default:~$ cat /etc/passwd
  root:x:0:0:root:/root:/bin/sh
  lp:x:7:7:lp:/var/spool/lpd:/bin/sh
  nobody:x:65534:65534:nobody:/nonexistent:/bin/false
  tc:x:1001:50:Linux User,,,:/home/tc:/bin/sh
  dockremap:x:100:101:Linux User,,,:/home/dockremap:/bin/false
  docker:x:1000:50:Linux User,,,:/home/docker:/bin/sh
</code></pre>
</li>
<li>显示<code>/etc/passwd</code>的账户name和账户对应的shell, 第一行添加列名”name,shell”, 最后一行添加”blue,/bin/nosh”<pre><code class="lang-bash">  docker@default:~$ cat /etc/passwd |awk  -F &#39;:&#39;  &#39;BEGIN {print &quot;name,shell&quot;}  {print $1&quot;,&quot;$7} END {print &quot;blue,/bin/nosh&quot;}&#39;
  name,shell
  root,/bin/sh
  lp,/bin/sh
  nobody,/bin/false
  tc,/bin/sh
  dockremap,/bin/false
  docker,/bin/sh
  blue,/bin/nosh
</code></pre>
</li>
<li>显示文件名filename，行号linenumber，列数columnes，每行内容linecontent<pre><code class="lang-bash">  # 使用printf替代print,更加简洁
  # eg：awk  -F &#39;:&#39;  &#39;{printf(&quot;filename:%10s,linenumber:%s,columns:%s,linecontent:%s\n&quot;,FILENAME,NR,NF,$0)}&#39; /etc/passwd
  docker@default:~$ awk  -F &#39;:&#39;  &#39;{print &quot;filename:&quot; FILENAME &quot;,linenumber:&quot; NR &quot;,columns:&quot; NF &quot;,linecontent:&quot;$0}&#39; /etc/passwd
  filename:/etc/passwd,linenumber:1,columns:7,linecontent:root:x:0:0:root:/root:/bin/sh
  filename:/etc/passwd,linenumber:2,columns:7,linecontent:lp:x:7:7:lp:/var/spool/lpd:/bin/sh
  filename:/etc/passwd,linenumber:3,columns:7,linecontent:nobody:x:65534:65534:nobody:/nonexistent:/bin/false
  filename:/etc/passwd,linenumber:4,columns:7,linecontent:tc:x:1001:50:Linux User,,,:/home/tc:/bin/sh
  filename:/etc/passwd,linenumber:5,columns:7,linecontent:dockremap:x:100:101:Linux User,,,:/home/dockremap:/bin/false
  filename:/etc/passwd,linenumber:6,columns:7,linecontent:docker:x:1000:50:Linux User,,,:/home/docker:/bin/sh
</code></pre>
</li>
<li><p>可自定义变量,<code>{action}</code>可以有多个语句，以<code>;</code>号隔开</p>
<pre><code class="lang-bash">  docker@default:~$ awk &#39;{count++;print $0;} END{print &quot;user count is &quot;, count}&#39; /etc/passwd
  root:x:0:0:root:/root:/bin/sh
  lp:x:7:7:lp:/var/spool/lpd:/bin/sh
  nobody:x:65534:65534:nobody:/nonexistent:/bin/false
  tc:x:1001:50:Linux User,,,:/home/tc:/bin/sh
  dockremap:x:100:101:Linux User,,,:/home/dockremap:/bin/false
  docker:x:1000:50:Linux User,,,:/home/docker:/bin/sh
  user count is  6

  docker@default:~$ awk &#39;BEGIN {count=0;print &quot;[start]user count is &quot;, count} {count=count+1;print $0;} END{print &quot;[end]user count is &quot;, count}&#39; /etc/passwd
  [start]user count is  0
  root:x:0:0:root:/root:/bin/sh
  lp:x:7:7:lp:/var/spool/lpd:/bin/sh
  nobody:x:65534:65534:nobody:/nonexistent:/bin/false
  tc:x:1001:50:Linux User,,,:/home/tc:/bin/sh
  dockremap:x:100:101:Linux User,,,:/home/dockremap:/bin/false
  docker:x:1000:50:Linux User,,,:/home/docker:/bin/sh
  [end]user count is  6
</code></pre>
</li>
<li>收集信息存储到数组， 下标可以是数字和字母（ 存储在内部的一张hash表里，即非顺序存储）<pre><code class="lang-bash">  docker@default:~$ awk -F &#39;:&#39; &#39;BEGIN {count=0;} {name[count] = $1;count++;}; END{for (i = 0; i &lt; NR; i++) print i, name[i]}&#39; /etc/passwd
  0 root
  1 lp
  2 nobody
  3 tc
  4 dockremap
  5 docker
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="header-22">sed</h3>
<pre><code class="lang-vim">sed [-nefri] [command]
</code></pre>
<p>说明：</p>
<ol>
<li><p>Options: <code>[-nefri]</code></p>
<ul>
<li><code>-n</code> : 使用安静(silent)模式。在一般sed的用法中，所有来自<code>STDIN</code>的资料一般都会被列出到屏幕上。加上<code>-n</code>后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来</li>
<li><code>-e</code>∶多点编辑，等价于<code>--expression</code><pre><code class="lang-bash">  # 同 /sbin/ifconfig | grep &#39;inet &#39; | sed &#39;s/inet//g&#39; | sed &#39;s/netmask.*//g&#39;
  &gt;  /sbin/ifconfig | grep &#39;inet &#39; | sed -e &#39;s/inet //g&#39; -e &#39;s/ netmask.*//g&#39;
  172.17.0.2
  127.0.0.1
</code></pre>
</li>
<li><code>-f</code>∶指定sed脚本的文件名。 直接将sed的动作写在一个档案内，<code>-f filename</code> 则可以执行filename内的sed动作</li>
<li><code>-r</code>∶sed 的动作支援的是延伸型正则表达式的语法。(预设是基础正则表达式语法)</li>
<li><code>-i</code>∶直接修改读取的文件内容，而不是由屏幕输出 <pre><code class="lang-bash">   # 直接在文件最后一行加入“This is a test”
   &gt;  cat 1.txt
   AAA
   BBB
   CCC
   &gt;  sed -i &#39;$a This is a test&#39; 1.txt
   &gt;  cat 1.txt
   AAA
   BBB
   CCC
   This is a test
</code></pre>
</li>
</ul>
</li>
<li><p>Command: <code>：[n1[,n2]]function</code></p>
<ul>
<li><code>a\</code>∶ 新增。后面可接字串，在当前行下面插入<pre><code class="lang-bash">  &gt;  nl /etc/passwd | sed &#39;2a drink tea&#39;
  1    root:x:0:0:root:/root:/bin/bash
  2    bin:x:1:1:bin:/bin:/sbin/nologin
  drink tea
  3    daemon:x:2:2:daemon:/sbin:/sbin/nologin
  4    adm:x:3:4:adm:/var/adm:/sbin/nologin
</code></pre>
<pre><code class="lang-bash">  # 加入两行,中间用‘\’换行输入或使用‘\n’来进行新行的添加：
  &gt;  nl /etc/passwd | sed &#39;2a Drink tea or ......\
  drink beer ?&#39;
  1    root:x:0:0:root:/root:/bin/bash
  2    bin:x:1:1:bin:/bin:/sbin/nologin
  Drink tea or ......
  drink beer ?
  3    daemon:x:2:2:daemon:/sbin:/sbin/nologin
  4    adm:x:3:4:adm:/var/adm:/sbin/nologin
</code></pre>
</li>
<li><code>i\</code>∶ 插入。后面可以接字串，在当前行上面插入文本<pre><code class="lang-bash">  &gt;  nl /etc/passwd | sed &#39;2i drink tea&#39;
  1    root:x:0:0:root:/root:/bin/bash
  drink tea
  2    bin:x:1:1:bin:/bin:/sbin/nologin
  3    daemon:x:2:2:daemon:/sbin:/sbin/nologin
  4    adm:x:3:4:adm:/var/adm:/sbin/nologin
</code></pre>
</li>
<li><code>c\</code>∶替换行。后面可以接字串，把选定的行改为新的文本<pre><code class="lang-bash">  # 将第2-4行的内容取代成为&quot;No 2-4 number&quot;
  &gt;  nl /etc/passwd | sed &#39;2,4c No 2-4 number&#39;
  1    root:x:0:0:root:/root:/bin/bash
  No 2-4 number
  5    lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
  6    sync:x:5:0:sync:/sbin:/bin/sync
</code></pre>
</li>
<li><p><code>s</code>∶ 替换行中字符。可以直接进行替换指定字符。通常这个<code>s</code>的动作可以搭配正则表达式。例如 <code>1,20s/old/new/g</code></p>
<pre><code class="lang-bash">  &gt;  /sbin/ifconfig | grep &#39;inet &#39;
  inet 172.17.0.2  netmask 255.255.0.0  broadcast 0.0.0.0
  inet 127.0.0.1  netmask 255.0.0.0

  &gt;  /sbin/ifconfig | grep &#39;inet &#39; | sed &#39;s/inet //g&#39;
  172.17.0.2  netmask 255.255.0.0  broadcast 0.0.0.0
  127.0.0.1  netmask 255.0.0.0

  &gt;  /sbin/ifconfig | grep &#39;inet &#39; | sed &#39;s/inet//g&#39; | sed &#39;s/netmask.*//g&#39;
  172.17.0.2
  127.0.0.1
</code></pre>
</li>
<li><code>g</code>: 全局搜索。整行匹配的都替换，没有<code>g</code>则只替换一行中第一个匹配的内容，当需要从第N处匹配开始替换时，可以使用<code>/Ng</code><pre><code class="lang-bash">  sed &#39;s/book/books/g&#39; file
  sed &#39;s/book/books/2g&#39; file
</code></pre>
</li>
<li><code>y</code> ：把一个字符翻译为另外的字符（不能用正则表达式）<pre><code class="lang-bash">  # 把1~10行内所有abcde转变为大写
  sed &#39;1,10y/abcde/ABCDE/&#39; file
</code></pre>
</li>
<li><code>d</code> :删除。后面通常不接任何内容<pre><code class="lang-bash">  sed &#39;2d&#39; datafile     # 删除第2行
  sed &#39;$d&#39; datafile     # 删除最后一行    
  sed &#39;2,$d&#39; datafile   # 删除第2行~末尾所有行
  sed &#39;2,5d&#39; datafile                 # 删除2～5行
  sed &#39;/My/,/You/d&#39; datafile         # 删除包含My的行~You的行的内容
  sed &#39;/My/,10d&#39; datafile            # 删除包含My的行~第10行的内容
  sed &#39;/^test/&#39;d datafile            # 删除文件中所有开头是test的行
  nl /etc/passwd | sed  &#39;/root/d&#39;  # 删除包含root的行
</code></pre>
</li>
<li><code>p</code>∶ 列印。将某个选择的资料印出。通常<code>p</code>会与参数<code>-n</code> 一起用<pre><code class="lang-bash">  sed -n &#39;3p&#39; datafile           # 打印第3行
  sed -n &#39;100,200p&#39; datafile     # 打印100～200行
  chenjindeMacBook-Pro:~ cj$  nl /etc/passwd | sed -n &#39;5,9p&#39;
  5    # in single-user mode.  At other times this information is provided by
  6    # Open Directory.
  7    #
  8    # See the opendirectoryd(8) man page for additional information about
  9    # Open Directory.
</code></pre>
</li>
<li><p><code>n</code>： 下一行。匹配行的下一行</p>
<pre><code class="lang-bash">  # 打印匹配字符串的下一行
  &gt; sed -n &#39;/AAA/{n;p}&#39; 1.txt    
  BBB
  CCC
  EEE

  # 替换匹配行的下一行中的BBB为bbb，打印所有行
  &gt; sed &#39;/AAA/{ n; s/BBB/bbb/; }&#39; 1.txt 
  AAA
  bbb
  CCC
  AAA
  CCC
  DDD
  AAA
  EEE

  # 注意以下结果不一样
  &gt; sed &#39;/AAA/{ n; s/BBB/bbb/; }&#39; 1.txt    # 对匹配AAA的下一行进行BBB匹配修改，打印所有行
  &gt; sed &#39;/AAA/{ n; s/BBB/bbb/;p}&#39; 1.txt    # 对匹配AAA的下一行进行BBB匹配修改，打印所有匹配AAA的下一行
  &gt; sed &#39;/AAA/{ n; s/BBB/bbb/p }&#39; 1.txt    # 对匹配AAA的下一行进行BBB匹配修改，打印所有匹配AAA的下一行中匹配BBB替换修改的行
</code></pre>
</li>
<li><p><code>q</code>：退出</p>
<pre><code class="lang-bash">  # 打印完第10行后，退出
  &gt;  sed &#39;5q&#39; 1.txt
  AAA
  BBB
  CCC
  AAA
  CCC
</code></pre>
</li>
<li><p>保持空间：</p>
<ul>
<li><code>h</code>： 拷贝模板块的内容到内存中的缓冲区</li>
<li><code>H</code>： 追加模板块的内容到内存中的缓冲区</li>
<li><code>g</code>： 获得内存缓冲区的内容，并替代当前模板块中的文本</li>
<li><code>G</code>： 获得内存缓冲区的内容，并追加到当前模板块文本的后面</li>
<li><p><code>x</code>： 表示互换模板块中的文本和缓冲区中的文本</p>
<pre><code class="lang-bash">&gt; cat 1.txt
AAA a
BBB b
CCC c
AAA 1
CCC 3
DDD 4
AAA 1
EEE 5

# 任何包含AAA的行都被复制并追加到该文件的末尾,只保留最后一个匹配行
&gt; sed -e &#39;/AAA/h&#39; -e &#39;$G&#39; 1.txt 
AAA a
BBB b
CCC c
AAA 1
CCC 3
DDD 4
AAA 1
EEE 5
AAA 1

# 任何包含AAA的行都被复制并追加到该文件的末尾,追加了所有匹配行
&gt; sed -e &#39;/AAA/H&#39; -e &#39;$G&#39; 1.txt 
AAA a
BBB b
CCC c
AAA 1
CCC 3
DDD 4
AAA 1
EEE 5
AAA a
AAA 1
AAA 1

# 把包含AAA的行与CCC行一对一互换
&gt; sed -e &#39;/AAA/h&#39; -e &#39;/CCC/x&#39; 1.txt 
AAA a
BBB b
AAA a
AAA 1
AAA 1
DDD 4
AAA 1
EEE 5
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>表达式元字符</p>
<ul>
<li><code>^</code> 匹配行开头，eg: <code>^abc</code> 匹配以abc开头的行</li>
<li><code>$</code> 匹配行结尾，eg：<code>abc$</code> 匹配以abc结尾的行</li>
<li><code>.</code> 匹配非换行符的任意一个字符，eg：<code>a.c</code> 可以匹配<code>abc</code>,<code>adc</code>,<code>a8c</code>,…</li>
<li><code>*</code> 匹配任意多个字符，eg: <code>a*c</code> 可以匹配 <code>ac</code>,<code>abc</code>,<code>adc</code>,<code>abdc</code>,…</li>
<li><code>+</code> 匹配某字符出现一次及以上次字符，eg：<code>a+</code> 可以匹配 <code>a</code>,<code>aa</code>,<code>aaa</code>,<code>aaaa</code>,…</li>
<li><code>?</code> 匹配0次或一次字符，eg：<code>a?</code> 可以匹配 <code>b</code>,<code>a</code></li>
<li><code>[]</code> 匹配一个指定范围内的字符<pre><code class="lang-bash">  [ABC]de     # 可以匹配Ade,Bde,Cde; 
  [A-Ca-c]     #与A-C及a-c范围内的字符匹配； 
  [ABC][DEF]     #匹配AD，AE，AF，BD，DE，BF，CD，CE，CF
</code></pre>
</li>
<li><code>[^]</code> 匹配一个不在指定范围内的字符，eg: <code>[^ABC]</code> 可以匹配不以A或B或C字母开头的行</li>
<li><code>|</code> 匹配或<pre><code class="lang-bash">  Desk|Chair             #与Desk和Chair中的任一个匹配；
  (Blue|Black)Berry： #匹配BlueBerry或BlackBerry
</code></pre>
</li>
<li><code>{}</code> 匹配次数<pre><code class="lang-bash">  a{3} 匹配 aaa; 
  a{3,5} 匹配 aaa,aaaa,aaaaa; 
  a{3,} 匹配 aaa,aaaa,aaaaa,aaaaaaa,....
  /a\{5,10\}/ 匹配5~10个a的行
</code></pre>
</li>
<li><code>\(..\)</code> 匹配子串，并保存匹配的字符。对于匹配到的第一个子串就标记为 <code>\1</code>，依此类推匹配到的第二个结果就是 <code>\2</code><pre><code class="lang-bash">  &gt; echo &quot;this is digit 7 in a number&quot; | sed &#39;s/digit \([0-9]\)/\1/&#39;
  this is 7 in a number
  &gt; echo &quot;loveable&quot; | sed &#39;s/\(love\)able/\1rs/&#39;
  lovers
</code></pre>
</li>
<li><p><code>&amp;</code> 保存匹配到的字符</p>
<pre><code class="lang-bash">  &gt; echo &quot;this is a test line&quot; | sed &#39;s/\w\+/[&amp;]/g&#39;  # 正则表达式 \w\+ 匹配每一个单词，使用 [&amp;] 替换它，&amp; 对应于之前所匹配到的单词
  [this] [is] [a] [test] [line]

  &gt; sed &#39;s/^192.168.0.1/&amp;localhost/&#39; file        # 所有以192.168.0.1开头的行都会被替换成它自已加localhost
  192.168.0.1localhost Hello
  192.210.0.1 Do you know
  192.168.0.1localhost World
</code></pre>
</li>
<li><code>\&lt;</code> 匹配单词的开始</li>
<li><code>\&gt;</code> 匹配单词的结束，eg: <code>/love\&gt;/</code> 匹配包含以love结尾的单词的行</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li><code>\s</code> 匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格</li>
<li><code>\S</code> 匹配任意不是空白符的字符</li>
<li><code>.*</code>  在使整个表达式能得到匹配的前提下,匹配尽可能多的字符(贪婪匹配) eg: <code>aabab</code> -&gt; <code>a.*b</code>  -&gt; <code>aabab</code></li>
<li><code>.*?</code> 在使整个表达式能得到匹配的前提下,匹配尽可能少的字符(懒惰匹配) eg: <code>aabab</code> -&gt; <code>a.*?b</code> -&gt; <code>aab</code>,<code>ab</code></li>
<li>定址： <ul>
<li>决定对哪些行进行编辑（可以是数字、正则表达式、或二者的结合，默认为输入文件的所有行。</li>
<li>注：数字表示行号，<code>$</code>表示最后一行</li>
</ul>
</li>
<li>定界符： <ul>
<li>命令中字符 <code>/</code> 在sed中作为定界符使用，也可以使用任意的定界符， 定界符出现在样式内部时，需要使用<code>\</code>进行转义</li>
</ul>
</li>
<li>引用：sed表达式可以使用单引号<code>&#39;&#39;</code>来引用，但是如果表达式内部包含变量字符串，就需要使用双引号<code>&quot;&quot;</code><pre><code class="lang-bash">  set test=Hello
  echo &quot;Hello WORLD,How are you?&quot; | sed &quot;s/$test/HELLO&quot;
  HELLO WORLD
</code></pre>
</li>
</ul>
</li>
</ol>
<p><strong> 示例：</strong></p>
<pre><code class="lang-bash"># &lt;SGUID isNull=&quot;true&quot;&gt;&lt;/SGUID&gt;` =&gt; `&lt;SGUID&gt;xxxxxxxx&lt;/SGUID&gt;
&gt; echo &quot;&lt;SGUID&gt;1234AJD839D&lt;/SGUID&gt;&quot; | sed -e &#39;s|&lt;SGUID&gt;[0-9A-Z]\{1,\}&lt;/SGUID&gt;|&lt;SGUID isNull=&quot;true&quot;&gt;&lt;/SGUID&gt;|g&#39;
&lt;SGUID&gt;xxxxxxxx&lt;/SGUID&gt;
</code></pre>
<pre><code>&gt; cat a.txt
&lt;Test bind_variables=&quot;{A=801,B=DD Flex}&quot; view_criteria=&quot;[PrimaryKeyCriteria]&quot; partitionkey_value=&quot;ABC&quot;/&gt;

&gt; grep -oP &quot;bind_variables=[^\s]\{.*?\}[^\s]&quot; a.txt
bind_variables=&quot;{A=801,B=DD Flex}&quot;
&gt; grep -oP &quot;bind_variables=[^\s]\{.*?\}[^\s]&quot; sdf.txt | sed &#39;s/{\(.*\)}/\1/g&#39;
bind_variables=&quot;A=801,B=DD Flex&quot;
&gt; grep -oP &quot;bind_variables=[^\s]\{.*?\}[^\s]&quot; sdf.txt | awk -F&#39;[{}]&#39; &#39;{print $2}&#39;
A=801,B=DD Flex

&gt; grep -oP &quot;view_criteria=[^\s]\[.*?\][^\s]&quot; sdf.txt
view_criteria=&quot;[PrimaryKeyCriteria]&quot;
&gt; grep -oP &quot;view_criteria=[^\s]\[.*?\][^\s]&quot; sdf.txt | awk -F&#39;[][]&#39; &#39;{print $2}&#39;
PrimaryKeyCriteria

&gt; grep -oP &quot;partitionkey_value=[^\s]\w+[^\s]&quot; sdf.txt
partitionkey_value=&quot;ABC&quot;
&gt; grep -oP &quot;partitionkey_value=[^\s]\w+[^\s]&quot; sdf.txt | awk -F&#39;[&quot;&quot;]&#39; &#39;{print $2}&#39;
ABC
&gt; grep -oP &quot;partitionkey_value=[^\s]\w+[^\s]&quot; sdf.txt | awk -F= &#39;{print $2}&#39; | sed s/\&quot;/\&#39;/g
&#39;ABC&#39;
</code></pre><h3 id="header-23">uniq</h3>
<pre><code>&gt; uniq --help
  -c, --count           prefix lines by the number of occurrences             在每行前面显示该行重复次数
  -d, --repeated        only print duplicate lines, one for each group        只输出重复的行
  -D, --all-repeated[=METHOD]  print all duplicate lines                      只输出重复的行，有几行输出几行
                          groups can be delimited with an empty line
                          METHOD={none(default),prepend,separate}
  -f, --skip-fields=N   avoid comparing the first N fields                    忽略的段数，eg: -f 1 忽略第一段
      --group[=METHOD]  show all items, separating groups with an empty line
                          METHOD={separate(default),prepend,append,both}
  -i, --ignore-case     ignore differences in case when comparing            不区分大小写
  -s, --skip-chars=N    avoid comparing the first N characters               忽略N个字符
  -u, --unique          only print unique lines                              去除重复的后，全部显示出来，即列出唯一项
  -z, --zero-terminated  end lines with 0 byte, not newline
  -w, --check-chars=N   compare no more than N characters in lines           只检查N个以内的字符，之外的不做对照
</code></pre><p><strong> 示例：</strong></p>
<p>测试数据：</p>
<pre><code class="lang-bash">&gt;  cat test.txt
this is a test
this is a test
this is a test
i am tank
i love tank
i love tank
this is a test
whom have a try
WhoM have a try
you  have a try
i want to abroad
those are good men
we are good men
</code></pre>
<ol>
<li><code>-c</code> 在每行前面显示该行重复次数，注意：检查重复行的时候，只会检查相邻的行<pre><code class="lang-bash"> &gt;  uniq -c test.txt
 3 this is a test
 1 i am tank
 2 i love tank
 1 this is a test
 1 whom have a try
 1 WhoM have a try
 1 you  have a try
 1 i want to abroad
 1 those are good men
 1 we are good men
</code></pre>
</li>
<li>排序后统计重复次数（解决只用-c统计的不准确问题）<pre><code class="lang-bash"> &gt;  sort test.txt | uniq -c
 1 WhoM have a try
 1 i am tank
 2 i love tank
 1 i want to abroad
 4 this is a test
 1 those are good men
 1 we are good men
 1 whom have a try
 1 you  have a try
</code></pre>
</li>
<li><code>-d</code> 只输出重复的行<pre><code class="lang-bash"> &gt;  uniq -d -c test.txt
 3 this is a test
 2 i love tank
</code></pre>
</li>
<li><code>-D</code> 只输出重复的行，有几行输出几行,注意：不能和<code>-c</code>一起使用<pre><code class="lang-bash"> &gt;  uniq -D test.txt
 this is a test
 this is a test
 this is a test
 i love tank
 i love tank
</code></pre>
</li>
<li><p><code>-f</code> 忽略第某列统计</p>
<pre><code class="lang-bash"> &gt;  uniq -f 1 -d -c test.txt
 3 this is a test
 2 i love tank
 2 whom have a try
 2 those are good men

 &gt;  uniq -f 1 -D test.txt
 this is a test
 this is a test
 this is a test
 i love tank
 i love tank
 whom have a try
 WhoM have a try
 those are good men
 we are good men
</code></pre>
</li>
<li><code>-s</code> 忽略前4个字符进行统计<pre><code class="lang-bash"> &gt;  uniq -s 4 -D test.txt
 this is a test
 this is a test
 this is a test
 i love tank
 i love tank
 whom have a try
 WhoM have a try
 you  have a try
</code></pre>
</li>
<li><code>-w</code> 只统计前2个字符<pre><code class="lang-bash"> &gt;  uniq -w 2 -D test.txt
 this is a test
 this is a test
 this is a test
 i am tank
 i love tank
 i love tank
</code></pre>
</li>
<li><code>-i</code> 忽略大小写<pre><code class="lang-bash"> &gt;  uniq -i -D test.txt
 this is a test
 this is a test
 this is a test
 i love tank
 i love tank
 whom have a try
 WhoM have a try
</code></pre>
</li>
<li><p><code>-u</code> 列出唯一项（count为1）</p>
<pre><code class="lang-bash"> &gt;  uniq -u test.txt
 i am tank
 this is a test
 whom have a try
 WhoM have a try
 you  have a try
 i want to abroad
 those are good men
 we are good men

 &gt;  uniq -u -i test.txt
 i am tank
 this is a test
 you  have a try
 i want to abroad
 those are good men
 we are good men
</code></pre>
</li>
</ol>
<h3 id="header-24">curl</h3>
<p>Command Line URL viewer，是一种命令行工具，用来发送网络请求</p>
<pre><code class="lang-vim">-#, --progress-bar             Make curl display a simple progress bar instead of the more informational standard meter.
-b, --cookie &lt;name=data&gt;       Supply cookie with request. If no =, then specifies the cookie file to use (see -c).
-c, --cookie-jar &lt;file name&gt;   File to save response cookies to.
-d, --data &lt;data&gt;              Send specified data in POST request. Details provided below.
-f, --fail                     Fail silently (don not output HTML error form if returned).
-F, --form &lt;name=content&gt;      Submit form data.
-H, --header &lt;header&gt;          Headers to supply with request.
-i, --include                  Include HTTP headers in the output.
-I, --head                     Fetch headers only.
-k, --insecure                 Allow insecure connections to succeed.
-L, --location                 Follow redirects.
-o, --output &lt;file&gt;            Write output to . Can use --create-dirs in conjunction with this to create any directories specified in the -o path.
-O, --remote-name              Write output to file named like the remote file (only writes to current directory).
-s, --silent                   Silent (quiet) mode. Use with -S to force it to show errors.
-v, --verbose                  Provide more information (useful for debugging).
-w, --write-out &lt;format&gt;       Make curl display information on stdout after a completed transfer. See man page for more details on available variables. Convenient way to force curl to append a newline to output: -w &quot;\n&quot; (can add to ~/.curlrc).
-X, --request                  The request method to use.
</code></pre>
<ol>
<li><p>显示：<code>-i</code> / <code>-l</code> / <code>-v</code> / <code>--trace</code></p>
<pre><code class="lang-bash"> curl -i www.example.com                      # 显示全部信息
 curl -l www.example.com                      # 只显示头部信息
 curl -v www.example.com                      # 显示一次请求全过程解析
 curl --trace output.txt www.example.com      # 可显示更详细的通信过程
</code></pre>
</li>
<li><p>HTTP Method：<code>-X</code></p>
<pre><code class="lang-bash"> curl -X GET www.example.com     # 同 curl www.example.com
 curl -X PUT www.example.com
 curl -X POST www.example.com
 curl -X DELETE www.example.com
</code></pre>
</li>
<li><p>指定发送数据：<code>-d</code> ( <code>--data</code> ) / <code>--data-urlencode</code> (自动转义特殊字符) / <code>-F</code> (<code>--form</code>)</p>
<pre><code class="lang-bash"> # curl -X POST -d &quot;username=Tom&amp;password=123&quot; http://www.example.com/login  # 使用了-d，默认即POST方法，可省略 -X POST
 curl -d &quot;username=Tom&amp;password=123&quot; http://www.example.com/login 

 # curl http://www.example.com/login?username=Tom&amp;password=123
 curl -G -d &quot;username=Tom&amp;password=123&quot; http://www.example.com/login  

 # PUT
 curl -X PUT -d &quot;username=Tom&amp;password=345&quot; http://www.example.com/change
</code></pre>
<pre><code class="lang-bash"> curl --data @localFilename http://www.example.com/login
</code></pre>
<pre><code class="lang-bash"> curl -X POST -F &#39;username=Tom&#39; -F &#39;password=123&#39; http://www.example.com/login
</code></pre>
<ul>
<li><code>-d</code>为<code>application/x-www-url-encoded</code>方式</li>
<li><code>-F</code>为<code>multipart/form-data</code>方式</li>
<li>注意：如果在一次curl中同时使用<code>-d</code>和<code>-F</code>选项会报<code>Warning: You can only select one HTTP request!</code>的警告，导致指令无法执行</li>
</ul>
</li>
<li><p>自定义头信息：<code>-H</code> (<code>--header</code>)</p>
<pre><code class="lang-bash"> curl  -H &quot;Content-Type: application/json&quot; -X POST -d &#39;{&quot;key1&quot;:&quot;value1&quot;, &quot;key2&quot;:&quot;value2&quot;}&#39; http://localhost:3000/data
</code></pre>
</li>
<li><p>文件上传: <code>-F</code> (<code>--form</code>) ，request会添加 <code>enctype=&quot;multipart/form-data&quot;</code> / <code>-T</code> ( <code>--upload-file &lt;file&gt;</code> )</p>
<pre><code class="lang-html"> &lt;!DOCTYPE html&gt;
 &lt;meta charset=&quot;utf-8&quot;&gt;
 &lt;body&gt;
 &lt;form method=&quot;POST&quot; action=&#39;/submit&#39; enctype=&quot;multipart/form-data&quot;&gt;
 &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;br&gt;
 &lt;input type=&quot;file&quot; name=&quot;img&quot;&gt;&lt;br&gt;
 &lt;input type=&quot;submit&quot;&gt;
 &lt;/form&gt;
</code></pre>
<pre><code class="lang-bash"> curl --form img=@localFilename --form user=Tom http://www.example.com/submit
 curl -F &#39;img=@localFilename&#39; http://www.example.com/submit?user=Tom
</code></pre>
<pre><code class="lang-bash"> curl -F &#39;fileX=@pathToFileX&#39; -F &#39;fileY=@pathToFileY&#39; http://www.example.com/upload      # Upload multiple files
 curl -F &#39;files[]=@pathToFileX&#39; -F &#39;files[]=@pathToFileY&#39; http://www.example.com/upload  # Upload an array of file
</code></pre>
<pre><code class="lang-bash"> curl -u ftpuser:ftppass -T myfile.txt ftp://ftp.testserver.com        # 将myfile.txt文件上传到服务器
 curl -u ftpuser:ftppass -T &quot;{file1,file2}&quot; ftp://ftp.testserver.com   # 同时上传多个文件
 curl -u ftpuser:ftppass -T - ftp://ftp.testserver.com/myfile_1.txt    # 从标准输入获取内容保存到服务器指定的文件中
</code></pre>
</li>
<li><p>下载文件:  <code>-o &lt;filename&gt;</code> 指定保存文件 / <code>-O</code> 直接使用URL中文件名保存 / <code>&gt;</code> 重定向，保存响应结果到指定路径的文件中</p>
<pre><code class="lang-bash"> curl -o mytest.txt http://www.example.com/test.html
 curl -O http://www.example.com/test.html
 curl http://www.example.com/test.html &gt; index.html
</code></pre>
<pre><code class="lang-bash"> curl -o filename1 URL1 -o filename2 URL2                    # 同时下载多个文件
 curl -O URL1 -O URL2
</code></pre>
<pre><code class="lang-bash"> curl -u ftpuser:ftppass -O ftp://ftp_server/public_html/           # 列出public_html下的所有文件夹和文件
 curl -u ftpuser:ftppass -O ftp://ftp_server/public_html/xss.php    # 下载xss.php文件
</code></pre>
</li>
<li><p>cookie: <code>-c</code> 保存cookie信息 / <code>-D</code> 保存整个header信息，包括cookie / <code>-b</code> 携带cookie信息发送请求</p>
<pre><code class="lang-bash"> curl -c cookie.txt -d &quot;username=Tom&amp;password=123&quot; http://www.example.com/login
 curl -b cookie.txt http://www.example.com/admin
</code></pre>
</li>
<li><p>跳转：<code>-L</code> 表示追踪重定向 / -e(<code>--referer</code>) 在http request头信息中，增加一个referer字段，表示来源网址</p>
<pre><code class="lang-bash"> curl -L http://www.example.com/login
 curl -e http://www.yourblog.com http://www.example.com    # 会让服务器其以为你是从http://www.yourblog.com点击某个链接过来的
</code></pre>
</li>
<li><p>User Agent: <code>-A</code> (<code>--user-agent</code>) 自定义用户代理            </p>
<pre><code class="lang-bash"> # 客户端的设备信息。服务器有时会根据这个字段，针对不同设备，返回不同格式的网页，比如手机版和桌面版
 curl -A “Mozilla/5.0 (Android; Mobile; rv:35.0) Gecko/35.0 Firefox/35.0” http://www.baidu.com   # 伪装成安卓火狐浏览器对网页进行请求
 curl URL -A &quot;Mozilla/5.0&quot;
 curl URL --user-agent &quot;Mozilla/5.0&quot;
</code></pre>
</li>
<li><p>认证: <code>-u</code> (<code>--user</code>) 设置服务器的用户名和密码，可用于HTTP，FTP的认证</p>
<pre><code class="lang-bash">curl -u user:pwd URL    # 可以指定密码
curl -u user URL        # 可在后续操作中输入密码
</code></pre>
</li>
</ol>
<p>示例：</p>
<pre><code class="lang-bash">curl -i -H &quot;Content-Type:application/json&quot; -X POST -d &#39;{&quot;name&quot;: &quot;cj&quot;, &quot;password&quot;:&quot;123456&quot;}&#39; http://127.0.0.1:8080/micro-auth/login
curl -i -H &quot;Content-Type:application/json&quot; -H &quot;micro-auth:1184e49a-8271-4de7-9323-c5f8c81c7cac&quot; -X POST http://127.0.0.1:8080/micro-auth/authentication
</code></pre>
<h3 id="header-25">crontab</h3>
<p>基本格式：<code>M   H   D   m   d   cmd</code></p>
<ul>
<li>M:     分鐘（0-59）   </li>
<li>H:    小時（0-23）   </li>
<li>D:    天（1-31）   </li>
<li>m:     月（1-12）   </li>
<li>d:     一星期內的天（0~6，0為星期天）</li>
<li>cmd：要運行的程序，程序被送入shell執行</li>
<li>例如：<pre><code class="lang-bash"># MIN   HOUR   DAY   MONTH   DAYOFWEEK  COMMAND
10         6          *           *           *               date       test.sh # 每天早上6:10   
0         */2         *           *           *               date       test.sh # 每隔两小时
0     23-7/2，8         *          *           *               date  test.sh # 晚上11点到早上7点之间，每隔一小时
0         11          4         *           mon-wed            date    test.sh # 每月的4号与每星期一至星期三的早上11点
</code></pre>
</li>
</ul>
<p>crontab命令：</p>
<ul>
<li><code>crontab file [-u   user]</code>    用指定的文件替代目前的crontab.</li>
<li><code>crontab    -[-u user]</code>            用標准輸入替代目前的crontab.</li>
<li><code>crontab    -l[user]</code>            列出用戶目前的crontab.</li>
<li><code>crontab    -e[user]</code>            編輯用戶目前的crontab.</li>
<li><code>crontab    -d[user]</code>            刪除用戶目前的crontab.</li>
<li><code>crontab    -c dir</code>                指定crontab的目錄</li>
<li>eg: 列出用戶目前的crontab<pre><code class="lang-bash">&gt; crontab -l
10 6 * * * hello.sh
40 10 01 * * java -jar InitContract.jar &gt;/dev/null
00 16 * * * /bin/ksh leave.sh &gt; leave_update.log
</code></pre>
</li>
</ul>
<p>示例：</p>
<ol>
<li>编写shell，并赋予执行权限<pre><code class="lang-bash">chmod +x file.sh
# csh -x file.sh
# ksh -x file.sh
</code></pre>
</li>
<li>导出现有crontab<pre><code class="lang-bash">crontab -l &gt; test_crontab
</code></pre>
</li>
<li>编辑导出的crontab文件，添加crontab任务<pre><code class="lang-bash">vi test_crontab
</code></pre>
</li>
<li>导入新的crontab文件，使其生效<pre><code class="lang-bash">crontab test_crontab
</code></pre>
</li>
</ol>
<h2 id="header-26">Shell</h2>
<pre><code class="lang-bash"># 查看當前使用的Shell
&gt; echo $SHELL
/bin/sh

# 查看当前shell的进程号
&gt; echo $$
12282

# ps-A看自己shell的pid
&gt; ps -A | grep 12282
12282 pts/19   0:00 sh

# 启动一个新的K Shell进程，用exit退出
&gt; ksh
&gt; exit

# 启动一个新的C Shell进程，用exit退出
&gt; csh
&gt; exit
</code></pre>
<ol>
<li><p>命令回传值 <code>$?</code></p>
<ul>
<li>若前一个命令运行的结果为正确，在 Linux 底下会回传一个 $? = 0 的值</li>
<li><code>cmd1 &amp;&amp; cmd2</code><ul>
<li>若 cmd1 运行完毕且正确运行(<code>$?=0</code>)，则开始运行 cmd2</li>
<li>若 cmd1 运行完毕且为错误 (<code>$?≠0</code>)，则 cmd2 不运行</li>
</ul>
</li>
<li><code>cmd1 || cmd2</code><ul>
<li>若 cmd1 运行完毕且正确运行(<code>$?=0</code>)，则 cmd2 不运行<br>+　若 cmd1 运行完毕且为错误 (<code>$?≠0</code>)，则开始运行 cmd2</li>
</ul>
</li>
<li><p>示例：</p>
<pre><code class="lang-bash"># 自动判断，如果没有该目录就给予创建
ls /tmp/abc || mkdir /tmp/abc

# 以 ls 测试 /tmp/vbirding 是否存在
# 若存在则显示 &quot;exist&quot;
# 若不存在，则显示 &quot;not exist&quot;
ls /tmp/vbirding &amp;&amp; echo &quot;exist&quot; || echo &quot;not exist&quot;
</code></pre>
</li>
</ul>
</li>
<li><p><code>exit n</code></p>
<ul>
<li>n 是数字</li>
<li>让程序中断,并回传一个数值给系统</li>
<li>利用此功能，可以自订错误信息，并通过<code>echo $?</code>获取错误信息</li>
</ul>
</li>
<li><p>变量</p>
<ul>
<li><p>变量的测试与内容替换</p>
<table class="table">
<thead>
<tr>
<th>变量配置方式</th>
<th>str 不存在</th>
<th>str 为空字符串</th>
<th>str 为非空字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>『判断』str是否存在</td>
<td>str不存在，返回expr</td>
<td></td>
<td>str存在，返回str原值</td>
</tr>
<tr>
<td><code>var=${str-expr}</code></td>
<td>var=expr</td>
<td>var=</td>
<td>var=$str</td>
</tr>
<tr>
<td><code>var=${str:-expr}</code></td>
<td>var=expr</td>
<td>var=expr</td>
<td>var=$str</td>
</tr>
<tr>
<td>『判断』str是否不存在</td>
<td>str不存在，返回空</td>
<td></td>
<td>str存在，返回expr</td>
</tr>
<tr>
<td><code>var=${str+expr}</code></td>
<td>var=</td>
<td>var=expr</td>
<td>var=expr</td>
</tr>
<tr>
<td><code>var=${str:+expr}</code></td>
<td>var=</td>
<td>var=</td>
<td>var=expr</td>
</tr>
<tr>
<td>使用等号 <code>=</code></td>
<td>str不存在，返回expr，且置str=expr</td>
<td></td>
<td>str存在，返回str原值，str不变</td>
</tr>
<tr>
<td><code>var=${str=expr}</code></td>
<td>var=expr , str=expr</td>
<td>var= ,str 不变</td>
<td>var=$str, str 不变</td>
</tr>
<tr>
<td><code>var=${str:=expr}</code></td>
<td>var=expr ,  str=expr</td>
<td>var=expr, str=expr</td>
<td>var=$str,  str 不变</td>
</tr>
<tr>
<td>使用<code>?</code></td>
<td>str不存在，expr 输出至 stderr</td>
<td></td>
<td>str存在，返回str原值</td>
</tr>
<tr>
<td><code>var=${str?expr}</code></td>
<td>expr 输出至 stderr</td>
<td>var=</td>
<td>var=$str</td>
</tr>
<tr>
<td><code>var=${str:?expr}</code></td>
<td>expr 输出至 stderr</td>
<td>expr 输出至stderr</td>
<td>var=$str</td>
</tr>
</tbody>
</table>
</li>
<li>注意： 使用 <code>:</code> 则变量不存在或为空字符串则是一个效果</li>
<li><p>打印变量</p>
<pre><code class="lang-bash">&gt; echo $var
1

# 扩展$var并添加串work
# {} 把该变量从给它添加的字符里分离出来
&gt; echo ${var}work
1work
</code></pre>
</li>
</ul>
</li>
<li><p>日期date</p>
<pre><code class="lang-bash"> &gt; date
 Tue Feb  7 15:35:15 CST 2012
 &gt; echo `date +%y%m%d`
 120207
 &gt; echo `date +%Y/%m/%d`
 2012/02/07
 &gt; echo `date &#39;+%H%M%S&#39;`
 153255
 &gt; echo `date +%D`
 02/07/12
 &gt; echo `date +%h`
 Feb
 &gt;  echo `date &#39;+%Y/%m/%d %H:%M:%S&#39;`
 2012/02/07 15:32:35
</code></pre>
<pre><code> date1=$(date --date=&#39;2 days ago&#39; +%Y%m%d)  # 前两天的日期
 date2=$(date --date=&#39;1 days ago&#39; +%Y%m%d)  # 前一天的日期
 date3=$(date +%Y%m%d)                      # 今天的日期

 # 配置档名
 file1=${filename}${date1}
 file2=${filename}${date2}
 file3=${filename}${date3}
</code></pre></li>
<li><p>命令替换：将命令放入反引号</p>
<pre><code class="lang-bash"> &gt; set d = `date`    # 产生的值是一个数组
 &gt; echo $d[1]
 Tue

 &gt; set d=&quot;`date`&quot;    # 输出封装在双引号里，所以是一个单串
 &gt; echo $d[1]
 Tue Feb 7 13:33:06 CST 2012
 &gt; echo $d[2]
 Subscript out of range

 &gt; cal 2 2012
  February 2012
 S  M Tu  W Th  F  S
       1  2  3  4
 5  6  7  8  9 10 11
 12 13 14 15 16 17 18
 19 20 21 22 23 24 25
 26 27 28 29
 &gt; echo Hello `cal 2 2012`        # 输出每个换行符都用一个空格代替
 Hello February 2012 S M Tu W Th F S 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29
</code></pre>
</li>
</ol>
<h3 id="header-27">C Shell</h3>
<ol>
<li><p><code>#!/bin/csh</code></p>
</li>
<li><p>用户接收 <code>$&lt;</code></p>
<pre><code class="lang-bash">echo -n &quot;What is your name? &quot;    # -n 取消末尾的换行
set name = $&lt;
</code></pre>
</li>
<li><p>测试变量是否被设置 <code>$?var</code></p>
<ul>
<li>1:设置了</li>
<li>0:未设置</li>
<li>eg: <code>echo $?hello</code></li>
</ul>
</li>
<li><p>命令行变元<code>$xxx</code></p>
<pre><code class="lang-bash">$0,$1,$2,...
$*
$argv[0]
$argv[1],$argv[2],...$argv[$#argv]
$argv[*],$argv
</code></pre>
</li>
<li><p>数值运算</p>
<pre><code class="lang-bash"> &gt; @ sum = 4 + 6
 &gt; echo $sum
 10

 &gt; @ sum ++
 &gt; echo $sum
 11

 &gt; @ sum += 3
 &gt; echo $sum
 14
</code></pre>
</li>
<li><p>数组</p>
<ul>
<li><code>(...)</code> 创建数组</li>
<li><code>$#var</code> 数组长度</li>
<li><code>$var[*]</code> ,<code>$var</code> 打印所有元素</li>
<li><code>$var[..]</code> 获取某个数组元素（数组从1～len）</li>
<li><p><code>shift var</code> 数组左移一个元素</p>
<pre><code class="lang-bash">&gt; set name = &quot;Hello GoodBye Sir&quot;
&gt; echo $name[1]
Hello GoodBye Sir
&gt; echo $name[2]
Subscript out of range

# 将变量封装在()中，创建一个叫做fruit的数组
&gt; set fruit = ($name)
&gt; echo $fruit
Hello GoodBye Sir
&gt; echo $fruit[2]
GoodBye
</code></pre>
<pre><code class="lang-bash"># 创建数组
&gt; set fruit = ( app1 app2 app3 )
&gt; echo $fruit
app1 app2 app3
&gt; echo $fruit[*]
app1 app2 app3

# 查询
&gt; echo $fruit[1]
app1
&gt; echo $fruit[2-3]
app2 app3
&gt; echo $#fruit
3
&gt; echo $fruit[$#fruit]
app3

# 操作
&gt; set fruit[2] = bana
&gt; echo $fruit
app1 bana app3

&gt; shift fruit
&gt; echo $fruit
bana app3
</code></pre>
</li>
</ul>
</li>
<li><p>条件表达式</p>
<ul>
<li><code>==</code>,<code>!=</code>,<code>&gt;</code>,<code>&gt;=</code>,<code>&lt;</code>,<code>&lt;=</code>,<code>~</code>,<code>!~</code>,<code>!</code>,<code>||</code>,<code>&amp;&amp;</code><pre><code class="lang-bash">if ( $answer =~ [Yy]* ) then
if ( $status == 0 ) then
if ( $?prompt ) then
if ( &quot;$name&quot; != &quot;KK&quot; ) then                #使用“”防止name中不止一个词而发生异常
if ( (&quot;$x&quot; &amp;&amp; &quot;$y&quot; ) || ! &quot;$z&quot; ) then            # ! 后面必须有一个空格
</code></pre>
</li>
<li><code>-r</code>,<code>-w</code>,<code>-x</code>,<code>-o</code><pre><code class="lang-bash">if ( -r $file &amp;&amp; -w $file ) then
</code></pre>
</li>
<li><code>-e</code>,<code>-z</code>,<code>-f</code>,<code>-d</code><pre><code class="lang-bash">if ( ! -d $file ) then
</code></pre>
</li>
</ul>
</li>
<li><p>条件判断</p>
<ul>
<li><code>if/else if/else/endif</code><pre><code class="lang-bash">if ( exp1 ) then
  echo &quot;case1&quot;
else if ( exp2 ) then
  echo &quot;case2&quot;
else if ( exp3 ) then
  echo &quot;case3&quot;
else
  echo &quot;case4&quot;
endif
</code></pre>
</li>
<li><code>switch/case/breaksw/endsw</code><pre><code class="lang-bash">switch ( str )
case red:
  echo &quot;case1&quot;
  breaksw
case bl*:
  echo &quot;case2&quot;
  breaksw
case [56].c:
  echo &quot;case1&quot;
  breaksw
default:
  breaksw
endsw
</code></pre>
</li>
</ul>
</li>
<li><p>循环</p>
<ul>
<li><code>foreach var (list) cmd end</code><pre><code class="lang-bash">  foreach person (`cat maillist`)
      echo $preson
  end
</code></pre>
<pre><code class="lang-bash">  foreach file (*.c)
      echo $file
  end
</code></pre>
</li>
<li><code>while(exp) cmd end</code><pre><code class="lang-bash">  while ( $num &lt; 10 )
      echo $num
      @ num++
  end
</code></pre>
<pre><code class="lang-bash">  while ( &quot;$answer&quot; != &quot;Bye&quot; )
      set answer = $&lt;
  end
</code></pre>
<pre><code class="lang-bash">  while ($#argv)
      echo $argv
      shift
  end
</code></pre>
<pre><code class="lang-bash">  while (1)
      cmd
      if () then
          break
      else if () then
          continue
      else
          cmd
      endif
  end
</code></pre>
</li>
<li><code>repeat n cmd</code><pre><code class="lang-bash">  repeat 3 echo hello
</code></pre>
</li>
</ul>
</li>
</ol>
<p>示例</p>
<ol>
<li><p>设置变量</p>
<pre><code class="lang-bash"> set FTP_FTSERVER  = (10.7.49.15 10.7.49.17 10.7.49.152 10.7.54.2) 
 set ServletURL = http://10.7.33.16/cim/servlet
 set Rawdata = $downup\/$LOTNO-$CPNO
</code></pre>
<pre><code class="lang-bash"> set tdtplogfile = /home/klt/log/tdtp_1.`date &#39;+%Y%m%d&#39;`    
 set LOGS =  /db/data/autoftp/logs/pixart/`/usr/ucb/whoami`
</code></pre>
<pre><code class="lang-bash"> set tmpfile = /home/klt/wgetlog/$$
 set TEMPLASER = /home/cim1tdtp/temp/&quot;$LLOTNO$WAFNUM&quot;-$$.asc
</code></pre>
<pre><code class="lang-bash"> set lenOfPfile = `echo $proberfile | cut -d &#39;/&#39; -f8 | awk &#39;{print length($1)}&#39;`
 set lenOfWno   = `echo $proberfile | cut -d &#39;/&#39; -f8 | cut -d &#39;.&#39; -f1 | awk &#39;{print length($1)}&#39;`
 @ lenOfWno = $lenOfWno + 2
 set partlotno = `echo $proberfile | cut -d &#39;/&#39; -f8 | cut -c $lenOfWno-$lenOfPfile`
 echo partlotno is $partlotno

 set fproberfile = `ls /db/prober/map/$testgrp/$Rawdata/$partlotno=* | tail -1`      
 set fpfilelength = ` echo $fproberfile | awk &#39;{print length($1)}&#39;`
</code></pre>
<pre><code class="lang-bash"> set cpNo = `echo $configArr[1] | cut -c 3- `
 set USER_COUNTS = `who | grep klt | wc -l`
 set os = `uname`
 set RETURNVALUE=`echo $TMPLINE |awk -F\| &#39;{print $1}&#39;`
 set RemoteHost = `who am i |awk  &#39;{print $NF}&#39; | awk -F\( &#39;{print $2}&#39;  | awk -F\) &#39;{print $1}&#39; | awk -F. &#39;{print $1}&#39; `
</code></pre>
</li>
<li><p>接收用户输入</p>
<ul>
<li>存入一个变量<pre><code class="lang-bash">echo CPNO:
set CPNO = $&lt;
</code></pre>
</li>
<li><p>存入数组，小写转换为大写，获取字符串长度，设置变量</p>
<pre><code class="lang-bash">echo   CPNO Flotno WaferNum PROBERIP TESTGROUP UP 
set tempfile    = $&lt;
set file    = ($tempfile)

if ( $#file == 6 ) then  
  set CPNO         = `echo $file[1] | tr &quot;[:lower:]&quot; &quot;[:upper:]&quot; `  
  set equip        = $file[4]
  set numchar      = ` echo $WAFERNUM | awk &#39;{print length($1)}&#39;`    
endif

if ( $numchar == 1 ) then
      set WAFERNUM = 0&quot;$WAFERNUM&quot;
endif
</code></pre>
</li>
</ul>
</li>
<li><p>if 判断</p>
<pre><code class="lang-bash"> if (-e $tmpfile) then
     echo `date &#39;+%H:%M:%S&#39;` &gt;&gt; $tdtplogfile    
 endif

 if ( ! -d $LOGS ) then 
     mkdir -p $LOGS
 endif

 if ( ! -d $FTP_SRC_DIR ) then
     mkdir $FTP_SRC_DIR
     chmod 777 $FTP_SRC_DIR
 endif
</code></pre>
<pre><code class="lang-bash"> if ( $USER_COUNTS &gt; 3 ) then 
     echo &quot;Too Many User Execute TDTP manual(Default:3 users), Please wait...&quot;
     echo &quot;You can contact with user, and list as follows:&quot;
     who | grep klt
     ps -ef | grep &quot; klt &quot;
     exit
 endif

 if ($os =~ [Ll][Ii][Nn][Uu][Xx]) then
     set wget = $srcpath&quot;download-Linux&quot;    
 else if ($os =~ [Ss][Uu][Nn][Oo][Ss]) then
     if ( `hostname` =~ [Jj]995*) then
         set wget = $srcpath&quot;download-SunOS41&quot;
     else
         set wget = $srcpath&quot;download-SunOS&quot; 
     endif
 endif

 if ($os !~ [Ll][Ii][Nn][Uu][Xx]) then
     unsetenv $PGM_WGETPATH
 endif
</code></pre>
<pre><code class="lang-bash"> # $status : 
 # grep 找到所寻找的模式 0; 找不到该模式 1; 找不到文件 2 ;
 # awk / sed 不论搜索的模式是否成功 0 ; 语法错误 非0

  grep &quot;tw.com.kyec.cim.cp.task.TaskTDTPProber: true&quot; $tmpfile  &gt; &amp;  /dev/null
   if ($status == 0 ) then
       echo TDTP have done $proberfile
   else 
      echo failed to do TDTP $proberfile
   endif

  set fproberfile = `ls /db/prober/map/$testertype/up/$templotno/$partlotno=* | tail -1`
  set fpfilelength = ` echo $fproberfile | awk &#39;{print length($1)}&#39;`
</code></pre>
</li>
<li><p>foreach 循环</p>
<pre><code class="lang-bash"> foreach FTP_SERVER ( `echo $FTP_FTSERVER`)
     /usr/sbin/ping $FTP_SERVER | grep alive                 &gt;&amp; /dev/null
     if ( $status != 0 ) then
         echo Server can\&#39;t connect to $FTP_SERVER           &gt;&gt; $FTP_LOG
         continue
     endif
 end
</code></pre>
<pre><code class="lang-bash"> set count = 1
 foreach filename (`cat $FileList`)
     set klotno = `echo $filename | cut -d&#39;-&#39; -f1`
     set barcode = `echo $filename | cut -d&#39;_&#39; -f1`
     set filetime = `echo $filename | cut -d&#39;_&#39; -f2 | cut -c 1-12`

     if ( $klotno == $lotno ) then
         set cmdStr = &quot;$ServletURL/chkWfrStatus?CUST=ZKT&amp;2DBARCODE=${barcode}&amp;STNO=1&amp;FILETIME=${filetime}&amp;TESTER=E320_BDB01&amp;HEAD=1&quot;
         $WGET -q -O $tmpfile &quot;$cmdStr&quot;
         @ count++
     else
         echo &quot;$klotno != $lotno&quot; &gt;&gt; $logfile
     endif     
 end
</code></pre>
</li>
<li><p>while 循环</p>
<pre><code class="lang-bash"> set waferno = 1
 while ( $waferno &lt; 26 ) 
     @ waferno = $waferno + 1
     if ($waferno &lt; 10 ) then
         continue
     endif
 end
</code></pre>
<pre><code class="lang-bash"> while ( $#argv &gt; 0 )
     set args = &quot;$args $argv[1]&quot;
     shift argv
 end
</code></pre>
</li>
<li><p>压缩/解压缩</p>
<pre><code class="lang-bash"> unzip -o $FTP_AIM_DIR/$LOTNO/$TEMP_FILE -d $FTP_AIM_DIR/$LOTNO/
 unzip $TEMP_ZIP1.zip -d $TEMP_ZIP1.ZIP 
 uncompress &lt; $FTP_AIM_DIR/$LOTNO/$TEMP_FILE | tar xf -

 tar -cvf $DirName&quot;.tar&quot; $DirName
 compress $DirName&quot;.tar&quot;
</code></pre>
</li>
<li><p>环境变量设置</p>
<pre><code class="lang-bash"> set srcpath = &quot;/cim/pgm/prod/&quot;
 setenv PGM_WGETPATH $srcpath

 setenv CIM_AUTO_INVOKED_PRCESS /home/asx/bin/auto_prober_klt.sh
 setenv CDC_PROBERD_LICENSE &quot;O54k43jL7aI2LGaBo6bf6IxaLPQtc2&quot;
</code></pre>
</li>
<li><p>FTP</p>
<pre><code class="lang-bash"> # ftp -inv $FTP_SERVER
 echo user $FTP_USER $FTP_PASSWORD    &gt;&gt; $FTP_CMD_FILE
 echo cd /down                        &gt;&gt; $FTP_CMD_FILE
 echo bin                             &gt;&gt; $FTP_CMD_FILE            
 echo put $file                       &gt;&gt; $FTP_CMD_FILE
 echo bye                             &gt;&gt; $FTP_CMD_FILE

 ftp -inv $FTP_SERVER &lt; $FTP_CMD_FILE
 echo &quot;OK\!&quot;
</code></pre>
<pre><code class="lang-bash"> echo user $FTP_USER $FTP_PASSWD           &gt;   $FTP_CMD_FILE
 echo cd $FTP_DIR_A                        &gt;&gt;  $FTP_CMD_FILE
 echo bin                                  &gt;&gt;  $FTP_CMD_FILE

 echo &quot;mget C*.TXT&quot;                         &gt;&gt;  $FTP_CMD_FILE
 echo &quot;mdir C*.TXT $DB_LOG&quot;                 &gt;&gt;  $FTP_CMD_FILE 
 foreach TEMP_FILE ( C*.TXT )
     echo &quot;del $TEMP_FILE&quot;                  &gt;&gt;   $FTP_CMD_FILE 
 end
 ls *.zip | awk &#39;{printf &quot;del %s\n&quot;,$1}&#39;     &gt;&gt;   $FTP_CMD_FILE    
 echo bye                                    &gt;&gt;  $FTP_CMD_FILE

 echo &quot;## start get emap data from csmc ftp Server at `date` ##&quot;  &gt;&gt;  $FTP_LOG
 (ftp -inv $FTP_SERVER &lt; $FTP_CMD_FILE)       &gt;&gt;  $FTP_LOG
 echo &quot;## end get emap data from csmc ftp Server at`date` ##&quot;     &gt;&gt;  $FTP_LOG
</code></pre>
</li>
<li><p>特殊命令</p>
<pre><code class="lang-bash"> java -classpath .:/home/asx/proberlog/classes12.jar probLogScan $proberfile /home/asx/proberlog/  
 unix2dos   $LLOTNO$WAFNUM.asc     $LLOTNO$WAFNUM.asc
 exec /home/asx/bin/cdc_proberd &gt; /home/asx/bin/cdc_screen.log.`date &#39;+%Y%m%d&#39;` 
 last | grep logged | grep tsk | grep $RemoteHost &gt;&amp; /dev/null 
 /home/asx/bin/auto_prober_real_klt.sh $1  $2 &amp;

 sed -n 17,&quot;$FILE_LENGTH&quot;p $FILE &gt; $tmpfile
 set CAT_X = `perl -e &#39;while(&lt;&gt;){$count+= s/X//g;} print &quot;$count&quot;;&#39; $tmpfile` 

 set lineSting =  `sed -n $line&quot;p&quot; $FILE_SHARE_TMP`
</code></pre>
</li>
<li><p>使用wget 触发 Servlet</p>
<pre><code class="lang-bash">set WGET = /cim/bin/wget/ADVAN/wget
$WGET -q -O $tmpfile  &quot;$ServletURL/CpTrigger?TASK=$TASK&quot;
</code></pre>
</li>
<li><p>调用java</p>
<pre><code class="lang-bash">#! /bin/csh
#classpath=.:$JAVA_HOME/lib/tools.jar:/home/cim1tdtp/oracle.jar
set srcPath=&quot;/db/data/CGSPGM/exec&quot;
cd $srcPath
echo `java ParseRawForCGS` &gt;&gt; insertResult.txt
exit
</code></pre>
</li>
</ol>
<h3 id="header-28">K Shell</h3>
<ol>
<li><p><code>#!/bin/ksh</code></p>
</li>
<li><p>读取用户输入<code>read</code></p>
<pre><code class="lang-bash"> read                # $REPLY
 read answer
 print $answer
 read first middle last
 read -u3 name        # -u 从文件描述符中读取一行存储到变量name中

 while read -u3 line1 &amp;&amp; read -u4 line2
 do
     print &quot;$line1:$line2&quot;
 done 3&lt;$1 4&lt;$2
</code></pre>
</li>
<li><p>只读 <code>readonly</code></p>
<pre><code class="lang-bash"> &gt; readonly name=Tom
 &gt; print $name
 Tom
 &gt; name=Joe
 ksh: name: is read only
</code></pre>
</li>
<li><p><code>typeset</code>  设置变量属性</p>
<ul>
<li><code>-u</code> 将变量值中所有字母全部转换成大写</li>
<li><code>-l</code> 将变量值中所有字母全部转换成小写</li>
<li><code>-i</code> 将变量值设为整数类型</li>
<li><code>-L</code> width 在width宽度之内左对齐</li>
<li><code>-R</code> width 在width宽度之内右对齐，前面空位用空格填充</li>
<li><code>-Z</code> width 在width宽度之内右对齐</li>
<li><code>-x</code> 设置一个全局变量。相当于 export</li>
<li><p><code>-r</code> 设置一个变量具有只读属性，相当于readonly</p>
<pre><code class="lang-bash">&gt; typeset -i num        # 整数
&gt; typeset -i2 num        # 将数值num转换为二进制,i后面为进制数
&gt; print $num
2#111

&gt; kk=5.6
&gt; typeset -i kk
&gt; echo $kk
</code></pre>
</li>
</ul>
</li>
<li><p>history</p>
<pre><code class="lang-bash"> history
 history -n            # print without line numbers
 history 8            # list form 8th command to present
 history -3            # list this command and  the 3 preceding it
 history -1 -5          # list last 5 commands,preceding this one in reversed order
 history -5 -1          # list last 5 commands,preceding this one in order
 history ls echo     # display from most recent &quot;ls&quot; command to most recent &quot;echo&quot; command
 history -r ls echo     # -r reverses the list
</code></pre>
</li>
<li><p><code>r</code> 重新执行命令</p>
<pre><code class="lang-bash"> r date
 r 3
 r vi
 r vi file1=file2
</code></pre>
</li>
<li><p>别名 <code>alias</code></p>
<pre><code class="lang-bash"> alias c1=&#39;clear&#39;
 alias l=&#39;ls -laF&#39;
 unalias c1
 alias -t
</code></pre>
</li>
<li><p>命令行变元</p>
<pre><code class="lang-bash"> &gt; set tom joe sam
 &gt; echo $*
 tom joe sam

 &gt; shift
 &gt; echo $*
 joe sam
 &gt; echo $#
 2

 &gt; set $(date)
 &gt; print $*
 Wed Feb 8 14:41:11 CST 2012
 &gt; shift 3
 &gt; print $*
 14:41:11 CST 2012
</code></pre>
</li>
<li><p>算数运算</p>
<pre><code class="lang-bash"> num=5
 let num=num+2        # (( num=num+2))
 print $num
</code></pre>
</li>
<li><p>数组</p>
<ul>
<li><code>set -A var ...</code> 创建数组</li>
<li><code>${var[*]}</code> 打印数组</li>
<li><code>${var[..]}</code> 获取数组某元素值</li>
</ul>
<pre><code class="lang-bash">&gt; typeset -i names[4]
&gt; names[0]=30

&gt; set -A fruit apples pears bananana
&gt; print $fruit
apples
&gt; print ${fruit[1]}
pears

&gt; print ${fruit[*]}
apples pears bananana
&gt; print ${#fruit[*]}  # 数组长度
3
</code></pre>
</li>
<li><p>函数</p>
<pre><code class="lang-bash">function funcName { cmd;}
$funcName
</code></pre>
<pre><code class="lang-bash">function funCName {print &quot;Hi $1 and $2&quot;;)
$funcName tom joe

&gt; typeset -f funCName                # list function define
&gt; typeset +f funCName                # list function name
&gt; unset -f funCName                  # clear funtion
</code></pre>
</li>
<li><p>条件判断</p>
<ul>
<li>整数测试: <code>-eq</code>,<code>-ne</code>,<code>-gt</code>,<code>-ge</code>,<code>-lt</code>,<code>-le</code></li>
<li>文件测试: <code>-r</code>,<code>-w</code>,<code>-x</code>,<code>-d</code>,<code>-f</code>, <code>-s</code>,<code>-e,</code>-a`</li>
<li>逻辑操作符: <code>&amp;&amp;</code>,<code>||</code>,<code>!</code></li>
<li><code>[]</code> 等价于旧 test 命令 (<code>[</code> 后面必须有空格)</li>
<li><code>[[]]</code> / <code>(())</code> 等价于新test 命令,允许使用Shell元字符扩展<pre><code class="lang-bash">&gt; name=Tom
&gt; test $name=Tome
&gt; [ $name = Tom ]
&gt; [[ $name = [Tt]?m ]]
</code></pre>
</li>
</ul>
</li>
<li><p>判断</p>
<ul>
<li><code>if/elif/else/fi</code><pre><code class="lang-bash">if [[ ... ]]
then
  cmd
elif [[ ... ]]
  cmd
else
  cmd
fi
</code></pre>
</li>
<li><code>case/esac</code><pre><code class="lang-bash">case var in
value1)
  cmd
  ;;
value2)
  cmd
  ;;
*)
  cmd
  ;;
esac
</code></pre>
</li>
</ul>
</li>
<li><p>循环</p>
<ul>
<li><p><code>for var in list do cmd done</code></p>
<pre><code class="lang-bash">  for person in `cat mylist`    # for person in $(&lt;mylist)
  do
      print $person
  done
</code></pre>
<p>-<code>while [[expr]] do cmd done</code></p>
<pre><code class="lang-bash">  while (( num &lt; 10 ))
  do
      print $num
      (( num=num+1))
  done
</code></pre>
<pre><code class="lang-bash">  while [[ $answer != &quot;Tom&quot; ]]
  do
      print &quot;wrong!&quot;
      read answer
  done
</code></pre>
<pre><code class="lang-bash">  cat $1 | while read line
  do
      print $line

  done &gt; tmp$$
</code></pre>
</li>
<li><code>until [[expr]] do cmd done</code><pre><code class="lang-bash">  until who | grep linda
  do    
      sleep 5
  done
</code></pre>
</li>
<li><code>select</code><pre><code class="lang-bash"> select var in wordlist
 do
     cmd
 done
</code></pre>
</li>
</ul>
</li>
<li><p><code>IFS</code> : shell 内部分隔符</p>
<pre><code class="lang-bash">names=Tom:Dick:Sam:John
OldIFS=&quot;$IFS&quot;
IFS=&quot;:&quot;
for person in $names
do
    print Hi $preson
done
IFS=&quot;$OldIFS&quot;
</code></pre>
</li>
</ol>
<p>使用示例：</p>
<ol>
<li><p>压缩备份资料(压缩文件夹)</p>
<pre><code class="lang-bash"> #!/bin/ksh
 read zipPath
 echo $zipPath
 cd     $zipPath

 # tar, compress
 for DirName in `ls `
 do
     tar -cvf $DirName&quot;.tar&quot; $DirName
     compress $DirName&quot;.tar&quot;
 done

 # zip
 for DirName in `ls `
     do
         echo $DirName
         zip -r $DirName&quot;.zip&quot; $DirName
         rm -r $DirName
     done

 #collectData=$zipPath/1.txt
 #echo $collectData
 #while read DirName
 #do
 #        echo $DirName
 #        zip -r $DirName&quot;.zip&quot; $DirName
 #        rm -r $DirName
 #done &lt; $collectData

 echo OK
 exit
</code></pre>
</li>
<li><p>If</p>
<pre><code class="lang-bash"> if [ ! -d $generatePath ]
 then
     mkdir $generatePath
 fi

 if [ -f $filePathWithName ]
 then
     if [[ $cpno -eq 1 ]] 
     then
         awk &#39;NR&gt;21 {print $3&quot; &quot;$4&quot; &quot;$5&quot; &quot;$6&quot; &quot;$7&quot; &quot;$8}&#39; $filePathWithName &gt; $generatePath/$wafid
     else
         awk &#39;NR&gt;21 {print $3&quot; &quot;$4&quot; &quot;$5&quot; &quot;$6&quot; &quot;$7}&#39; $filePathWithName &gt; $generatePath/$wafid
     fi
     echo &quot;OK : $wafid &quot; &gt;&gt; $resultLog
 else
     echo &quot;FAIL : $count $filePathWithName unfound&quot; &gt;&gt; $resultLog
     echo &quot;FAIL : $count $filePathWithName unfound&quot; &gt;&gt;$FailLog
 fi
</code></pre>
<pre><code class="lang-bash"> if [ $TEMPMAXNUM -lt 50 ]
 if [ $NUM -eq &quot;0&quot; ]
 if [ -f $FTP_SRC_DIR/$CUSTOMER/$FILE ]
 if [[ $LOCAL_SIZE == $REMOTE_SIZE ]]
</code></pre>
<pre><code class="lang-bash"> if [ -f $FTP_SRC_DIR/$CUSTOMER/$FYLE_TYPE/*H2T340* ]
 then
     if [ ! -d $FTP_SRC_DIR/$CUSTOMER/$FYLE_TYPE/stdfFilter ] 
     then
         mkdir $FTP_SRC_DIR/$CUSTOMER/$FYLE_TYPE/stdfFilter
     fi
     echo $FTP_SRC_DIR/$CUSTOMER/$FYLE_TYPE/*H2T340*
     mv $FTP_SRC_DIR/$CUSTOMER/$FYLE_TYPE/*H2T340* $FTP_SRC_DIR/$CUSTOMER/$FYLE_TYPE/stdfFilter/
     echo &quot;move to stdfFilter ok&quot;
 fi
</code></pre>
</li>
<li><p>while</p>
<pre><code class="lang-bash"> count=1
 while read line
 do
    echo $count `date &#39;+%m%d%H%M&#39;` :$line    &gt;&gt; $resultLog
    filename=`echo $line | awk  &#39;{print $6}&#39;`
    generatePath=$resultPath/$klotNo

    let i=count%5 
    if [[ $i == 0 ]] 
    then
         echo &quot;********************************************&quot; &gt;&gt; $resultLog
         echo $count
    fi 
    let count=count+1 
 done &lt; $collectData
</code></pre>
<pre><code class="lang-bash"> usedFilePathLength=1 
 while (( $usedFilePathLength &lt; ${#arrayFileDir[*]}-1 ))  
 do
      echo mkdir ${arrayFileDir[$usedFilePathLength]} &gt;&gt; $FTP_CMD_FILE
      echo cd ${arrayFileDir[$usedFilePathLength]}    &gt;&gt; $FTP_CMD_FILE 
      cd ${arrayFileDir[$usedFilePathLength]} 
      let usedFilePathLength=usedFilePathLength+1
 done
</code></pre>
</li>
</ol>
<h3 id="header-29">B Shell</h3>
<ol>
<li><p><code>#!/bin/bash</code></p>
</li>
<li><p>read</p>
<pre><code class="lang-bash">read -p &quot;Please input your first name: &quot; firstname  # 提示使用者输入
read -p &quot;Please input your last name:  &quot; lastname   # 提示使用者输入
echo -e &quot;\nYour full name is: $firstname $lastname&quot; # 结果输出
</code></pre>
</li>
<li><p>数值运算 ( bash shell 默认仅支持到整数的数据 )</p>
<pre><code class="lang-bash">var=$((运算内容))
echo $(( 13 % 3 ))
</code></pre>
</li>
</ol>
<p>更多可参考：<a href="http://vbird.dic.ksu.edu.tw/linux_basic/0320bash.php" target="_blank" rel="noopener">鸟哥的Linux私房菜</a></p>
<h3 id="header-30">注意</h3>
<p>shell脚本执行错误 <code>$&#39;\r&#39;:command not found</code></p>
<p>原因：<br>脚本是在window下编辑完成后上传到linux上执行的，win下的换行是回车符+换行符，也就是<code>\r\n</code>,而unix下是换行符<code>\n</code>。<br>linux下不识别<code>\r</code>为回车符，所以导致每行的配置都多了个<code>\r</code>，因此是脚本编码的问题。</p>
<p>解决方案：<br>在linux上执行 <code>dos2unix 脚本名</code>，再次执行脚本，报错消失</p>
<pre><code class="lang-bash">&gt; dos2unix a.sh
&gt; ./a.sh                # 或 sh a.sh
</code></pre>
  </section>
</article>

      <hr/>
      
<section class="post-comment">
	
		<div id="gitment_container"></div>

<link rel="stylesheet" href="/gitment/default.css">
<script src="/gitment/gitment.browser.js"></script>


<script type="text/javascript">
	var gitment = new Gitment({
	  id: document.location.pathname,
	  owner: 'chenjin-zero',
	  repo: 'blogComment',
	  oauth: {
	    client_id: '36a09bb7399efe69c6ce',
	    client_secret: 'ad9ad546b23b708c71d92e513dc36e0486179dea',
	  }
	})
      
	gitment.render('gitment_container')
</script>
	
</section>

    </div>
  </div>
</body>

<script src="/jquery/dist/jquery.min.js"></script>
<script src="/bootstrap/dist/js/bootstrap.min.js"></script>


	<script src="/highlight/highlight.pack.js"></script>
	<script type="text/javascript">
		hljs.initHighlightingOnLoad();
	</script>



<script type="text/javascript">

  $(document).ready(function(){
    var sidebarCtrl=$("#sidebar-ctrl");
    var sidebar=$("#sidebar");
    var wrapper=$("#wrapper");
    sidebarCtrl.on("click",function(event){
        //alert("click");
        sidebar.toggleClass("sidebar-toggle");
        wrapper.toggleClass("sidebar-toggle");
        sidebarCtrl.toggleClass("sidebar-toggle");
        sidebarCtrl.toggleClass("active");
    })
  });
</script>


</html>
