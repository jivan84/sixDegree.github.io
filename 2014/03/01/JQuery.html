<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>JQuery</title>
  
  <!-- Meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="javascript,object,prototype,jquery,event,deferred,promise,ajax,plugin">
  
  
    <meta name="description" content="Javascript and JQuery Introduce">
  

  <!-- Feed -->
  
    <link rel="alternative" href="/atom.xml" title="SixDegree" type="application/atom+xml">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/bootstrap/dist/css/bootstrap.css">
  
    <link rel="stylesheet" href="/highlight/demo/styles/tomorrow-night-bright.css">
  
  <link rel="stylesheet" href="/css/fontello.css">
  <link rel="stylesheet" href="/css/style.css">

  <!-- Site Analyse -->
  
	<script>
	var userID='2bbb83cc0f781dd7502e9d5e19661866';
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?"+userID;
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>


</head>

<body data-spy="scroll" data-target="#nav-catalog">
  <div id="top-push"></div>
<a href="#top-push" id="go-top">
	<span class="glyphicon glyphicon-chevron-up"></span>
</a>
  <aside id="sidebar">
    <section class="sidebar-header">Catalog</section>
     <nav id="nav-catalog">
        <ol class="sidebar-nav nav"><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#JQuery基础"><span class="sidebar-nav nav-text">JQuery基础</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#搭建环境"><span class="sidebar-nav nav-text">搭建环境</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#文档加载"><span class="sidebar-nav nav-text">文档加载</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#JQuery与DOM"><span class="sidebar-nav nav-text">JQuery与DOM</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#选择器"><span class="sidebar-nav nav-text">选择器</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#包装集操作"><span class="sidebar-nav nav-text">包装集操作</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#改变结果集"><span class="sidebar-nav nav-text">改变结果集</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#结果集检查"><span class="sidebar-nav nav-text">结果集检查</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#元素的操作：取值-赋值"><span class="sidebar-nav nav-text">元素的操作：取值/赋值</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#元素的操作：替换"><span class="sidebar-nav nav-text">元素的操作：替换</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#元素的操作：创建-删除"><span class="sidebar-nav nav-text">元素的操作：创建/删除</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#元素操作-移动"><span class="sidebar-nav nav-text">元素操作: 移动</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#工具方法"><span class="sidebar-nav nav-text">工具方法</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#数据缓存"><span class="sidebar-nav nav-text">数据缓存</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#判别"><span class="sidebar-nav nav-text">判别</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#数组和对象操作"><span class="sidebar-nav nav-text">数组和对象操作</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#格式转化"><span class="sidebar-nav nav-text">格式转化</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#特效"><span class="sidebar-nav nav-text">特效</span></a></li></ol></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#事件"><span class="sidebar-nav nav-text">事件</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#支持事件"><span class="sidebar-nav nav-text">支持事件</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#事件对象"><span class="sidebar-nav nav-text">事件对象</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#事件绑定"><span class="sidebar-nav nav-text">事件绑定</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#事件触发"><span class="sidebar-nav nav-text">事件触发</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#延迟"><span class="sidebar-nav nav-text">延迟</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#Deferred"><span class="sidebar-nav nav-text">Deferred</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#Ajax"><span class="sidebar-nav nav-text">Ajax</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#调用函数"><span class="sidebar-nav nav-text">调用函数</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#插件"><span class="sidebar-nav nav-text">插件</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#符号冲突"><span class="sidebar-nav nav-text">$符号冲突</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#fn包装集插件"><span class="sidebar-nav nav-text">$.fn包装集插件</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#自定义插件"><span class="sidebar-nav nav-text">自定义插件</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#优化"><span class="sidebar-nav nav-text">优化</span></a></li></ol>
    </nav>
  </aside>
  <span id="sidebar-ctrl" class="glyphicon glyphicon-list-alt circle"></span>
  <div id="wrapper">
    <header>
  <nav class="navbar navbar-default">
    <div class="container-fluid">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#nav-menu" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/">SixDegree</a>
      </div>
      <div class="collapse navbar-collapse" id="nav-menu">
        <ul class="nav navbar-nav navbar-right">
          
              <li  >
                <a href="/">Blogs</a>
              </li>
          
              <li  >
                <a href="/tags.html">Tags</a>
              </li>
          
              <li  >
                <a href="/about.html">About</a>
              </li>
          
          
              <li>
                <a href="/atom.xml" target="_blank">
                  <span class="icon-rss"></span>
                </a>
              </li>
          
              <li>
                <a href="http://github.com/sixdegree" target="_blank">
                  <span class="icon-github"></span>
                </a>
              </li>
          
        </ul>
      </div>
    </div>
  </nav>
</header>



    <div class="container">
      <article class="detail" role="main">
  <section class="post-header">
    <h1 class="post-title">JQuery</h1>
    <ul class="post-meta">
      <li>
        <span class="glyphicon glyphicon-calendar"></span>
        <time datetime="2014-02-28T16:00:00.000Z">2014-03-01</time>
      </li>
      
        <li>
         <span class="glyphicon glyphicon-tags"></span>
          
            <a href="/tags.html#tag-JQuery">JQuery</a>
          
        </li>
      
    </ul>
  </section>
  <section class="post-content">
    <h2 id="JQuery基础"><a href="#JQuery基础" class="headerlink" title="JQuery基础"></a>JQuery基础</h2><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><p>下载JQuery：</p>
<pre><code>&gt; bower install jquery
</code></pre><p>引入JQuery包：</p>
<pre><code class="nulljs">&lt;script type=&quot;text/javascript&quot; src=&quot;bower_components/jquery/dist/jquery.min.js&quot;/&gt;
</code></pre>
<p>使用：</p>
<p>jQuery构造函数：<code>jQuery(...)</code>,可简写为<code>$(...)</code>，每次<code>$(xxx)</code>都是创建一个新的JQuery对象</p>
<pre><code class="nulljs">&lt;script type=&quot;text/javascript&quot;&gt;
    //$(xxx)
&lt;/script&gt;
</code></pre>
<h3 id="文档加载"><a href="#文档加载" class="headerlink" title="文档加载"></a>文档加载</h3><ul>
<li>使用JS的<code>onload</code>加载文档（注意：若定义多个，执行时会使用后一个的定义）<pre><code class="nulljs">window.onload=function(){
  //...
};
</code></pre>
</li>
<li>使用JQuery的<code>$</code>加载文档（注意：是一个方法，多个时都会被执行）<pre><code class="nulljs">$(document).ready(function(){
  //...
});
</code></pre>
</li>
<li>注意：都是在页面DOM加载完成后执行</li>
</ul>
<h3 id="JQuery与DOM"><a href="#JQuery与DOM" class="headerlink" title="JQuery与DOM"></a>JQuery与DOM</h3><ul>
<li><p>Javascript操作DOM元素：</p>
<ul>
<li>获取（一个或一组）<pre><code class="nulljs">document.getElementById(&quot;xxx&quot;);
document.getElementByName(&quot;xxx&quot;);
document.getElementByTagName(&quot;xxx&quot;);
</code></pre>
</li>
<li>创建DOM元素<pre><code class="nulljs">document.createElement(&quot;xxx&quot;);
</code></pre>
</li>
</ul>
</li>
<li><p>JQuery操作DOM元素：</p>
<ul>
<li>获取： <code>$(&quot;xxx&quot;)</code>，<code>$(dom)</code>（会筛选出页面中一组满足xxx的元素，用JQuery封装）</li>
<li>创建：<code>$(&quot;&lt;xxx/&gt;&quot;)</code></li>
<li><strong>注意</strong>：使用<code>$(xxx)</code>，返回的一定是一个集合，所以称为<code>JQuery包装集</code></li>
</ul>
</li>
<li><p>JQuery与DOM转换</p>
<ul>
<li><code>$(...)</code>：DOM=&gt;JQuery</li>
<li><code>$(...)[index]</code>,<code>$(...).get(index)</code>: JQuery=&gt;DOM</li>
</ul>
</li>
</ul>
<p>举例：</p>
<pre><code class="nulljs">//dom
var div=document.getElementById(&quot;testDiv&quot;);
div.innerHtml=&quot;Hello&quot;;

//dom=&gt;jquery
var divJquery1=$(div);
divJquery1.html();            // Hello
divJquery1.html(&quot;Hello World&quot;);

//dom=&gt;jquery
divJquery=$(&quot;#testDiv&quot;);
divJquery.html();            // Hello World

//jquery=&gt;dom
var div=divJquery[0];
console.log(div.innerHtml);        // Hello World

//create element by javascript
var input=document.createElement(&quot;input&quot;);
input.type=&quot;text&quot;;
document.body.appendChild(input);

//create element by jquery
var inputJquery=$(&quot;&lt;input/&gt;&quot;);
inputJquery.appendTo($(&quot;body&quot;));
</code></pre>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>将一个选择表达式xxx，放进构造函数<code>$(&quot;xxx&quot;)</code>，得到匹配的元素集合（即为一个包装集）</p>
<p>其中xxx可为（类似CSS选择器的格式）：</p>
<ul>
<li><p>基础选择：</p>
<ul>
<li><code>#id</code></li>
<li><code>tagName</code></li>
<li><code>.styleClass</code></li>
<li><code>*</code></li>
</ul>
</li>
<li><p>层级选择</p>
<ul>
<li><code>ancestor descendent</code></li>
<li><code>parent &gt; child</code></li>
<li><code>prev + next</code> (相当于<code>$(&quot;prev&quot;).next(&quot;next&quot;)</code>)</li>
<li><code>prev ~ siblings</code> (相当于<code>$(&quot;prev&quot;).nextAll(&quot;next&quot;)</code>)</li>
</ul>
</li>
<li><p>基本过滤</p>
<ul>
<li><code>:first</code></li>
<li><code>:last</code></li>
<li><code>:not(selector)</code></li>
<li><code>:even</code></li>
<li><code>:odd</code></li>
<li><code>:eq(index)</code>（index&gt;=0）</li>
<li><code>:gt(index)</code></li>
<li><code>:lt(index)</code></li>
</ul>
</li>
<li><p>子元素过滤</p>
<ul>
<li><code>:nth-child(index/even/odd/equation)</code></li>
<li><code>:first-child</code></li>
<li><code>:last-child</code></li>
<li><code>:only-child</code></li>
</ul>
</li>
<li><p>内容过滤</p>
<ul>
<li><code>:contains(text)</code></li>
<li><code>:empty</code></li>
<li><code>:has(selector)</code></li>
<li><code>:parent</code> (匹配含有子元素或者文本的元素)</li>
</ul>
</li>
<li><p>可见性过滤</p>
<ul>
<li><code>:hidden</code></li>
<li><code>:visible</code></li>
</ul>
</li>
<li><p>属性过滤</p>
<ul>
<li><code>[attribute]</code></li>
<li><code>[attribute=value]</code></li>
<li><code>[attribute!=value]</code></li>
<li><code>[attribute^=value]</code></li>
<li><code>[attribute$=value]</code></li>
<li><code>[attribute*=value]</code></li>
</ul>
</li>
<li><p>表单对象</p>
<ul>
<li><code>:hidden</code></li>
<li><code>:input</code>,<code>:text</code>,<code>:password</code>,<code>:radio</code>,<code>:checkbox</code></li>
<li><code>:submit</code>,<code>:reset</code></li>
</ul>
</li>
<li><p>表单属性过滤</p>
<ul>
<li><code>:enabled</code></li>
<li><code>:checked</code></li>
<li><code>:selected</code></li>
<li><code>:disabled</code></li>
</ul>
</li>
<li><p>混合</p>
<ul>
<li><code>selector1, selector2, selectorN</code>：获取多个选择符的合集</li>
<li><code>[selector1][selector2][selectorN]</code>：匹配同时符合多个属性选择符的对象</li>
</ul>
</li>
</ul>
<h3 id="包装集操作"><a href="#包装集操作" class="headerlink" title="包装集操作"></a>包装集操作</h3><h4 id="改变结果集"><a href="#改变结果集" class="headerlink" title="改变结果集"></a>改变结果集</h4><ul>
<li><p>过滤：对结果集进行筛选，缩小选择结果（返回原对象）</p>
<ul>
<li><code>not</code></li>
<li><code>filter</code></li>
<li><code>has</code></li>
<li><code>eq(index)</code>,<code>first</code>,<code>last</code></li>
</ul>
</li>
<li><p>查找：从结果集出发，选择附近的元素（返回新对象）</p>
<ul>
<li><code>next</code>,<code>nextAll</code>,<code>prev</code>,<code>prevAll</code>,<code>siblings</code></li>
<li><code>children</code>,<code>find</code></li>
<li><code>parent</code>,<code>parents</code>,<code>closest</code><ul>
<li><code>closest</code>：从元素本身逐级向上匹配，返回可包含0或1个元素</li>
<li><code>parents</code>：从根元素开始逐级向下匹配，返回可包含0或1或多个元素</li>
</ul>
</li>
<li><code>slice(start,[end])</code></li>
<li><code>contents()</code>：返回匹配元素内部所有子节点，包括文本节点（若是iframe，则查找文档内容）</li>
</ul>
</li>
<li><p>串联</p>
<ul>
<li><code>add</code>：添加匹配元素到包装集</li>
<li><code>end()</code>：返回前一个包装集</li>
<li><code>addSelf()</code>：筛选结果集添加到最初包装集</li>
</ul>
</li>
</ul>
<h4 id="结果集检查"><a href="#结果集检查" class="headerlink" title="结果集检查"></a>结果集检查</h4><ul>
<li><code>size()</code></li>
<li><code>index(obj)</code></li>
<li><code>is(expr)</code>：判断，包装集中有一个匹配则返回true</li>
<li><code>hasClass</code>：判断，包装集中有一个含有某特定类则返回true（= <code>is(&quot;.&quot; + class)</code>）</li>
</ul>
<h4 id="元素的操作：取值-赋值"><a href="#元素的操作：取值-赋值" class="headerlink" title="元素的操作：取值/赋值"></a>元素的操作：取值/赋值</h4><ul>
<li><p>使用同一个函数，来完成取值和赋值（由函数的参数决定是取值还是赋值）</p>
<ul>
<li><code>attr({...})</code>,<code>attr(&quot;...&quot;,&quot;...&quot;)</code>,<code>attr(&quot;...&quot;)</code></li>
<li><code>prop({...})</code>,<code>prop(&quot;...&quot;,&quot;...&quot;)</code>,<code>prop(&quot;...&quot;)</code></li>
<li><code>css({...})</code>,<code>css(&quot;...&quot;,&quot;...&quot;)</code>,<code>css(&quot;...&quot;)</code></li>
<li><code>width</code>,<code>height</code></li>
<li><code>html(&quot;xxx&quot;)</code>,<code>html()</code></li>
<li><code>text(&quot;xxx&quot;)</code>,<code>text()</code></li>
<li><code>val(xxx)</code>,<code>val()</code></li>
</ul>
</li>
<li><p>赋值，返回原包装集</p>
<ul>
<li><code>removeAttr</code></li>
<li><code>removeProp</code></li>
<li><code>addClass</code>,<code>removeClass</code>,<code>toggleClass</code></li>
<li><code>empty()</code> ：清空元素内容（但是不删除该元素）</li>
</ul>
</li>
</ul>
<h4 id="元素的操作：替换"><a href="#元素的操作：替换" class="headerlink" title="元素的操作：替换"></a>元素的操作：替换</h4><ul>
<li>替换节点(是移动到目标位置来替换，而不是复制一份来替换)<ul>
<li><code>replaceWith</code>：某集合被某集合替换掉</li>
<li><code>replaceAll</code>：使用某集合替换掉某集合</li>
<li>eg：<pre><code class="nullhtml">&lt;b class=&quot;first&quot;&gt;Hello1&lt;/b&gt;
&lt;b class=&quot;second&quot;&gt;Hello2&lt;/b&gt;
&lt;b class=&quot;third&quot;&gt;Hello3&lt;/b&gt;
=&gt;
&lt;b class=&quot;second&quot;&gt;Hello2&lt;/b&gt;
&lt;b class=&quot;first&quot;&gt;Hello1&lt;/b&gt;
</code></pre>
<pre><code class="nulljs">$(&quot;b.third&quot;).replaceWith($(&quot;b.first&quot;));
</code></pre>
<pre><code class="nulljs">$(&quot;b.first&quot;).replaceAll($(&quot;b.third&quot;));
</code></pre>
<pre><code class="nulljs">$(&quot;b&quot;).replaceWith(&quot;&lt;p&gt;World&lt;/p&gt;&quot;);
=&gt;
&lt;p&gt;World&lt;/p&gt;
&lt;p&gt;World&lt;/p&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="元素的操作：创建-删除"><a href="#元素的操作：创建-删除" class="headerlink" title="元素的操作：创建/删除"></a>元素的操作：创建/删除</h4><ul>
<li><p>创建：</p>
<ul>
<li><code>&lt;Xxx/&gt;</code> 新元素标签直接传入jQuery的构造函数即可</li>
<li><code>clone</code>：复制，返回新包装集</li>
</ul>
</li>
<li><p>删除</p>
<ul>
<li><code>remove</code>：不保留被删除元素的事件（返回被移除的集合）</li>
<li><code>detach</code>：保留被删除元素的事件，有利于重新插入文档时使用</li>
</ul>
</li>
</ul>
<h4 id="元素操作-移动"><a href="#元素操作-移动" class="headerlink" title="元素操作: 移动"></a>元素操作: 移动</h4><p>操作元素在网页中的位置：移动直接移动该元素或移动其他元素<br>（以下操作都返回原对象）</p>
<ul>
<li><p>内部插入</p>
<ul>
<li><code>append</code>,<code>prepend</code>：在节点内部的后面/前面添加某元素</li>
<li><code>appendTo</code>,<code>prependTo</code>：将节点添加到某元素内部的后面/前面</li>
<li><p>eg：</p>
<pre><code class="nullhtml">&lt;p&gt;Say&lt;/p&gt;
&lt;b&gt;Hello&lt;/b&gt;
&lt;i&gt;Tom&lt;i&gt;
=&gt;
&lt;p&gt;&lt;i&gt;Tom&lt;/i&gt;Say&lt;b&gt;Hello&lt;/b&gt;&lt;/p&gt;
</code></pre>
<pre><code class="nulljs">$(&quot;p&quot;).append(b).prepend(i);
</code></pre>
<pre><code class="nulljs">$(&quot;b&quot;).appendTo(&quot;p&quot;);
$(&quot;i&quot;).prependTo(&quot;p&quot;);
</code></pre>
</li>
</ul>
</li>
<li>外部插入<ul>
<li><code>after</code>,<code>before</code>：在节点前面/后面添加元素</li>
<li><code>insertAfter</code>，<code>insertBefore</code>：将节点添加到某元素后面/前面</li>
<li>eg：<pre><code class="nullhtml">&lt;a&gt;Say&lt;/a&gt;
&lt;b&gt;Hello&lt;/b&gt;
&lt;i&gt;Tom&lt;i&gt;
=&gt;
&lt;i&gt;Tom&lt;/i&gt;&lt;a&gt;Say&lt;/a&gt;&lt;b&gt;Hello&lt;/b&gt;
</code></pre>
<pre><code class="nulljs">$(&quot;a&quot;).after(&quot;b&quot;).before(&quot;i&quot;)
</code></pre>
<pre><code class="nulljs">$(&quot;b&quot;).insertAfter(&quot;a&quot;);
$(&quot;i&quot;).insertBefore(&quot;a&quot;);
</code></pre>
</li>
</ul>
</li>
<li><p>包裹</p>
<ul>
<li><code>wrap</code>：匹配的每个节点分别用某个元素包裹</li>
<li><code>wrapAll</code>：整个包装集用某个元素包裹</li>
<li><code>wrapInner</code>：匹配的每个节点的内容用某个元素包裹</li>
<li><p>eg：</p>
<pre><code class="nullhtml">&lt;b&gt;Hello1&lt;/b&gt;
&lt;b&gt;Hello2&lt;/b&gt;
</code></pre>
<pre><code class="nulljs">$(&quot;b&quot;).wrap(&quot;&lt;div/&gt;&quot;);

&lt;div&gt;&lt;b&gt;Hello1&lt;/b&gt;&lt;/div&gt;
&lt;div&gt;&lt;b&gt;Hello2&lt;/b&gt;&lt;/div&gt;
</code></pre>
<pre><code class="nulljs">$(&quot;b&quot;).wrapAll(&quot;&lt;div/&gt;&quot;);

&lt;div&gt;
  &lt;b&gt;Hello1&lt;/b&gt;
  &lt;b&gt;Hello2&lt;/b&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="nulljs">$(&quot;b&quot;).wrapInner(&quot;&lt;div/&gt;&quot;);

&lt;b&gt;&lt;div&gt;Hello1&lt;/div&gt;&lt;/b&gt;
&lt;b&gt;&lt;div&gt;Hello2&lt;/div&gt;&lt;/b&gt;
</code></pre>
</li>
<li><p><code>unwrap</code>：移除节点的父元素</p>
<pre><code class="nulljs">&lt;div&gt;
  &lt;b&gt;Hello1&lt;/b&gt;
  &lt;b&gt;Hello2&lt;/b&gt;
&lt;/div&gt;
=&gt;
&lt;b&gt;Hello1&lt;/b&gt;
&lt;b&gt;Hello2&lt;/b&gt;

$(&quot;b&quot;).unwrap();
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="工具方法"><a href="#工具方法" class="headerlink" title="工具方法"></a>工具方法</h3><h4 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h4><ul>
<li><code>$(xxx).data(key,value)</code>,<code>$(xxx).data(key)</code></li>
<li><code>$(xxx).removeData(key)</code></li>
</ul>
<h4 id="判别"><a href="#判别" class="headerlink" title="判别"></a>判别</h4><ul>
<li><code>$.contains(container,contained)</code> 一个DOM节点是否包含另一个DOM节点</li>
<li><code>$.type</code> 判断对象的类别（函数对象、日期对象、数组对象、正则对象等等）</li>
<li><code>$.isNumeric</code> 判断是否是一个数字</li>
<li><code>$.isArray</code> 判断某个参数是否为数组</li>
<li><code>$.isEmptyObject</code> 判断某个对象是否为空（不含有任何属性）</li>
<li><code>$.isFunction</code> 判断某个参数是否为函数</li>
<li><code>$.isPlainObject</code> 判断某个参数是否为用”{}”或”new Object”建立的对象</li>
<li><p><code>$.support</code> 判断浏览器是否支持某个特性</p>
<pre><code class="nulljs">  $.type(true) === &quot;boolean&quot;
  $.type(3) === &quot;number&quot;
  $.type(&quot;test&quot;) === &quot;string&quot;
  $.type(function(){}) === &quot;function&quot;
  $.type([]) === &quot;array&quot;
  $.type(new Date()) === &quot;date&quot;
  $.type(/test/) === &quot;regexp&quot;

  $.isNumeric(&quot;&quot;);     // false
  $.isNumeric({});     // false (empty object)
  $.isNumeric(NaN);    // false
  $.isNumeric(null);   // false
  $.isNumeric(true);   // false

  $.isNumeric(&quot;-10&quot;);  // true
  $.isNumeric(16);     // true
  $.isNumeric(0xFF);   // true
  $.isNumeric(3.1415); // true
  $.isNumeric(+10);    // true

  $.isFunction($.noop)    //true
  $.isFunction(&quot;Hello&quot;)    //false

  $.isEmptyObject(undefined)        //true
  $.isEmptyObject(null)        //true
  $.isEmptyObject({})        //true
  $.isEmptyObject( new Object() )  // true
  $.isEmptyObject([] )  // true
  $.isEmptyObject({ foo: &quot;bar&quot; }) // false
  $.isEmptyObject([1,2]) // false
  $.isEmptyObject(&quot;sdfe&quot;) // false
  $.isEmptyObject(function(){...}) // false

  $.isPlainObject({}) // true
  $.isPlainObject(new Object()) // true
  $s.isPlainObject(&quot;test&quot;) // false
</code></pre>
</li>
</ul>
<h4 id="数组和对象操作"><a href="#数组和对象操作" class="headerlink" title="数组和对象操作"></a>数组和对象操作</h4><ul>
<li><p><code>$.merge(first,second)</code>  合并数组</p>
<ul>
<li>合并第二个数组到第一个数组上</li>
<li>eg: <pre><code class="nulljs">$.merge( [0,1,2], [2,3,4] )   //[0,1,2,2,3,4]
</code></pre>
</li>
</ul>
</li>
<li><p><code>$.extend([d],tgt,obj1,[objN])</code></p>
<ul>
<li><code>$.extend(p1,p2)</code>：p2覆盖p1，返回p1</li>
<li><code>$.extend(p0,p1,p2)</code>：p2与p1合并存储到p0，返回p0</li>
</ul>
</li>
<li><p><code>$.makeArray(obj)</code></p>
<ul>
<li>将类对象转换为数组对象</li>
</ul>
</li>
<li><p><code>$.toArray()</code></p>
<ul>
<li>把jQuery集合中所有DOM元素恢复成一个数组</li>
<li>eg:<pre><code class="nulljs">$(&#39;li&#39;).toArray();  // [&lt;li id=&quot;foo&quot;&gt;, &lt;li id=&quot;bar&quot;&gt;]
</code></pre>
</li>
</ul>
</li>
<li><p><code>$.inArray(val,arr,[from])</code></p>
<ul>
<li>返回value在arrayObj中下标的位置(从0开始计数)</li>
<li>如果value不在array中则返回-1 </li>
<li>eg: <pre><code class="nulljs">$.inArray(&quot;Pete&quot;,[4, &quot;Pete&quot;, 8, &quot;John&quot;],2) // -1
</code></pre>
</li>
</ul>
</li>
<li><p><code>$.unique(array)</code></p>
<ul>
<li>删除数组中重复元素</li>
<li>只处理删除DOM元素数组，不能处理字符串或者数字数组</li>
</ul>
</li>
<li><p><code>$.each( collection, callback )</code> 遍历集合,返回原对象</p>
<ul>
<li><code>$.each(jsonObj,function(key,value){...});</code></li>
<li><code>$.each(arrayObj,function(indexInArray,valueOfElement){...});</code></li>
<li>callback中<ul>
<li>return false ：将停止循环 (同 break)</li>
<li>return true ： 跳至下一个循环(同 continue)</li>
</ul>
</li>
<li>注意：和<code>$(selector).each(function(index,domEle){...});</code>不一样<ul>
<li>function中使用this时， this 指代的是 DOM 对象而非 jQuery 对象</li>
</ul>
</li>
<li>eg:<pre><code class="nulljs">var arrayObj= [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;];
var returnValue = $.each(arrayObj, function(index,value) {
  alert(index + &quot; &quot; + value);
});
</code></pre>
<pre><code class="nulljs">var jsonObj= {one:1, two:2, three:3};
var returnValue=$.each(jsonObj,function(key,value) {
  alert(key+&quot;:&quot;+value);
});
</code></pre>
<pre><code class="nulljs">$(&quot;div&quot;).each(function(index, domEle) { 
    // domEle == this
    $(domEle).css(&quot;backgroundColor&quot;, &quot;yellow&quot;);
    if ($(this).is(&quot;#stop&quot;)) {
         $(&quot;span&quot;).text(&quot;Stopped at div index #&quot; + index);
         return false;
    }
});
</code></pre>
</li>
</ul>
</li>
<li><p><code>$.map(array,callback)</code> 转换数组，返回一个新的数组</p>
<ul>
<li><code>$.map( array, callback(elementOfArray, indexInArray){...} )</code></li>
<li>callback中<ul>
<li>通过return返回新的值，不return就没有值了</li>
<li>返回null在这里相当于不返回</li>
</ul>
</li>
<li>注意：和 <code>$(dom).map(callback(){...})</code>不一样</li>
<li>eg：<pre><code class="nulljs">var arr = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ];
var arr2 = jQuery.map(arr, function(n, i){
  return (n.toUpperCase() + i);
});
alert(arr);        //a,b,c,d,e
alert(arr2);    //A0,B1,C2,D3,E4
</code></pre>
</li>
</ul>
</li>
<li><p><code>$.grep(array,callback)</code> 过滤数组</p>
<ul>
<li><code>$.grep( array, function(elementOfArray, indexInArray) [, invert] )</code></li>
<li>参数二：<ul>
<li>一个测试函数（注意：这里此函数参数和each,map的回调函数的参数顺序相反）</li>
<li>字符串：正则表达式，相当于执行<code>return elementOfArray.match(正则表达式)</code> (a 代表数组元素，i 代表元素索引值)</li>
</ul>
</li>
<li>参数三：<ul>
<li>false：默认</li>
<li>true：回调函数的返回值的效果刚好相反，返回true的会被去掉</li>
</ul>
</li>
<li>eg：<pre><code class="nulljs">var arrayObj = [ 1, 9, 3, 8, 6, 1, 5, 9, 4, 7, 3, 8, 6, 9, 1 ];
arr = jQuery.grep(arrayObj , function(n, i){
return (n != 5 &amp;&amp; i &gt; 4);
});
</code></pre>
<pre><code class="nulljs">var bigNumbers = $.grep(arrayObj ,&#39;a&gt;5&#39;);
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="格式转化"><a href="#格式转化" class="headerlink" title="格式转化"></a>格式转化</h4><ul>
<li><code>$(&quot;form&quot;).serialize()</code> 序列表格内容为字符串</li>
<li><code>$(&quot;form&quot;).serializearray()</code>  序列表格内容为JSON数组</li>
<li><code>$.param(obj,[traditional])</code>  对象序列化为字符串（是.serialize()的核心方法）</li>
<li><code>$.parseXML(data)</code> 解析一个字符串，返回XML文档</li>
<li><code>$.parseJSON(jsonString)</code>  解析一个字符串，返回jsonObj</li>
<li><code>JSON.stringify(jsonObje)</code> 将jsonObj转换为一个字符串</li>
</ul>
<h4 id="特效"><a href="#特效" class="headerlink" title="特效"></a>特效</h4><ul>
<li><p><code>animate(css,time,callbackFunc)</code></p>
<pre><code class="nulljs">  $(&quot;#go&quot;).click(function(){
      $(&quot;#block&quot;).animate({
          width: &quot;90%&quot;,
          height: &quot;100%&quot;,
          fontSize: &quot;10em&quot;,
          borderWidth: 10
      }, 1000 );
  })
  $(&quot;#right&quot;).click(function(){
      $(&quot;.block&quot;).animate({left: &#39;+50px&#39;}, &quot;slow&quot;);
  });

  $(&quot;p&quot;).animate({
      left: 50, opacity: &#39;show&#39;
  }, 500);

  $(&quot;p&quot;).animate({
      opacity: &#39;show&#39;
  }, &quot;slow&quot;, &quot;easein&quot;);

  $(&#39;div&#39;).animate(
      {
        left : &quot;+=50&quot;, //不断右移
        opacity : 0.25 //指定透明度
      },
      300, // 持续时间
      function() { alert(&#39;done!&#39;); } //回调函数
  );
</code></pre>
</li>
<li><p>淡入淡出：<code>fadeIn/fadeOut([speed],[easing],[fn])</code>,<code>fadeToggle</code></p>
<pre><code class="nulljs">  $(&#39;h1&#39;).fadeIn(300); // 300毫秒内淡入
  $(&#39;h1&#39;).fadeOut(&#39;slow&#39;); // 缓慢地淡出
  $(&#39;p&#39;).fadeOut(300, function() { $(this).remove(); });
</code></pre>
</li>
<li>滑入滑出：<code>slideDown/slideUp([speed],[easing],[fn])</code>,<code>slideToggle</code></li>
<li><code>stop()</code>和<code>delay()</code>停止或延缓特效的执行</li>
<li><code>$.fx.off</code>,设置为true，则关闭所有网页特效</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="支持事件"><a href="#支持事件" class="headerlink" title="支持事件"></a>支持事件</h3><ul>
<li><code>blur</code> 表单元素失去焦点。</li>
<li><code>change</code> 表单元素的值发生变化</li>
<li><code>click</code> 鼠标单击</li>
<li><code>dblclick</code> 鼠标双击</li>
<li><code>focus</code> 表单元素获得焦点</li>
<li><code>focusin</code> 子元素获得焦点</li>
<li><code>focusout</code> 子元素失去焦点</li>
<li><code>hover</code> 同时为<code>mouseenter</code>和<code>mouseleave</code>事件指定处理函数</li>
<li><code>keydown</code> 按下键盘（长时间按键，只返回一个事件）</li>
<li><code>keypress</code> 按下键盘（长时间按键，将返回多个事件）</li>
<li><code>keyup</code> 松开键盘</li>
<li><code>load</code> 元素加载完毕</li>
<li><code>mousedown</code> 按下鼠标</li>
<li><code>mouseenter</code> 鼠标进入（进入子元素不触发）</li>
<li><code>mouseleave</code> 鼠标离开（离开子元素不触发）</li>
<li><code>mousemove</code> 鼠标在元素内部移动</li>
<li><code>mouseout</code> 鼠标离开（离开子元素也触发）</li>
<li><code>mouseover</code> 鼠标进入（进入子元素也触发）</li>
<li><code>mouseup</code> 松开鼠标</li>
<li><code>ready</code>DOM加载完成</li>
<li><code>resize</code> 浏览器窗口的大小发生改变</li>
<li><code>scroll</code> 滚动条的位置发生变化</li>
<li><code>select</code> 用户选中文本框中的内容</li>
<li><code>submit</code> 用户递交表单</li>
<li><code>toggle</code> 根据鼠标点击的次数，依次运行多个函数</li>
<li><code>unload</code> 用户离开页面</li>
</ul>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><ul>
<li><code>event.target</code></li>
<li><code>event.currentTarget</code></li>
<li><code>event.data</code></li>
<li><code>event.preventDefault()</code> 阻止事件的默认行为（比如点击链接，会自动打开新页面）</li>
<li><code>event.stopPropagation()</code> 停止事件向上层元素冒泡</li>
<li><code>event.pageX</code> 事件发生时，鼠标距离网页左上角的水平距离</li>
<li><code>event.pageY</code> 事件发生时，鼠标距离网页左上角的垂直距离</li>
<li><code>event.type</code> 事件的类型（比如click）</li>
<li><code>event.which</code> 按下了哪一个键</li>
</ul>
<h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><ul>
<li><p>把事件直接绑定在网页元素</p>
<ul>
<li>Xxx([[data],fn])</li>
</ul>
</li>
<li><p>绑定事件/解除事件绑定</p>
<ul>
<li>bind/unbind</li>
<li>one: 一次性</li>
<li>on/off ：代替bine,unbind</li>
<li>hover(overFunc,outFunc)：绑定鼠标悬停事件（鼠标移动到一个对象上面及移出这个对象）</li>
<li>toggle([speed],[easing],[fn]) ：绑定多个事件处理器函数，以响应被选元素的轮流的 click 事件</li>
</ul>
</li>
<li><p>事件的委托处理</p>
<ul>
<li>on/off：代替live,delegate</li>
<li>子元素”委托”父元素处理事件：<ul>
<li>子元素的事件会逐级向上”冒泡”，成为父元素的事件</li>
<li>利用这一点，可以大大简化事件的绑定</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>使用举例：</p>
<ol>
<li><p>事件直接绑定</p>
<pre><code class="nulljs"> $(&#39;p&#39;).click(function(){
     alert(&#39;Hello&#39;);
 });
</code></pre>
</li>
<li><p>使用bind绑定（on方法使用类似）</p>
<pre><code class="nulljs"> //可同时绑定click和change事件
 $(&#39;input&#39;).bind(&#39;click change&#39;,function() {
   alert(&#39;Hello&#39;);
 });
 //可在事件名后面加命名空间
 $(&quot;#test&quot;).bind(&quot;mouseover.test mouseout.test&quot;,function(event){
     $(this).toggleClass(&quot;bgClass&quot;);
 })
</code></pre>
</li>
<li><p>使用unbind解绑（off方法使用类似）</p>
<pre><code class="nulljs"> $(&quot;input&quot;).unbind();        //解绑所有事件
 $(&quot;#test&quot;).unbind(&quot;.test&quot;);    //解绑使用“test”命名空间的事件

 var foo=function(){...};
 $(&quot;input&quot;).bind(&quot;click&quot;,foo);
 $(&quot;input&quot;).unbind(&quot;click&quot;,foo);        //解绑特定函数的绑定
</code></pre>
</li>
<li><p>使用on/off进行事件的委托处理<br>说明：<br>相较与上面使用<code>$(&quot;td&quot;).on(&quot;click&quot;,function(){...})</code><br>这个事件只需要在父元素绑定1次即可<br>而不需要在子元素上绑定n次<br>大大提高了性能</p>
<pre><code class="nulljs"> //方式一：
 $(&quot;table&quot;).on(&quot;click&quot;, &quot;td&quot;, function(){
     $(this).toggleClass(&quot;click&quot;);
 });
 $(&quot;table&quot;).off(&quot;click&quot;, &quot;td&quot;);

 //方式二（更好）：
 $(document).on(&quot;click&quot;, &quot;td&quot;, function(){
     $(this).toggleClass(&quot;click&quot;);
 });
 $(document).off(&quot;click&quot;, &quot;td&quot;);
</code></pre>
</li>
<li><p>使用hover绑定切换事件（鼠标移入移除时触发）</p>
<pre><code class="nulljs"> $(&quot;td&quot;).hover(
   function () {
     $(this).addClass(&quot;hover&quot;);
   },
   function () {
     $(this).removeClass(&quot;hover&quot;);
   }
 );
</code></pre>
</li>
<li><p>使用toggle绑定切换事件（点击时触发）</p>
<pre><code class="nulljs"> $(&#39;td&#39;).toggle();            //隐藏/显示
 $(&quot;p&quot;).toggle(&quot;slow&quot;);    //缓慢显示
 $(&quot;p&quot;).toggle(&quot;fast&quot;,function(){
    alert(&quot;Animation Done.&quot;);
  });
 $(&quot;td&quot;).toggle(
     function () { $(this).addClass(&quot;selected&quot;); },
     function () { $(this).removeClass(&quot;selected&quot;); }
 );
</code></pre>
</li>
</ol>
<h3 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h3><ul>
<li><code>xxx()</code> : 直接调用事件</li>
<li><code>trigger(type,[data])</code>：存在冒泡</li>
<li><code>triggerHandler(type,[data])</code>：不冒泡</li>
</ul>
<pre><code class="nulljs">$(&quot;p&quot;).click();    
$(&quot;input&quot;).change();
</code></pre>
<pre><code class="nulljs">$(&quot;#test&quot;).on(&quot;click&quot;,{name:&quot;Tom&quot;},function(event,a,b){
    console.log(event.target);
    console.log(event.currentTarget);
    console.log(a+&quot;,&quot;+b);            //1,2
    console.log(event.data)        //{name:&quot;Tom&quot;}
});
$(&quot;#test&quot;).trigger(&quot;click&quot;,[1,2]);
</code></pre>
<h2 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h2><p>（参考 <a href="http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html">jQuery的deferred对象详解</a>）</p>
<h3 id="Deferred"><a href="#Deferred" class="headerlink" title="Deferred"></a>Deferred</h3><p>【回调函数：异步/同步操作，一般不能立即返回结果，为它们指定回调函数（callback），一旦那些操作运行结束，就触发调用】</p>
<p>Deferred：”延迟”到未来某个点再执行，作为回调函数解决方案，提供了更好的控制：</p>
<ul>
<li>可以进行链式操作</li>
<li>允许自由添加多个回调函数</li>
<li>所有操作都可用（本地操作，ajax操作，同步，异步均可）</li>
</ul>
<p>deferred对象</p>
<ul>
<li>创建<ul>
<li><code>$.Deferred()</code></li>
</ul>
</li>
<li>三种执行状态：<ul>
<li>未完成：继续等待，或调用<code>progress</code>方法指定的回调函数</li>
<li>已完成：立刻调用<code>done</code>方法指定的回调函数</li>
<li>已失败：立刻调用<code>fail</code>方法指定的回调函数</li>
</ul>
</li>
<li>改变执行状态：<ul>
<li>自动修改<ul>
<li>ajax操作时，deferred对象根据返回结果，自动改变自身的执行状态</li>
</ul>
</li>
<li>手动修改：<ul>
<li><code>resolve()</code> ：”未完成”=&gt;”已完成”，触发<code>done</code>方法指定的function</li>
<li><code>reject()</code> ：”未完成”=&gt;”已失败”，触发<code>fail</code>方法指定的function</li>
</ul>
</li>
</ul>
</li>
<li>绑定回调函数：<ul>
<li><code>progress(callback)</code></li>
<li><code>done(callback)</code></li>
<li><code>fail(callback)</code></li>
<li><code>then(doneCallback,failCallback)</code></li>
<li><code>always(callback)</code></li>
</ul>
</li>
<li>注意：deferred对象是一个全局对象，执行状态可以从外部改变，防止执行状态被外部改变：<ul>
<li>方式一：<code>deferred.promise()</code>：<ul>
<li>在原来的deferred对象上返回另一个deferred对象，屏蔽了与改变执行状态有关的方法（resolve,reject）</li>
</ul>
</li>
<li>方式二：<code>deffered.promise(func)</code>：<ul>
<li>在func上部署Deferred接口</li>
</ul>
</li>
<li>方式三：<code>$.Deferred(func)</code>：<ul>
<li>生成的deferred对象将作为这个函数的默认参数</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>使用示例1：<code>$.Deferred</code></p>
<p>一个耗时的操作</p>
<pre><code class="nulljs">var wait = function(){
    var tasks = function(){
      alert(&quot;执行完毕！&quot;);
    };
    setTimeout(tasks,5000);
};
</code></pre>
<p>为它指定回调函数</p>
<pre><code class="nulljs">var wait=function(){
    var dtd = $.Deferred();     // 新建一个Deferred对象
    var tasks = function(){
        alert(&quot;执行完毕！&quot;);
        //dtd.reject();
        dtd.resolve();         // 改变Deferred对象的执行状态
    };
    setTimeout(tasks,5000);
    return dtd.promise();     // 返回promise对象
}

wait()
.done(function(){ alert(&quot;Success！&quot;); })
.fail(function(){ alert(&quot;Fail！&quot;); });
</code></pre>
<p>使用示例2：<code>$.ajax</code></p>
<pre><code class="nulljs">$.ajax(&quot;test.html&quot;)
    .done(function(){ alert(&quot;Success&quot;); })
    .fail(function(){ alert(&quot;Fail&quot;); });
    .done(function(){ alert(&quot;Success 2&quot;);} );
</code></pre>
<p>使用示例3：<code>$.when</code></p>
<pre><code class="nulljs">$.when($.ajax(&quot;test1.html&quot;), $.ajax(&quot;test2.html&quot;))
　　.done(function(){ alert(&quot;Success&quot;); })    //都成功时执行
　　.fail(function(){ alert(&quot;Fail！&quot;); });    //其中一个失败就执行
</code></pre>
<h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>以下操作返回一个Promise对象（屏蔽了修改执行状态方法的Deferred对象）</p>
<ul>
<li><code>$.get(url,{...},successCallback,type);</code>,<code>$.post(url,{...},successCallback,type);</code><ul>
<li>简单HTTP GET/POST请求</li>
<li>successCallback：请求成功调用回调函数</li>
<li>type：返回内容格式，例如 xml, html, script, json, text<pre><code class="nulljs">$.get(url,{name:&quot;tom&quot;},function(data,status){
  console.log(data);
},&quot;json&quot;);
$.post(url,{name:&quot;tom&quot;},function(data,status){
  console.log(data);
},&quot;json&quot;);
</code></pre>
</li>
</ul>
</li>
<li><code>$.getJSON(url, {...}, successCallback)</code><pre><code class="nulljs">$.getJSON(&quot;test.json&quot;, { name: &quot;John&quot;, time: &quot;2pm&quot; }, function(data){
    alert(&quot;JSON Data: &quot; + data.users[3].name);
});
</code></pre>
</li>
<li><code>$.getScript(url,successCallback)</code> 加载并执行脚本<pre><code class="nulljs">$.getScript(&quot;test.js&quot;, function(){
    alert(&quot;Script loaded and executed.&quot;);
});
</code></pre>
</li>
<li><p><code>$(...).load(url,{...},successCallback)</code></p>
<ul>
<li>返回内容成功加载到包装集后调用successCallback函数</li>
<li>successCallback: <code>function(data){...}</code>,data为DOM对象</li>
</ul>
</li>
<li><p><code>$.ajax({...});</code> ,<code>$.ajax(url,{...});</code> 返回一个<code>promise</code>对象</p>
<ul>
<li><code>type</code>: 默认为GET，表请求方式（GET,POST,DELETE,PUT,…）</li>
<li><code>async</code>:默认为true，表异步</li>
<li><code>contentType</code>:默认为<code>application/x-www-form-urlencoded; charset=UTF-8</code>,发送服务器时内容编码类型</li>
<li><code>data</code>: 发送到服务器的数据，object或string类型</li>
<li><code>processData</code>：默认为true,会自动转换要发送的<code>data</code>为对象以配合<code>contentType</code></li>
<li><code>dataType</code>: 预期服务器返回的数据类型（html,xml,json,script,jsonp），默认自动根据 HTTP 包 MIME 信息返回</li>
<li><code>global</code>：默认为true，允许触发 AJAX 全局事件</li>
<li><code>ifModified</code>：默认为false，表示仅在服务器数据改变时获取新数据（根据 HTTP 包 Last-Modified 头信息判断）</li>
<li><code>headers</code>：默认<code>{}</code>,会被<code>beforeSend</code> 函数内的设置覆盖</li>
<li>局部事件触发方法（除了beforeSend外，其他在1.8后被弃用，推荐使用Promise对象的<code>done</code>,<code>fail</code>,<code>always</code>方法）：<ul>
<li><code>beforeSend:function (XMLHttpRequest,settings) {}</code></li>
<li><code>success:function (data, textStatus,jqXHR) {...}</code></li>
<li><code>error:function (jqXHR, textStatus, errorThrown){...}</code></li>
<li><code>complete:function (jqXHR, textStatus){...}</code></li>
</ul>
</li>
<li>AJAX全局事件：通过事件绑定的方式绑定到元素上（可通过设置<code>global:false</code>来禁用）<ul>
<li>ajaxStart</li>
<li>ajaxSend</li>
<li>ajaxSuccess</li>
<li>ajaxError</li>
<li>ajaxComplete</li>
<li>ajaxStop</li>
</ul>
</li>
<li><p>eg：</p>
<pre><code class="nulljs">$.ajax({
  url:&quot;/test&quot;,
  type:&quot;get&quot;,
  data:{id:1},
  beforeSend:function(xhr,settings){
      $(&quot;#preLoading&quot;).show();
  }
}).then(function(data, textStatus, jqXHR){
  //success/done
},function(jqXHR, textStatus, errorThrown){
  //error/fail
});
</code></pre>
<pre><code class="nulljs">$.ajax({
  url:&quot;/test&quot;,
  type:&quot;post&quot;,
  data:JSON.stringify({id:1}),
  processData:false,
  contentType:&quot;application/json;charset=utf-8&quot;,
  dataType:&quot;json&quot;,
  beforeSend:function(xhr,settings){...}
}).done(function(data, textStatus, jqXHR){
  //success
  ...
}).fail(function(jqXHR, textStatus, errorThrown){
  //error
  ...
}).always(function(data|jqXHR, textStatus, jqXHR|errorThrown) {
  //complete
  ...
})
</code></pre>
<pre><code class="nulljs">$(&quot;#loading&quot;).bind(&quot;ajaxSend&quot;, function(){
  $(this).show();
}).bind(&quot;ajaxComplete&quot;, function(){
  $(this).hide();
});
</code></pre>
<pre><code class="nulljs">// 禁用全局Ajax事件
$.ajax({
  url: &quot;test.html&quot;,
  global: false
  ...
});
</code></pre>
</li>
</ul>
</li>
</ul>
<p>注意：</p>
<p>若返回完整html</p>
<pre><code class="nullhtml">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;UserBlocks&lt;/title&gt;
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;  href=&quot;resources/css/base/reset.css&quot; media=&quot;screen&quot;/&gt; 
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div&gt;Hello&lt;/div&gt;
        &lt;div&gt;World&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;

$(data)=&gt;包装集内容为：

&lt;title&gt;UserBlocks&lt;/title&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;  href=&quot;resources/css/base/reset.css&quot; media=&quot;screen&quot;/&gt; 
&lt;div&gt;Hello&lt;/div&gt;
&lt;div&gt;World&lt;/div&gt;
</code></pre>
<p>若返回html片段</p>
<pre><code class="nullhtml">&lt;div&gt;Hello&lt;/div&gt;
&lt;div&gt;World&lt;/div&gt;

$(data)=&gt;包装集内容为：

&lt;div&gt;Hello&lt;/div&gt;
&lt;div&gt;World&lt;/div&gt;
</code></pre>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>不同作用域函数使用</p>
<ul>
<li><p><code>call(context,param1,param2,...)</code>，<code>apply(context,[...])</code></p>
<pre><code class="nulljs">  var sum=function(arg1,arg2){
      console.log(arg1+arg2);
  }
  sum.call(this,1,2);        //3
  sum.apply(this,[1,2]);    //3
  console.log(sum.length)    //2 表示sum函数的参数个数
</code></pre>
<pre><code class="nulljs">  var showName=function(){
      console.log(this.name);
  }
  var c={
      name:&quot;Tom&quot;
  }
  function People(name){
      this.name=name;
  }

  //传入不同上下文作用域，结果不同
  sum.call(c);    //Tom
  sum.call(new People(&quot;Jerry&quot;));    //Jerry
</code></pre>
</li>
<li><p><code>$.proxy(func,context)(args)</code>,<code>$.proxy(context,funcName)(args)</code></p>
<pre><code class="nulljs">  var obj = {
      name: &quot;John&quot;,
      test: function() {
          alert( this.name );
          alert(arguments);
      }
  };

  //两种方式等效，返回代理函数
  var func=$.proxy( obj, &quot;test&quot; );
  func=$.proxy( obj.test, obj );

  func();            //执行：实则执行obj的test函数，能获取this.name
  obj.test();        //执行：无法获取this.name
</code></pre>
<pre><code class="nulljs">  var obj={
      name:&quot;John&quot;
  };
  var fn=function(color){
      alert(this.name);
      alert(color);
  }

  //两种方式等效
  $.proxy(fn,obj)(&quot;red&quot;);        //John,red
  fn.call(obj,&quot;red&quot;);            //John,red
</code></pre>
</li>
</ul>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="符号冲突"><a href="#符号冲突" class="headerlink" title="$符号冲突"></a><code>$</code>符号冲突</h3><ul>
<li>使用<code>jQuery.noConflict()</code><pre><code class="nulljs">var $j=jQuery.noConflict();
$j(&quot;td&quot;).css(&quot;color&quot;,&quot;#f00&quot;);
</code></pre>
</li>
<li>使用闭包<pre><code class="nulljs">(function($){
  $(&quot;td&quot;).css(&quot;color&quot;,&quot;#f00&quot;);
})(jQuery)
</code></pre>
</li>
</ul>
<h3 id="fn包装集插件"><a href="#fn包装集插件" class="headerlink" title="$.fn包装集插件"></a><code>$.fn</code>包装集插件</h3><p>使用<code>$.fn</code>创建包装集插件（jQuery专门定义了<code>jQuery.fn=jQuery.prototype</code>）</p>
<p>使用举例：</p>
<p>定义</p>
<pre><code class="nulljs">$.fn.setColor=function(){
    this.css(&quot;color&quot;,&quot;#0f0&quot;);    // this为包装集对象
    return this;                //必须返回this （包装集的函数一定要能支持链式结构）
}
</code></pre>
<p>调用</p>
<pre><code class="nulljs">$(&quot;td&quot;).setColor();
</code></pre>
<h3 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h3><p>例如：</p>
<p>自定义JFillContent插件</p>
<pre><code class="nulljs">(function($){
    //私有构造函数
    var JFillContent=function(element,options){
        this.element=element;
        this.options=options;
        this._init();
    };

    //预设值设置
    JFillContent.Defaults={...};

    //原型中定义方法，例如：
    JFillContent.prototype._init=function(){
        ...
    };

    //原型中定义方法，例如：
    JFillContent.prototype.fillContent=function(optUrl){
        ...
    };

    ...
    //定义包装集插件
    $.fn.jFillContent=function(option){
        var options = $.extend({}, JFillContent.Defaults, this.data(), typeof option == &#39;object&#39; &amp;&amp; option);
        var instance=this.data(&#39;jFillContent&#39;);
        if (!instance) {
            this.data(&#39;jFillContent&#39;,(instance=new JFillContent(this, options)));
        }
        if (option === true) 
            return instance;
       if ($.type(option) === &#39;string&#39;) {
               if ( !$.isFunction( instance[option] ) || option.charAt( 0 ) === &quot;_&quot; ) {
                    return $.error( &quot;no such method &#39;&quot; + option+&quot;&#39;&quot; );
            }
           instance[option]();
        }
       return this;
    };
    $.fn.jFillContent.Constructor = JFillContent;

})(jQuery);
</code></pre>
<p>使用插件：</p>
<pre><code class="nulljs">$(&quot;#nav-left&quot;).jFillContent({...});                    //返回$(&quot;#nav-left&quot;);
$(&quot;#nav-left&quot;).jFillContent({...}).trigger(&quot;xxx&quot;);    //触发方法，等同$(&quot;#nav-left&quot;).trigger(&quot;xxx&quot;)

$(&quot;#nav-left&quot;).jFillContent(true);    //返回JFillContent对象（从包装集的data中获取，若无，则创建一个新的）
$(&quot;#nav-left&quot;).jFillContent(true).fillContent(url);    //调用jFillContent插件中定义的方法
</code></pre>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>（参考 <a href="http://www.ruanyifeng.com/blog/2011/08/jquery_best_practices.html">jQuery最佳实践</a>）</p>
<ul>
<li>用对选择器，选择器快到慢：<ul>
<li><code>id/tag选择器&gt;.class选择器&gt;:xxx伪类/[attr]属性选择器</code></li>
<li><code>parent.find(&#39;xxx&#39;) &gt; parent.children(&quot;xxx&quot;) &gt; $(&#39;#parent .child&#39;)</code></li>
</ul>
</li>
<li>缓存（减少使用<code>$(xxx)</code>生成jQuery对象）<ul>
<li>变量中暂存jQuery对象</li>
<li>链式写法，jQuery自动缓存每一步的结果</li>
</ul>
</li>
<li>减少DOM结构改动<ul>
<li>尽量合并改动，减少改动次数</li>
<li>对于大量操作，推荐先使用<code>detach</code>方法从DOM中分离出，处理完毕后再重新插回文档</li>
</ul>
</li>
<li>事件管理<ul>
<li>多个对象绑定事件，尽量使用委托处理</li>
<li>eg: <code>$(document).on(&quot;click&quot;, &quot;td&quot;, function(){...})</code>方式优于<code>$(td).on(&quot;click&quot;,function(){...})</code></li>
</ul>
</li>
</ul>
  </section>
</article>

      <hr/>
      <section class="post-comment">
	<!-- disqus默认将数据加载到id为'disqus_thread'的容器中，可配置disqus_container_id改变-->
<div id="disqus_thread"> 
	<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</div>

	<script type="text/javascript">
		var disqus_shortname = 'sixdegreespace'; 
		var disqus_identifier = '2014/03/01/JQuery.html';	
		var disqus_title = 'JQuery';
		var disqus_url = 'http://sixdegree.github.io/2014/03/01/JQuery.html' ;
		//var disqus_category_id = '4262241'; 

		(function() {
		    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
		})();
	</script>


 
</section>
    </div>
  </div>
</body>

<script src="/jquery/dist/jquery.min.js"></script>
<script src="/bootstrap/dist/js/bootstrap.min.js"></script>
<script src="/highlight/highlight.pack.js"></script>
<script type="text/javascript">
  hljs.initHighlightingOnLoad();
  
  $(document).ready(function(){
    var sidebarCtrl=$("#sidebar-ctrl");
    var sidebar=$("#sidebar");
    var wrapper=$("#wrapper");
    sidebarCtrl.on("click",function(event){
        //alert("click");
        sidebar.toggleClass("sidebar-toggle");
        wrapper.toggleClass("sidebar-toggle");
        sidebarCtrl.toggleClass("sidebar-toggle");
        sidebarCtrl.toggleClass("active");
    })
  });
</script>


</html>
