<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>MongoDB</title>
  
  <!-- Meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="MongoDB,NoSql">
  
  

  <!-- Feed -->
  
    <link rel="alternative" href="/atom.xml" title="SixDegree" type="application/atom+xml">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/bootstrap/dist/css/bootstrap.css">
  
	
		<link rel="stylesheet" href="/highlight/styles/tomorrow-night-bright.css">
	
    
  
  <link rel="stylesheet" href="/css/fontello.css">
  <link rel="stylesheet" href="/css/style.css">

  <!-- Site Analyse -->
  
	<script>
	var userID='2bbb83cc0f781dd7502e9d5e19661866';
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?"+userID;
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>


</head>

<body data-spy="scroll" data-target="#nav-catalog">
  <div id="top-push"></div>
<a href="#top-push" id="go-top">
	<span class="glyphicon glyphicon-chevron-up"></span>
</a>
  <aside id="sidebar">
    <section class="sidebar-header">Catalog</section>
     <nav id="nav-catalog">
        <ol class="sidebar-nav nav"><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-1"><span class="sidebar-nav nav-text">Starter</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-2"><span class="sidebar-nav nav-text">数据模型</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-3"><span class="sidebar-nav nav-text">搭建MongoDB测试环境</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-4"><span class="sidebar-nav nav-text">Server/Client</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-5"><span class="sidebar-nav nav-text">Mongo Shell</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-6"><span class="sidebar-nav nav-text">ACID</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-7"><span class="sidebar-nav nav-text">原子性 Atomicity</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-8"><span class="sidebar-nav nav-text">一致性 Consistency</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-9"><span class="sidebar-nav nav-text">隔离性 Isolation</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-10"><span class="sidebar-nav nav-text">持久性 Durability</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-11"><span class="sidebar-nav nav-text">写关注机制 WriteConcern</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-12"><span class="sidebar-nav nav-text">MongoDB数据安全总结</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-13"><span class="sidebar-nav nav-text">CRUD</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-14"><span class="sidebar-nav nav-text">Create(insert)</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-15"><span class="sidebar-nav nav-text">Read(find)</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-16"><span class="sidebar-nav nav-text">Update</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-17"><span class="sidebar-nav nav-text">Delete</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-18"><span class="sidebar-nav nav-text">WriteConcern</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-19"><span class="sidebar-nav nav-text">索引 Index</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-20"><span class="sidebar-nav nav-text">CRUD</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-21"><span class="sidebar-nav nav-text">单字段/复合/多键索引</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-22"><span class="sidebar-nav nav-text">文本索引</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-23"><span class="sidebar-nav nav-text">索引属性</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-24"><span class="sidebar-nav nav-text">衡量索引使用情况</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-25"><span class="sidebar-nav nav-text">索引优化</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-26"><span class="sidebar-nav nav-text">聚合 Aggregate</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-27"><span class="sidebar-nav nav-text">聚合管道</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-28"><span class="sidebar-nav nav-text">Map-Reduce</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-29"><span class="sidebar-nav nav-text">单目聚合操作</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-30"><span class="sidebar-nav nav-text">Security</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-31"><span class="sidebar-nav nav-text">复制集 & 分片</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-32"><span class="sidebar-nav nav-text">MongoDB 4.0 新特性</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-33"><span class="sidebar-nav nav-text">Application</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-34"><span class="sidebar-nav nav-text">Reference</span></a></li></ol>
    </nav>
  </aside>
  <span id="sidebar-ctrl" class="glyphicon glyphicon-list-alt circle"></span>
  <div id="wrapper">
    <header>
  <nav class="navbar navbar-default">
    <div class="container-fluid">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#nav-menu" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/">SixDegree</a>
      </div>
      <div class="collapse navbar-collapse" id="nav-menu">
        <ul class="nav navbar-nav navbar-right">
          
              <li  >
                <a href="/">Blogs</a>
              </li>
          
              <li  >
                <a href="/tags.html">Tags</a>
              </li>
          
              <li  >
                <a href="/about.html">About</a>
              </li>
          
          
              <li>
                <a href="/atom.xml" target="_blank">
                  <span class="icon-rss"></span>
                </a>
              </li>
          
              <li>
                <a href="http://github.com/sixdegree" target="_blank">
                  <span class="icon-github"></span>
                </a>
              </li>
          
        </ul>
      </div>
    </div>
  </nav>
</header>



    <div class="container">
      <article class="detail" role="main">
  <section class="post-header">
    <h1 class="post-title">MongoDB</h1>
    <ul class="post-meta">
      <li>
        <span class="glyphicon glyphicon-calendar"></span>
        <time datetime="2018-08-03T16:00:00.000Z">2018-08-04</time>
      </li>
      
        <li>
         <span class="glyphicon glyphicon-tags"></span>
          
            <a href="/tags.html#tag-NoSql">NoSql</a>
          
        </li>
      
    </ul>
  </section>
  <section class="post-content">
    <h2 id="header-1">Starter</h2>
<blockquote>
<p>文档型数据库： 一条记录就是一个文档，由字段和值对组成（BSON）</p>
</blockquote>
<p><a href="www.mongodb.org">官网</a> | <a href="http://www.mongoing.com/docs/index.html">Doc</a> | <a href="http://www.mongoing.com/">中文社区</a> | <a href="https://github.com/mongodb">Github</a> | <a href="https://jira.mongodb.org">Jira (bug fix)</a></p>
<ol>
<li><p>特性：</p>
<ul>
<li>无数据结构限制（每条记录可以有完全不同的结构）</li>
<li>完全的索引支持（单键／多键索引，复合索引，全文索引，地理位置索引）</li>
<li>丰富的查询语言（Shell内置javascript引擎可以直接执行JS代码）</li>
<li>方便的冗余和扩展（复制集Replica Set：保证数据安全，高可用性，分片Sharding：水平扩展数据规模）</li>
<li>插件化的存储引擎支持（WiredTiger, MMAPv1, In-Memory, Encrypted, 3rd Party Engine）<ul>
<li>WiredTiger（存储引擎）: <ul>
<li>MongoDB3.2 之后的默认存储引擎</li>
<li>拥有效率非常高的缓存机制</li>
<li>支持在内存中和磁盘上对索引进行压缩（压缩时使用了前缀压缩的方式以减少RAM的使用）</li>
<li>能够保证对于同一个文档的操作都是原子的，任意一个写操作都不能原子性地影响多个文档或者多个集合</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用：</p>
<ul>
<li>CRUD -&gt; 索引创建和使用 -&gt; 复杂聚合查询 -&gt; 数据集分片，在不同分片间维持数据均衡 -&gt; 数据备份和恢复 -&gt; 数据迁移</li>
</ul>
</li>
<li><p>部署：</p>
<ul>
<li>单机 -&gt; 拥有冗余容错功能的复制集 -&gt; 分片大规模数据集群(横向扩展，自动分片，轻松支持TB-PB数量级) -&gt; 集群的自动部署
<img src="/2018/08/04/High-Deploy.png" alt="High Deploy"></li>
</ul>
</li>
</ol>
<h3 id="header-2">数据模型</h3>
<p><strong> RelationDB vs. MongoDB : </strong></p>
<ol>
<li>RelationDB: <ul>
<li>Table -&gt; Record -&gt; field &amp; value</li>
</ul>
</li>
<li>MongoDB: <ul>
<li>Collection -&gt; Document -&gt; key &amp; value</li>
<li>表示文档间关系的方式：<ul>
<li><code>Reference</code> 引用：标准化的数据模型，可通过某个引用值链接到其他文档（与 MySQL 的外键非常相似，但不会对引用的对象是否真正存在做出任何的约束）
  <img src="/2018/08/04/model-reference.png" alt="model-reference"> </li>
<li><code>Embedded Data</code> 嵌入：非标准化的数据模型，相关联的数据保存在同一个文档结构之内
  <img src="/2018/08/04/model-embedded.png" alt="model-embeded"></li>
</ul>
</li>
<li>注：MongoDB不对Collection的数据结构进行限制，但在实际使用中，尽量同一个Collection中的文档具有类似的结构</li>
</ul>
</li>
</ol>
<h3 id="header-3">搭建MongoDB测试环境</h3>
<p>这里直接使用Docker搭建MongoDB测试环境</p>
<ol>
<li>搜索下载mongo image<pre><code class="lang-bash"> $ docker search mongo
 $ docker pull mongo
</code></pre>
</li>
<li><p>启动一个容器(micro-mongo)作为mongo server</p>
<pre><code class="lang-bash"> # 建一个单独的数据卷store-mongo (为防止docker machine重启后数据丢失)
 $ docker create --name store-mongo mongo

 # 创建启动一个container as mongo server : micro-mongo，并挂载数据卷store-mongo
 $ docker run --volumes-from store-mongo --name micro-mongo -p 27017:27017 -e MONGO_INITDB_ROOT_USERNAME=mongoadmin -e MONGO_INITDB_ROOT_PASSWORD=123456 -d mongo:latest

 # 检查
 $ docker ps
 $ docker log
</code></pre>
</li>
<li>使用：<ul>
<li>方式一：直接进入刚才创建的mongo server容器(micro-mongo)<pre><code class="lang-bash">  $ docker exec -it micro-mongo /bin/bash
  root@480e8bf33600:/# mongo -u mongoadmin -p 123456 --authenticationDatabase admin
  &gt; show dbs
  admin   0.000GB
  config  0.000GB
  demo    0.000GB
  local   0.000GB
</code></pre>
</li>
<li>方式二：启动一个容器(mongo)作为mongo client连接刚才的micro-mongo<pre><code class="lang-bash">  $ docker run -it --rm --link micro-mongo:mongod --name mongo-client mongo:latest mongo -host mongod -u mongoadmin -p 123456 --authenticationDatabase admin demo
  &gt; show dbs
  admin   0.000GB
  config  0.000GB
  demo    0.000GB
  local   0.000GB
</code></pre>
</li>
<li>方式三：客户端工具 MongoDB Compass</li>
</ul>
</li>
<li>导入测试数据 <pre><code class="lang-bash"> # load(filename): Loads and runs a JavaScript file into the current shell environment
 &gt; load(&quot;testData.js&quot;)
</code></pre>
</li>
</ol>
<h3 id="header-4">Server/Client</h3>
<ul>
<li><p>Server: 启动服务，使用命令<code>mongod</code></p>
<pre><code class="lang-bash">  $ vi conf/mongod.conf
  port = 12345
  dbpath = data
  logpath = log/mongod.log
  fork = true

  $ mongod -f conf/mongod.conf
</code></pre>
</li>
<li><p>Client: 连接数据库，使用命令<code>mongo</code></p>
<pre><code class="lang-bash">  $ mongo --help
  $ mongo localhost:12345/testdb
  &gt; use admin
  &gt; db.shutdownServer()
</code></pre>
</li>
</ul>
<h3 id="header-5">Mongo Shell</h3>
<p>MongoDB的Shell内置javascript引擎可以直接执行JS代码</p>
<pre><code class="lang-bash"># 列出所有可用db
show dbs

# 查看当前正在使用的db
db

# 切换当前数据库上下文，即切换当前使用db
# Note：可以切换到一个不存在的db，后面执行db.&lt;collection&gt;.insert(...)操作时会自动创建
use &lt;database&gt;

# 查看当前db的集合集(table)
show collections
show tables


# 格式化打印结果
db.myCollection.find().pretty()
# 无格式打印
db.myCollection.print()
# JSON格式打印
db.myCollection.printjson()

# 多行操作
# 代码行以 &#39;(&#39;，&#39;{&#39;,&#39;[&#39; 结束，则随后一行将以省略号 &quot;...&quot; 开始，直到输入对应的&#39;)&#39;，&#39;}&#39;，&#39;]&#39;
if(x&gt;0){
...count++;
...print(x);
...}


# Tab命令补全
# 例如下面 &lt;Tab&gt; 补全后将列出各种以‘c’开头的方法
db.myCollection.c&lt;Tab&gt;
</code></pre>
<h2 id="header-6">ACID</h2>
<p><img src="/2018/08/04/txn.png" alt="Transaction"></p>
<table class="table">
<thead>
<tr>
<th>事物特性</th>
<th style="text-align:left">MongoDB</th>
<th style="text-align:left">MySQL (InnoDB)</th>
</tr>
</thead>
<tbody>
<tr>
<td>原子性 Atomicity</td>
<td style="text-align:left">单行/文档级原子性</td>
<td style="text-align:left">多行原子性</td>
</tr>
<tr>
<td>一致性 Consistency</td>
<td style="text-align:left">强一致或最终一致</td>
<td style="text-align:left">强一致</td>
</tr>
<tr>
<td>隔离性 Isolation</td>
<td style="text-align:left">提交读</td>
<td style="text-align:left">可重复读</td>
</tr>
<tr>
<td>持久性 Durability</td>
<td style="text-align:left">日志及复制</td>
<td style="text-align:left">日志</td>
</tr>
</tbody>
</table>
<h3 id="header-7">原子性 Atomicity</h3>
<p><img src="/2018/08/04/txn-atomicity1.png" alt="Atomicity"> <img src="/2018/08/04/txn-atomicity2.png" alt="Non-Atomicity"></p>
<ul>
<li>支持: 单行/文档级原子性<pre><code class="lang-javascript">  db.users.update({ username:&quot;Tom&quot;},{$set:{salary:5000}});
</code></pre>
</li>
<li>尚不支持(4.0以下): 多行/多文档/多语句原子性 <pre><code class="lang-javascript">  db.users.update({ salary:{$lt:5000}},{$set:{salary:5000}});
</code></pre>
<ul>
<li>开始状态:<table class="table">
<thead>
<tr>
<th style="text-align:left">username</th>
<th style="text-align:left">salary</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">James</td>
<td style="text-align:left">3000</td>
</tr>
<tr>
<td style="text-align:left">Tom</td>
<td style="text-align:left">4000</td>
</tr>
<tr>
<td style="text-align:left">Melody</td>
<td style="text-align:left">4500</td>
</tr>
<tr>
<td style="text-align:left">Frank</td>
<td style="text-align:left">2500</td>
</tr>
<tr>
<td style="text-align:left">Kelly</td>
<td style="text-align:left">3500</td>
</tr>
<tr>
<td style="text-align:left">Lucy</td>
<td style="text-align:left">7600</td>
</tr>
</tbody>
</table>
</li>
<li>结束状态：中间出错（eg：宕机）<table class="table">
<thead>
<tr>
<th style="text-align:left">username</th>
<th style="text-align:left">salary</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">James</td>
<td style="text-align:left">5000</td>
</tr>
<tr>
<td style="text-align:left">Tom</td>
<td style="text-align:left">5000</td>
</tr>
<tr>
<td style="text-align:left">Melody</td>
<td style="text-align:left">5000</td>
</tr>
<tr>
<td style="text-align:left">Frank</td>
<td style="text-align:left">2500 &lt;- 宕机</td>
</tr>
<tr>
<td style="text-align:left">Kelly</td>
<td style="text-align:left">3500</td>
</tr>
<tr>
<td style="text-align:left">Lucy</td>
<td style="text-align:left">7600</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
<h3 id="header-8">一致性 Consistency</h3>
<p><img src="/2018/08/04/txn-consistency.png" alt="Consistency"></p>
<p>多文档一致性处理：</p>
<ul>
<li>通过建模来避免</li>
<li>二阶段提交</li>
<li>记录日志，人工干预</li>
</ul>
<p>注：</p>
<ul>
<li>传统数据库：规则校验主外键</li>
<li>分布式数据库：多节点数据一致（Read your writes）
  <img src="/2018/08/04/txn-consistency-nodes.png" alt="MongoDB：可调一致性"></li>
</ul>
<h3 id="header-9">隔离性 Isolation</h3>
<p><img src="/2018/08/04/txn-isolation.png" alt="Isolation"></p>
<table class="table">
<thead>
<tr>
<th style="text-align:left">Isolation Level</th>
<th style="text-align:left">Default Setting</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Serializable</td>
<td style="text-align:left">/</td>
</tr>
<tr>
<td style="text-align:left">Repeatable Read</td>
<td style="text-align:left">MySQL</td>
</tr>
<tr>
<td style="text-align:left">Read Committed</td>
<td style="text-align:left">PostgreSQL,Oracle</td>
</tr>
<tr>
<td style="text-align:left">Read UnCommitted</td>
<td style="text-align:left">MongoDB</td>
</tr>
</tbody>
</table>
<h3 id="header-10">持久性 Durability</h3>
<p><img src="/2018/08/04/txn-durability.png" alt="Durability"></p>
<ul>
<li>机制：
  <img src="/2018/08/04/txn-durability-journal.png" alt="MongoDB vs. 传统数据库"></li>
<li>MongoDB单节点写操作
  <img src="/2018/08/04/write-single-node.png" alt="MongoDB单节点写操作"></li>
<li>MongoDB多节点写操作<br>  <img src="/2018/08/04/write-multiple-nodes.png" alt="MongoDB多节点写操作"></li>
</ul>
<h3 id="header-11">写关注机制 WriteConcern</h3>
<pre><code class="lang-javascript">{ w: &lt;value&gt;, j: &lt;boolean&gt;, wtimeout: &lt;number&gt; }
</code></pre>
<ul>
<li>用来指定mongoDB对写操作的回执行为</li>
<li>可在｀connection level｀或者｀写操作level｀(insert/update/delete操作的最后一个参数)指定</li>
<li>支持以下值：<ul>
<li><code>w</code>: 0/1/n/majority/tag</li>
<li><code>j</code>: true/false 或 0/1</li>
<li><code>wtimeout</code>: millis -- only applicable for <code>w&gt;1</code></li>
</ul>
</li>
</ul>
<p><strong> 具体：</strong></p>
<ol>
<li><p><strong> <code>w</code>: write acknowledgement instance </strong></p>
<ul>
<li><p><code>w:0</code> Unacknowledged (无任何回执)</p>
<ul>
<li>2.2及以前版本的默认行为</li>
<li>网络丢包，系统崩溃，无效数据（早期版本丢数据之罪魁祸首）
<img src="/2018/08/04/w0-unacknowledged.png" alt="Unacknowledged"></li>
</ul>
</li>
<li><p><code>w:1</code> Acknowledged （Mongod在写完内存后返送确认）</p>
<ul>
<li>2.4版本以后的默认行为</li>
<li>能够处理网络故障，无效数据等错误状态</li>
<li>系统崩溃时可能会丢失最多100ms数据
<img src="/2018/08/04/w1-acknowledged.png" alt="Acknowledged"></li>
</ul>
</li>
<li><p><code>w:2/n/majority</code> Replica Acknowledged (等待数据复制到<code>n个/大部分</code>节点后再发送回执)
  <img src="/2018/08/04/wn-replicaAcknowledged.png" alt="Replica Acknowledged"></p>
</li>
</ul>
</li>
<li><p><strong> <code>j</code>: journal(恢复日志) </strong></p>
<ul>
<li>用于系统宕机时恢复内存数据,保证MongoDB中数据的持久性，<code>journal</code>与检查点<code>Checkpoint</code>协作：<ul>
<li>在数据文件中查找上一个Checkpoint标识符；</li>
<li>在 journal 日志文件中查找Checkpoint标识符对应的记录；</li>
<li>重做对应记录之后的全部操作；</li>
</ul>
</li>
<li>刷盘间隔：<ul>
<li>MMAP: 30~100ms</li>
<li>WiredTiger: 100MB/Checkpoint</li>
<li>eg: 每隔<code>60s</code> 或在 <code>journal文件</code>数据的写入达到<code>2GB</code>时设置一次<code>检查点Checkpoint</code></li>
</ul>
</li>
<li>默认为异步刷盘，可用<code>j:1</code>强制同步刷盘</li>
<li><code>j:1/true</code> Journaled，强制 journal 文件的同步 (Journal刷盘后再发送写回执)
  <img src="/2018/08/04/j1-journaled.png" alt="Journaled"></li>
</ul>
</li>
</ol>
<p><strong> 示例：</strong> </p>
<ol>
<li><p>场景：插入一些无效数据（eg：10个document同一个<code>_id</code>），检查实际插入数据数目</p>
<ul>
<li><p>不使用写关注 <code>{w:0}</code> : 未报错，本以为是10条记录但却显示1条记录</p>
<pre><code class="lang-bash">  &gt; db.test.count()
  0
  &gt; for(var i=0;i&lt;10;i++){
      var res=db.test.insert({_id:10,a:i},{writeConcern:{w:0}})
      if(!res.getWriteError())
          print(&quot;Inserted doc #&quot;+(i+1));
      else
          print(res.getWriteError().errmsg);
  }

  Inserted doc #1
  Inserted doc #2
  Inserted doc #3
  Inserted doc #4
  Inserted doc #5
  Inserted doc #6
  Inserted doc #7
  Inserted doc #8
  Inserted doc #9
  Inserted doc #10

  &gt; db.test.count()
  1                            # 期望值为10
</code></pre>
</li>
<li><p>指定写关注<code>{w:1}</code> (2.4以后版本默认为1) : 会acknowledge写错误，返回给客户端，最后显示1条记录</p>
<pre><code class="lang-bash">  &gt; db.test.count()
  0
  &gt; for(var i=0;i&lt;10;i++){
      var res=db.test.insert({_id:10,a:i},{writeConcern:{w:1}})
      if(!res.getWriteError())
          print(&quot;Inserted doc #&quot;+(i+1));
      else
          print(res.getWriteError().errmsg);
  }

  Inserted doc #1
  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }
  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }
  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }
  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }
  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }
  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }
  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }
  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }
  E11000 duplicate key error index: test.test.$_id_ dup key: { : 10.0 }

  &gt; db.test.count()
  1                            # 期望值为1
</code></pre>
</li>
</ul>
</li>
<li><p>场景：系统崩溃导致数据丢失（eg：<code>w:1</code> 高速持续写入数据，<code>kill -9 mongod</code>强制关闭mongo服务，然后重新启动mongo检查程序汇报写入的数据和实际插入的数据）</p>
<pre><code class="lang-bash"> function journalDataLoss(journal){
     var count=0,start=new Date();
     try{
         var docs=[];
         for(var i=0;i&lt;1000;i++)
             docs.push({a:i});
         while(true){
             var res=db.test.insert(docs,{writeConcern:{j:journal}})        # 0/1
             count+=res.nInserted;
             if(count%100000==0)
                 print(&quot;inserted &quot;+count+&quot; time used:&quot;+(((new Date()).getTime()-start.getTime())/1000)+&quot; seconds&quot;);    
         }
     }catch(error){
         print(&quot;Total doc inserted successfully:&quot;+count);
     }
 }
</code></pre>
<ul>
<li><p><code>j:0</code> 不实时刷日志</p>
<pre><code class="lang-bash">  &gt; journalDataLoss(0)
  Inserted 10000 times used: 3.579 seconds
  Inserted 20000 times used: 7.123 seconds
  ...
  ...                                         &lt;- execute: kill -9 mongod
  Total doc inserted successfully:715000

  # 重启mongod，检查插入数量
  &gt; db.test.count()
  713000                        # 数据丢失
</code></pre>
<p>  <img src="/2018/08/04/j0-journaled.png" alt="No Journaled"></p>
</li>
<li><p><code>j:1</code> 实时刷日志</p>
<pre><code class="lang-bash">  &gt; journalDataLoss(1)
  Inserted 10000 times used: 4.579 seconds
  Inserted 20000 times used: 8.123 seconds
  ...
  ...                                         &lt;- execute: kill -9 mongod
  Total doc inserted successfully:726000

  # 重启mongod，检查插入数量
  &gt; db.test.count()
  726000                        # 数据未丢失
</code></pre>
</li>
</ul>
</li>
<li><p>场景：主备置换导致数据丢失（eg：<code>w:1/majority</code>,<code>j:1</code>高速持续写入数据，<code>kill -9 mongod</code>主节点，连接到新的主节点，检查实际插入的数据与程序汇报的插入数据）</p>
<ul>
<li><code>w:1</code>
  <img src="/2018/08/04/write-case-1.png" alt="CaseC-1">
  <img src="/2018/08/04/write-case-2.png" alt="CaseC-2">
  <img src="/2018/08/04/write-case-3.png" alt="CaseC-3"></li>
<li><code>w:majority</code> 设置确认数据写到大部分节点再返回
  <img src="/2018/08/04/write-case-solution.png" alt="CaseC-Solution"></li>
</ul>
</li>
</ol>
<h3 id="header-12">MongoDB数据安全总结</h3>
<p><img src="/2018/08/04/write-concern.png" alt="WriteConcern">
<img src="/2018/08/04/read-perference.png" alt="ReadPerference"></p>
<blockquote>
<p>Read preference describes how MongoDB clients route read operations to the members of a replica set.By default, an application directs its read operations to the primary member in a replica set.</p>
</blockquote>
<h2 id="header-13">CRUD</h2>
<h3 id="header-14">Create(insert)</h3>
<p>Insert Document into Collection
注：</p>
<ul>
<li>单条document操作是原子性的</li>
<li>每一个document都有一个唯一的<code>_id</code> 字段作为 primary_key（若未指定，则MongoDB自动为<code>_id</code>生成一个<code>ObjectId</code>）</li>
<li><code>_id</code>字段值无法修改</li>
</ul>
<pre><code class="lang-javascript">db.myCollection.insert({...})            # 返回WriteResult对象
db.myCollection.insert([{},{},..])         # 返回BulkWriteResult对象

db.myCollection.insertOne({...})
db.myCollection.insertMany([{},{},..])
</code></pre>
<h3 id="header-15">Read(find)</h3>
<pre><code class="lang-javascript">db.myCollection.find(&lt;query filter&gt;,&lt;projection&gt;)
db.myCollection.findOne(...)

// 参数&lt;query filter&gt;/&lt;projection&gt;格式：
{
  &lt;field1&gt;: &lt;value1&gt;,
  &lt;field2&gt;: { &lt;operator&gt;: &lt;value&gt; },
  ...
}
</code></pre>
<ol>
<li><p><code>&lt;query filter&gt;</code></p>
<ul>
<li>value：<ul>
<li>普通特定值</li>
<li><code>{ &lt;operator&gt;: &lt;value&gt; }</code>：specify conditions</li>
</ul>
</li>
<li><p>operator:</p>
<pre><code class="lang-bash">  #  Comparison
  $eq,$gt,$gte,$lt,$lte,$ne,$in,$nin

  # Logical
  $or,$and,$not,$nor

  # Element
  $exists,$type

  # Evaluation
  $mod,$regex,$text,$where

  # Geospatial
  $geoWithin,$geoIntersects,$near,$nearsphere

  # Array
  $all,$elemMatch,$size

  # Bitwise
  $bitsAllSet,$bitsAnySet,$bitsAllClear,$bitsAnyClear

  # Comments
  $comment
</code></pre>
</li>
</ul>
</li>
<li><p><code>&lt;projection&gt;</code></p>
<ul>
<li>value：<ul>
<li><code>1/true</code>: 返回文档包含该字段</li>
<li><code>0/false</code>: 返回文档排除该字段</li>
<li><code>{ &lt;operator&gt;: &lt;value&gt; }</code>: specify conditions</li>
</ul>
</li>
<li>operator：<pre><code class="lang-bash">  $,$elemMatch,$slice,$meta
</code></pre>
</li>
<li>注：不能使用数组索引来指定映射的特定数组元素，eg： <code>{ &quot;ratings.0&quot;: 1 } -- wrong</code></li>
</ul>
</li>
<li><p>示例：</p>
<ul>
<li><p>查询</p>
<pre><code class="lang-bash">  db.users.find( { status:&quot;A&quot; } )
  db.users.find( { status:{ $in:[&quot;P&quot;,&quot;D&quot;] } } )
  db.users.find({
      status:&quot;A&quot;,
      $or:[ {age:{$lt:30}},{type:1} ]
  })

  # 嵌入式document匹配
  db.users.find({
      favorites:{artist:&quot;Picasso&quot;}
  })
  db.users.find({
      &quot;favorites.artist&quot;:&quot;Picasso&quot;
  })

  # 精确匹配
  db.users.find({
      badges:[&quot;blue&quot;,&quot;black&quot;]
  })    

  # 匹配包含black的
  db.users.find({
      badges:&quot;black&quot;
  })    

  # 匹配第一个元素为black的
  db.users.find({
      &quot;badges.0&quot;:&quot;black&quot;
  })    

  # 查询 finished 数组至少包含一个大于15并且小于20的元素的文档
  # $elemMatch 为数组元素指定复合条件，查询数组中至少一个元素满足所有指定条件的文档
  db.users.find({ 
      finished: { $elemMatch: { $gt: 15, $lt: 20 } } 
  })

  # 查询 finished 数组中包含大于15 ，或者小于20的元素的文档
  db.users.find({ 
      finished: { $gt: 15, $lt: 20 } 
  })
</code></pre>
</li>
<li><p>查询返回部分字段</p>
<pre><code class="lang-javascript">  // 返回文档 _id,name,status 字段
  db.users.find(
      {status:&quot;A&quot;},
      {name:1,status:1}
  )

  // 返回文档 name,status 字段
  // Note: 除了 _id 字段，不能在映射文档中组合包含和排除语句
  // Eg: name:1,status:0 -- wrong!
  db.users.find({
      {status:&quot;A&quot;},
      {name:1,status:1,_id:0}
  })

  // 返回文档不显示 favorites,points字段
  db.users.find({
      {status:&quot;A&quot;},
      {favorites:0,points:0}
  })

  // 返回文档显示_id,name,status,points的bonus字段
  db.users.find({
      {status:&quot;A&quot;},
      {name:1,status:1,&quot;points.bonus&quot;:1}
  })

  // 使用$slice映射操作符来返回 points数组中最后的元素
  db.users.find({
      {status:&quot;A&quot;},
      {name:1,status:1,&quot;points&quot;:{$slice:-1}}
  })
</code></pre>
</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li><p>查询值为Null或不存在的字段</p>
<pre><code class="lang-javascript">  { &quot;_id&quot; : 900, &quot;name&quot; : null },
  { &quot;_id&quot; : 901 }
</code></pre>
<ul>
<li><code>db.users.find({name:null})</code>: 会返回name为null和不存在name字段的记录（注：若使用了sparse稀疏索引，只会匹配到name为null的记录，不会匹配到不存在的）</li>
<li><code>db.users.find({name:{$type:&quot;null&quot;}})</code>: 只会返回name为null的记录 （<code>$type</code> <a href="http://www.mongoing.com/docs/reference/operator/query/type.html#op._S_type">类型筛查</a>）</li>
<li><code>db.users.find({name:{$exists:false}})</code>: 只返回不存在name字段的documents (<code>$exists</code> 存在性筛查)</li>
</ul>
</li>
<li><p>游标Cursor</p>
<pre><code class="lang-javascript">  var myCursor=db.users.find({type:&quot;string&quot;})

  while(myCursor.hasNext()){
      printjson(myCursor.next())
  }

  myCursor.forEach(printjson);

  myCursor.forEach(function(myDoc){
      print(&quot;user:&quot;+myDoc.name);
  })

  var myArray=myCursor.toArray();
  myArray[3];

  myCursor[1]             // same with myCursor.toArray()[1]
</code></pre>
<ul>
<li><code>find</code>方法返回的（若不赋给一个变量，则会自动遍历显示，默认是展示20条记录，可以使用<code>DBQuery.shellBatchSize</code> 来改变迭代结果的数量）</li>
<li>Cursor Method: count,hint,forEach,map,limit,sort,size,skip,toArray,... <a href="http://www.mongoing.com/docs/reference/method/js-cursor.html">More</a></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="header-16">Update</h3>
<pre><code class="lang-javascript">db.myCollection.update(&lt;query filter&gt;,&lt;update document&gt;,&lt;option&gt;)    # 默认情况下只更新 一个 文档
db.myCollection.updateOne(...)
db.myCollection.updateMany(...)
db.myCollection.replaceOne(...)

// 更多：
db.myCollection.findOneAndReplace()
db.myCollection.findOneAndUpdate()
db.myCollection.findAndModify()
</code></pre>
<ol>
<li><code>&lt;query filter&gt;</code>: 同上</li>
<li><p><code>&lt;update document&gt;</code>: </p>
<ul>
<li><code>{ &lt;field1&gt;: &lt;value1&gt;, ... }</code></li>
<li><code>{&lt;update operator&gt;: { &lt;field1&gt;: &lt;value1&gt;, ... },...}</code></li>
<li><p>update operators:</p>
<pre><code class="lang-bash">  # Field
  $inc
  $mul
  $rename
  $setOnInsert
  $set
  $unset
  $min
  $max
  $currentDate

  # Array
  $
  $[]
  $[&lt;identifier&gt;]
  $addToSet
  $pop
  $pull
  $push
  $pullAll

  # Modifiers
  $each
  $position
  $slice
  $sort

  # Bitwise
  $bit
</code></pre>
</li>
</ul>
</li>
<li><p><code>&lt;option&gt;</code> </p>
<ul>
<li>multi:false/true 配置是否更新多个文档</li>
<li>upsert:false/true 表示不存在时是否插入新的document</li>
</ul>
</li>
<li><p>示例：</p>
<pre><code class="lang-javascript"> db.users.update(
    { name: &quot;xyz&quot; },
    { name: &quot;mee&quot;, age: 25, type: 1, status: &quot;A&quot;, favorites: { &quot;artist&quot;: &quot;Matisse&quot;, food: &quot;mango&quot; } }
 )

 db.users.update(
     {status:&quot;A&quot;},
     {
         $set:{status:&quot;B&quot;,type:0},
         $currentDate:{lastModified:true}
     },
     {multi:true}
 )
</code></pre>
</li>
</ol>
<h3 id="header-17">Delete</h3>
<pre><code class="lang-javascript">// delete
db.myCollection.deleteOne(&lt;query filter&gt;)

// delete all matched
db.myCollection.deleteMany(...)
db.myCollection.remove(&lt;query filter&gt;, &lt;justOne&gt;)

// delete all,include index
db.myCollection.drop()

// 删除以指定顺序排序的文档中的第一个文档.
db.myCollection.findOneAndDelete().
</code></pre>
<p>示例：</p>
<pre><code class="lang-javascript">// delete all documents
db.users.deleteMany({})
db.users.remove({})

// delete all matched
db.users.remove({status:&quot;D&quot;})
db.users.deleteMany({status:&quot;D&quot;})

// delete just one
// &lt;justOne&gt;:1
db.users.remove({status:&quot;D&quot;},1}
db.users.deleteOne({status:&quot;D&quot;})
</code></pre>
<h3 id="header-18">WriteConcern</h3>
<p>在安全写情况下,可以指定MongoDB写操作要求的确认级别（insert/update/delete 操作的最后一个参数）</p>
<pre><code class="lang-javascript">{ w: &lt;value&gt;, j: &lt;boolean&gt;, wtimeout: &lt;number&gt; }
</code></pre>
<ul>
<li><code>w</code>:0/1/&quot;majority&quot; -- write acknowledgement instance</li>
<li><code>j</code>:true/false -- journal</li>
<li><code>wtimeout</code> -- only applicable for w&gt;1</li>
</ul>
<h2 id="header-19">索引 Index</h2>
<ul>
<li>优点：加快索引相关的查询；</li>
<li>缺点：增加磁盘空间消耗，降低写入性能</li>
</ul>
<h3 id="header-20">CRUD</h3>
<ol>
<li><p>创建索引</p>
<pre><code class="lang-javascript"> // &lt;field&gt;: &lt; 1 or -1 &gt;
 // 1 : 索引正序，－1 : 索引倒序
 db.collection.createIndex( &lt;Key Index specification&gt;, &lt;options&gt;)
</code></pre>
</li>
<li><p>查看索引</p>
<pre><code class="lang-javascript"> db.collection.getIndexes()
</code></pre>
</li>
<li><p>删除索引</p>
<pre><code class="lang-javascript"> db.collection.dropIndex({...})
 db.collection.dropIndexs()
</code></pre>
</li>
<li><p>重建索引: ( drop all indexes,include _id index,then rebuilds all in the background,rebuild _id index in the foreground,which takes the db&#39;s write lock.)</p>
<pre><code class="lang-javascript"> db.collection.reIndex()
</code></pre>
</li>
<li><p>检查索引</p>
<pre><code class="lang-javascript"> // 扫描集合中的数据和索引以检查正确性的内部命令
 db.collection.validate()
</code></pre>
</li>
</ol>
<h3 id="header-21">单字段/复合/多键索引</h3>
<ol>
<li><p>单字段索引 Single Field Index</p>
<pre><code class="lang-javascript"> db.users.createIndex({age:-1});
</code></pre>
<ul>
<li>在任意一个field上（包括Embedded Field）建立索引</li>
<li>默认索引 <code>_id</code>：类型ObjectId(代替递增的 id，能够解决分布式的 MongoDB 生成唯一标识符的问题)，12个字节构成: <code>Timestamp(4)+MachineIdentifier(3)+ProcessIdentifier(2)+Coounter(3)</code></li>
<li>可配置顺序/倒序(<code>1</code>: 正序，<code>-1</code>:倒序)</li>
</ul>
</li>
<li><p>复合索引 Compound Index</p>
<pre><code class="lang-javascript"> db.users.createIndex( { username: 1, age: -1 } )
 db.users.createIndex( { username: 1, age: 1 } )
 // 方便按照username和age查找
 db.users.find({username:&quot;Tom&quot;,age:5});
</code></pre>
<ul>
<li>多个不同field组成</li>
<li>注：上面的两个索引是完全不同的，在磁盘上的 <code>B+树</code> 其实也按照了完全不同的顺序进行存储，在使用查询语句对集合中数据进行查找时，是会使用不同的索引，所以在索引创建时要考虑好使用的场景，避免创建无用的索引。</li>
</ul>
</li>
<li><p>多键索引 Multikey Index</p>
<pre><code class="lang-javascript"> //{ _id: 1, item: &quot;ABC&quot;, ratings: [ 2, 5, 9 ] }
 db.survey.createIndex( { ratings: 1 } )
</code></pre>
<ul>
<li>在一个储存数组的键上添加索引，会对数组中的每个元素都添加索引项，加速对数组中元素的查找</li>
<li>注：不需要显示地指定索引为多键类型，MongoDB会自动地决定是否需要创建一个多键索引</li>
</ul>
</li>
</ol>
<h3 id="header-22">文本索引</h3>
<p>Text Index 文本索引（也叫全文索引）</p>
<ul>
<li>支持在字符串内容上的文本检索查询</li>
<li>一个集合只能有一个文本检索索引，但是这个索引可以覆盖多个字段</li>
<li>创建文本索引（<code>name:&quot;text&quot;</code>）：<pre><code class="lang-javascript">  db.stores.createIndex({name:&quot;text&quot;,description:&quot;text&quot;})        # 在name，description字段建立文本索引
</code></pre>
</li>
<li>查询：使用<code>$text</code>操作符在一个创建了text index的Collection上执行文本检索<pre><code class="lang-javascript">  {
    $text:
      {
        $search: &lt;string&gt;,
        $language: &lt;string&gt;,
        $caseSensitive: &lt;boolean&gt;,
        $diacriticSensitive: &lt;boolean&gt;
      }
  }
</code></pre>
</li>
<li>查询示例：<ul>
<li><code>$text</code> 会使用空格和标点符号作为分隔符对检索字符串进行分词 (OR操作)<pre><code class="lang-javascript">  // 包含 aa or bb or cc
  db.stores.find({ $text:{$search:&quot;aa bb cc&quot;} })
  // 包含 (aa or bb ) and not cc
  db.stores.find({ $text:{$search:&quot;aa bb -cc&quot;} })
  // 包含 aa or &quot;bb cc&quot;
  db.stores.find({ $text:{$search:&quot;aa \&quot;bb cc\&quot;&quot;} })
</code></pre>
</li>
<li><code>$text</code>+<code>$meta</code> 显示匹配相似度<pre><code class="lang-javascript">  # Sort by Additional Query and Text Search Score and Return top 2 matching documents
  # score: 计算一个相关性分数，表明该文档与查询的匹配程度
  # 显式地对 $meta:&quot;textScore&quot; 字段进行映射然后基于该字段进行sort排序
  db.stores.find({
      {$text:{$search:&quot;aa bb cc&quot;}},
      {score:{$meta:&quot;textScore&quot;}}
  }).sort({ date:1, score:{$meta:&quot;textScore&quot;} }).limit(2)
</code></pre>
</li>
<li>聚合管道中，在 $match 阶段使用文本搜索（限制：只能是管道中的第一个阶段，$text只能在阶段中出现一次，$text不能出现在$or,$nor表达式中）<pre><code class="lang-javascript">  db.articles.aggregate([
      { $match:{ $text:{$search:&quot;aa bb&quot;} } },
      { $sort:{ score:{$meta:&quot;textScore&quot;} } },
      { $project:{ title:1,_id:0 } }
  ])
  db.articles.aggregate([
      { $match:{ $text:{$search:&quot;aa bb&quot;} } },
      { $project:{ title:1,_id:0,score:{$meta:&quot;textScore&quot;} } },
      { $match:{ score:{$gt:1.0} } }
  ])
</code></pre>
</li>
</ul>
</li>
<li>注：如果要做更细致的全文索引的话，推荐使用 Elasticsearch</li>
</ul>
<h3 id="header-23">索引属性</h3>
<p>创建索引时的可配置选项<code>&lt;options&gt;</code>，说明Index的一些特性</p>
<pre><code class="lang-javascript">db.collection.createIndex( &lt;Key Index specification&gt;, &lt;options&gt;)
</code></pre>
<ol>
<li><p><code>expireAfterSeconds</code> (TTL): 过一段时间后自动移除集合中的document</p>
<pre><code class="lang-javascript"> db.users.createIndex(
     {lastModifiedDate:1},
     {expireAfterSeconds:3600}
 )
 // 设置文档过期的时间expireAt字段的值一致
 db.log_events.createIndex( 
     { &quot;expireAt&quot;: 1 }, 
     { expireAfterSeconds: 0 } 
 )
</code></pre>
<ul>
<li>index 字段存储数据类型必需是date或date数组（若是数组，则其中最低过期阈值得到匹配时，删除此document）</li>
<li>不能保证过期数据会被立刻删除,删除过期数据的后台任务每隔60秒运行一次</li>
<li>应用场景：机器生成的事件数据，日志，会话信息等，这些数据都只需要在数据库中保存有限时间</li>
</ul>
</li>
<li><p><code>unique</code></p>
<pre><code class="lang-javascript"> db.members.createIndex( { &quot;user_id&quot;: 1 }, { unique: true } )
</code></pre>
</li>
<li><p><code>collation</code>: Case Insensitive Indexes</p>
<pre><code class="lang-javascript"> db.fruit.createIndex( 
     { type: 1},
     { collation: { locale: &#39;en&#39;, strength: 2 } }
 )
</code></pre>
</li>
<li><p><code>sparse</code>( 稀疏索引): null值不计入索引，常和唯一索引连用</p>
<pre><code class="lang-javascript"> db.users.createIndex({name:1},{sparse:true})
</code></pre>
</li>
<li><p><code>partialFilterExpression</code> ( 局部索引Partial Indexes )：稀疏索引进化版，一种在指定赛道上（可跨赛道），消耗更低的索引</p>
<pre><code class="lang-javascript"> db.users.createIndex(
     {name:1},
     {unique:true,partialFilterExpression:{age:{$gt:18}}}
 )
</code></pre>
<ul>
<li>不能作为分片的片键</li>
<li><code>_id</code>不能创建局部索引</li>
<li>同一个索引不能和sparse同时使用</li>
<li>一个键上不能有多个不同的局部索引</li>
<li>particalFilterExpression 支持的过滤操作：<pre><code>  $eq,$gt,$gte,$lt,$lte,
  $exists:true,
  $type,
  $and -- at top level
</code></pre></li>
</ul>
</li>
<li><p><code>background</code> : 后台创建索引会比默认的慢，但不会锁表（生产环境使用<code>background:true</code>比较好）</p>
<pre><code class="lang-javascript"> db.users.createIndex({username:1},{background:true})
</code></pre>
</li>
</ol>
<h3 id="header-24">衡量索引使用情况</h3>
<ol>
<li>mongostat工具－查看mongodb运行状态的程序 <pre><code class="lang-bash"> mongostat --help
 mongostat -h localhost:12345
</code></pre>
</li>
<li>profile集合<pre><code class="lang-javascript"> db.getProfilingLevel()
 db.getProfilingStatus()
 db.setProfilingLevel(2)
 show tables
 db.system.profile.find().sort({$natural:-1}).limit(10)
</code></pre>
</li>
<li><p>日志</p>
<pre><code class="lang-bash"> # 配置日志
 vim conf/mongod.conf
 ...
 verbose = vvvvv    # v,vv,...,vvvvv
</code></pre>
</li>
<li><p>查看容量占用（注意: 确保索引与内存相适应）</p>
<pre><code class="lang-javascript"> // indexSizes: 查看索引在磁盘存储的大小
 db.users.stats().indexSizes`
 // indexDetails: 查看索引占用内存的大小 (内存中会放最近使用的索引)
 db.users.stats({indexDetails:true}).indexDetails
 // totalIndexSize 查询索引大小 
 db.users.totalIndexSize()
</code></pre>
</li>
<li><p><code>$indexStats</code> 索引具体信息</p>
<pre><code class="lang-javascript"> // { $indexStats: { } } 返回包括 name,key,host,accesses字段
 db.orders.aggregate([ 
     { $indexStats: { } } 
 ])
 db.orders.aggregate([ 
     { $indexStats: { } } ,
     {$match:{name:&quot;_id_ type_1_item_1&quot;}}
 ])

 // Eg: Return
 {
    &quot;name&quot; : &quot;_id_&quot;,
    &quot;key&quot; : {&quot;_id&quot; : 1},
    &quot;host&quot; : &quot;examplehost.local:27017&quot;,
    &quot;accesses&quot; : {
       &quot;ops&quot; : NumberLong(0),
       &quot;since&quot; : ISODate(&quot;2015-10-02T14:31:32.479Z&quot;)
    }
 }
 {
    &quot;name&quot; : &quot;type_1_item_1&quot;,
    &quot;key&quot; : {&quot;type&quot; : 1,&quot;item&quot; : 1},
    &quot;host&quot; : &quot;examplehost.local:27017&quot;,
    &quot;accesses&quot; : {
       &quot;ops&quot; : NumberLong(1),
       &quot;since&quot; : ISODate(&quot;2015-10-02T14:31:58.321Z&quot;)
    }
 }
</code></pre>
</li>
<li><p><code>explain()</code> 返回查询计划(query plan)，即查询的详细信息</p>
<pre><code class="lang-javascript"> // 返回一个含有查询过程的统计数据的文档，包括所使用的索引，扫描过的文档数，查询所消耗的毫秒数
 db.users.find(...).explain(&quot;executionStats&quot;)
</code></pre>
</li>
<li><p><code>hint()</code> 以索引作为方法参数, 强制 MongoDB使用指定的索引来匹配查询</p>
<pre><code class="lang-javascript"> db.people.find(
    { name: &quot;John Doe&quot;, zipcode: { $gt: &quot;63000&quot; } }
 ).hint( { zipcode: 1 } ).explain(&quot;executionStats&quot;)

 // 指定 $natural 操作符来避免MongoDB使用任何索引(注; 亦即，查询不会使用索引)
 db.people.find(
    { name: &quot;John Doe&quot;, zipcode: { $gt: &quot;63000&quot; } }
 ).hint( { $natural: 1 } ).explain(&quot;executionStats&quot;)
</code></pre>
</li>
</ol>
<h3 id="header-25">索引优化</h3>
<p><strong> 索引策略: </strong></p>
<ul>
<li>创建索引以支持查询</li>
<li>使用索引来排序查询结果</li>
<li>确保索引与内存相适应</li>
<li>创建能确保选择力的查询</li>
</ul>
<p><strong> 优化策略: </strong>    </p>
<ol>
<li>重复率越低越适合做索引（distinct／count 越接近1越适合），例如状态，性别等重复率不适合</li>
<li>联合索引，索引前缀由低到高，eg: <code>db.test.createIndex({a:1,b:1,c:1})</code>,则 a b c, a b, a</li>
<li>索引顺序：等值，范围，顺序<pre><code class="lang-javascript"> // 查询
 db.test.find({
     a:2,
     b:{$gt2,$le:10}
 }).sort({c:1})
 // 则建立索引如下所以更优：
 db.test.createIndex({a:1,c:1:b:1})
</code></pre>
</li>
<li>有条件尽量匹配覆盖索引<pre><code class="lang-javascript"> db.test.createIndex({a:1,b:1,c:1})
 db.test.find({a:3},{b:1,c:1,_id:0})     # select b,c from test where a=3 -&gt; 能用到索引，且获取的值在索引中
</code></pre>
</li>
<li>指定<code>从节点</code>创建索引,这样不影响<code>主节点</code>的写入，不会驱逐掉常规缓存(适用于BI，报表查询，需添加大量索引的情况)，步骤：<ol>
<li>指定从节点priority为0 （不会变成主节点）</li>
<li>单机模式重启该从节点（配置文件注释）</li>
<li>添加索引</li>
<li>副本集模式重启该节点（配置文件还原）</li>
</ol>
</li>
</ol>
<h2 id="header-26">聚合 Aggregate</h2>
<p>MongoDB中有三种实现聚合的方式：</p>
<ul>
<li>聚合管道 Aggregator pipeline</li>
<li>Map-Reduce function</li>
<li>单目聚合方法（group,count,distinct)</li>
</ul>
<h3 id="header-27">聚合管道</h3>
<p>Aggregation Pipeline</p>
<ul>
<li>基于数据处理的聚合管道，使用内置的原生sql操作，效率高 （支持类似mysql的group by功能 ）</li>
<li>每个document通过一个由多个阶段（stage）组成的管道，经过一系列的处理（例如对每个阶段的管道进行分组、过滤等）输出相应的结果</li>
<li>限制：<ul>
<li>每个阶段管道限制为<code>100MB</code>的内存，超过将报错（可以设置<code>allowDiskUse</code>为<code>true</code>来在聚合管道节点把数据写入临时文件来解决100MB的内存的限制）</li>
<li>输出的结果只能保存在一个文档中，BSON Document大小限制为<code>16M</code>（2.6后：<code>DB.collect.aggregate()</code>方法返回一个指针cursor ，可以返回任何结果集的大小）</li>
<li>可作用在分片集合，但结果不能输在分片集合（MapReduce可作用在分片集合，结果也可输在分片集合）</li>
</ul>
</li>
</ul>
<p><img src="/2018/08/04/aggregation-pipeline.png" alt="aggregation-pipeline"></p>
<p><a href="https://docs.mongodb.com/manual/reference/method/db.collection.aggregate/index.html">Doc</a>     </p>
<pre><code class="lang-javascript">// 方式一：
db.collection.aggregate(pipeline, options)

// 方式二：
db.runCommand({
  aggregate: &quot;&lt;collection&gt;&quot; || 1,
  pipeline: [ &lt;stage&gt;, &lt;...&gt; ],
  //options ( belows are optional )
  explain: &lt;boolean&gt;,
  allowDiskUse: &lt;boolean&gt;,
  cursor: &lt;document&gt;,
  maxTimeMS: &lt;int&gt;,
  bypassDocumentValidation: &lt;boolean&gt;,
  readConcern: &lt;document&gt;,
  collation: &lt;document&gt;,
  hint: &lt;string or document&gt;,
  comment: &lt;string&gt;,
  writeConcern: &lt;document&gt;
})
</code></pre>
<ol>
<li><p>参数<code>pipeline</code>: </p>
<pre><code class="lang-javascript"> [&lt;stage&gt;,&lt;Stage&gt;,...]

 //&lt;stage&gt;
 $stageOperator:{&lt;key&gt;:&lt;value&gt;,&lt;key&gt;:&lt;expression&gt;...}

 // &lt;expression&gt; 
 { &lt;expressionOperator&gt;:&lt;arg&gt; }
 { &lt;expressionOperator&gt;:[&lt;arg1&gt;,&lt;arg2&gt;,... &lt;argN&gt;] }
</code></pre>
<ul>
<li><p>StageOperator <a href="https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/#aggregation-pipeline-operator-reference">阶段操作符</a></p>
<pre><code class="lang-javascript">  $match          // 过滤数据,传输到下一个阶段管道
  $project        // 投影，过滤显示文档字段(可选择字段，重命名字段，派生字段)
  $group          // 将数据根据key进行分组,统计结果
  $unwind         // 将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值
  $lookup         // 进行两个集合之间左连接操作
  $sort           // 将输入文档排序后输出
  $skip           // 跳过指定数量的文档，返回余下的文档
  $limit          // 限制返回的文档数
  $redact         // 根据字段所处的document结构的级别，对文档进行“修剪”，通常和“判断语句if-else”结合使用，即＄cond
  $sample         // 抽样输出
  $geoNear        // 用于地理位置数据分析
  $indexStats     // 返回数据集合的每个索引的使用情况 { $indexStats: { } }
  $out            // 将最后计算结果写入到指定的collection中,必须为pipeline最后一个阶段管道
  ...

  // 常用组合
  $match -&gt; $project
  $match -&gt; $group
  $match -&gt; $group -&gt; $sort
  $match -&gt; $match -&gt; $ project -&gt; $group
  $match -&gt; $lookup -&gt; $match -&gt; $sort
  $match -&gt; $project -&gt; $sort -&gt; $skip -&gt; $limit
  $match -&gt; $project -&gt; $unwind -&gt; $group -&gt; $sort -&gt;$skip -&gt; $limit
</code></pre>
</li>
<li><p>ExpressionOperator <a href="https://docs.mongodb.com/manual/meta/aggregation-quick-reference/#aggregation-expressions">表达式操作符</a></p>
<pre><code class="lang-javascript">  // 1. 布尔管道 Boolean Operators 
  // eg: $or: [ { $gt: [ &quot;$qty&quot;, 250 ] }, { $lt: [ &quot;$qty&quot;, 200 ] } ]
  $and,$or,$not

  // 2. 条件操作符 Conditinal Operator 
  // eg: $cond: { if: { $gte: [ &quot;$qty&quot;, 250 ] }, then: 30, else: 20 }
  $cond,$ifNull,$switch

  // 3. 数据类型 DataType Operators
  $type

  // 4. 集合操作 Set Operators
  // eg: $setUnion: [ &quot;$A&quot;, &quot;$B&quot; ] 
  $setEquals                                     // 完全相等
  $setIsSubset                                   // 完全被包含
  $anyElementTrue                                // 集合中任一元素符合，则true
  $allElementsTrue                               // 集合中所有元素符合，则true
  $setIntersection                               // 交集
  $setUnion                                      // 并集
  $setDifference                                 // 差集

  // 5. 比较操作符 Comparison Operators
  $cmp                                         // 0/1/-1
  $eq,$gt,$lt,$gte,$lte,$ne

  // 6. 算术操作符 Arithmetic Operators
  // eg: $abs: { $subtract: [ &quot;$start&quot;, &quot;$end&quot; ] } 
  $abs                                         // 绝对值
  $in
  $add, $substract, $multiply, $divide, $mod
  $ceil, $floor ,$trunc
  $log, $log10, $sqrt, $pow, $exp

  // 7. 字符串操作 String Operators
  // eg: $split: [&quot;$city&quot;, &quot;, &quot;]
  $concat, $split
  $trim, $ltrim, $rtrim
  $toLower, $toUpper
  $toString
  $dateFromString, $dateToString
  $strcasecmp                                  // case-insensitive,return 0,1/-1
  $substr                                      // Deprecated!
  $substrBytes, $substrCP
  $indexOfBytes, $indexOfCP
  $strLenBytes,$strLenCP

  // 8. 数组 Array Operators
  // eg: $arrayElemAt: [ &quot;$favorites&quot;, -1 ]
  $arrayElemAt
  $map
  $filter
  $slice                                      // subset
  $zip                                        // merge two arrays
  $reduce                                     // combine into a single value return
  $isArray, $arrayToObject, $objectToArray
  $concatArrays
  $reverseArray
  $indexOfArray
  $in
  $range
  $size

  // 9. 日期 Date Operators
  $dateFromParts, $dateToParts
  $dateFromString, $dateToString
  $dateOfMonth, $dateOfWeek, $dateOfYear
  $year,$month, $week, $hour, $minute, $second, $millisecond
  $isoDayOfWeek, $isoWeek, $isoWeekYear
  $toDate

  ...
</code></pre>
</li>
</ul>
</li>
<li><p>参数<code>options</code>:</p>
<pre><code class="lang-javascript"> {
   explain: &lt;boolean&gt;,
   allowDiskUse: &lt;boolean&gt;,
   cursor: &lt;document&gt;,
   maxTimeMS: &lt;int&gt;,
   bypassDocumentValidation: &lt;boolean&gt;,
   readConcern: &lt;document&gt;,
   collation: &lt;document&gt;,
   hint: &lt;string or document&gt;,
   comment: &lt;string&gt;,
   writeConcern: &lt;document&gt;
 }
</code></pre>
</li>
</ol>
<p><strong> 示例：</strong></p>
<ol>
<li><p>Prepare Test data</p>
<pre><code class="lang-javascript"> // catalogues: name,description
 db.catalogues.insert([
 {name:&quot;Spring&quot;,description:&quot;spring framework&quot;},
 {name:&quot;ReactJS&quot;,description:&quot;reactJS front framework&quot;},
 {name:&quot;NoSql&quot;,description:&quot;not only sql databases&quot;}
 {name:&quot;Docker&quot;,description:&quot;Build, Ship, and Run Any App, Anywhere&quot;}
 ]);

 // articles: title,author,description,tags,catalogue,postDate,content
 db.articles.insert([
 {title:&quot;Spring Basic&quot;,author:&quot;Tom&quot;,description:&quot;introduce spring basic&quot;,tags:[&quot;java&quot;,&quot;spring&quot;],catalogueId:db.catalogues.findOne({name:&quot;Spring&quot;})._id,postDate:&quot;2015-01-01&quot;,content:&quot;spring basic:ioc,aop&quot;,click:1},
 {title:&quot;Spring MVC&quot;,author:&quot;Tom&quot;,description:&quot;introduce spring mvc&quot;,tags:[&quot;java&quot;,&quot;spring&quot;,&quot;mvc&quot;],catalogueId:db.catalogues.findOne({name:&quot;Spring&quot;})._id,postDate:&quot;2015-01-11&quot;,content:&quot;spring mvc:dispatchServlet,restful&quot;,click:5},
 {title:&quot;Spring Security&quot;,author:&quot;Tom&quot;,description:&quot;introduce spring security&quot;,tags:[&quot;java&quot;,&quot;spring&quot;,&quot;security&quot;],catalogueId:db.catalogues.findOne({name:&quot;Spring&quot;})._id,postDate:&quot;2015-01-21&quot;,content:&quot;spring security:securityFilter,authentication,accessDecide&quot;,click:20},
 {title:&quot;ReactJS Basic&quot;,author:&quot;Lucy&quot;,description:&quot;introduce reactJS front framework basic&quot;,tags:[&quot;front&quot;,&quot;reateJS&quot;],catalogueId:db.catalogues.findOne({name:&quot;ReactJS&quot;})._id,postDate:&quot;2015-02-01&quot;,content:&quot;reactJS basic:component,lifecycle,props,state&quot;,click:30},
 {title:&quot;ReactJS Flux&quot;,author:&quot;Lucy&quot;,description:&quot;introduce reactJS Flux&quot;,tags:[&quot;front&quot;,&quot;reateJS&quot;],catalogueId:db.catalogues.findOne({name:&quot;ReactJS&quot;})._id,postDate:&quot;2015-02-11&quot;,content:&quot;reactJS Flux:reflux,redux&quot;},
 {title:&quot;Redis&quot;,author:&quot;Jack&quot;,description:&quot;introduce redis key-value db&quot;,tags:[&quot;nosql&quot;,&quot;redis&quot;],catalogueId:db.catalogues.findOne({name:&quot;NoSql&quot;})._id,postDate:&quot;2015-03-11&quot;,content:&quot;redis:install,master-slave,persist,subscribe,crud&quot;,click:0},
 {title:&quot;MongoDB&quot;,author:&quot;Jack&quot;,description:&quot;introduce mongo document database&quot;,tags:[&quot;nosql&quot;,&quot;mongodb&quot;],catalogueId:db.catalogues.findOne({name:&quot;NoSql&quot;})._id,postDate:&quot;2015-03-21&quot;,content:&quot;mongodb:mongo shell,crud,index,aggregation,replica,sharding&quot;,click:25}
 ]);
</code></pre>
</li>
<li><p><code>$lookup</code>: Join</p>
<pre><code class="lang-bash"> # $lookup
 # {
 #      $lookup: {
 #           from: &lt;collection to join&gt;,
 #           localField: &lt;field from the input documents&gt;,
 #           foreignField: &lt;field from the documents of the &quot;from&quot; collection&gt;,
 #           as: &lt;output array field&gt;
 #      }
 # }
 &gt; db.catalogues.aggregate([ 
     {$project:{id:1,name:1}},
     { $lookup:{ from:&quot;articles&quot;, localField:&quot;_id&quot;, foreignField:&quot;catalogueId&quot; ,as:&quot;articles&quot;} },
     {$project:{&quot;_id&quot;:0,&quot;name&quot;:1,&quot;articles.title&quot;:1,&quot;articles.click&quot;:1}} 
 ])
 { &quot;name&quot; : &quot;Spring&quot;, &quot;articles&quot; : [ { &quot;title&quot; : &quot;Spring Basic&quot;, &quot;click&quot; : 1 }, { &quot;title&quot; : &quot;Spring MVC&quot;, &quot;click&quot; : 5 }, { &quot;title&quot; : &quot;Spring Security&quot;, &quot;click&quot; : 20 } ] }
 { &quot;name&quot; : &quot;ReactJS&quot;, &quot;articles&quot; : [ { &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;click&quot; : 30 }, { &quot;title&quot; : &quot;ReactJS Flux&quot; } ] }
 { &quot;name&quot; : &quot;NoSql&quot;, &quot;articles&quot; : [ { &quot;title&quot; : &quot;Redis&quot;, &quot;click&quot; : 0 }, { &quot;title&quot; : &quot;MongoDB&quot;, &quot;click&quot; : 25 } ] }
 { &quot;name&quot; : &quot;Docker&quot;, &quot;articles&quot; : [ ] }
</code></pre>
</li>
<li><p><code>$group</code> : 按照特定的字段的值进行分组（非流式运算:必须等收到所有的文档之后，才能对文档进行处理）</p>
<pre><code class="lang-bash"> &gt; db.articles.count()
 7

 # 1. $sum
 # select count(*) as count from articles;
 &gt; db.articles.aggregate([
     { $group:{_id:&quot;null&quot;,count:{$sum:1}} }
 ])
 { &quot;_id&quot; : &quot;null&quot;, &quot;count&quot; : 7 }

 # select catalogueId as _id,count(*) as count as from articles group by catalogueId
 &gt; db.articles.aggregate([
     { $group:{_id:&quot;$catalogueId&quot;,count:{$sum:1}} }
 ])
 { &quot;_id&quot; : ObjectId(&quot;5b8e342212b995b45c17d5ec&quot;), &quot;count&quot; : 2 }
 { &quot;_id&quot; : ObjectId(&quot;5b8e342212b995b45c17d5eb&quot;), &quot;count&quot; : 2 }
 { &quot;_id&quot; : ObjectId(&quot;5b8e342212b995b45c17d5ea&quot;), &quot;count&quot; : 3 }

 # select author as _id, sum(click) as total_click from articles group by author
 &gt; db.articles.aggregate([
     { $group:{_id:&quot;$author&quot;,total_click:{$sum:&quot;$click&quot;}} }
 ])
 { &quot;_id&quot; : &quot;Lucy&quot;, &quot;total_click&quot; : 30 }
 { &quot;_id&quot; : &quot;Jack&quot;, &quot;total_click&quot; : 25 }
 { &quot;_id&quot; : &quot;Tom&quot;, &quot;total_click&quot; : 26 }

 # 2. $max/$min
 # select author as _id, max(click) as max_click from articles group by author
 &gt; db.articles.aggregate([
     { $group:{_id:&quot;$author&quot;,max_click:{$max:&quot;$click&quot;}} }
 ]) 
 { &quot;_id&quot; : &quot;Lucy&quot;, &quot;max_click&quot; : 30 }
 { &quot;_id&quot; : &quot;Jack&quot;, &quot;max_click&quot; : 25 }
 { &quot;_id&quot; : &quot;Tom&quot;, &quot;max_click&quot; : 20 }

 # 3. $avg
 # select author as _id, avg(click) as avg_click from articles group by author
 &gt; db.articles.aggregate([
     { $group:{_id:&quot;$author&quot;,avg_click:{$avg:&quot;$click&quot;}} }
 ]) 
 { &quot;_id&quot; : &quot;Lucy&quot;, &quot;avg_click&quot; : 30 }
 { &quot;_id&quot; : &quot;Jack&quot;, &quot;avg_click&quot; : 12.5 }
 { &quot;_id&quot; : &quot;Tom&quot;, &quot;avg_click&quot; : 8.666666666666666 }

 # 4. $first/$last
 &gt; db.articles.aggregate([
     { $group:{_id:&quot;$author&quot;,click_list:{$first:&quot;$click&quot;}} }
 ]) 
 { &quot;_id&quot; : &quot;Lucy&quot;, &quot;click_list&quot; : 30 }
 { &quot;_id&quot; : &quot;Jack&quot;, &quot;click_list&quot; : 0 }
 { &quot;_id&quot; : &quot;Tom&quot;, &quot;click_list&quot; : 1 }

 # 5. $push/$addToSet
 &gt; db.articles.aggregate([
     { $group:{_id:&quot;$author&quot;,click_list:{$push:&quot;$click&quot;}} }
 ]) 
 { &quot;_id&quot; : &quot;Lucy&quot;, &quot;click_list&quot; : [ 30 ] }
 { &quot;_id&quot; : &quot;Jack&quot;, &quot;click_list&quot; : [ 0, 25 ] }
 { &quot;_id&quot; : &quot;Tom&quot;, &quot;click_list&quot; : [ 1, 5, 20 ] }
</code></pre>
</li>
<li><p><code>$match</code> 过滤（尽量放在前面，提高效率）</p>
<pre><code class="lang-bash"> # select _id,title,author from articles where click&gt;0 and click&lt;25
 db.articles.aggregate([
     { $match:{click:{$gt:0,$lt:25}} },
     { $project:{&quot;_id&quot;:0,&quot;title&quot;:1,&quot;author&quot;:1,&quot;click&quot;:1}}
 ]) 
 { &quot;title&quot; : &quot;Spring Basic&quot;, &quot;author&quot; : &quot;Tom&quot;, &quot;click&quot; : 1 }
 { &quot;title&quot; : &quot;Spring MVC&quot;, &quot;author&quot; : &quot;Tom&quot;, &quot;click&quot; : 5 }
 { &quot;title&quot; : &quot;Spring Security&quot;, &quot;author&quot; : &quot;Tom&quot;, &quot;click&quot; : 20 }

 # select author as _id,sum(click) as total_click from articles group by author having sum(click)&gt;0 and sum(click)&lt;30
 db.articles.aggregate([
     { $group:{_id:&quot;$author&quot;,total_click:{$sum:&quot;$click&quot;} } },
     { $match:{total_click:{$gt:0,$lt:30}} }
 ]) 
 { &quot;_id&quot; : &quot;Jack&quot;, &quot;total_click&quot; : 25 }
 { &quot;_id&quot; : &quot;Tom&quot;, &quot;total_click&quot; : 26 }
</code></pre>
</li>
<li><p><code>$project</code>: 选择字段，重命名字段，派生字段    </p>
<pre><code class="lang-bash"> # 选择字段: field:1/0，表示选择/不选择 field；将无用的字段从pipeline中过滤掉，能够减少聚合操作对内存的消耗
 &gt; db.articles.aggregate([
     { $project:{&quot;_id&quot;:0,&quot;title&quot;:1,&quot;postData&quot;:1,&quot;click&quot;:1,&quot;tags&quot;:1} }
 ])
 { &quot;title&quot; : &quot;Spring Basic&quot;, &quot;tags&quot; : [ &quot;java&quot;, &quot;spring&quot; ], &quot;click&quot; : 1 }
 { &quot;title&quot; : &quot;Spring MVC&quot;, &quot;tags&quot; : [ &quot;java&quot;, &quot;spring&quot;, &quot;mvc&quot; ], &quot;click&quot; : 5 }
 { &quot;title&quot; : &quot;Spring Security&quot;, &quot;tags&quot; : [ &quot;java&quot;, &quot;spring&quot;, &quot;security&quot; ], &quot;click&quot; : 20 }
 { &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;tags&quot; : [ &quot;front&quot;, &quot;reateJS&quot; ], &quot;click&quot; : 30 }
 { &quot;title&quot; : &quot;ReactJS Flux&quot;, &quot;tags&quot; : [ &quot;front&quot;, &quot;reateJS&quot; ] }
 { &quot;title&quot; : &quot;Redis&quot;, &quot;tags&quot; : [ &quot;nosql&quot;, &quot;redis&quot; ], &quot;click&quot; : 0 }
 { &quot;title&quot; : &quot;MongoDB&quot;, &quot;tags&quot; : [ &quot;nosql&quot;, &quot;mongodb&quot; ], &quot;click&quot; : 25 }

 # 重命名字段: 引用符$，格式是：&quot;$field&quot;，表示引用doc中 field 的值
 &gt; db.articles.aggregate([
     { $project:{_id:0,title:1,&quot;preClick&quot;:&quot;$click&quot;} }
 ])
 { &quot;title&quot; : &quot;Spring Basic&quot;, &quot;preClick&quot; : 1 }
 { &quot;title&quot; : &quot;Spring MVC&quot;, &quot;preClick&quot; : 5 }
 { &quot;title&quot; : &quot;Spring Security&quot;, &quot;preClick&quot; : 20 }
 { &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;preClick&quot; : 30 }
 { &quot;title&quot; : &quot;ReactJS Flux&quot; }
 { &quot;title&quot; : &quot;Redis&quot;, &quot;preClick&quot; : 0 }
 { &quot;title&quot; : &quot;MongoDB&quot;, &quot;preClick&quot; : 25 }

 # 派生字段: 对字段进行计算，派生出一个新的字段
 &gt; db.articles.aggregate([
     { $project:{
         &quot;title&quot;:1,
         &quot;click&quot;:1,
         &quot;result&quot;: { $or: [ { $gt: [ &quot;$click&quot;, 20 ] }, { $lt: [ &quot;$click&quot;, 100 ] } ] }
       } 
     }
 ])
 { &quot;_id&quot; : ObjectId(&quot;5be2b3347ec0ecb208b54816&quot;), &quot;title&quot; : &quot;Spring Basic&quot;, &quot;click&quot; : 1, &quot;result&quot; : true }
 { &quot;_id&quot; : ObjectId(&quot;5be2b3347ec0ecb208b54817&quot;), &quot;title&quot; : &quot;Spring MVC&quot;, &quot;click&quot; : 5, &quot;result&quot; : true }
 { &quot;_id&quot; : ObjectId(&quot;5be2b3347ec0ecb208b54818&quot;), &quot;title&quot; : &quot;Spring Security&quot;, &quot;click&quot; : 20, &quot;result&quot; : true }
 { &quot;_id&quot; : ObjectId(&quot;5be2b3347ec0ecb208b54819&quot;), &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;click&quot; : 30, &quot;result&quot; : true }
 { &quot;_id&quot; : ObjectId(&quot;5be2b3347ec0ecb208b5481a&quot;), &quot;title&quot; : &quot;ReactJS Flux&quot;, &quot;result&quot; : true }
 { &quot;_id&quot; : ObjectId(&quot;5be2b3347ec0ecb208b5481b&quot;), &quot;title&quot; : &quot;Redis&quot;, &quot;click&quot; : 0, &quot;result&quot; : true }
 { &quot;_id&quot; : ObjectId(&quot;5be2b3347ec0ecb208b5481c&quot;), &quot;title&quot; : &quot;MongoDB&quot;, &quot;click&quot; : 25, &quot;result&quot; : true }

 # 派生字段
 &gt; db.articles.aggregate([
     { $project:{
         _id:0,
         title:1,
         click:1,
         level: { $cond:{if:{$gte:[&quot;$click&quot;,20]},then: &quot;High&quot;,else: &quot;Low&quot;} }
      } 
     }
 ])
 { &quot;title&quot; : &quot;Spring Basic&quot;, &quot;click&quot; : 1, &quot;level&quot; : &quot;Low&quot; }
 { &quot;title&quot; : &quot;Spring MVC&quot;, &quot;click&quot; : 5, &quot;level&quot; : &quot;Low&quot; }
 { &quot;title&quot; : &quot;Spring Security&quot;, &quot;click&quot; : 20, &quot;level&quot; : &quot;High&quot; }
 { &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;click&quot; : 30, &quot;level&quot; : &quot;High&quot; }
 { &quot;title&quot; : &quot;ReactJS Flux&quot;, &quot;level&quot; : &quot;Low&quot; }
 { &quot;title&quot; : &quot;Redis&quot;, &quot;click&quot; : 0, &quot;level&quot; : &quot;Low&quot; }
 { &quot;title&quot; : &quot;MongoDB&quot;, &quot;click&quot; : 25, &quot;level&quot; : &quot;High&quot; }
</code></pre>
</li>
<li><p><code>$limit</code>,<code>$skip</code>,<code>$sort</code></p>
<pre><code class="lang-bash"> &gt; db.articles.aggregate([
     {$skip:2},
     {$limit:3},
     {$sort:{&quot;postDate&quot;:1}},
     {$project:{&quot;_id&quot;:0,&quot;title&quot;:1,&quot;postDate&quot;:1}}
 ])
 { &quot;title&quot; : &quot;Spring Security&quot;, &quot;postDate&quot; : &quot;2015-01-21&quot; }
 { &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;postDate&quot; : &quot;2015-02-01&quot; }
 { &quot;title&quot; : &quot;ReactJS Flux&quot;, &quot;postDate&quot; : &quot;2015-02-11&quot; }

 &gt; db.articles.aggregate([
     {$sort:{&quot;postDate&quot;:1}},
     {$limit:3},
     {$skip:2},
     {$project:{&quot;_id&quot;:0,&quot;title&quot;:1,&quot;postDate&quot;:1}}
 ])
 { &quot;title&quot; : &quot;Spring Security&quot;, &quot;postDate&quot; : &quot;2015-01-21&quot; }
</code></pre>
</li>
<li><p><code>$unwind</code>: 拆分数组字段</p>
<pre><code class="lang-bash"> &gt; db.articles.aggregate([
     {$project:{&quot;_id&quot;:0,&quot;title&quot;:1,&quot;tags&quot;:1}},
     {$unwind:&quot;$tags&quot;}
 ])
 { &quot;title&quot; : &quot;Spring Basic&quot;, &quot;tags&quot; : &quot;java&quot; }
 { &quot;title&quot; : &quot;Spring Basic&quot;, &quot;tags&quot; : &quot;spring&quot; }
 { &quot;title&quot; : &quot;Spring MVC&quot;, &quot;tags&quot; : &quot;java&quot; }
 { &quot;title&quot; : &quot;Spring MVC&quot;, &quot;tags&quot; : &quot;spring&quot; }
 { &quot;title&quot; : &quot;Spring MVC&quot;, &quot;tags&quot; : &quot;mvc&quot; }
 { &quot;title&quot; : &quot;Spring Security&quot;, &quot;tags&quot; : &quot;java&quot; }
 { &quot;title&quot; : &quot;Spring Security&quot;, &quot;tags&quot; : &quot;spring&quot; }
 { &quot;title&quot; : &quot;Spring Security&quot;, &quot;tags&quot; : &quot;security&quot; }
 { &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;tags&quot; : &quot;front&quot; }
 { &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;tags&quot; : &quot;reateJS&quot; }
 { &quot;title&quot; : &quot;ReactJS Flux&quot;, &quot;tags&quot; : &quot;front&quot; }
 { &quot;title&quot; : &quot;ReactJS Flux&quot;, &quot;tags&quot; : &quot;reateJS&quot; }
 { &quot;title&quot; : &quot;Redis&quot;, &quot;tags&quot; : &quot;nosql&quot; }
 { &quot;title&quot; : &quot;Redis&quot;, &quot;tags&quot; : &quot;redis&quot; }
 { &quot;title&quot; : &quot;MongoDB&quot;, &quot;tags&quot; : &quot;nosql&quot; }
 { &quot;title&quot; : &quot;MongoDB&quot;, &quot;tags&quot; : &quot;mongodb&quot; }
</code></pre>
<ul>
<li>参数数组字段为空或不存在时，待处理的文档将会被忽略，该文档将不会有任何输出</li>
<li>参数不是一个数组类型时，将会抛出异常</li>
</ul>
</li>
<li><p><code>$out</code>: 把执行的结果写入指定数据表(会先清空原数据)</p>
<pre><code class="lang-bash"> &gt; db.articles.aggregate([
     { $group:{_id:&quot;$author&quot;,total_click:{$sum:&quot;$click&quot;}} },
     { $out:&quot;author_click&quot; }
 ])
 &gt; db.author_click.find()
 { &quot;_id&quot; : &quot;Lucy&quot;, &quot;total_click&quot; : 30 }
 { &quot;_id&quot; : &quot;Jack&quot;, &quot;total_click&quot; : 25 }
 { &quot;_id&quot; : &quot;Tom&quot;, &quot;total_click&quot; : 26 }

 &gt; db.articles.aggregate([
     { $group:{_id:&quot;$author&quot;,total_click:{$sum:&quot;$click&quot;}} },
     { $project:{&quot;_id&quot;:0}},
     { $limit:2},
     { $out:&quot;author_click&quot; }
 ])
 &gt; db.author_click.find()
 { &quot;_id&quot; : ObjectId(&quot;5be3a0ec58072db74ca83569&quot;), &quot;total_click&quot; : 30 }
 { &quot;_id&quot; : ObjectId(&quot;5be3a0ec58072db74ca8356a&quot;), &quot;total_click&quot; : 25 }
</code></pre>
</li>
<li><p>options:<code>explain</code> 返回aggregate各个阶段管道的执行计划信息</p>
<pre><code class="lang-bash"> &gt; db.articles.aggregate([
     { $group:{_id:&quot;$author&quot;,click_list:{$push:&quot;$click&quot;}} }
 ]) 
 { &quot;_id&quot; : &quot;Lucy&quot;, &quot;click_list&quot; : [ 30 ] }
 { &quot;_id&quot; : &quot;Jack&quot;, &quot;click_list&quot; : [ 0, 25 ] }
 { &quot;_id&quot; : &quot;Tom&quot;, &quot;click_list&quot; : [ 1, 5, 20 ] }

 &gt; db.articles.aggregate([
     { $group:{_id:&quot;$author&quot;,click_list:{$push:&quot;$click&quot;}} }
 ],{explain:true})
 {
     &quot;stages&quot; : [
             {
                     &quot;$cursor&quot; : {
                             &quot;query&quot; : {

                             },
                             &quot;fields&quot; : {
                                     &quot;author&quot; : 1,
                                     &quot;click&quot; : 1,
                                     &quot;_id&quot; : 0
                             },
                             &quot;queryPlanner&quot; : {
                                     &quot;plannerVersion&quot; : 1,
                                     &quot;namespace&quot; : &quot;demo.articles&quot;,
                                     &quot;indexFilterSet&quot; : false,
                                     &quot;parsedQuery&quot; : {

                                     },
                                     &quot;winningPlan&quot; : {
                                             &quot;stage&quot; : &quot;COLLSCAN&quot;,
                                             &quot;direction&quot; : &quot;forward&quot;
                                     },
                                     &quot;rejectedPlans&quot; : [ ]
                             }
                     }
             },
             {
                     &quot;$group&quot; : {
                             &quot;_id&quot; : &quot;$author&quot;,
                             &quot;click_list&quot; : {
                                     &quot;$push&quot; : &quot;$click&quot;
                             }
                     }
             }
     ],
     &quot;ok&quot; : 1
 }
</code></pre>
</li>
</ol>
<h3 id="header-28">Map-Reduce</h3>
<ul>
<li>是一种计算模型（能够在多台Server上并行执行），将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）</li>
<li>分为两个阶段:Map和Reduce；主要分为三步：Map，Shuffle，Reduce<ul>
<li>Map: 将操作映射到每条document，产生key和value。eg：Map一个document产生key value对：<code>{female,{count:1}}</code>,<code>{male,{count:1}}</code></li>
<li>Shuffle: 按照key进行分组，并将key相同的value组合成数组。eg：产生<code>(female:[{count:1},{count:1},...])</code>,<code>(male:[{count:1},{count:1},...])</code></li>
<li>Reduce: 把Value数组化简为单值(聚合运算统计)。eg：<code>(female:{count:20})</code>,<code>(male:{count:15})</code></li>
<li>注：Map和Reduce需要显式定义，shuffle由MongoDB来实现</li>
</ul>
</li>
</ul>
<p><img src="/2018/08/04/map-reduce.png" alt="map-reduce"></p>
<pre><code class="lang-javascript">db.collection.mapReduce(
     &lt;map&gt;,                            // map 映射函数,生成键值对 (遍历 collection,调用emit(key, value))
     &lt;reduce&gt;,                        // reduce 统计函数 (key-values -&gt; key-value,把values数组变成一个单一的值value)
     {
       out: &lt;collection&gt;,            // 存放统计结果 (不指定则使用临时集合,在客户端断开后自动删除)
       query: &lt;document&gt;,            // 一个筛选条件，只有满足条件的文档才会调用map函数
       sort: &lt;document&gt;,            // 发往map函数前给文档排序
       limit: &lt;number&gt;,                // 发往map函数的文档数量的上限
       finalize: &lt;function&gt;,
       scope: &lt;document&gt;,
       jsMode: &lt;boolean&gt;,
       verbose: &lt;boolean&gt;,
       bypassDocumentValidation: &lt;boolean&gt;
     }
)
</code></pre>
<p><strong> 示例：</strong></p>
<pre><code class="lang-bash">&gt; db.articles.find({},{&quot;_id&quot;:0,&quot;title&quot;:1,&quot;author&quot;:1,&quot;click&quot;:1,&quot;tags&quot;:1})
{ &quot;title&quot; : &quot;Spring Basic&quot;, &quot;author&quot; : &quot;Tom&quot;, &quot;tags&quot; : [ &quot;java&quot;, &quot;spring&quot; ], &quot;click&quot; : 1 }
{ &quot;title&quot; : &quot;Spring MVC&quot;, &quot;author&quot; : &quot;Tom&quot;, &quot;tags&quot; : [ &quot;java&quot;, &quot;spring&quot;, &quot;mvc&quot; ], &quot;click&quot; : 5 }
{ &quot;title&quot; : &quot;Spring Security&quot;, &quot;author&quot; : &quot;Tom&quot;, &quot;tags&quot; : [ &quot;java&quot;, &quot;spring&quot;, &quot;security&quot; ], &quot;click&quot; : 20 }
{ &quot;title&quot; : &quot;ReactJS Basic&quot;, &quot;author&quot; : &quot;Lucy&quot;, &quot;tags&quot; : [ &quot;front&quot;, &quot;reateJS&quot; ], &quot;click&quot; : 30 }
{ &quot;title&quot; : &quot;ReactJS Flux&quot;, &quot;author&quot; : &quot;Lucy&quot;, &quot;tags&quot; : [ &quot;front&quot;, &quot;reateJS&quot; ] }
{ &quot;title&quot; : &quot;Redis&quot;, &quot;author&quot; : &quot;Jack&quot;, &quot;tags&quot; : [ &quot;nosql&quot;, &quot;redis&quot; ], &quot;click&quot; : 0 }
{ &quot;title&quot; : &quot;MongoDB&quot;, &quot;author&quot; : &quot;Jack&quot;, &quot;tags&quot; : [ &quot;nosql&quot;, &quot;mongodb&quot; ], &quot;click&quot; : 25 }

# 1. 各author的click大于0的文章总数
&gt; db.articles.mapReduce(
    function(){emit(this.author,1)},
    function(key,values){return Array.sum(values)},
    {query:{click:{$gt:0}},out: &quot;author_sum&quot;}
)
{
        &quot;result&quot; : &quot;author_sum&quot;,            // 储存结果的collection的名字
        &quot;timeMillis&quot; : 122,                    // 执行花费的时间，毫秒为单位
        &quot;counts&quot; : {
                &quot;input&quot; : 5,                // 满足条件被发送到map函数的文档个数
                &quot;emit&quot; : 5,                    // 在map函数中emit被调用的次数，也就是所有集合中的数据总量
                &quot;reduce&quot; : 1,                // reduce函数调用次数
                &quot;output&quot; : 3                // 结果集合中的文档个数
        },
        &quot;ok&quot; : 1                            // 是否成功，成功为1
}
&gt; db.author_sum.find()
{ &quot;_id&quot; : &quot;Jack&quot;, &quot;value&quot; : 1 }
{ &quot;_id&quot; : &quot;Lucy&quot;, &quot;value&quot; : 1 }
{ &quot;_id&quot; : &quot;Tom&quot;, &quot;value&quot; : 3 }

# 2. 各author文章的平均点击数
&gt; db.articles.mapReduce(
    function(){emit(this.author,{click:this.click||0,article:1})},
    function(key,values){ 
        reducedVal={sum_click:0,sum_article:0};
        values.forEach(function(item){
            reducedVal.sum_click+=item.click;
            reducedVal.sum_article+=item.article;
        })
        return reducedVal.sum_click/reducedVal.sum_article;
    },
    {out:&quot;author_sum&quot;}
)
{
        &quot;result&quot; : &quot;author_sum&quot;,
        &quot;timeMillis&quot; : 241,
        &quot;counts&quot; : {
                &quot;input&quot; : 7,
                &quot;emit&quot; : 7,
                &quot;reduce&quot; : 3,
                &quot;output&quot; : 3
        },
        &quot;ok&quot; : 1
}
&gt; db.author_sum.find()
{ &quot;_id&quot; : &quot;Jack&quot;, &quot;value&quot; : 12.5 }
{ &quot;_id&quot; : &quot;Lucy&quot;, &quot;value&quot; : 15 }
{ &quot;_id&quot; : &quot;Tom&quot;, &quot;value&quot; : 8.666666666666666 }
</code></pre>
<h3 id="header-29">单目聚合操作</h3>
<p><img src="/2018/08/04/distinct.png" alt="distinct"></p>
<ol>
<li><p>count: <code>db.collection.count(query, options)</code></p>
<pre><code class="lang-bash"> &gt; db.articles.count()
 7
 &gt; db.articles.count({click:{$gt:10}})
 3
 &gt; db.articles.count({click:{$gt:10},tags:{$size:2}})
 2
 &gt; db.articles.find({click:{$gt:10},tags:{$size:2}}).count()
 2
</code></pre>
</li>
<li><p>distinct: <code>db.collection.distinct(field, query, options)</code></p>
<pre><code class="lang-bash"> &gt; db.articles.distinct(&quot;click&quot;)
 [ 1, 5, 20, 30, 0, 25 ]

 &gt; db.articles.distinct(&quot;tags&quot;)
 [&quot;java&quot;,&quot;spring&quot;,&quot;mvc&quot;,&quot;security&quot;,&quot;front&quot;,&quot;reateJS&quot;,&quot;nosql&quot;,&quot;redis&quot;,&quot;mongodb&quot;]

 &gt; db.articles.distinct(&quot;tags&quot;,{click:{$gt:20}})
 [ &quot;front&quot;, &quot;reateJS&quot;, &quot;mongodb&quot;, &quot;nosql&quot; ]
</code></pre>
</li>
</ol>
<h2 id="header-30">Security</h2>
<p>安全:</p>
<ul>
<li>物理隔离（最安全）</li>
<li>网络隔离</li>
<li>IP白名单隔离（防火墙配置等）</li>
<li>用户名密码鉴权</li>
</ul>
<p>开启权限认证:</p>
<ul>
<li>auth开启<pre><code class="lang-bash">  &gt; vim conf/mongod.conf
  ...
  auth = true
</code></pre>
</li>
<li>keyfile开启</li>
</ul>
<p><strong> 操作：</strong></p>
<ol>
<li><p>查看用户<code>db.getUsers()</code>，查看角色<code>db.getRoles()</code></p>
<pre><code class="lang-bash"> &gt; use admin
 switched to db admin
 &gt; db.getUsers()
 [
     {
             &quot;_id&quot; : &quot;admin.mongoadmin&quot;,
             &quot;user&quot; : &quot;mongoadmin&quot;,
             &quot;db&quot; : &quot;admin&quot;,
             &quot;roles&quot; : [
                     {
                             &quot;role&quot; : &quot;root&quot;,
                             &quot;db&quot; : &quot;admin&quot;
                     }
             ],
             &quot;mechanisms&quot; : [
                     &quot;SCRAM-SHA-1&quot;,
                     &quot;SCRAM-SHA-256&quot;
             ]
     }
 ]
 &gt; db.getRoles()
 [ ]
</code></pre>
</li>
<li><p>创建用户<code>db.createUser</code> (role内建类型：read,readWrite,dbAdmin,dbOwner,userAdmin)</p>
<pre><code class="lang-bash"> &gt; db.createUser({
     user:&quot;cj&quot;,
     pwd:&quot;123&quot;,
     roles:[
         {role:&quot;userAdmin&quot;,db:&quot;demo&quot;},
         {role:&quot;read&quot;,db:&quot;local&quot;}
     ]
 })
 &gt; mongo localhost:12345 -u cj -p 123
 &gt; use testdb
 &gt; show tables
</code></pre>
</li>
<li><p>创建角色<code>db.createRole</code></p>
<pre><code class="lang-bash"> # 用户角色：
 # 数据库角色（read,readWrite,dbAdmin,dbOwner,userAdmin)
 # 集群角色（clusterAdmin,clusterManager,...）
 # 备份角色（backup,restore,...）
 # 其他特殊权限（DBAdminAnyDatabase,...）
 &gt; db.createRole({
     role:&quot;appUser&quot;,
     db:&quot;myApp&quot;
     privileges:[
         {
             resource:{db:&quot;myApp&quot;,collection:&quot; &quot;},
             actions:[&quot;find&quot;,&quot;createCollection&quot;,&quot;dbStates&quot;,&quot;collStats&quot;]
         },
         {
             resource:{db:&quot;myApp&quot;,collection:&quot;logs&quot;},
             actions:[&quot;insert&quot;]
         },
         {
             resource:{db:&quot;myApp&quot;,collection:&quot;data&quot;},
             actions:[&quot;insert&quot;,&quot;update&quot;,&quot;remove&quot;,&quot;compact&quot;]
         },
         {
             resource:{db:&quot;myApp&quot;,collection:&quot;system.indexes&quot;},
             actions:[&quot;find&quot;]
         }
     ],
     roles:[]
 })
</code></pre>
</li>
</ol>
<h2 id="header-31">复制集 &amp; 分片</h2>
<ol>
<li>复制集 Replica Set （纵向）: 基于领导（Leader-based）复制状态机 (关键：选举和数据复制)</li>
<li>分片 Sharding（横向）：将数据进行拆分，水平的分散到不同的服务器上；架构上：读写均衡，去中心化</li>
<li>分片与复制集集群对比<table class="table">
<thead>
<tr>
<th style="text-align:left">-</th>
<th style="text-align:left">Shard</th>
<th style="text-align:left">Replication</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">实现意义|提升并发性能，提高大量数据随机访问性能|数据冗余，提升读性能</td>
</tr>
<tr>
<td style="text-align:left">架构上|水平化|中心化</td>
</tr>
<tr>
<td style="text-align:left">实现原理|数据打散分布|数据镜像</td>
</tr>
<tr>
<td style="text-align:left">维护成本|相对较高|相对容易</td>
</tr>
</tbody>
</table>
</li>
</ol>
<p><strong> More about Sharding </strong></p>
<ol>
<li><p>分片成员节点：
 <img src="/2018/08/04/sharding-nodes.png" alt="Sharding nodes"></p>
<ul>
<li><code>Shard节点</code>： 存储数据的节点（单个mongod或者副本集） <code>mongod --shardsvr --rpelSet</code></li>
<li><code>Config Server</code>：存储元数据，为mongos服务，将数据路由到Shard <code>mongod --configsvr</code></li>
<li><code>Query routers</code>: 查询路由节点，即<code>Mongos</code>节点，接入Client请求，根据路由规则转发给合适的shard或者shards <code>mongos --configdb &lt;configdb server&gt;</code></li>
</ul>
</li>
<li><p>概念：</p>
<ol>
<li>分片片键（Shard Key）：集合里面选个键，用该键的值作为数据拆分的依据,例如配置<code>sh.shardCollection(&quot;records.people&quot;, {user_id:&quot;hashed&quot;})</code></li>
<li>数据块（Chunk）：mongodb分片后，存储数据的单元块，默认大小为64M</li>
<li>拆分 （Split Chunk）：一个后台进程避免chunk增长的过大，当chunk尺寸超过指定的chunk size时，拆分此chunk（split后shard将会修改config server上这个chunk的metadata元信息）</li>
<li>平衡 （Balancing Chunks）：一个后台线程用于对chunks迁移以达到平衡，会周期性的检查分片是否存在不均衡，如果存在则会进行块的迁移（balancer均衡器运行在mongos上，注：balancer进行均衡的条件是块数量的多少，而不是块大小）</li>
<li>拆分－&gt;平衡过程：
 <img src="/2018/08/04/sharding-spliting.png" alt="Spliting">
 <img src="/2018/08/04/sharding-balancing.png" alt="Balancing"></li>
</ol>
</li>
<li><p>Sharding Strategy：</p>
<ul>
<li>Hashed Sharding（哈希切片) : 能将写入均衡分布到各个 shard</li>
<li>Ranged Sharding（范围切片）: 能很好的支持基于 shard key的范围查询</li>
<li>Tag aware Sharding</li>
<li>好的shard key：<ul>
<li>key分布足够离散 sufficient cardinality: 片键相同导致数据块不拆分，容易形成大的数据块，导致数据不均</li>
<li>写请求均匀分布 （evenly distributed write）: 例如单调递增的<code>_id</code>或者时间戳作为片键，会导致一直往最后一个复本集添加数据</li>
<li>尽量避免 scatter-gather 查询 （targeted read） </li>
</ul>
</li>
</ul>
</li>
<li><p>添加分片过程：</p>
<ol>
<li>连接到mongos</li>
<li>Add Shards</li>
<li>Enable Sharding</li>
<li>对一个Collection进行分片    </li>
</ol>
</li>
<li><p>示例：手动分片（减少自动平衡过程带来的IO等资源消耗，前提：充分了解数据，对数据进行预先划分）</p>
<pre><code class="lang-bash"> # 关闭自动平衡 auto balance    
 sh.stopBalancer()    # Currently enabled: no

 # 分片切割 spliting
 &gt; use admin
 &gt; db.runCommand({&quot;enablesharding&quot;:&quot;myapp&quot;})
 &gt; db.runCommand({&quot;shardcollection&quot;:&quot;myapp.users&quot;,&quot;key&quot;:{&quot;email&quot;:1}})

 for(var x=97;x&lt;97+26;x++){
     for(var y=97;y&lt;97+26;y+=6){
         var prefix=String.fromCharCode(x)+String.fromCharCode(y);
         db.runCommand({split:&quot;myapp.users&quot;,middle:{email:prefix}})
     }
 }

 # 手动移动分割块 balancing
 var shServer=[
     &quot;ShardServer 1&quot;,
     &quot;ShardServer 2&quot;,
     &quot;ShardServer 3&quot;,
     &quot;ShardServer 4&quot;,
     &quot;ShardServer 5&quot;
 ]
 for(var x=97;x&lt;97+26;x++){
     for(var y=97;y&lt;97+26;y+=6){
         var prefix=String.fromCharCode(x)+String.fromCharCode(y);
         db.adminCommand({moveChunk:&quot;myapp.users&quot;,find:{email:prefix},to:shServer[(y-97)/6]})
     }
 }

 # 循环(y-97)/6的数值结果为0，6，12，18，24； shServer[0] -&gt; shServer[4]
</code></pre>
</li>
</ol>
<h2 id="header-32">MongoDB 4.0 新特性</h2>
<ol>
<li><p>多文档事务</p>
<ul>
<li>4.0: 单文档事务 -&gt; 跨文档事务</li>
<li>4.2: 复制集事务 -&gt; 分片集群事务</li>
</ul>
</li>
<li><p>聚合类型转换: 引入<code>$convert</code>聚合操作符来简化ETL（抽取，转化，加载）流程和负荷</p>
<ul>
<li>可结合:<pre><code class="lang-bash">  # 1. 类型转换
  $toBool,$toDate,$toDecimal,$toDouble,$toInt,$toLong,$toObjectId,$toString
  # 2. 日期操作转换
  $dateToParts,$dateFromParts,$dateFromString
  # 3. 修剪
  $trim,$rtrim,$ltrim
  {$trim:{input:&lt;expression&gt;}}
  {$trim:{input:[&lt;expression&gt;],chars:&lt;string&gt;}}
</code></pre>
</li>
<li>prepare test data:<pre><code class="lang-bash">  &gt; db.address.insert([
      { street: &quot;Canal st&quot;, building: NumberDecimal(21), _id: 0},
      { street: &quot;43rd st&quot;, building: &quot;229&quot;, _id: 1},
      { street: &quot;Fulton st&quot;, building: &quot;31&quot;, _id: 2 },
      { street: &quot;52nd st&quot;, building: &quot;11w&quot;, _id: 3}, 
      { street: &quot;78th st&quot;, building: null, _id: 4}, 
      { street: &quot;78th st&quot;,  _id: 5}, 
      { street: &quot;Rector st&quot;, building: NumberInt(10), _id: 6,last_visited: {year: 2017, month: 10}}
  ]);
</code></pre>
</li>
<li><code>$convert</code>示例：<pre><code class="lang-bash">  &gt; db.address.aggregate( [
    {
      $addFields: {
        building: {
          $convert: {
            input: &quot;$building&quot;,
            to: &quot;int&quot;,
            onError: 0,
            onNull: -1
          }
        }
      }
    },
    { $sort: {building: 1}}
  ]);
  { &quot;_id&quot; : 4, &quot;street&quot; : &quot;78th st&quot;, &quot;building&quot; : -1 }
  { &quot;_id&quot; : 5, &quot;street&quot; : &quot;78th st&quot;, &quot;building&quot; : -1 }
  { &quot;_id&quot; : 3, &quot;street&quot; : &quot;52nd st&quot;, &quot;building&quot; : 0 }
  { &quot;_id&quot; : 6, &quot;street&quot; : &quot;Rector st&quot;, &quot;building&quot; : 10, &quot;last_visited&quot; : { &quot;year&quot; : 2017, &quot;month&quot; : 10 } }
  { &quot;_id&quot; : 0, &quot;street&quot; : &quot;Canal st&quot;, &quot;building&quot; : 21 }
  { &quot;_id&quot; : 2, &quot;street&quot; : &quot;Fulton st&quot;, &quot;building&quot; : 31 }
  { &quot;_id&quot; : 1, &quot;street&quot; : &quot;43rd st&quot;, &quot;building&quot; : 229 }
</code></pre>
</li>
<li><code>$dateFromParts</code>示例：<pre><code class="lang-bash">  # Add 15 months to month date field:
  &gt; db.address.aggregate([
    {
      $addFields: {
        next_visit: {
            $convert:{
              input: {
                $dateFromParts: {
                  year: &quot;$last_visited.year&quot;,
                  month: {$add:[15, &quot;$last_visited.month&quot;]},
                }},
              to: &quot;date&quot;,
              onNull: &quot;&quot;,
              onError: &quot;&quot;
          }
        }
      }
    }
  ]);
  { &quot;_id&quot; : 0, &quot;street&quot; : &quot;Canal st&quot;, &quot;building&quot; : NumberDecimal(&quot;21.0000000000000&quot;), &quot;next_visit&quot; : &quot;&quot; }
  { &quot;_id&quot; : 1, &quot;street&quot; : &quot;43rd st&quot;, &quot;building&quot; : &quot;229&quot;, &quot;next_visit&quot; : &quot;&quot; }
  { &quot;_id&quot; : 2, &quot;street&quot; : &quot;Fulton st&quot;, &quot;building&quot; : &quot;31&quot;, &quot;next_visit&quot; : &quot;&quot; }
  { &quot;_id&quot; : 3, &quot;street&quot; : &quot;52nd st&quot;, &quot;building&quot; : &quot;11w&quot;, &quot;next_visit&quot; : &quot;&quot; }
  { &quot;_id&quot; : 4, &quot;street&quot; : &quot;78th st&quot;, &quot;building&quot; : null, &quot;next_visit&quot; : &quot;&quot; }
  { &quot;_id&quot; : 5, &quot;street&quot; : &quot;78th st&quot;, &quot;next_visit&quot; : &quot;&quot; }
  { &quot;_id&quot; : 6, &quot;street&quot; : &quot;Rector st&quot;, &quot;building&quot; : 10, &quot;last_visited&quot; : { &quot;year&quot; : 2017, &quot;month&quot; : 10 }, &quot;next_visit&quot; : ISODate(&quot;2019-01-01T00:00:00Z&quot;) }
</code></pre>
</li>
<li><p><code>$trim</code>示例：</p>
<pre><code class="lang-bash">  # conversion error:
  &gt; db.address.aggregate( [
    {
      $addFields: {
         building: {$convert: { input: &quot;$building&quot;, to: &quot;int&quot;  }}  }
    },
    {$sort: {building: 1}}
  ]);
  Error: command failed: {
      &quot;ok&quot; : 0,
      &quot;errmsg&quot; : &quot;Failed to parse number &#39;11w&#39; in $convert with no onError value: Bad digit \&quot;w\&quot; while parsing 11w&quot;,
      &quot;code&quot; : 241,
      &quot;codeName&quot; : &quot;ConversionFailure&quot;
  } : aggregate failed

  # avoid conversion error: Using $trim expression with longer list of chars to remove:
  &gt; db.address.aggregate( [
    {$match: { building: {$type: &quot;string&quot;} }},
    {
      $addFields: {
        building: {
          $convert: {
            input: {$trim: {
              input: &quot;$building&quot;,
              chars: &quot;abcdefghijklmnopqrstuvwxyz &quot;}},
            to: &quot;int&quot;  }
          }
       }
    },
    {$sort: {building: 1}}
  ]);
  { &quot;_id&quot; : 3, &quot;street&quot; : &quot;52nd st&quot;, &quot;building&quot; : 11 }
  { &quot;_id&quot; : 2, &quot;street&quot; : &quot;Fulton st&quot;, &quot;building&quot; : 31 }
  { &quot;_id&quot; : 1, &quot;street&quot; : &quot;43rd st&quot;, &quot;building&quot; : 229 }
</code></pre>
</li>
</ul>
</li>
<li><p>修改订阅扩展</p>
<ul>
<li>3.6 集合层面的修改订阅</li>
<li>4.0 数据库／集群层面的修改订阅(为修改事件返回clusterTime)</li>
</ul>
</li>
<li><p>后备节点读取: 阻塞 -&gt; 非阻塞性(引入快照机制)</p>
<ul>
<li>阻塞性后备节点：
  <img src="/2018/08/04/mongo4-block.png" alt="Block"> <img src="/2018/08/04/mongo4-block-rw.png" alt="Block Read and Write"><ul>
<li>读取：需等待批量数据复制写入操作完成才可</li>
<li>写入： 需等待数据读取操作完成，否则会导致一致性问题</li>
<li>形成了一个恶性循环</li>
</ul>
</li>
<li>非阻塞性后备节点: 
  <img src="/2018/08/04/mongo4-unblock.png" alt="Unblock"> <img src="/2018/08/04/mongo4-unblock-rw.png" alt="UnBlock Read and Write"></li>
<li>改进优化了性能：
  <img src="/2018/08/04/mongo4-delay-cmp.png" alt="Delay Cmp"></li>
</ul>
</li>
</ol>
<h2 id="header-33">Application</h2>
<ul>
<li>Java: <code>mongodb-driver</code><ul>
<li>Refer <a href="http://www.runoob.com/mongodb/mongodb-java.html">MongoDB Java</a></li>
<li>Demo <a href="https://github.com/sixDegree/java-mongo">java-mongo</a></li>
</ul>
</li>
<li>NodeJS: <code>mongoose</code><ul>
<li>Refer <a href="https://mongoosejs.com/docs/guide.html">mongoose</a></li>
<li>Demo <a href="https://github.com/sixDegree/node-mongo">node-mongo</a></li>
</ul>
</li>
</ul>
<h2 id="header-34">Reference</h2>
<p><a href="http://www.mongoing.com/docs/index.html">MongoDB 3.4 中文文档</a>
<a href="https://docs.mongodb.com/manual/">MongoDB 4.0 Manual</a>
<a href="http://www.runoob.com/mongodb/mongodb-tutorial.html">MongoDB 教程</a>
<a href="https://draveness.me/mongodb-wiredtiger">『浅入浅出』MongoDB 和 WiredTiger</a></p>
  </section>
</article>

      <hr/>
      
<section class="post-comment">
	
		<div id="gitment_container"></div>

<link rel="stylesheet" href="/gitment/default.css">
<script src="/gitment/gitment.browser.js"></script>


<script type="text/javascript">
	var gitment = new Gitment({
	  id: document.location.pathname,
	  owner: 'chenjin-zero',
	  repo: 'blogComment',
	  oauth: {
	    client_id: '36a09bb7399efe69c6ce',
	    client_secret: 'ad9ad546b23b708c71d92e513dc36e0486179dea',
	  }
	})
      
	gitment.render('gitment_container')
</script>
	
</section>

    </div>
  </div>
</body>

<script src="/jquery/dist/jquery.min.js"></script>
<script src="/bootstrap/dist/js/bootstrap.min.js"></script>


	<script src="/highlight/highlight.pack.js"></script>
	<script type="text/javascript">
		hljs.initHighlightingOnLoad();
	</script>






<script type="text/javascript">

  $(document).ready(function(){
    var sidebarCtrl=$("#sidebar-ctrl");
    var sidebar=$("#sidebar");
    var wrapper=$("#wrapper");
    sidebarCtrl.on("click",function(event){
        //alert("click");
        sidebar.toggleClass("sidebar-toggle");
        wrapper.toggleClass("sidebar-toggle");
        sidebarCtrl.toggleClass("sidebar-toggle");
        sidebarCtrl.toggleClass("active");
    })
  });
</script>


</html>
