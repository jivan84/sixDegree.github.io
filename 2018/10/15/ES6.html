<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>ES6</title>
  
  <!-- Meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="let,const,symbol,scope,proxy,reflect,descriptor,arrow-function,destructuring,iterator,object,function,class,module">
  
  
    <meta name="description" content="ES6 Introduce">
  

  <!-- Feed -->
  
    <link rel="alternative" href="/atom.xml" title="SixDegree" type="application/atom+xml">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/bootstrap/dist/css/bootstrap.css">
  
	
		<link rel="stylesheet" href="/highlight/demo/styles/tomorrow-night-bright.css">
	
    
  
  <link rel="stylesheet" href="/css/fontello.css">
  <link rel="stylesheet" href="/css/style.css">

  <!-- Site Analyse -->
  
	<script>
	var userID='2bbb83cc0f781dd7502e9d5e19661866';
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?"+userID;
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>


</head>

<body data-spy="scroll" data-target="#nav-catalog">
  <div id="top-push"></div>
<a href="#top-push" id="go-top">
	<span class="glyphicon glyphicon-chevron-up"></span>
</a>
  <aside id="sidebar">
    <section class="sidebar-header">Catalog</section>
     <nav id="nav-catalog">
        <ol class="sidebar-nav nav"><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-1"><span class="sidebar-nav nav-text">声明变量</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-2"><span class="sidebar-nav nav-text">块级作用域 {}</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-3"><span class="sidebar-nav nav-text">顶层对象 global</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-4"><span class="sidebar-nav nav-text">扩展运算符 ...</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-5"><span class="sidebar-nav nav-text">解构赋值 (Destructuring)</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-6"><span class="sidebar-nav nav-text">解构数组赋值</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-7"><span class="sidebar-nav nav-text">解构对象赋值</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-8"><span class="sidebar-nav nav-text">解构函数参数赋值</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-9"><span class="sidebar-nav nav-text">解构基础类型赋值</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-10"><span class="sidebar-nav nav-text">指定默认值</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-11"><span class="sidebar-nav nav-text">应用示例</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-12"><span class="sidebar-nav nav-text">Iterator 遍历器</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-13"><span class="sidebar-nav nav-text">Proxy 代理器</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-14"><span class="sidebar-nav nav-text">Proxy 对象</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-15"><span class="sidebar-nav nav-text">Reflect 对象</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-16"><span class="sidebar-nav nav-text">对象 Object</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-17"><span class="sidebar-nav nav-text">对象属性</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-18"><span class="sidebar-nav nav-text">对象比较</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-19"><span class="sidebar-nav nav-text">对象拷贝</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-20"><span class="sidebar-nav nav-text">super对象</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-21"><span class="sidebar-nav nav-text">函数 function</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-22"><span class="sidebar-nav nav-text">name属性</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-23"><span class="sidebar-nav nav-text">函数参数</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-24"><span class="sidebar-nav nav-text">参数默认值</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-25"><span class="sidebar-nav nav-text">函数绑定运算符 ::</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-26"><span class="sidebar-nav nav-text">箭头函数 arrow-function</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-27"><span class="sidebar-nav nav-text">优化：尾调用，尾递归</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-28"><span class="sidebar-nav nav-text">Symbol</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-29"><span class="sidebar-nav nav-text">Set/WeakSet</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-30"><span class="sidebar-nav nav-text">Set</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-31"><span class="sidebar-nav nav-text">WeakSet</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-32"><span class="sidebar-nav nav-text">Map/WeakMap</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-33"><span class="sidebar-nav nav-text">Map</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-34"><span class="sidebar-nav nav-text">Weakmap</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-35"><span class="sidebar-nav nav-text">类 Class</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-36"><span class="sidebar-nav nav-text">extened 继承</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-37"><span class="sidebar-nav nav-text">super/this 关键字</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-38"><span class="sidebar-nav nav-text">Decorator 修饰器</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-39"><span class="sidebar-nav nav-text">模块 Module</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-40"><span class="sidebar-nav nav-text">ES6 Module</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-41"><span class="sidebar-nav nav-text">浏览器环境加载</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-42"><span class="sidebar-nav nav-text">Node环境加载</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-43"><span class="sidebar-nav nav-text">实践</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-44"><span class="sidebar-nav nav-text">var/let/const</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-45"><span class="sidebar-nav nav-text">解构赋值</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-46"><span class="sidebar-nav nav-text">String</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-47"><span class="sidebar-nav nav-text">Array</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-48"><span class="sidebar-nav nav-text">Object</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-49"><span class="sidebar-nav nav-text">Function</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-50"><span class="sidebar-nav nav-text">Class</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-51"><span class="sidebar-nav nav-text">Module</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-52"><span class="sidebar-nav nav-text">ESLint</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-53"><span class="sidebar-nav nav-text">Reference</span></a></li></ol>
    </nav>
  </aside>
  <span id="sidebar-ctrl" class="glyphicon glyphicon-list-alt circle"></span>
  <div id="wrapper">
    <header>
  <nav class="navbar navbar-default">
    <div class="container-fluid">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#nav-menu" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/">SixDegree</a>
      </div>
      <div class="collapse navbar-collapse" id="nav-menu">
        <ul class="nav navbar-nav navbar-right">
          
              <li  >
                <a href="/">Blogs</a>
              </li>
          
              <li  >
                <a href="/tags.html">Tags</a>
              </li>
          
              <li  >
                <a href="/about.html">About</a>
              </li>
          
          
              <li>
                <a href="/atom.xml" target="_blank">
                  <span class="icon-rss"></span>
                </a>
              </li>
          
              <li>
                <a href="http://github.com/sixdegree" target="_blank">
                  <span class="icon-github"></span>
                </a>
              </li>
          
        </ul>
      </div>
    </div>
  </nav>
</header>



    <div class="container">
      <article class="detail" role="main">
  <section class="post-header">
    <h1 class="post-title">ES6</h1>
    <ul class="post-meta">
      <li>
        <span class="glyphicon glyphicon-calendar"></span>
        <time datetime="2018-10-14T16:00:00.000Z">2018-10-15</time>
      </li>
      
        <li>
         <span class="glyphicon glyphicon-tags"></span>
          
            <a href="/tags.html#tag-Javascript">Javascript</a>
          
        </li>
      
    </ul>
  </section>
  <section class="post-content">
    <blockquote>
<p>参阅 <a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="noopener">阮一峰 ECMAScript 6 入门</a> ，作一个归纳整理吧。。。</p>
</blockquote>
<p>ES6 : 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等,而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。</p>
<p>ES6 的第一个版本在 2015 年 6 月发布，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）</p>
<h2 id="header-1">声明变量</h2>
<ul>
<li>var （ES5）</li>
<li>function （ES5）</li>
<li>let</li>
<li>const</li>
<li>class</li>
<li>import</li>
</ul>
<p><strong> var/let/const: </strong></p>
<ul>
<li><p>scope:</p>
<pre><code class="lang-js">  {
    var a = 1;
    let b = 10;
    const c = 20;
  }

  a               // 1
  b              // ReferenceError: b is not defined.
  c              // ReferenceError: c is not defined.
</code></pre>
</li>
<li><code>var</code> : 声明的变量在全局范围内都有效；会发生”变量提升“现象（即变量可以在声明之前使用，值为undefined）<pre><code class="lang-js">  var a = [];
  for (var i = 0; i &lt; 10; i++) {
    a[i] = function () {
      console.log(i);
    };
  }
  a[6]();                     // 10
</code></pre>
</li>
<li><code>let</code> : 声明的变量只在所在的代码块内有效（局部有效）；声明的变量一定要在声明后使用，否则报错（“暂时性死区”）<pre><code class="lang-js">  var a = [];
  for (let i = 0; i &lt; 10; i++) {
    a[i] = function () {
      console.log(i);
    };
  }
  a[6]();                     // 6
</code></pre>
</li>
<li><code>const</code> : 声明一个只读的常量；与let相同，只在声明所在的块级作用域内有效，同样存在暂时性死区<ul>
<li>ES5 常量写法：<pre><code class="lang-js">  Object.defineProperty(window,&quot;PI&quot;,{
      value:3.1415926,
      writable:false
  });
  console.log(window.PI);
</code></pre>
</li>
<li>ES6 常量写法（使用const）<pre><code class="lang-js">  const PI = 3.1415;
  PI                                           // 3.1415
  PI = 3;                                      // TypeError: Assignment to constant variable.
</code></pre>
</li>
<li>scope:<pre><code class="lang-js">  const foo;                                // SyntaxError: Missing initializer in const declaration
  if (true) {
    const MAX = 5;
    MAX                                      // 5
  }
  MAX                                        // Uncaught ReferenceError: MAX is not defined
</code></pre>
</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li><code>const</code>实际上保证的是变量指向的内存地址中保存的数据不得改动</li>
<li><p>所以对于简单类型的数据（例如：数值、字符串、布尔值）可以保证只读，但对于复合类型的数据就无法保证了</p>
<pre><code class="lang-js">  const foo = {};
  foo.prop = 123;              // 成功
  foo = {};                    // TypeError: &quot;foo&quot; is read-only

  const a = [];
  a.push(&#39;Hello&#39;);             //  成功
  a.length = 0;                //  成功
  a = [&#39;Dave&#39;];                // 报错
</code></pre>
</li>
<li>在<code>let</code>和<code>const</code>之间，建议优先使用<code>const</code>，尤其是在全局环境，不应该设置变量，只应设置常量</li>
</ul>
</li>
</ul>
<h2 id="header-2">块级作用域 <code>{}</code></h2>
<ol>
<li><p>可代替闭包</p>
<ul>
<li>ES5 闭包（执行函数表达式 IIFE）写法：<pre><code class="lang-js">  (function () {
    var tmp = ...;
    ...
  }());
</code></pre>
</li>
<li>ES6 块级作用域写法：<pre><code class="lang-js">  {
    let tmp = ...;
    ...
  }
</code></pre>
</li>
</ul>
</li>
<li><p>声明的函数在不同环境下可能会有差异，建议使用函数表达式，而不是函数声明语句</p>
<ul>
<li>使用函数声明语句 – 不推荐，不同环境下会有差异：<pre><code class="lang-js">  {
    let a = &#39;secret&#39;;
    function f() {return a;}
  }
</code></pre>
<ul>
<li>浏览器环境： 函数声明类似于var（即会提升到全局作用域和函数作用域的头部）</li>
<li>其他环境：函数声明类似于let （对作用域之外没有影响）</li>
</ul>
</li>
<li>使用函数表达式方式(推荐方式)<pre><code class="lang-js">  {
    let a = &#39;secret&#39;;
    let f = function () {return a;};
  }
</code></pre>
</li>
</ul>
</li>
</ol>
<h2 id="header-3">顶层对象 <code>global</code></h2>
<p>为同一段代码能够在各种环境，都能取到顶层对象，引入global<br>注：</p>
<ul>
<li>浏览器中顶层对象： windows，self</li>
<li>Node中顶层对象： global</li>
<li>一般通用方法是使用this，但有局限性</li>
</ul>
<p><strong> 示例：</strong></p>
<ol>
<li><p>全局变量与顶层对象</p>
<ul>
<li>ES5中，全局变量与顶层对象等价<pre><code class="lang-js">  var a = 1;
  window.a                 // 1  -- Node 的 REPL 环境，可以写成 global.a，或者用通用方法this.a
</code></pre>
</li>
<li>ES6中，全局变量与顶层对象不等价<pre><code class="lang-js">  let a = 1;
  window.a                 // undefined
</code></pre>
</li>
</ul>
</li>
<li><p>使用垫片库system.global取到global</p>
<pre><code class="lang-js"> // CommonJS 的写法
 var global = require(&#39;system.global&#39;)();

 // ES6 模块的写法
 import getGlobal from &#39;system.global&#39;;
 const global = getGlobal();
</code></pre>
</li>
</ol>
<h2 id="header-4">扩展运算符 <code>...</code></h2>
<p><code>...变量</code> ： 将剩余传入的参数值，存入一个数组变量中<br><code>...对象</code> ： 拷贝对象的可遍历属性给一个新对象</p>
<p><strong> 示例：</strong> </p>
<ol>
<li><p>function rest 参数</p>
<pre><code class="lang-js"> function add(...values) {
   let sum = 0;
   for (let val of values) {
     sum += val;
   }
   return sum;
 }
 add(2, 5, 3)                 // 10
</code></pre>
<ul>
<li>注：rest参数只能是最后一个参数，否则会报错<br>（ES5 使用arguments对象，类似数组，但非数组，可使用Array.prototype.slice.call(arguments)转换为数组）</li>
</ul>
</li>
<li><p>解构赋值</p>
<pre><code class="lang-js"> let [head, ...tail] = [1, 2, 3, 4];
 head             // 1
 tail             // [2, 3, 4]
</code></pre>
</li>
<li><p>拷贝对象的可遍历属性，同<code>Object.assign</code></p>
<pre><code class="lang-js"> let aClone = { ...a };                                  // 等同 let aClone = Object.assign({}, a);
 let abClone = { ...a, ...b };                           // 等同 let abClone = Object.assign({}, a, b);

 let aWithOverrides = { ...a, x: 1, y: 2 };       
 let aWithOverrides = { ...a, ...{ x: 1, y: 2 } };
 let x = 1, y = 2, aWithOverrides = { ...a, x, y };
 // 以上都等同 let aWithOverrides = Object.assign({}, a, { x: 1, y: 2 });
</code></pre>
<ul>
<li>注： 扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行<pre><code class="lang-js">  let obj={
      a:1,
      get x(){
         throw new Error(&#39;get x error!&#39;);
      }
  }
  let c={...obj};    //  get x error!
</code></pre>
</li>
</ul>
</li>
</ol>
<h2 id="header-5">解构赋值 (Destructuring)</h2>
<p>从等式右边的对象中提取值，赋给左边对应变量:</p>
<ul>
<li>模式匹配：只要等号两边的模式相同，左边的变量就会被赋予对应的值</li>
<li>类型转换：若等号右边的值不是对象或数组，就先将其转为对象</li>
<li>浅拷贝：解构赋值的拷贝都是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本</li>
<li>注：<ul>
<li><code>undefined</code>/<code>null</code>: 无法转为对象，对它们进行解构赋值，会报错</li>
<li><code>...</code>：扩展运算符的解构赋值(<code>...a</code>)，只能读取对象自身的属性</li>
</ul>
</li>
</ul>
<p>eg：</p>
<pre><code class="lang-js">let a = 1;
let b = 2;

// 可合并成：
let [a, b] = [1, 2];
a    // 1
b    // 2
</code></pre>
<h3 id="header-6">解构数组赋值</h3>
<p>右边数据结构具有 Iterator 接口，即可用数组形式解构赋值，否则报错</p>
<p><strong> 示例：</strong></p>
<ol>
<li><p>完全解构</p>
<pre><code class="lang-js"> let [foo, [[bar], baz]] = [1, [[2], 3]];
 foo                 // 1
 bar                 // 2
 baz                 // 3

 let [x, , y] = [1, 2, 3];
 x                     // 1
 y                     // 3

 let [head, ...tail] = [1, 2, 3, 4];
 head                 // 1
 tail                 // [2, 3, 4]
</code></pre>
</li>
<li><p>不完全解构</p>
<pre><code class="lang-js"> let [a, [b], d] = [1, [2, 3], 4];
 a // 1
 b // 2
 d // 4

 let [x, y, ...z] = [&#39;a&#39;];
 x                     // &quot;a&quot;
 y                     // undefined
 z                     // []
</code></pre>
</li>
<li><p>解构不成功</p>
<pre><code class="lang-js"> let [foo] = [];
 foo                // undefined

 //报错
 let [foo] = 1;
 let [foo] = false;
 let [foo] = {};
 let [foo] = null;
</code></pre>
</li>
<li>对数组进行对象属性的解构，使用：属性名表达式<pre><code class="lang-js"> let arr = [1, 2, 3];
 let {0 : first, [arr.length - 1] : last} = arr;
 first                 // 1
 last                 // 3
</code></pre>
</li>
</ol>
<h3 id="header-7">解构对象赋值</h3>
<p>对象的属性没有次序，变量须与属性同名或给变量指定对应属性，才能取到正确的值<br>（解构数组赋值：是按照数组顺序位置给对应变量赋值的）</p>
<p><strong> 示例：</strong></p>
<ol>
<li><p>单层结构对象</p>
<pre><code class="lang-js"> let { foo, bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
 foo                 // &quot;aaa&quot;
 bar                 // &quot;bbb&quot;

 let { x } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
 x                    // undefined

 let { foo: x } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; };
 x                    // aaa
</code></pre>
</li>
<li><p>嵌套结构的对象</p>
<pre><code class="lang-js"> let obj = {
   p: [ &#39;Hello&#39;,{ y: &#39;World&#39; }]
 };

 let { p: [x, { y }] } = obj;  // 这时p是模式，不是变量，不会被赋值
 x                             // &quot;Hello&quot;
 y                             // &quot;World&quot;

 let { p, p: [x, { y }] } = obj;
 p                             // [&quot;Hello&quot;, {y: &quot;World&quot;}]
 x                             // &quot;Hello&quot;
 y                             // &quot;World&quot;

 // 嵌套对象，若子对象所在的父属性不存在，会报错
 let {foo: {bar}} = {baz: &#39;baz&#39;};        // 报错，因为foo不存在
</code></pre>
</li>
</ol>
<h3 id="header-8">解构函数参数赋值</h3>
<pre><code class="lang-js">function add([x, y]){
  return x + y;
}
add([1, 2]);                                    // 3
</code></pre>
<p>函数<code>add</code>的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量<code>x</code>和<code>y</code></p>
<pre><code class="lang-js">[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);        // [ 3, 7 ]
</code></pre>
<h3 id="header-9">解构基础类型赋值</h3>
<p>会先转为对象</p>
<p><strong> 示例：</strong></p>
<ol>
<li><p>字符串</p>
<pre><code class="lang-js"> const [a, b, c, d, e] = &#39;hello&#39;;
 a                 // &quot;h&quot;
 b                 // &quot;e&quot;

 let {length : len} = &#39;hello&#39;;
 len                 // 5
</code></pre>
</li>
<li>数值<pre><code class="lang-js"> let {toString: s} = 123;
 s === Number.prototype.toString         // true
</code></pre>
</li>
<li>布尔值<pre><code class="lang-js"> let {toString: s} = true;
 s === Boolean.prototype.toString         // true
</code></pre>
</li>
<li><code>undefined</code>，<code>null</code>: 无法转换为对象，解构报错<pre><code class="lang-js"> let { prop: x } = undefined;             // TypeError
 let { prop: y } = null;                  // TypeError
</code></pre>
</li>
</ol>
<h3 id="header-10">指定默认值</h3>
<p><code>undefined</code>会触发使用默认值</p>
<p><strong> 示例：</strong></p>
<ol>
<li><p>数组</p>
<pre><code class="lang-js"> let [x, y = &#39;b&#39;] = [&#39;a&#39;];         // x=&#39;a&#39;, y=&#39;b&#39;

 // 默认值可以是一个表达式，表达式是惰性求值的，即只有在用到的时候，才会求值
 function f() {
   console.log(&#39;aaa&#39;);
 }
 let [x = f()] = [1];                // x 能取到值，所以函数f根本不会执行

 // 默认值可以引用解构赋值的其他变量，但该变量必须已经声明
 let [x = 1, y = x] = [];         // x=1; y=1
 let [x = 1, y = x] = [2];        // x=2; y=2
 let [x = 1, y = x] = [1, 2];     // x=1; y=2
 let [x = y, y = 1] = [];         // ReferenceError: y is not defined -- 因为x用y做默认值时，y还没有声明
</code></pre>
</li>
<li><p>对象</p>
<pre><code class="lang-js"> // 注：默认值生效的条件是，对象的属性值严格等于（===）undefined
 var {x, y = 5} = {x: 1};
 x                     // 1
 y                     // 5

 var {x: y = 3} = {};
 y                     // 3

 var {x = 3} = {x: null};
 x                     // null
</code></pre>
</li>
<li><p>函数</p>
<pre><code class="lang-js"> function move({x = 0, y = 0} = {}) {        // 为变量x，y指定默认值
   return [x, y];
 }
 move({x: 3, y: 8});         // [3, 8]
 move({x: 3});               // [3, 0]
 move({});                   // [0, 0]
 move();                     // [0, 0]

 function move({x, y} = { x: 0, y: 0 }) {        // 为函数参数对象整体指定默认值，而不是为变量x和y指定默认值
   return [x, y];，
 }
 move({x: 3, y: 8});         // [3, 8]
 move({x: 3});               // [3, undefined]
 move({});                   // [undefined, undefined]
 move();                     // [0, 0]
</code></pre>
</li>
</ol>
<h3 id="header-11">应用示例</h3>
<ol>
<li><p>交换变量的值</p>
<pre><code class="lang-js"> let x = 1;
 let y = 2;
 [x, y] = [y, x];        // x=2,y=1
</code></pre>
</li>
<li><p>合并数组</p>
<pre><code class="lang-js"> // ES5
 var params=[&#39;hello&#39;,true,7];
 var other=[1,2].concat(params);
 console.log(other);

 // ES6
 // 利用扩展运算符合并数组
 var params=[&#39;hello&#39;,true,7];
 var other=[1,2,...params];
 console.log(other);
</code></pre>
</li>
<li><p>函数返回多个值: 函数返回多个值，只能将它们放在数组或对象里，通过解构赋值，取出这些值很方便</p>
<pre><code class="lang-js"> function example() {
   return [1, 2, 3];
 }
 let [a, b, c] = example();
</code></pre>
</li>
<li><p>函数参数的定义：方便地将一组参数与变量名对应起来</p>
<pre><code class="lang-js"> // 参数是一组有次序的值
 function f([x, y, z]) { 
     ... 
 }
 f([1, 2, 3]);

 // 参数是一组无次序的值
 function f({x, y, z}) { 
     ... 
 }
 f({z: 3, y: 2, x: 1});
</code></pre>
</li>
<li><p>提取 JSON 数据</p>
<pre><code class="lang-js"> let jsonData = {
   id: 42,
   status: &quot;OK&quot;,
   data: [867, 5309]
 };
 let { id, status, data: number } = jsonData;
 console.log(id, status, number);        // 42, &quot;OK&quot;, [867, 5309]
</code></pre>
</li>
<li><p>遍历 Map 结构 ：任何部署了 Iterator 接口的对象，都可以用for…of循环遍历</p>
<pre><code class="lang-js"> const map = new Map();
 map.set(&#39;first&#39;, &#39;hello&#39;);
 map.set(&#39;second&#39;, &#39;world&#39;);
 for (let [key, value] of map) {
   console.log(key + &quot; is &quot; + value);
 }
 // first is hello
 // second is world

 // 只获取键名
 for (let [key] of map) { ...}

 // 只获取键值
 for (let [,value] of map) { ...}
</code></pre>
</li>
<li><p>import模块的部分项</p>
<pre><code class="lang-js"> const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);
</code></pre>
</li>
</ol>
<p>注： 圆括号</p>
<pre><code class="lang-js">// 错误
let x;
{x} = {x: 1};  // SyntaxError: syntax error  因为{x}会被当成一个代码块

// 正确
let x;
({x} = {x: 1});
</code></pre>
<h2 id="header-12">Iterator 遍历器</h2>
<p>提供一种统一的遍历接口，供<code>for...of</code>（或<code>while</code>）消费（循环遍历）</p>
<ul>
<li><p>本质：创建一个指针对象，通过<code>next</code>方法移动指针，指向遍历对象的成员，返回成员信息</p>
</li>
<li><p>属性：</p>
<ul>
<li><code>value</code> : 当前成员的值</li>
<li><code>done</code> : 布尔值，表示遍历是否结束</li>
</ul>
</li>
<li><p>方法：</p>
<ul>
<li><code>next</code> ：指针跳到下一个成员（遍历器必需部署此方法）</li>
<li><code>return</code> : 循环遍历中提前退出（出错，break）时触发调用 （可选部署）<ul>
<li>注：必须返回一个对象</li>
<li>使用场景：一个对象在完成遍历前，需要清理或释放资源</li>
</ul>
</li>
<li><code>throw</code> : 主要配合 Generator 函数使用（可选部署）</li>
</ul>
</li>
<li><p>可遍历性（iterable）：</p>
<ul>
<li>部署了Iterator 接口的数据结构，此数据结构即是“可遍历的”</li>
<li><p><code>Symbol.iterator</code>属性：当前数据结构默认的遍历器生成函数（即<code>Iterator</code>接口），执行这个函数，就会返回一个遍历器对象</p>
<pre><code class="lang-js">  let arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
  let iter = arr[Symbol.iterator]();

  iter.next() // { value: &#39;a&#39;, done: false }
  iter.next() // { value: &#39;b&#39;, done: false }
  iter.next() // { value: &#39;c&#39;, done: false }
  iter.next() // { value: undefined, done: true }
</code></pre>
</li>
</ul>
</li>
<li><p>原生具备<code>Iterator</code>接口的数据结构：</p>
<ul>
<li>Array/TypedArray</li>
<li>Set/Map</li>
<li>String</li>
<li>function的arguments对象</li>
<li>Dom NodeList</li>
<li>Generator对象</li>
</ul>
</li>
<li><p>遍历操作：</p>
<ul>
<li><code>for...of</code> 循环<ul>
<li>循环读取键值(value)</li>
<li>遍历所有数据结构的统一的方法</li>
<li>内部调用的是数据结构的<code>Symbol.iterator</code>方法，可以与<code>break</code>，<code>continue</code>，<code>return</code>配合使用（<code>forEach</code>不行）</li>
</ul>
</li>
<li><code>for...in</code> 循环<ul>
<li>循环读取键名(key)，</li>
<li>任意顺序，不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键</li>
<li>主要是为遍历对象而设计</li>
</ul>
</li>
<li><p>示例:</p>
<ul>
<li><p>遍历数组</p>
<pre><code class="lang-js">  let arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
  arr.foo = &#39;hello&#39;;

  // for...in循环读取键名(key)，注意：数组的key为数字，但循环键名为字符串
  for (let i in arr) {
    console.log(i);     // &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;
  }

  // for...of循环读取键值(value)，注意：数组的遍历器接口只返回具有数字索引的属性
  for (let i of arr) {
    console.log(i);     // a,b,c -- 不会返回数组arr的foo属性
  }
</code></pre>
</li>
<li><p>遍历对象</p>
<pre><code class="lang-js">  // 对于普通的对象，for...of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用
  let es6 = {
    edition: 6,
    committee: &quot;TC39&quot;,
    standard: &quot;ECMA-262&quot;
  };

  for (let e of es6) {
    console.log(e);        // TypeError: es6[Symbol.iterator] is not a function
  }

  // for...in可以遍历普通对象
  for (let e in es6) {
    console.log(e);        // edition,committee,standard
  }
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="header-13">Proxy 代理器</h2>
<p>用于修改某些操作的默认行为，相当于在目标对象之前架设一层“拦截”,对外界的访问进行过滤和改写</p>
<h3 id="header-14">Proxy 对象</h3>
<p><strong> 构造Proxy实例对象：</strong></p>
<ul>
<li><p>方式一：<code>var proxy = new Proxy(target, handler);</code></p>
<pre><code class="lang-js">  var person = {
    name: &quot;张三&quot;
  };

  var proxy = new Proxy(person, {
    get: function(target, property) {
      if (property in target) {
        return target[property];
      } else {
        throw new ReferenceError(&quot;Property \&quot;&quot; + property + &quot;\&quot; does not exist.&quot;);
      }
    }
  });

  proxy.name // &quot;张三&quot;
  proxy.age // 抛出一个错误
</code></pre>
</li>
<li><p>方式二：<code>let {proxy,revoke}=Proxy.revocable(target,handler);</code> : 生成一个可取消的 Proxy 实例</p>
<ul>
<li>Proxy.revocable方法返回一个对象</li>
<li>该对象的proxy属性是Proxy实例</li>
<li><p>该对象的revoke属性是一个函数，可以取消Proxy实例</p>
<pre><code class="lang-js">let target = {};
let handler = {};

let {proxy, revoke} = Proxy.revocable(target, handler);

proxy.foo = 123;
proxy.foo // 123
revoke();
proxy.foo // TypeError: Revoked
</code></pre>
</li>
</ul>
</li>
<li><p>参数说明：</p>
<ul>
<li><code>target</code>：所要拦截的目标对象</li>
<li><code>handler</code>：对象，用于定制拦截行为，若为空对象{}，则没有任何拦截效果，访问proxy对象等同于访问target对象</li>
</ul>
</li>
<li><p>注：Proxy代理后，目标对象内部的<code>this</code>会指向Proxy代理对象</p>
<pre><code class="lang-js">  const target = {
    m: function () {
      console.log(this === proxy);
    }
  };
  const handler = {};

  const proxy = new Proxy(target, handler);

  target.m() // false
  proxy.m()  // true
</code></pre>
</li>
</ul>
<p><strong> Proxy 支持的拦截操作：</strong></p>
<ul>
<li>对象属性<ul>
<li><code>get(target,propKey,receiver)</code> : 拦截对象属性的读取,eg: <code>proxy.foo,proxy[&#39;foo&#39;]</code></li>
<li><code>set(target,propKey,value,receiver)</code> : 拦截对象属性的设置,eg: <code>proxy.foo=v,proxy[&#39;foo&#39;]=v</code></li>
<li><code>has(target,propKey)</code> : propKey in proxy</li>
<li><code>deleteProperty(target,propKey)</code>: delete proxy[propKey]</li>
</ul>
</li>
<li>函数调用<ul>
<li><code>apply(target,ctx,args)</code>: 拦截 Proxy 实例作为函数调用的操作,eg: <code>proxy(...args)</code>,<code>proxy.call(ctx,...args)</code>,<code>proxy.apply(...)</code></li>
<li><code>construct(target,args)</code>: 拦截 Proxy 实例作为构造函数调用的操作,eg: <code>new proxy(...args)</code></li>
</ul>
</li>
<li>属性描述对象<ul>
<li><code>defineProperty(target,propKey,propDesc)</code>: 拦截添加新属性,eg: <code>Object.defineProperty(proxy, propKey, propDesc)</code>,<code>Object.defineProperties(proxy, propDescs)</code></li>
<li><code>ownKeys(target)</code>: 拦截对象自身属性的读取操作, eg: <code>Object.getOwnPropertyNames</code>,<code>Object.getOwnPropertySymbols</code>,<code>Object.keys</code>,<code>for...in</code></li>
<li><code>getOwnPropertyDescriptor(target,propKey)</code>: 拦截获取属性描述对象, eg: <code>Object.getOwnPropertyDescriptor(proxy, propKey)</code></li>
</ul>
</li>
<li>对象原型<ul>
<li><code>getPropertyOf(target)</code>: 拦截获取对象原型, eg: <code>Object.getPrototypeOf(proxy)</code>,<code>instanceof</code></li>
<li><code>setPropertyOf(target,proto)</code>: 拦截设置对象原型, eg: <code>Object.setPrototypeOf(proxy, proto)</code></li>
</ul>
</li>
<li>对象扩展<ul>
<li><code>isExtensible(target)</code>: Object.isExtensible(proxy)</li>
<li><code>preventExtensions(target)</code>: Object.preventExtensions(proxy)</li>
</ul>
</li>
</ul>
<p><strong> 应用示例：</strong></p>
<ol>
<li><p>Proxy对象作为普通函数调用 VS 作为构造函数调用</p>
<pre><code class="lang-js"> var handler = {
   get: function(target, name) {
     if (name === &#39;prototype&#39;) {
       return Object.prototype;
     }
     return &#39;Hello, &#39; + name;
   },

   apply: function(target, thisBinding, args) {
     return args[0];
   },

   construct: function(target, args) {
     return {value: args[1]};
   }
 };

 var fproxy = new Proxy(function(x, y) {
   return x + y;
 }, handler);

 fproxy(1, 2) // 1
 new fproxy(1, 2) // {value: 2}
 fproxy.prototype === Object.prototype // true
 fproxy.foo === &quot;Hello, foo&quot; // true
</code></pre>
</li>
<li><p>私有变量</p>
<ul>
<li><p>ES3 写法</p>
<pre><code class="lang-js">  var Person=function(){
      var data={
          name:&#39;Tom&#39;,
          sex:&#39;male&#39;,
          age:15
      }
      this.get=function(key){
          return data[key];
      }
      this.set=function(key,value){
          if(key!==&#39;sex&#39;)
              data[key]=value;
      }
  }

  var person=new Person();
  person.set(&#39;name&#39;,&#39;Jack&#39;);
  person.set(&#39;sex&#39;,&#39;female&#39;);
  console.table({
      name: person.get(&#39;name&#39;),
      sex: person.get(&#39;sex&#39;),
      age: person.get(&#39;age&#39;)
  }); // Jack,male,15
</code></pre>
</li>
<li>ES5 写法<pre><code class="lang-js">  var Person={
      name:&#39;Tom&#39;,
      age: 15
  }
  Object.defineProperty(Person,&#39;sex&#39;,{
      writable:false,
      value:&#39;male&#39;
  })
  Person.name=&#39;Jack&#39;;
  console.table({
      name: Person.name,
      age: Person.age,
      sex: Person.sex
  }); // Jack,male,15
  Person.sex=&#39;female&#39;;    // will throw exception
</code></pre>
</li>
<li><p>ES6</p>
<pre><code class="lang-js">  let Person={
      name:&#39;Tom&#39;,
      sex:&#39;male&#39;,
      age:15
  };
  let person=new Proxy(Person,{
      get(target,key){
          return target[key]
      }
      set(target,key){
          if(key!==&#39;sex&#39;)
              target[key]=value;
      }
  });

  person.set(&#39;name&#39;,&#39;Jack&#39;);
  console.table({
      name: person.get(&#39;name&#39;),
      sex: person.get(&#39;sex&#39;),
      age: person.get(&#39;age&#39;)
  }); // Jack,male,15
  person.set(&#39;sex&#39;,&#39;female&#39;);    // will throw exception
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="header-15">Reflect 对象</h3>
<ol>
<li><p>将Object的一些方法放到Reflect上，使用Reflect代替Object的一些方法，例如：</p>
<ul>
<li><p>defineProperty方法</p>
<pre><code class="lang-js">  // 老写法
  try {
    Object.defineProperty(target, property, attributes);
    // success
  } catch (e) {
    // failure
  }

  // 新写法
  if (Reflect.defineProperty(target, property, attributes)) {
    // success
  } else {
    // failure
  }
</code></pre>
</li>
<li><p>判断对象是否有某属性</p>
<pre><code class="lang-js">  // 老写法
  &#39;assign&#39; in Object // true

  // 新写法
  Reflect.has(Object, &#39;assign&#39;) // true
</code></pre>
</li>
<li><p>方法调用</p>
<pre><code class="lang-js">  // 老写法
  Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1

  // 新写法
  Reflect.apply(Math.floor, undefined, [1.75]) // 1
</code></pre>
</li>
</ul>
</li>
<li><p>与Proxy对象的方法一一对应，可通过Reflect获取对象原有的默认行为，例如：</p>
<pre><code class="lang-js"> var loggedObj = new Proxy(obj, {
   get(target, name) {
     console.log(&#39;get&#39;, target, name);
     return Reflect.get(target, name);
   },
   deleteProperty(target, name) {
     console.log(&#39;delete&#39; + name);
     return Reflect.deleteProperty(target, name);
   },
   has(target, name) {
     console.log(&#39;has&#39; + name);
     return Reflect.has(target, name);
   }
 });
</code></pre>
</li>
</ol>
<h2 id="header-16">对象 <code>Object</code></h2>
<h3 id="header-17">对象属性</h3>
<p><strong> <code>Descriptor</code>属性描述对象：</strong> 对象的每个属性都有一个描述对象，用来控制该属性的行为</p>
<ul>
<li><p>数据属性描述对象包含：</p>
<ul>
<li>value</li>
<li>writable</li>
<li>enumerable</li>
<li>configurable</li>
</ul>
</li>
<li><p>获取对象自身属性（非继承属性）的描述对象</p>
<ul>
<li>Object.getOwnPropertyDescriptor</li>
<li>Object.getOwnPropertyDescriptors</li>
<li>Reflect.getOwnPropertyDescriptors</li>
</ul>
</li>
<li><p>某属性的描述对象的enumerable：可枚举性，若为false，即不可枚举，则一下操作会忽略该属性</p>
<ul>
<li>for…in循环</li>
<li>Object.keys()</li>
<li>JSON.stringify()</li>
<li>Object.assign()</li>
<li>注：<ul>
<li>以上操作除了<code>for...in</code>会包含继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性</li>
<li>ES6 规定，所有 Class 的原型的方法都是不可枚举的</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong> <code>__prop__</code>属性 </strong>（前后各两个下划线）： 等于<code>Object.prototype.__proto__</code>，即一个对象的<code>__prop__</code>属性值就是对象的原型</p>
<ul>
<li>操作对象的prototype对象（原型对象）的方法：<ul>
<li>Object.setPrototypeOf(object, prototype); </li>
<li>Object.getPrototypeOf(object); </li>
<li>Object.create(…) </li>
</ul>
</li>
</ul>
<p><strong> 获取对象自身属性的操作 </strong>（即不包括继承属性）:</p>
<ul>
<li>可枚举属性（无Symbol）：Object.keys(obj) – ES2017 引入了Object.values,Object.entries，作为遍历一个对象的补充手段，供for…of循环使用</li>
<li>可枚举和不可枚举属性（无Symbol）：Object.getOwnPropertyNames(obj) </li>
<li>Symbol属性：Object.getOwnPropertySymbols(obj) </li>
<li>所有（可枚举，不可枚举，Symbol）：Reflect.ownKeys(obj) </li>
</ul>
<p><strong> 示例：</strong></p>
<ol>
<li><p>Descriptor 属性描述对象</p>
<pre><code class="lang-js"> const obj = {
   foo: 123,
   get bar() { return &#39;abc&#39; }
 };

 Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;)
 Object.getOwnPropertyDescriptors(obj)

 // descriptor对象
 // { foo:
 //    { value: 123,
 //      writable: true,
 //      enumerable: true,         // 可枚举性
 //      configurable: true
 //     },
 //   bar:
 //    { get: [Function: get bar],
 //      set: undefined,
 //      enumerable: true,
 //      configurable: true } 
 // }
</code></pre>
</li>
<li><p>读取/遍历对象</p>
<pre><code class="lang-js"> let obj = { a: 1, b: 2, c: 3 };

 Object.keys(obj)                                            // [&#39;a&#39;, &#39;b&#39;]
 Object.values(obj)                                         //  [1,2,3]
 Object.entries(obj)                                        // [ [&#39;a&#39;, 1], [&#39;b&#39;, 2],[&#39;c&#39;,3] ]

 for (let [key, value] of entries(obj)) {
   console.log([key, value]);                                // [&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]
 }
 const map = new Map(Object.entries(obj));    // Map {a: 1, b: 2, c: 3}
</code></pre>
</li>
</ol>
<h3 id="header-18">对象比较</h3>
<ul>
<li><code>==</code> 相等运算符：自动转换数据类型</li>
<li><code>===</code> 严格相等运算符：NaN不等于自身，+0与-0相等</li>
<li><code>Object.is</code> 同值相等：比较两个值是否严格相等，与<code>===</code>相比，<code>NaN</code>等于自身，<code>+0</code>与<code>-0</code>不等</li>
</ul>
<pre><code class="lang-js">+0 === -0                 //true
NaN === NaN                 // false

Object.is(+0, -0)         // false
Object.is(NaN, NaN)        // true

Object.is(&#39;foo&#39;, &#39;foo&#39;)    // true
Object.is({}, {})          // false
</code></pre>
<h3 id="header-19">对象拷贝</h3>
<p><strong> 浅拷贝：</strong> 只能进行值的复制，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用</p>
<ol>
<li><p><code>Object.assign(target,src1,src2,...)</code> : 拷贝可被枚举的自有属性到目标对象（浅拷贝，同名属性替换， 取值函数求值后再复制）</p>
<pre><code class="lang-js"> // 浅拷贝，同名属性替换
 const target = { a: 1, b: 1,d:{e:&#39;hello&#39;,f:&#39;world&#39;} };
 const source1 = { b: 2, c: 2 };
 const source2 = { c: 3,d:{g:&#39;say&#39;} };
 Object.assign(target, source1, source2);                // {a:1, b:2, c:3,d:{g:&#39;say&#39;}}
</code></pre>
<ul>
<li>参数注意点：<ul>
<li>只有一个参数，即只有<code>target</code>，则返回<code>target</code>（不是对象会先转换成对象返回）</li>
<li>传入不是对象的参数，会先转成对象（eg：字符串可转换为字符数组，数组视为属性名为 0、1、2 的对象）</li>
<li>传入无法转成对象的参数（eg: undefined,null，数值，布尔值）：<ul>
<li>作为第一个参数（即target）会报错；</li>
<li>不是第一个参数（即source），会跳过</li>
</ul>
</li>
</ul>
</li>
<li>只拷贝属性值，不会拷贝它背后的赋值方法或取值方法，取值函数求值后再复制值<pre><code class="lang-js">  // 不会复制取值函数,会用取值函数求值后再复制
  const source = {
    get foo() { return 1 }
  };
  Object.assign({}, source)                                        // { foo: 1 }
</code></pre>
</li>
<li><p>使用<code>Object.getOwnPropertyDescriptors方法</code>配合<code>Object.defineProperties方法</code>添加描述对象，可实现正确拷贝</p>
<pre><code class="lang-js">// 配合Object.defineProperties方法添加描述对象
const source = {
set foo(value) {
  console.log(value);
}
};
const target = {};
Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));

Object.getOwnPropertyDescriptor(target, &#39;foo&#39;);
// {
//   get: undefined,
//   set: [Function: set foo],
//   enumerable: true,
//   configurable: true
//}
</code></pre>
</li>
</ul>
</li>
<li><p><code>Object.create(proto [, propertyDescriptors ])</code> ：创建一个新对象，对象继承到<code>__proto__</code>属性上</p>
<pre><code class="lang-js"> const person = {
   isHuman: false,
   printIntroduction: function () {
     console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);
   }
 };

 const me = Object.create(person);

 me.name = &quot;Matthew&quot;;             // &quot;name&quot; is a property set on &quot;me&quot;, but not on &quot;person&quot;
 me.isHuman = true;               // inherited properties can be overwritten
 me.printIntroduction();          // &quot;My name is Matthew. Am I human? true&quot;
</code></pre>
<ul>
<li><code>proto</code>：新创建对象的原型对象，可为null</li>
<li><p><code>propertyDescriptors</code>：可选项，新对象属性的描述对象（其自身定义的属性，不是其原型链上的属性）</p>
<pre><code class="lang-js">  let o = Object.create({}, { p: { value: 42 } }) 
  // 创建一个以空对象为原型,拥有一个属性p的对象 
  // 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的

  // p的属性描述对象的enumerable默认是false, 改成true，Object.values就会返回属性p的值
  Object.values(obj)     // []

  o.p                    // 42
  o.p = 20               // 失败

  o.__proto__            // Object {}
  o.__proto__.p          // undefined
</code></pre>
<pre><code class="lang-js">  var o = Object.create(Object.prototype, {
  foo: {                                    // foo会成为所创建对象的数据属性 
      writable:true,
      configurable:true,
      value: &quot;hello&quot;
    },
  bar: {                                    // bar会成为所创建对象的访问器属性  
      configurable: false,                // false，下面set,get方法不起作用
      get: function() { return 10 },
      set: function(value) {
        console.log(&quot;Setting `o.bar` to&quot;, value);
      }
    }
  });
  console.log(o);                         // {foo:&#39;hello&#39;}
</code></pre>
</li>
</ul>
</li>
<li><p><code>Object.create()</code>,<code>new Object()</code>,<code>{}</code> 区别</p>
<pre><code class="lang-js"> // test1,test2,test3的__proto 一样
 var test1 = {};
 var test2 = new Object();
 var test3 = Object.create(Object.prototype);

 // 创建一个原型为null的对象，test4.__proto__为undefined， 没有继承原型属性和方法，不同于test1，2，3
 var test4 = Object.create(null);

 var test = Object.create({x:123,y:345});
 console.log(test);                                               //{}
 console.log(test.x);                                            //123
 console.log(test.__proto__.x);                            //123
 console.log(test.__proto__.x === test.x);          //true

 var test1 = new Object({x:123,y:345});
 console.log(test1);                                              //{x:123,y:345}
 console.log(test1.x);                                            //123
 console.log(test1.__proto__.x);                            //undefined
 console.log(test1.__proto__.x === test1.x);        //false

 var test2 = {x:123,y:345};
 console.log(test2);                                                 //{x:123,y:345};
 console.log(test2.x);                                                //123
 console.log(test2.__proto__.x);                                //undefined
 console.log(test2.__proto__.x === test2.x);            //false
</code></pre>
</li>
</ol>
<p><strong> 综合示例：</strong> 克隆一个对象（包括对象原型的属性，浅拷贝）</p>
<pre><code class="lang-js">// 写法一，注：__proto__属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三
const clone1 = {
  __proto__: Object.getPrototypeOf(obj),
  ...obj
};

// 写法二
const clone2 = Object.assign(
  Object.create(Object.getPrototypeOf(obj)),
  obj
);

// 写法三
const clone3 = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
);
</code></pre>
<h3 id="header-20">super对象</h3>
<p>指向当前对象的原型对象</p>
<p><strong> 示例：</strong></p>
<ol>
<li><p>调用当前对象原型对象的属性</p>
<pre><code class="lang-js"> const proto = { foo: &#39;hello&#39;};
 const obj = {
   foo: &#39;world&#39;,
   find() {
     return super.foo;                                        // 引用了原型对象proto的foo属性，同 Object.getPrototypeOf(this).foo
   }
 };
 Object.setPrototypeOf(obj, proto);
 obj.find()                                                         // &quot;hello&quot;
</code></pre>
</li>
<li><p>调用当前对象原型对象的方法</p>
<pre><code class="lang-js"> const proto = {
   x: &#39;hello&#39;,
   foo() {
     console.log(this.x);
   },
 };

 const obj = {
   x: &#39;world&#39;,
   foo() {
     super.foo();                                                    // 同 Object.getPrototypeOf(this).foo.call(this)，this绑定的是当前obj
   }
 }

 Object.setPrototypeOf(obj, proto);
 obj.foo()                                                             // &quot;world&quot;
</code></pre>
</li>
<li><p><strong> 注：</strong> 只能用在对象的方法中（注：方法为简写方式才可以让 JavaScript 引擎确认，定义的是对象的方法）</p>
<ul>
<li>super用在属性里面，报错<pre><code class="lang-js">  const obj = {
    foo: super.foo
  }
</code></pre>
</li>
<li><p>super用在一个函数里面，然后赋值给foo属性,报错</p>
<pre><code class="lang-js">  // 错
  const obj = {
    foo: () =&gt; super.foo
  }

  // 错
  const obj = {
    foo: function () {
      return super.foo
    }
  }
</code></pre>
</li>
</ul>
</li>
</ol>
<h2 id="header-21">函数 <code>function</code></h2>
<h3 id="header-22">name属性</h3>
<p>返回函数的函数名</p>
<pre><code class="lang-js">function foo() {}
foo.name                                     // &quot;foo&quot;

const a = function baz() {};
a.name                                       // &quot;baz&quot;
</code></pre>
<p><strong> 注：</strong></p>
<ul>
<li>匿名函数: ES5返回空字符串，ES6返回赋给的变量名<pre><code class="lang-js">  var f = function () {};
  f.name                                  // ES5 &quot;&quot;； ES6 &quot;f&quot;
</code></pre>
</li>
<li>Function构造函数返回的函数实例: anonymous<pre><code class="lang-js">  (new Function).name                      // &quot;anonymous&quot;
</code></pre>
</li>
<li><p>bind返回的函数: name属性值会加上<code>bound</code>前缀</p>
<pre><code class="lang-js">  function foo() {};
  foo.bind({}).name                         // &quot;bound foo&quot;

  (function(){}).bind({}).name            // &quot;bound &quot;
</code></pre>
</li>
</ul>
<h3 id="header-23">函数参数</h3>
<ol>
<li><p>通过解构赋值设置参数</p>
<pre><code class="lang-js"> function add([x, y]){                        // 参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y
   return x + y;
 }
 add([1, 2]);                                // 3

 [[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);    // [ 3, 7 ]
</code></pre>
</li>
<li><p>处理可变参数: 使用rest参数<code>...参数名</code>（类似ES5的arguments）</p>
<pre><code class="lang-js"> function add(...values) {    // values同ES5 Array.prototype.slice.call(arguments);
   let sum = 0;
   for (let val of values) {
     sum += val;
   }
   return sum;
 }
 add(2, 5, 3)                 // 10
</code></pre>
</li>
</ol>
<h3 id="header-24">参数默认值</h3>
<ul>
<li><p>直接写在参数定义的后面</p>
<pre><code class="lang-js">  function log(x, y = &#39;World&#39;) {
    console.log(x, y);
  }
  log(&#39;Hello&#39;)              // Hello World
  log(&#39;Hello&#39;, &#39;China&#39;)     // Hello China
</code></pre>
</li>
<li><p>可以使用表达式/函数（惰性求值）</p>
<pre><code class="lang-js">  let x = 99;
  function foo(p = x + 1) {
    console.log(p);
  }
  foo()             // 100
  x = 100;
  foo()             // 101
</code></pre>
</li>
<li><p>使用解构赋值设置默认值</p>
<pre><code class="lang-js">  /* 1. 为函数参数对象整体指定默认值，eg: 为{x,y}对象整体指定默认值，而不是为变量x和y指定默认值 */
  function m2({x, y} = { x: 0, y: 0 }) {
    return [x, y];
  }
  m2()                    // [0,0]
  m2({})                  // [undefined,undefined]
  m2({x: 3})              // [3, undefined]
  m2({x:3,y:8})           // [3, 8]

  /* 2. 为函数某个具体参数指定默认值，eg：为变量y指定默认值 */
  function foo({x, y = 5} = {}) {
    console.log(x, y);
  }
  foo()                     // undefined 5
  foo({})                   // undefined 5
  foo({x:3})                // 3 5
  foo({x:3,y:8})            // 3 8
</code></pre>
</li>
<li><p>注：指定了默认值后，函数的length属性将失真，会返回没有指定默认值的参数个数</p>
<pre><code class="lang-js">  // 函数的length属性: 函数预期传入的参数个数
  (function(...args) {}).length                 // 0
  (function (a) {}).length                      // 1

  // 设置默认参数后，函数的length属性将失真：
  (function (a, b, c = 5) {}).length             // 2
  (function (a, b = 1, c) {}).length             // 1    -- 默认值以后的参数也不计数
</code></pre>
</li>
</ul>
<p><strong> 应用示例：</strong></p>
<ol>
<li>利用参数默认值，指定某一个参数不得省略，若省略就抛出一个错误<pre><code class="lang-js"> function throwIfMissing() {
   throw new Error(&#39;Missing parameter&#39;);
 }
 function foo(mustBeProvided = throwIfMissing()) {
   return mustBeProvided;
 }
 foo()        // Error: Missing parameter
</code></pre>
</li>
<li>利用参数默认值，指定某一个参数是可以省略的(将参数默认值设为undefined)<pre><code class="lang-js"> function foo(optional = undefined) { 
     //···
 }
</code></pre>
</li>
</ol>
<h3 id="header-25">函数绑定运算符 <code>::</code></h3>
<p>用来取代call、apply、bind调用</p>
<ul>
<li><p><code>对象::函数</code> : 会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面</p>
<pre><code class="lang-js">  bar.bind(foo);        // ES5
  foo::bar;             // ES6

  bar.apply(foo, arguments);        // ES5
  foo::bar(...arguments);           // ES6
</code></pre>
</li>
<li><code>::对象.方法</code> ：等于将该方法绑定在该对象上面<pre><code class="lang-js">  var log = console.log.bind(console);    // ES5
  let log = ::console.log;                // ES6， 同 let log = console::console.log;
</code></pre>
</li>
<li>若双冒号运算符的运算结果，还是一个对象，可采用链式写法</li>
</ul>
<h3 id="header-26">箭头函数 arrow-function</h3>
<p>简化函数编写形式</p>
<pre><code class="lang-js">// ES3,ES5
function a(){
    exp
}

// ES6
// 只有一个参数，可省略&quot;()&quot;
// 表达式直接作为返回值时，可省略&quot;{}&quot;
(arg)=&gt;{
    exp
}
</code></pre>
<p><strong> 示例：</strong></p>
<pre><code class="lang-js">var f = function () { return 5 };                          // ES5
var f = () =&gt; 5;                                          // ES6

var sum = function(num1, num2) { return num1 + num2;};    // ES5
var sum = (num1, num2) =&gt; num1 + num2;                    // ES6

[1,2,3,4,5].map(function(v){ return v+1; });              // ES5
[1,2,3,4,5].map(v=&gt;v+1);                                  // ES6

//无返回
let fn = () =&gt; void doesNotReturn();

//返回一个对象（为防止语法歧义报错，用圆括号包起来）
let getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; });

//使用rest参数
const headAndTail = (head, ...tail) =&gt; [head, tail];
headAndTail(1, 2, 3, 4, 5)        // [1,[2,3,4,5]]
</code></pre>
<p><strong> 限制：</strong></p>
<ul>
<li>不能用作构造函数（即不能用new）</li>
<li>不能使用arguments对象，用rest参数代替</li>
<li>不能用作Generator函数（即不能使用yield）</li>
</ul>
<p><strong> <code>this</code>对象: </strong> 在箭头函数中，this对象的指向是固定的，为定义时所在的对象，不是使用时所在的对象</p>
<ul>
<li>实际上：箭头函数没有自己的 <code>this</code>、<code>arguments</code>、<code>super</code>、<code>new.target</code>，只能引用外层代码块的对应变量</li>
<li>因为没有自己的<code>this</code>（使用外层代码块的<code>this</code>），所以不能用作构造函数，也不能使用<code>call</code>，<code>apply</code>，<code>bind</code>这些方法去改变<code>this</code>的指向</li>
</ul>
<p><strong> 示例：</strong></p>
<ol>
<li><p>ES3,ES5 原始写法 : this 指向的是该函数被调用的对象</p>
<pre><code class="lang-js"> var factory=function(){
     this.a=&#39;a&#39;;
     this.b=&#39;b&#39;;
     this.c={
         a:&#39;a+&#39;,
         b:function(){
             return this.a;
         }
     }
 }
 console.log(new factory().c.b());            // a+     -- this指向c
</code></pre>
</li>
<li><p>ES6 箭头函数 : this 指向的是定义时this的指向</p>
<pre><code class="lang-js"> var factory=function(){
      this.a=&#39;a&#39;;
      this.b=&#39;b&#39;;
      this.c={
         a: &#39;a+&#39;,
         b: ()=&gt;{
             return this.a;
         }
     }
 }
 console.log(new factory().c.b());    // a    -- 同外层代码this，指向factory
</code></pre>
</li>
<li><p>箭头函数转成 ES5写法（注意this）</p>
<pre><code class="lang-js"> // ES6 箭头函数
 function foo() {
   setTimeout(() =&gt; {
     console.log(&#39;id:&#39;, this.id);            // this -- foo
   }, 100);
 }

 // ES5 原始写法
 function foo() {
   var _this = this;
   setTimeout(function () {
     console.log(&#39;id:&#39;, _this.id);
   }, 100);
 }
</code></pre>
</li>
</ol>
<h3 id="header-27">优化：尾调用，尾递归</h3>
<p><strong> 尾调用：</strong> 函数的最后一步是返回调用另一个函数</p>
<pre><code class="lang-js">function f(x){
  return g(x);
}

function f(x) {
  if (x &gt; 0) {
    return m(x)
  }
  return n(x);
}
</code></pre>
<p>由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，直接用内层函数的调用帧取代外层函数的调用帧即可<br>注：</p>
<ul>
<li>ES6支持尾调用优化，且只在严格模式下开启</li>
<li>只有不再用到外层函数的内部变量才可取代</li>
<li><p>例：以下三种情况，都不属于尾调用</p>
<pre><code class="lang-js">  function f(x){
    let y = g(x);
    return y;                // 因为调用后还有赋值操作
  }

  function f(x){
    return g(x) + 1;    // 因为调用后还有操作
  }

  function f(x){
    g(x);                    // 函数最后一步为 return undefined；
  }
</code></pre>
</li>
</ul>
<p><strong> 尾递归：</strong> 尾调用自身</p>
<p>函数调用自身，因为调用栈太多，容易发生“栈溢出”错误（stack overflow）；<br>而尾递归，由于只存在一个调用帧，所以不会发生“栈溢出”错误</p>
<p>应用示例：</p>
<ol>
<li>计算n的阶乘: <code>n!</code><ul>
<li>非尾递归实现: 最多需要保存n个调用记录，复杂度 O(n) <pre><code class="lang-js">  function factorial(n) {
    if (n === 1) return 1;
    return n * factorial(n - 1);
  }
  factorial(5)             // 120
</code></pre>
</li>
<li>尾递归实现（将所有用到的内部中间变量改写成函数的参数）: 只保留一个调用记录，复杂度 O(1)<pre><code class="lang-js">  function factorial(n, total=1) {
    if (n === 1) return total;
    return factorial(n - 1, n * total);
  }
  factorial(5, 1)             // 120
</code></pre>
</li>
</ul>
</li>
<li><p>Fibonacci 数列</p>
<ul>
<li><p>非尾递归的 Fibonacci 数列实现</p>
<pre><code class="lang-js">  function Fibonacci (n) {
    if ( n &lt;= 1 ) {
          return 1
      };
    return Fibonacci(n - 1) + Fibonacci(n - 2);
  }

  Fibonacci(10)               // 89
  Fibonacci(100)             // 堆栈溢出
  Fibonacci(500)             // 堆栈溢出
</code></pre>
</li>
<li><p>尾递归优化过的 Fibonacci 数列实现</p>
<pre><code class="lang-js">  function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
    if( n &lt;= 1 ) {
          return ac2
      };
    return Fibonacci2 (n - 1, ac2, ac1 + ac2);
  }

  Fibonacci2(100)             // 573147844013817200000
  Fibonacci2(1000)           // 7.0330367711422765e+208
  Fibonacci2(10000)         // Infinity
</code></pre>
</li>
</ul>
</li>
</ol>
<p><strong> 注：</strong><br>尾递归优化只在严格模式下生效，正常模式下可采用“循环”换掉“递归”的方式进行优化</p>
<h2 id="header-28">Symbol</h2>
<ol>
<li>ES6新增的原始数据类型，类似于字符串的数据类型 （Javascript其他原始数据类型有：undefined，null，Boolean，String，Number，Object）</li>
<li><strong> 表示独一无二的值 </strong>（例如：可以用来保证对象的属性名是独一无二的）</li>
<li>通过<code>Symbol()</code>函数生成，可以接受一个字符串作为参数，表示对Symbol实例的描述</li>
<li>注：不能使用<code>new</code>，基本上，它是一种类似于字符串的数据类型</li>
</ol>
<pre><code class="lang-js">let s = Symbol(); 
typeof s                                // &quot;symbol&quot;

let s1 = Symbol(&#39;foo&#39;);
s1                                     // Symbol(foo)
s1.toString()                         // &quot;Symbol(foo)&quot;  

//相同参数的Symbol函数的返回值是不相等
let s2 = Symbol(&#39;foo&#39;);
s1 === s2                             // false

// 用于对象属性
let mySymbol = Symbol();
let a = {
  [mySymbol]: &#39;Hello!&#39;
};
a[mySymbol]                         // &quot;Hello!&quot;
</code></pre>
<h2 id="header-29">Set/WeakSet</h2>
<h3 id="header-30">Set</h3>
<ul>
<li>类似于数组，但是成员的值都是唯一，可枚举（<code>Array.from</code>方法可以将 Set 结构转为数组）</li>
<li>可以接受一个具有 iterable 接口的数据结构作为参数（例如数组），用来初始化</li>
<li>内部使用同值相等判断两个值是否相同（比严格相等<code>===</code>，多了NaN和0的比较)，注：两个对象总是不相等的</li>
<li>属性：<ul>
<li><code>Set.prototype.constructor</code>：构造函数，默认就是Set函数。</li>
<li><code>Set.prototype.size</code>：返回Set实例的成员总数。</li>
</ul>
</li>
<li>方法（操作）：<ul>
<li>add(value)</li>
<li>delete(value)</li>
<li>has(value)</li>
<li>clear()</li>
</ul>
</li>
<li>方法（遍历）：<ul>
<li>keys()</li>
<li>values()</li>
<li>entries()</li>
<li>forEach()        </li>
</ul>
</li>
</ul>
<p><strong> 示例：</strong></p>
<ol>
<li><p>无参构造使用Set</p>
<pre><code class="lang-js"> let s= new Set();
 s.add(1).add(2).add(2);
 s.size                                       // 2

 s.has(1)                                     // true
 s.has(2)                                     // true
 s.has(3)                                     // false
 s.delete(2);
 s.has(2)                                     // false
</code></pre>
</li>
<li><p>可枚举对象作为参数构造</p>
<pre><code class="lang-js"> const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
 items.size                                     // 5

 const s = new Set();
 [2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));

 // 去除数组的重复成员
 [...new Set(array)]
</code></pre>
</li>
<li><p>遍历</p>
<pre><code class="lang-js"> let s2= new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);

 s2.keys()                    // [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]
 s2.values()                  // [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]
 s2.entries()                 // [ [&#39;red&#39;,&#39;red&#39;], [&#39;green&#39;,&#39;green&#39;], [&#39;blue&#39;,&#39;blue&#39;] ]

 // for...of循环遍历
 for (let x of s2) {          // 默认遍历器生成函数就是它的values方法
   console.log(x);
 }
 // red
 // green
 // blue

 // forEach循环遍历
 s2.forEach((value, key) =&gt; console.log(key + &#39; : &#39; + value))
 // red:red
 // green:green
 // blue:blue
</code></pre>
<ul>
<li>注：<code>keys/values()</code> Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致，默认遍历器生成函数就是values方法</li>
</ul>
</li>
<li><p>应用：Set 实现并集（Union）、交集（Intersect）和差集（Difference）</p>
<pre><code class="lang-js"> let a = new Set([1, 2, 3]);
 let b = new Set([4, 3, 2]);

 // 并集
 let union = new Set([...a, ...b]);                                // Set {1, 2, 3, 4}

 // 交集
 let intersect = new Set([...a].filter(x =&gt; b.has(x)));            // set {2, 3}

 // 差集
 let difference = new Set([...a].filter(x =&gt; !b.has(x)));          // Set {1}
</code></pre>
</li>
</ol>
<h3 id="header-31">WeakSet</h3>
<ul>
<li>与Set区别：<ul>
<li>成员只能是对象，而不能是其他类型的值    </li>
<li>成员对象都是弱引用，随时可能消失（即如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中）</li>
<li>垃圾回收机制运行前后可能会导致成员数不一样，所以ES6 规定 WeakSet不可遍历</li>
</ul>
</li>
<li>方法：<ul>
<li>add(value)</li>
<li>delete(value)</li>
<li>has(value)</li>
</ul>
</li>
</ul>
<p><strong> 示例：</strong></p>
<ol>
<li><p>构造使用 WeakSet</p>
<pre><code class="lang-js"> const ws = new WeakSet();
 const obj = {};
 const foo = {};

 ws.add(window);
 ws.add(obj);

 ws.has(window);             // true
 ws.has(foo);                // false
 ws.delete(window);
 ws.has(window);                // false

 // WeakSet 没有size属性，不能遍历：因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在
 ws.size                     // undefined
 ws.forEach                     // undefined
</code></pre>
</li>
<li><p>有参构造 WeakSet（注：WeakSet的成员只能是对象）</p>
<pre><code class="lang-js"> // 可以接受具有 Iterable 接口的对象
 const a = [[1, 2], [3, 4]];
 const ws1 = new WeakSet(a);            // WeakSet {[1, 2], [3, 4]} 注：a数组的成员成为 WeakSet 的成员，不是a数组本身

 const b = [3, 4];
 const ws2 = new WeakSet([3, 4]);      // Uncaught TypeError: Invalid value used in weak set(…) 注：b数组的成员不是对象
</code></pre>
</li>
<li><p>应用：Weakset 储存 DOM 节点，不用担心这些节点从文档移除时，会引发内存泄漏</p>
<pre><code class="lang-js"> const foos = new WeakSet()            // foos对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑foos，也不会出现内存泄漏
 class Foo {
   constructor() {
     foos.add(this)
   }
   method () {
     if (!foos.has(this)) {
       throw new TypeError(&#39;Foo.prototype.method 只能在Foo的实例上调用！&#39;);
     }
   }
 }
</code></pre>
</li>
</ol>
<h2 id="header-32">Map/WeakMap</h2>
<h3 id="header-33">Map</h3>
<ul>
<li>键值对集合，类似对象（Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，key不限于字符串，各种类型的值包括对象都可以当作键，是一种更完善的 Hash 结构实现）</li>
<li>键唯一，跟内存地址绑定的，只要内存地址不一样，就视为两个键（0和-0是一个键，NaN视为同一个键）    </li>
<li>Map 的遍历顺序就是插入顺序</li>
<li>属性：<ul>
<li>size</li>
</ul>
</li>
<li>方法（操作）：<ul>
<li>set(key,value)</li>
<li>get(key)</li>
<li>has(key)</li>
<li>delete(key)</li>
<li>clear()</li>
</ul>
</li>
<li>方法（遍历）：<ul>
<li>keys()</li>
<li>values()</li>
<li>entries()</li>
<li>forEach()</li>
</ul>
</li>
</ul>
<p><strong> 示例：</strong></p>
<ol>
<li><p>无参数构造</p>
<pre><code class="lang-js"> const m = new Map();
 const o = {p: &#39;Hello World&#39;};

 m.set(o, &#39;content&#39;)
 m.get(o)                        // &quot;content&quot;

 m.set(1,&#39;Hello&#39;) 
 m.get(1)                        // &quot;Hello&quot;

 m.get(&#39;a&#39;)                        // undefined

 m.set(undefined, 3);            
 m.get(undefined)                // 3

 m.set([&#39;a&#39;], 555);
 m.get([&#39;a&#39;])                    // undefined

 m.set(1,&#39;a&#39;).set(2,&#39;b&#39;)
</code></pre>
</li>
<li><p>可枚举对象作为参数构造</p>
<pre><code class="lang-js"> const m= new Map([
   [&#39;name&#39;, &#39;张三&#39;],
   [&#39;title&#39;, &#39;Author&#39;]
 ]);                             // Map {&#39;name&#39;:&#39;张三&#39;,&#39;title&#39;:&#39;Author&#39;}

 // 相当于
 param.forEach(
   ([key, value]) =&gt; m.set(key, value)
 );

 m.size                            // 2
 m.has(&#39;name&#39;)                    // true
 m.get(&#39;name&#39;)                    // &quot;张三&quot;
</code></pre>
</li>
<li><p>遍历</p>
<pre><code class="lang-js"> m.keys()        // [&#39;name&#39;,&#39;title&#39;]
 m.values()        // [&#39;张三&#39;,&#39;Author&#39;]
 m.entries()        // [ [&#39;name&#39;, &#39;张三&#39;],[&#39;title&#39;, &#39;Author&#39;] ]

 // forEach循环遍历
 m.forEach(function(value, key, map) {
   console.log(&quot;Key: %s, Value: %s&quot;, key, value);
 });

 // for...of循环遍历
 for (let [key, value] of map) {
   console.log(key, value);
 }
 for (let [key, value] of map.entries()) {
   console.log(key, value);
 }
 for (let item of map.entries()) {
   console.log(item[0], item[1]);
 }

 // name 张三
 // title Author
</code></pre>
<ul>
<li>注：<code>entries()</code> 是Map结构的默认遍历器接口（部署在Symbol.iterator属性上，即<code>map[Symbol.iterator] === map.entries</code>）</li>
</ul>
</li>
<li><p>Map &lt;-&gt; Array 转换</p>
<ul>
<li>Map -&gt; Array: 使用扩展运算符 <code>...</code><pre><code class="lang-js">  const myMap = new Map()
    .set(true, 7)
    .set({foo: 3}, [&#39;abc&#39;]);
  [...myMap]                                    // [ [ true, 7 ], [ { foo: 3 }, [ &#39;abc&#39; ] ] ]
</code></pre>
</li>
<li>Array -&gt; Map: 直接作为参数传入Map构造函数<pre><code class="lang-js">  new Map([
    [true, 7],
    [{foo: 3}, [&#39;abc&#39;]]
  ])                                           // Map { true:7, {foo:3}:[&#39;abc&#39;] }
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="header-34">Weakmap</h3>
<ul>
<li>与Map区别：<ul>
<li>只接受对象作为键名（null除外）</li>
<li>键名所指向的对象为弱引用（不计入垃圾回收机制，即一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用）</li>
<li>注：WeakMap 弱引用的只是键名，而不是键值，所以即使在 WeakMap 外部消除了键值的引用，WeakMap 内部的引用依然存在</li>
<li>没有遍历操作（即没有keys()、values()，entries()，forEach方法），也没有size属性</li>
<li>无法清空，即不支持clear方法</li>
</ul>
</li>
<li>方法：<ul>
<li>get()、set()、has()、delete()</li>
</ul>
</li>
<li>应用（WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏）<ul>
<li>DOM 节点作为键名（在网页的 DOM 元素上添加数据，当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除，有助于防止内存泄漏）</li>
<li>部署私有属性</li>
</ul>
</li>
</ul>
<p><strong> 示例：</strong></p>
<ol>
<li><p>构造使用 WeakMap</p>
<pre><code class="lang-js"> const wm = new WeakMap();

 const key = {foo: 1};
 wm.set(key, 2);                        // set 添加成员
 wm.get(key)                         // get 获取成员

 // 只接受对象作为键名（null除外）
 wm.set(1, 2)                        // TypeError: 1 is not an object!
 wm.set(Symbol(), 2)                    // TypeError: Invalid value used as weak map key

 // size、forEach、clear 方法都不存在
 wm.size                             // undefined
 wm.forEach                             // undefined
 wm.clear                             // undefined

 // 可接受一个数组，作为构造函数的参数
 const k1 = [1, 2, 3];
 const k2 = [4, 5, 6];
 const wm2 = new WeakMap([[k1, &#39;foo&#39;], [k2, &#39;bar&#39;]]);
 wm2.get(k2) // &quot;bar&quot;
</code></pre>
</li>
<li><p>应用：DOM 节点作为键名存储在Weakmap中，防止内存泄漏</p>
<pre><code class="lang-js"> // myElement是一个 DOM 节点，每当发生click事件，就更新一下状态
 // 一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险

 let myElement = document.getElementById(&#39;logo&#39;);

 let myWeakmap = new WeakMap();
 myWeakmap.set(myElement, {timesClicked: 0});

 myElement.addEventListener(&#39;click&#39;, function() {
   let logoData = myWeakmap.get(myElement);
   logoData.timesClicked++;
 }, false);
</code></pre>
</li>
<li><p>应用：Weakmap 部署私有属性，实例消失，它们也就随之消失</p>
<pre><code class="lang-js"> // Countdown类的两个内部属性_counter和_action，是实例的弱引用
 // 如果删除实例，它们也就随之消失，不会造成内存泄漏

 const _counter = new WeakMap();
 const _action = new WeakMap();

 class Countdown {
   constructor(counter, action) {
     _counter.set(this, counter);
     _action.set(this, action);
   }
   dec() {
     let counter = _counter.get(this);
     if (counter &lt; 1) return;
     counter--;
     _counter.set(this, counter);
     if (counter === 0) {
       _action.get(this)();
     }
   }
 }

 const c = new Countdown(2, () =&gt; console.log(&#39;DONE&#39;));

 c.dec()
 c.dec()
 // DONE
</code></pre>
</li>
</ol>
<h2 id="header-35">类 Class</h2>
<p>类的数据类型就是函数，类本身就指向构造函数</p>
<ul>
<li><code>constructor</code> 构造函数<ul>
<li>默认返回实例对象，即this（this 代表实例对象）</li>
<li>无参构造，可以不显式定义，会默认添加一个空的constructor方法</li>
</ul>
</li>
<li><code>new</code> 创建实例对象<ul>
<li><code>new 构造函数(args)</code>： 从prototype对象生成一个实例对象 ( 注：ES6 class必须使用new调用,否则会报错 )</li>
<li><code>new.target</code>: 一般在构造函数中调用，返回new命令作用于的那个构造函数，若不是用new命令调用，返回undefined (这个属性可以用来确定构造函数是怎么调用的)</li>
</ul>
</li>
</ul>
<p><strong> 类成员: </strong></p>
<ul>
<li>变量：定义在this上，是类的实例对象自身的属性，属于类实例对象<pre><code class="lang-js">  class Point {
    constructor(x, y) {
      this.x = x;
      this.y = y;
    }
  }
</code></pre>
<ul>
<li>提案：实例属性: 用等式直接写入类的定义之中（以前只能写在类的constructor方法里面）<pre><code class="lang-js">  class MyClass {
    myProp = 42;
    constructor() {
      console.log(this.myProp); // 42
    }
  }
</code></pre>
</li>
</ul>
</li>
<li>方法: 定义在class上，是原型对象prototype的属性，属于类<pre><code class="lang-js">  class Point {
      say(){
          console.log(&quot;Hello&quot;);
      }
  }
</code></pre>
</li>
<li><p>注：<code>getter/setter</code> 对某个属性设置存值函数和取值函数(部署在Descriptor属性描述对象上)，拦截该属性的存取行为</p>
<pre><code class="lang-js">  class MyClass {
    get prop() {
      return &#39;getter&#39;;
    }
    set prop(value) {
      console.log(&#39;setter: &#39;+value);
    }
  }

  let inst = new MyClass();

  inst.prop = 123;        // setter: 123
  inst.prop                    // &#39;getter&#39;
</code></pre>
</li>
</ul>
<p><strong> 私有属性/方法: </strong> </p>
<ul>
<li><p>利用<code>Symbol</code>值的唯一性，将私有方法的名字命名为一个Symbol值</p>
<pre><code class="lang-js">  const bar = Symbol(&#39;bar&#39;);
  const snaf = Symbol(&#39;snaf&#39;);

  export default class myClass{
    // 公有方法
    foo(x) {
      this[bar](x);
    }

    // 私有方法
    [bar](x) {
      return this[snaf] = x;
    }
  }
</code></pre>
</li>
<li>提案：使用<code>#</code>表示<pre><code class="lang-js">  class Foo {
    #a;
    #b;
    #sum() { return #a + #b; }
    printSum() { console.log(#sum()); }
    constructor(a, b) { #a = a; #b = b; }
  }
</code></pre>
</li>
</ul>
<p><strong> 静态属性/方法：</strong> 直接通过类来调用（实例上调用，会抛出错误，表示不存在）</p>
<ul>
<li><p>静态属性：ES6 没有静态属性，可在类外部定义实现</p>
<pre><code class="lang-js">  class Foo {}

  Foo.prop = 1;        // 为Foo类定义了一个静态属性prop
  Foo.prop // 1
</code></pre>
<ul>
<li><p>提案：在实例属性写法前面加上static关键字</p>
<pre><code class="lang-js">  class MyClass {
    static myStaticProp = 42;

    constructor() {
      console.log(MyClass.myStaticProp); // 42
    }
  }
</code></pre>
</li>
</ul>
</li>
<li><p>静态方法: 可以与非静态方法重名 ( 注：static方法中的this指向类，不是实例 )</p>
<pre><code class="lang-js">  class Foo {
    static classMethod() {
      return &#39;hello&#39;;
    }
  }

  Foo.classMethod() // &#39;hello&#39;

  var foo = new Foo();
  foo.classMethod()                // TypeError: foo.classMethod is not a function
</code></pre>
</li>
</ul>
<p><strong> 示例：</strong></p>
<ol>
<li><p>定义使用类</p>
<ul>
<li><p>ES5方式</p>
<pre><code class="lang-js">  // 构造函数：
  function Point(x, y) {
    this.x = x;
    this.y = y;
  }
  // 类的所有方法都定义在类的prototype属性上面：
  Point.prototype={
      constructor:Point,
      toString:function(){
          return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;};
      }
  }

  // 使用
  var p = new Point(1, 2);
  console.log(p.toString());
</code></pre>
</li>
<li><p>ES6方式</p>
<pre><code class="lang-js">  class Point {
    constructor(x, y) {
      this.x = x;
      this.y = y;
    }

    toString() {
      return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
    }
  }

  var p = new Point(1, 2);
  console.log(p.toString());
</code></pre>
</li>
<li><p>注: </p>
<ul>
<li>类的数据类型就是函数，类本身就指向构造函数<pre><code class="lang-js">  typeof Point // &quot;function&quot;
  Point === Point.prototype.constructor // true
</code></pre>
</li>
<li>类属性定义在this变量上，属于类实例对象； 类方法定义在class上 ，属于类<pre><code class="lang-js">  p.hasOwnProperty(&#39;x&#39;) // true
  p.hasOwnProperty(&#39;y&#39;) // true
  p.hasOwnProperty(&#39;toString&#39;) // false
  p.__proto__.hasOwnProperty(&#39;toString&#39;) // true
</code></pre>
</li>
<li><p>类的内部所有定义的方法，ES6定义的不可枚举，ES5方式定义的可枚举</p>
<pre><code class="lang-js">  /* ES5 */
  Object.keys(Point.prototype)    // [&quot;toString&quot;]
  Object.getOwnPropertyNames(Point.prototype)    // [&quot;constructor&quot;,&quot;toString&quot;]

  /* ES6 */
  Object.keys(Point.prototype)    // []
  Object.getOwnPropertyNames(Point.prototype)    // [&quot;constructor&quot;,&quot;toString&quot;]
</code></pre>
</li>
<li>ES6 class必须使用new调用,否则会报错<pre><code class="lang-js">  var point = Point(2, 3);        // 报错
  var point = new Point(2, 3);    // 正确
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>无参构造类( constructor可以不显式定义)</p>
<ul>
<li><p>ES5方式</p>
<pre><code class="lang-js">  /* Javascript */

  function Point() {}
  Point.prototype.toString=function(){...}

  // 等同于
  function Point(){}
  Point.prototype={
      constructor:Point,
      toString:function(){...}
  }
</code></pre>
</li>
<li><p>ES6方式</p>
<pre><code class="lang-js">  class Point{
      toString(){...}
  }

  // 等同于
  class Point {
    constructor() {}
    toString(){...}
  }
</code></pre>
</li>
</ul>
</li>
<li><p>匿名类</p>
<pre><code class="lang-js"> let person = new class {
   constructor(name) {
         this.name = name;
   }
   sayName() {
     console.log(this.name);
   }
 }(&#39;张三&#39;);

 person.sayName();     // &quot;张三&quot;
</code></pre>
</li>
<li><p><code>new.target</code>: 用在构造函数中调用，返回new命令作用于的那个构造函数</p>
<ul>
<li><p>ES5方式</p>
<pre><code class="lang-js">  function Person(name) {
    if (new.target === Person) {
      this.name = name;
    } else {
      throw new Error(&#39;必须使用 new 命令生成实例&#39;);
    }
  }

  var person = new Person(&#39;张三&#39;); // 正确
  var notAPerson = Person.call(person, &#39;张三&#39;);  // throw Error: 必须使用 new 命令生成实例
</code></pre>
</li>
</ul>
<ul>
<li><p>ES6</p>
<pre><code class="lang-js">  class Rectangle {
    constructor(length, width) {
      console.log(new.target === Rectangle);
      this.length = length;
      this.width = width;
    }
  }

  var obj = new Rectangle(3, 4);         // 输出 true
  var obj2 = Rectangle(2, 3);         // 报错,ES6 class必须使用new调用
</code></pre>
</li>
<li><p>应用：创建不能独立使用、必须继承后才能使用的类</p>
<pre><code class="lang-js">  //Class内部调用new.target，返回当前Class；子类继承父类时，返回子类
  class Shape {
    constructor() {
      if (new.target === Shape) {
        throw new Error(&#39;本类不能实例化&#39;);
      }
    }
  }

  class Rectangle extends Shape {
    constructor(length, width) {
      super();
      // ...
    }
  }

  var x = new Shape();  // 报错
  var y = new Rectangle(3, 4);  // 正确
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="header-36">extened 继承</h3>
<pre><code class="lang-js">class A {
  constructor() {
    console.log(new.target.name);  // new.target 指向new命令作用于的那个构造函数
  }
}

class B extends A {
  constructor() {
    super();                  // 相当于 A.prototype.constructor.call(this)， 这里this指的是B的实例 -- super代表父类的构造函数
  }
}

new A()     // A
new B()     // B
</code></pre>
<p><strong> 继承机制：</strong></p>
<ul>
<li>ES5：创造子类的实例对象this，再将父类的方法添加到this上面</li>
<li>ES6：将父类实例对象的属性和方法加到this上面，再用子类的构造函数修改this<ul>
<li>子类必须在constructor方法中调用super方法，且只有调用super之后，才可以使用this关键字，否则新建实例时会报错</li>
<li>子类会继承父类的静态方法，也可通过super对象调用父类的静态方法</li>
</ul>
</li>
<li>获取对象原型: <code>Object.getPrototypeof(obj)</code><ul>
<li>可以用来从子类上获取父类，使用这个方法判断，一个类是否继承了另一个类</li>
<li>eg:  <code>Object.getPrototypeOf(ColorPoint) === Point</code> 为 true</li>
</ul>
</li>
</ul>
<p><strong> 原生构造函数的继承（原生类的继承）：</strong></p>
<ul>
<li>语言内置的构造函数，ES5无法继承，ES6可以（ ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承）</li>
<li>ECMAScript 的原生构造函数：<ul>
<li>Boolean()</li>
<li>Number()</li>
<li>String()</li>
<li>Array()</li>
<li>Date()</li>
<li>Function()</li>
<li>RegExp()</li>
<li>Error()</li>
<li>Object()</li>
</ul>
</li>
<li><p>特例：继承Object的子类，无法通过super方法向父类Object传参</p>
<pre><code class="lang-js">  class NewObj extends Object{
    constructor(){
      super(...arguments);
    }
  }

  var o = new NewObj({attr: true});
  o.attr === true                                      // false
</code></pre>
<ul>
<li>因为 ES6 改变了Object构造函数的行为，一旦发现Object方法不是通过<code>new Object()</code>这种形式调用，ES6 规定Object构造函数会忽略参数</li>
</ul>
</li>
<li><p>应用实例：定义一个带版本功能的数组</p>
<pre><code class="lang-js">  class VersionedArray extends Array {
    constructor() {
      super();
      this.history = [[]];
    }
    commit() {
      this.history.push(this.slice());
    }
    revert() {
      this.splice(0, this.length, ...this.history[this.history.length - 1]);
    }
  }

  var x = new VersionedArray();

  x.push(1);
  x.push(2);
  x                                 // [1, 2]
  x.history                     // [[]]
  x.commit();
  x.history                    // [[], [1, 2]]

  x.push(3);
  x                                 // [1, 2, 3]
  x.history                     // [[], [1, 2]]
  x.revert();
  x                                 // [1, 2]
</code></pre>
</li>
</ul>
<h3 id="header-37">super/this 关键字</h3>
<p><strong> this: </strong> 一般指向该方法运行时所在的环境</p>
<ul>
<li>在类中：<ul>
<li>普通方法中：指向类的实例；</li>
<li>静态方法中：指向类；</li>
</ul>
</li>
<li>在子类中：<ul>
<li>普通方法中：指向子类实例；注：用super对象调用父类方法时，父类方法中的this指向的也是子类实例</li>
<li>静态方法中：指向子类；注：用super对象调用父类方法时，父类方法中的this指向的也是子类</li>
</ul>
</li>
<li>在箭头函数中：<ul>
<li>指向是固定的，为定义时所在的对象，不是使用时所在的对象（因为箭头函数没有自己的this，只能使用外层代码块的this）</li>
<li>注：箭头函数不能用作构造函数，也不能使用call，apply，bind这些方法去改变this的指向</li>
</ul>
</li>
<li></li>
</ul>
<p><strong> 示例：</strong>    </p>
<pre><code class="lang-js">class Logger {
  printName(name = &#39;there&#39;) {
    this.print(`Hello ${name}`);            // this 指向类的实例
  }
  print(text) {
    console.log(text);
  }
}

const logger = new Logger();
logger.printName();                        // Hello there
</code></pre>
<p>注：单独使用类方法，而此类方法中使用this调用其他类方法，可能会报错，eg：将printName方法提取出来单独使用会报错</p>
<pre><code class="lang-js">const { printName } = logger;
printName();                              // TypeError: Cannot read property &#39;print&#39; of undefined

// 解决方案： 在构造方法中绑定this
class Logger {
  constructor() {
    this.printName = this.printName.bind(this);
  }
  // ...
}
</code></pre>
<p><strong> super </strong></p>
<ul>
<li><code>super(...)</code>: super方法代表父类的构造函数，只能用在子类的构造函数之中，用在其他地方就会报错</li>
<li><code>super.xxx</code>: super对象一般指向当前对象的原型对象, 只能用在对象的方法中<ul>
<li>在子类：<ul>
<li>普通方法中: super指向父类的原型对象；注：通过super调用父类的方法时，父类方法内部的this指向的是子类实例</li>
<li>静态方法中：super指向父类本身；注：通过super方法调用父类的方法时，父类方法内部的this指向的是子类</li>
</ul>
</li>
</ul>
</li>
<li>注：使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错</li>
</ul>
<p><strong> 示例: </strong></p>
<ol>
<li><p><strong>super方法</strong> vs <strong>super对象</strong></p>
<pre><code class="lang-js"> class Point {
   constructor(x, y) {
     this.x = x;
     this.y = y;
   }
   p() {
     return 2;
   }
 }

 class ColorPoint extends Point {
   constructor(x, y, color) {
     this.color = color;                 // ReferenceError
     super(x, y);                        // 调用父类构造函数
     this.color = color;                 // 正确，super之后，才可以使用this
     console.log(super.p());             // 2 -- super指向父类原型对象，相当于Point.prototype.p()

     console.log(super);                   // 报错： 使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错

     // super.valueOf()表明super是一个对象，指向父类原型对象，super使得this指向B的实例，所以返回的是一个B的实例
     console.log(super.valueOf() instanceof B);    // true 

   }
 }

 let cp = new ColorPoint(25, 8, &#39;green&#39;);

 cp instanceof ColorPoint         // true
 cp instanceof Point              // true
</code></pre>
</li>
<li><p>super对象调用父类静态方法和普通方法</p>
<pre><code class="lang-js"> class Parent {
   static hello() {
     console.log(&#39;hello world&#39;);
   }
   static myMethod(msg) {
     console.log(&#39;static&#39;, msg);
   }
   myMethod(msg) {
     console.log(&#39;instance&#39;, msg);
   }
 }

 class Child extends Parent {
   static myMethod(msg) {
     super.myMethod(msg);        // 在子类静态方法中，super对象指向父类本身，调用父类静态方法
   }
   myMethod(msg) {
     super.myMethod(msg);        // 在子类普通方法中，super对象指向父类原型对象，调用父类方法
   }
 }

 // 调用子类静态方法
 Child.hello();              // hello world
 Child.myMethod(1);          // static 1

 // 调用子类普通方法
 var child = new Child();
 child.myMethod(2);          // instance 2
</code></pre>
</li>
</ol>
<h3 id="header-38">Decorator 修饰器</h3>
<pre><code class="lang-js">@decorator
class A {}

// 等同于
class A {}
A = decorator(A) || A;
</code></pre>
<p>只能用于修饰类和类属性（eg：不能用于函数，因为存在函数提升），本质即<strong>编译时执行的函数</strong> （不是在运行时）</p>
<ul>
<li>类修饰器<ul>
<li>参数（只有一个）：<ul>
<li><code>target</code>：所要修饰的目标类（即类本身）</li>
</ul>
</li>
</ul>
</li>
<li>类属性修饰器<ul>
<li>参数（三个）：<ul>
<li><code>target</code> ： 类的原型对象（类.prototype）– 修饰器的本意是要“修饰”类的实例，但是这个时候实例还没生成，所以只能去修饰原型</li>
<li><code>name</code> ： 修饰的类属性名</li>
<li><code>decriptor</code>：修饰类属性的描述对象</li>
</ul>
</li>
<li>返回：该属性的描述对象<code>Descriptor</code></li>
</ul>
</li>
<li>修饰器参数扩展：<ul>
<li>可以通过在修饰器外面再封装一层函数来传入入其他参数</li>
</ul>
</li>
<li>多个修饰器：<ul>
<li>会像剥洋葱一样，先从外到内进入，然后由内向外执行</li>
</ul>
</li>
<li>第三方模块提供的修饰器：<ul>
<li><code>core-decorators.js</code>：<ul>
<li>@autobind : 使得方法中的this对象，绑定原始对象</li>
<li>@readonly : 使得属性或方法不可写</li>
<li>@override : 检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错</li>
<li>@deprecate/@deprecated : 在控制台显示一条警告，表示该方法将废除</li>
<li>@suppressWarnings : 抑制deprecated修饰器导致的console.warn()调用 （异步代码发出的调用除外）</li>
</ul>
</li>
<li><code>traits-decorator</code>：<ul>
<li>@traits : 效果与 Mixin 类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等      </li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong> 示例: </strong> </p>
<ol>
<li><p>类修饰器</p>
<pre><code class="lang-js"> @testable
 class MyTestableClass {
   // ...
 }

 function testable(target) {    // target为所要修饰的目标类（类本身），即MyTestClass
   target.isTestable = true;    // 为类MyTestClass添加静态属性isTestable，想添加实例属性，可以通过目标类的prototype对象操作
 }

 MyTestableClass.isTestable     // true
</code></pre>
</li>
<li><p>类属性修饰器</p>
<pre><code class="lang-js"> function readonly(target, name, descriptor){
   descriptor.writable = false;
   return descriptor;
 }

 // descriptor对象原来的值如下
 // {
 //   value: specifiedFunction,
 //   enumerable: false,
 //   configurable: true,
 //   writable: true
 // };

 class Person {
   @readonly                                                                // readonly(Person.prototype, &#39;name&#39;, descriptor);
   name() { return `${this.first} ${this.last}` }
 }
</code></pre>
<pre><code class="lang-js"> class Math {
   @log
   add(a, b) {
     return a + b;
   }
 }

 function log(target, name, descriptor) {
   var oldValue = descriptor.value;

   descriptor.value = function() {
     console.log(`Calling ${name} with`, arguments);
     return oldValue.apply(this, arguments);
   };

   return descriptor;
 }

 const math = new Math();
 math.add(2, 4);                            // Calling add with 2,4
</code></pre>
</li>
<li><p>多个修饰器</p>
<pre><code class="lang-js"> function dec(id){
   console.log(&#39;evaluated&#39;, id);
   return (target, property, descriptor) =&gt; console.log(&#39;executed&#39;, id);
 }

 class Example {
     @dec(1)
     @dec(2)
     method(){}
 }

 const example=new Example();
 example.method();
 // evaluated 1
 // evaluated 2
 // executed 2
 // executed 1
</code></pre>
</li>
<li><p>应用: 实现Mixin模式（在一个对象之中混入另外一个对象的方法）</p>
<ul>
<li><p>使用类修饰器实现</p>
<pre><code class="lang-js">  // mixins.js
  export function mixins(...list) {              // 可以在修饰器外面再封装一层函数，以便传入其他参数
    return function (target) {
      Object.assign(target.prototype, ...list)   // 添加实例属性
    }
  }

  // main.js
  import { mixins } from &#39;./mixins&#39;

  const Foo = {
    foo() { console.log(&#39;foo&#39;) }
  };

  // 在MyClass类上面“混入”Foo对象的foo方法
  @mixins(Foo)
  class MyClass {}

  let obj = new MyClass();
  obj.foo()                                                 // &#39;foo&#39;
</code></pre>
</li>
<li><p>通过类的继承实现 Mixin （上面的方法会改写MyClass类的prototype对象）</p>
<pre><code class="lang-js">  // 返回一个继承superclass的子类，该子类包含一个foo方法 
  let MyMixin = (superclass) =&gt; class extends superclass {           
    foo() {
      console.log(&#39;foo from MyMixin&#39;);
    }
  };

  class MyClass extends MyMixin(MyBaseClass) {}

  let c = new MyClass();
  c.foo();                                                     // &quot;foo from MyMixin&quot;
</code></pre>
</li>
</ul>
</li>
<li><p>应用: React 与 Redux 库结合使用</p>
<pre><code class="lang-js"> class MyReactComponent extends React.Component {}
 export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);

 // 有了装饰器，就可以写成如下方式：
 @connect(mapStateToProps, mapDispatchToProps)
 export default class MyReactComponent extends React.Component {}
</code></pre>
</li>
</ol>
<h2 id="header-39">模块 Module</h2>
<p><strong> 模块加载方案：</strong></p>
<ul>
<li>CommonJS：用于服务器，动态加载（运行时加载）</li>
<li>AMD：用于浏览器，动态加载（运行时加载）</li>
<li>ES6：浏览器和服务器通用,静态加载（编译时加载）</li>
</ul>
<p><strong> 动态加载 vs 静态加载：</strong></p>
<ul>
<li>动态加载：<ul>
<li>运行时加载，无法在编译时做“静态优化”</li>
<li>模块输出的是值的拷贝，不存在动态更新</li>
</ul>
</li>
<li>静态加载：<ul>
<li>编译时加载，编译时就能确定模块的依赖关系，以及输入和输出的变量；</li>
<li>模块输出的是值的引用（类似Unix 系统的“符号连接”），可动态更新</li>
</ul>
</li>
</ul>
<h3 id="header-40">ES6 Module</h3>
<ul>
<li>自动采用严格模式，不管有没有在模块头部加上”use strict” （ES5引入的）</li>
<li>一个模块就是一个独立的文件，该文件内部的内容，外部无法获取</li>
<li>导出/导入<ul>
<li><code>export ...</code> ：定义模块的对外接口，可处于模块顶层的任何位置<ul>
<li>一个module可以有多条export，但只能有一条<code>export default</code></li>
<li><code>export default</code>：<ul>
<li>指定默认输出，这样 import 时就可以指定一个任意名字给加载项</li>
<li>本质上，就是输出一个叫做default的变量或方法 ( 将default后面的值，赋给default变量 )，然后系统允许你为它取任意名字</li>
</ul>
</li>
</ul>
</li>
<li><code>import ... from ...</code>：加载模块，Singleton 模式，静态加载（在静态解析阶段执行，所以它是一个模块之中最早执行的）<ul>
<li>静态执行，不能使用表达式和变量，不能使用逻辑判断动态加载</li>
<li>输入的加载项是只读的（本质是输入接口），即不允许在加载模块的脚本里面改写接口</li>
<li>多次重复执行同一句import语句或多次加载同一module，也只会执行一次</li>
<li><code>import &lt;module&gt;</code> : 不导入任何值，仅仅执行所加载的模块，eg: import ‘lodash’;</li>
</ul>
</li>
<li><code>export ... from ...</code>: <ul>
<li>在一个模块之中，输入输出同一个模块，export 和 import 可复合成一条</li>
<li>注： <code>export * from &#39;xxx&#39;</code> 会忽略export default输出</li>
</ul>
</li>
<li>可使用<code>as</code>重命名加载对象</li>
</ul>
</li>
</ul>
<ul>
<li>注： <ul>
<li>模块之中，顶层的this指向undefined（CommonJS 模块的顶层this指向当前模块）</li>
<li>通过 Babel 转码，CommonJS 模块的require命令和 ES6 模块的import命令，可以写在同一个模块里面 – 但不建议这样使用</li>
</ul>
</li>
</ul>
<p><strong> 示例：</strong></p>
<ol>
<li><p><code>export...</code> </p>
<ul>
<li><p>export 变量</p>
<pre><code class="lang-js">  // 写法一
  export var m = 1;

  // 写法二
  var m = 1;
  export {m};

  // 写法三
  var m = 1;
  export {m as n};
</code></pre>
</li>
<li><p>export 方法</p>
<pre><code class="lang-js">  // 写法一
  export function f() {};

  //写法二
  function f() {}
  export {f};

  // 写法三
  function f() {}
  export {f as fun};
</code></pre>
</li>
<li>export 多个，重命名<pre><code class="lang-js">  export {m,f}
  export {m as n, f as fun, f as fun2}
</code></pre>
</li>
</ul>
</li>
<li><p><code>import...from...</code></p>
<ul>
<li>cicle.js (module export)：<pre><code class="lang-js">  // circle.js
  export function area(radius) {
    return Math.PI * radius * radius;
  }
  export function circumference(radius) {
    return 2 * Math.PI * radius;
  }
</code></pre>
</li>
<li><p>import 部分：</p>
<pre><code class="lang-js">  import { area, circumference } from &#39;./circle&#39;;
  console.log(&#39;圆面积：&#39; + area(4));
  console.log(&#39;圆周长：&#39; + circumference(14));

  // 输入的变量都是只读的，因为它的本质是输入接口，不允许在加载模块的脚本里面，改写接口
  area.foo = &#39;hello&#39;;            // 合法操作
  area = {};                         // Syntax Error : &#39;area&#39; is read-only;
</code></pre>
</li>
<li><p>import 所有（整体加载）：</p>
<pre><code class="lang-js">  import * as circle from &#39;./circle&#39;;
  console.log(&#39;圆面积：&#39; + circle.area(4));
  console.log(&#39;圆周长：&#39; + circle.circumference(14));

  // 整体加载所在的那个对象，应该是可以静态分析的，不允许运行时改变
  circle.foo = &#39;hello&#39;;                    // Syntax Error
  circle.area = function () {};        // Syntax Error
</code></pre>
</li>
<li><p>注：</p>
<ul>
<li>以上加载部分和整体加载的区别</li>
<li><p>import是静态执行，不能使用表达式和变量</p>
<pre><code class="lang-js">  // 报错
  import { &#39;f&#39; + &#39;oo&#39; } from &#39;my_module&#39;;

  // 报错
  let module = &#39;my_module&#39;;
  import { foo } from module;    

  // 报错
  if (x === 1) {
    import { foo } from &#39;module1&#39;;
  } else {
    import { foo } from &#39;module2&#39;;
  }
</code></pre>
</li>
<li><p>多次重复执行同一句import语句或多次加载同一module，也只会执行一次</p>
<pre><code class="lang-js">  import &#39;lodash&#39;;       
  import &#39;lodash&#39;;      
  // 只执行一次，等同于：import &#39;lodash&#39;;

  import { foo } from &#39;my_module&#39;;
  import { bar } from &#39;my_module&#39;;
  // 只执行一次，等同于：import { foo, bar } from &#39;my_module&#39;;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>export default ...</code></p>
<ul>
<li><p>export和export default混合</p>
<pre><code class="lang-js">  export default function (obj) { ···}
  export function each(obj, iterator, context) {···}
  export { each as forEach };

  import _ , { each, forEach } from &#39;lodash&#39;;        // _ 即代表export default的内容
</code></pre>
</li>
<li><p>export和export default比较</p>
<pre><code class="lang-js">  // 第一组：export
  export function crc32() { ...};
  import {crc32} from &#39;crc32&#39;;            // import 使用大括号 {}

  // 第二组：export default
  export default function crc32() { ...}  // 同 export default function () { ... }
  import a from &#39;crc32&#39;;                    // import 不使用大括号{}，且可直接指定一个任意的名字
</code></pre>
</li>
<li><p>export default 变量（export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句）</p>
<pre><code class="lang-js">  var a = 1; 
  export default a;                     // 正确
  export default var a = 1;            // 错误

  export default 42;        // 正确
  export 42;                // 错误
</code></pre>
</li>
</ul>
</li>
<li><p><code>export ... from ...</code> </p>
<ul>
<li><p>部分导入导出： <code>export {...} from ...</code></p>
<pre><code>  export { foo, bar } from &#39;my_module&#39;;    // foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口

  // 可以简单理解为
  import { foo, bar } from &#39;my_module&#39;;
  export { foo, bar };
</code></pre></li>
<li><p>整体导入导出：<code>export * from ...</code>  ( 注：会忽略模块的default方法)</p>
<pre><code class="lang-js">  // 整体输出
  export * from &#39;my_module&#39;;                    // 会忽略模块的default方法

  //默认接口的写法
  export { default } from &#39;my_module&#39;;
  export { default as es6 } from &#39;./my_module&#39;;
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="header-41">浏览器环境加载</h3>
<p>使用<code>type=&quot;module&quot;</code> </p>
<ul>
<li>默认异步加载</li>
<li>按在页面出现的顺序依次执行加载</li>
<li>模块：<ul>
<li>代码是在模块作用域之中运行，而不是在全局作用域运行</li>
<li>可以使用<code>import</code>命令加载其他模块，<code>.js</code>后缀不可省略</li>
<li>顶层的this关键字返回undefined，而不是指向window，利用这个特点，可以侦测当前代码是否在 ES6 模块之中（eg：<code>const isNotModuleScript = this !== undefined;</code>）    </li>
</ul>
</li>
<li>转码：若浏览器不支持 ES6 Module，可以将其转为 ES5 的写法，eg：使用Babal，SystemJS</li>
</ul>
<p><strong> 示例：</strong></p>
<ol>
<li><p>浏览器加载javascript（使用 <code>type=&quot;application/javascript&quot;</code> 默认语言，可省略）</p>
<pre><code class="lang-js"> // 默认同步加载
 &lt;script src=&quot;path/to/myModule.js&quot;&gt;&lt;/script&gt;

 // 异步加载
 // defer： 渲染完再执行；多个defer时，会按照它们在页面出现的顺序加载；
 // async：下载完就执行，会中断渲染，执行完成后恢复渲染； 多个async时，不保证加载顺序；
 &lt;script src=&quot;path/to/myModule.js&quot; defer&gt;&lt;/script&gt;
 &lt;script src=&quot;path/to/myModule.js&quot; async&gt;&lt;/script&gt;
</code></pre>
</li>
<li><p>浏览器加载ES6 Module</p>
<pre><code class="lang-js"> &lt;script type=&quot;module&quot; src=&quot;./foo.js&quot;&gt;&lt;/script&gt;
 &lt;!-- 等同于 --&gt;
 &lt;script type=&quot;module&quot; src=&quot;./foo.js&quot; defer&gt;&lt;/script&gt;
</code></pre>
</li>
</ol>
<h3 id="header-42">Node环境加载</h3>
<p><strong> CommonJS Module VS ES6 Module：</strong></p>
<table class="table">
<thead>
<tr>
<th>操作</th>
<th style="text-align:left">CommonJS Module</th>
<th style="text-align:left">ES6 Module</th>
</tr>
</thead>
<tbody>
<tr>
<td>输出</td>
<td style="text-align:left">值的拷贝，不存在动态更新</td>
<td style="text-align:left">值的引用，可动态更新</td>
</tr>
<tr>
<td>加载</td>
<td style="text-align:left">运行时加载，无法做“静态优化” <br> （加载的是一个对象，即module.exports属性，该对象只有在脚本运行完才会生成）</td>
<td style="text-align:left">编译时加载，可做“静态优化” <br> （只是一种静态定义，编译时就能确定模块的依赖关系，以及输入和输出的变量）</td>
</tr>
<tr>
<td>循环加载</td>
<td style="text-align:left">使用require命令加载脚本 <br> ( 返回的是当前已经执行的部分的值，而不是代码全部执行后的值)</td>
<td style="text-align:left">使用import命令加载 <br> ( 返回的是引用，需要开发者自己保证，真正取值的时候能够取到值）</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">第一次加载: 会执行整个脚本，在内存中生成一个对象; <br> 第N次加载：不会再执行，直接到缓存中取值，除非手动清除缓存</td>
<td style="text-align:left">加载项不会被缓存，已加载项不会重复加载</td>
</tr>
</tbody>
</table>
<p>注：</p>
<ol>
<li><p>CommonJS Module第一次加载在内存中生成的对象如下：</p>
<pre><code class="lang-js"> {
   id: &#39;...&#39;,               // 模块名
   exports: { ... },        // 模块输出的各个接口（以后需要用到这个模块的时候，就会到exports属性上面取值）
   loaded: true,            // 表示该模块的脚本是否执行完毕
   ...
 }
</code></pre>
</li>
<li><p>CommonJS Module 循环加载示例：（加载返回的是当前已经执行的部分的值，而不是代码全部执行后的值）</p>
<ul>
<li>a.js : 加载 b.js<pre><code class="lang-js">  exports.done = false;
  var b = require(&#39;./b.js&#39;);
  console.log(&#39;在 a.js 之中，b.done = %j&#39;, b.done);
  exports.done = true;
  console.log(&#39;a.js 执行完毕&#39;);
</code></pre>
</li>
<li>b.js : 加载 a.js<pre><code class="lang-js">  exports.done = false;
  var a = require(&#39;./a.js&#39;);
  console.log(&#39;在 b.js 之中，a.done = %j&#39;, a.done);
  exports.done = true;
  console.log(&#39;b.js 执行完毕&#39;);
</code></pre>
</li>
<li>main.js : 加载 a.js,b.js<pre><code class="lang-js">  var a = require(&#39;./a.js&#39;);
  var b = require(&#39;./b.js&#39;);
  console.log(&#39;在 main.js 之中, a.done=%j, b.done=%j&#39;, a.done, b.done);
</code></pre>
</li>
<li><p>node执行</p>
<pre><code>  $ node main.js

  在 b.js 之中，a.done = false
  b.js 执行完毕
  在 a.js 之中，b.done = true
  a.js 执行完毕
  在 main.js 之中, a.done=true, b.done=true
</code></pre></li>
</ul>
</li>
</ol>
<p><strong> Node 模板加载方案：</strong></p>
<p>Node 有自己的 CommonJS 模块格式，与 ES6 模块格式不兼容，所以ES6 模块和 CommonJS 需采用各自的加载方案</p>
<ul>
<li>ES6<ul>
<li>采用<code>.mjs</code>后缀文件名</li>
<li>使用<code>export</code>/<code>import</code>命令，不能使用<code>require</code>命令</li>
</ul>
</li>
<li>CommonJS<ul>
<li>使用<code>module.export</code>/<code>require</code>命令</li>
</ul>
</li>
<li>ES6 module 加载 CommonJS module: <ul>
<li>使用 <code>import ... from ...</code> 命令</li>
<li>Node 会将<code>module.exports</code>属性，当作模块的默认输出，即等同于<code>export default ...</code></li>
</ul>
</li>
<li>CommonJS module 加载 ES6 module: <ul>
<li>使用<code>import(...)</code>函数</li>
<li>ES6 模块的所有输出接口，会成为输入对象的属性（注：不能使用require命令）</li>
</ul>
</li>
</ul>
<ul>
<li>注：<ul>
<li>通过 Babel 转码，CommonJS 模块的require命令和 ES6 模块的import命令，可以写在同一个模块里面，但不建议这样使用</li>
<li>ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量<ul>
<li>ES6 模块之中，顶层的this指向undefined；CommonJS 模块的顶层this指向当前模块</li>
<li>在 ES6 模块之中不存在的顶层变量：arguments,require,module,exports,<strong>filename,</strong>dirname</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong> 说明：</strong>    </p>
<ol>
<li><code>import ... from ...</code> 命令：异步加载，只支持加载本地模块，不支持加载远程模块<ul>
<li>模块名不含路径：会去node_modules目录寻找这个模块</li>
<li>模块名包含路径：会按照路径去寻找这个名字的脚本文件</li>
<li>省略了后缀名的加载,依次尝试:<ul>
<li>依次尝试四个后缀名：mjs，js，json，node;</li>
<li>尝试加载该目录下的package.json的main字段指定的脚本；</li>
<li>尝试加载该目录下的名为index，后缀为mjs,js,json,node的文件</li>
</ul>
</li>
</ul>
</li>
<li><code>import(...)</code>函数：同步加载<ul>
<li>返回一个Promise对象，实现动态加载，类似于 Node 的require方法（异步加载）</li>
<li>与所加载的模块没有静态连接关系，可以用在任何地方，非模块的脚本也可以使用</li>
</ul>
</li>
</ol>
<p><strong> 示例：</strong> </p>
<ol>
<li><p>ES6 Module加载CommonJS Module : 使用 <code>import...from...</code>命令</p>
<ul>
<li><p>a.js （CommonJS module）： CommonJS模块的输出都定义在module.exports这个属性上面</p>
<pre><code class="lang-js">  module.exports = {
    foo: &#39;hello&#39;,
    bar: &#39;world&#39;
  };

  // 等同于 ES6：
  export default {
    foo: &#39;hello&#39;,
    bar: &#39;world&#39;
  };
</code></pre>
</li>
<li><p>ES6 Module导入a.js （注：需使用整体输入）：使用Node的<code>import...from...</code>命令加载 CommonJS 模块，Node 会自动将<code>module.exports</code>属性，当作模块的默认输出，即等同于<code>export default ...</code></p>
<pre><code class="lang-js">  // 写法一
  import baz from &#39;./a&#39;;
  // baz = {foo: &#39;hello&#39;, bar: &#39;world&#39;};

  // 写法二
  import {default as baz} from &#39;./a&#39;;
  // baz = {foo: &#39;hello&#39;, bar: &#39;world&#39;};

  // 写法三
  import * as baz from &#39;./a&#39;;
  // baz = {
  //   get default() {return module.exports;},
  //   get foo() {return this.default.foo}.bind(baz),
  //   get bar() {return this.default.bar}.bind(baz)
  // }
  baz.default         // {foo: &#39;hello&#39;, bar: &#39;world&#39;}
  baz.foo                // hello

  // 注意：ES6 模块是编译时确定输出接口，CommonJS 模块是运行时确定输出接口，只有在运行时才能确定foo，所以下面方式不正确
  import { foo } from &#39;./a&#39;
</code></pre>
</li>
</ul>
</li>
<li><p>CommonJS module加载ES6 module: 使用<code>import(...)</code>函数（注：不能使用require命令），ES6 模块的所有输出接口，会成为输入对象的属性</p>
<ul>
<li>ES6 Module：es.js<pre><code class="lang-js">  export let foo = { bar:&#39;my-default&#39; };
  export { foo as bar };
  export function f() {};
  export class c {};
</code></pre>
</li>
<li>CommonJS 导入 es.js<pre><code class="lang-js">  const es_namespace = await import(&#39;./es&#39;);
  // es_namespace = {
  //   get foo() {return foo;}
  //   get bar() {return foo;}
  //   get f() {return f;}
  //   get c() {return c;}
  // }
</code></pre>
</li>
</ul>
</li>
</ol>
<h2 id="header-43">实践</h2>
<h3 id="header-44">var/let/const</h3>
<ol>
<li><p>let取代var</p>
<ul>
<li>两者语义相同，且let没有副作用：var命令存在变量提升效用，let命令没有这个问题,let只在其声明的代码块内有效</li>
</ul>
</li>
<li><p>优先使用const</p>
<ul>
<li>防止了无意间修改变量值所导致的错误（函数应该都设置为const）</li>
<li>const比较符合函数式编程思想，运算不改变值，只是新建值，这样也有利于将来的分布式运算；</li>
<li>JavaScript编译器会对const进行优化，有利于提高程序的运行效率（let和const的本质区别，其实是编译器内部的处理不同）</li>
<li>长远来看，JavaScript 可能会有多线程的实现,const利于保证线程安全</li>
</ul>
</li>
</ol>
<h3 id="header-45">解构赋值</h3>
<p>以下情况优先使用解构赋值</p>
<ol>
<li><p>使用数组成员对变量赋值</p>
<pre><code class="lang-js"> const arr = [1, 2, 3, 4];

 // bad
 const first = arr[0];
 const second = arr[1];

 // good
 const [first, second] = arr;
</code></pre>
</li>
<li><p>函数的参数是对象的成员</p>
<pre><code class="lang-js"> // bad
 function getFullName(user) {
   const firstName = user.firstName;
   const lastName = user.lastName;
 }

 // good
 function getFullName(obj) {
   const { firstName, lastName } = obj;
 }

 // best
 function getFullName({ firstName, lastName }) {
 }
</code></pre>
</li>
<li><p>函数返回多个值，优先使用对象的解构赋值（注：不是数组的解构赋值），便于以后添加返回值，以及更改返回值的顺序</p>
<pre><code class="lang-js"> // bad
 function processInput(input) {
   return [left, right, top, bottom];
 }

 // good
 function processInput(input) {
   return { left, right, top, bottom };
 }

 const { left, right } = processInput(input);
</code></pre>
</li>
</ol>
<h3 id="header-46">String</h3>
<ul>
<li>静态字符串: 使用单引号或反引号</li>
<li>动态字符串: 使用反引号</li>
</ul>
<pre><code class="lang-js">// bad
const a = &quot;foobar&quot;;
const b = &#39;foo&#39; + a + &#39;bar&#39;;

// acceptable
const c = `foobar`;

// good
const a = &#39;foobar&#39;;
const b = `foo${a}bar`;
</code></pre>
<h3 id="header-47">Array</h3>
<ol>
<li><p>拷贝数组: 使用扩展运算符<code>...</code></p>
<pre><code class="lang-js"> // bad
 const len = items.length;
 const itemsCopy = [];
 let i;

 for (i = 0; i &lt; len; i++) {
   itemsCopy[i] = items[i];
 }

 // good
 const itemsCopy = [...items];
</code></pre>
</li>
<li><p>对象转为数组: 使用 <code>Array.from</code> 方法</p>
<pre><code class="lang-js"> const foo = document.querySelectorAll(&#39;.foo&#39;);
 const nodes = Array.from(foo);
</code></pre>
</li>
</ol>
<h3 id="header-48">Object</h3>
<ol>
<li><p>定义对象</p>
<ul>
<li>单行定义：最后一个成员不以逗号结尾</li>
<li><p>多行定义：最后一个成员可以逗号结尾</p>
<pre><code class="lang-js">// bad
const a = { k1: v1, k2: v2, };
const b = {
k1: v1,
k2: v2
};

// good
const a = { k1: v1, k2: v2 };
const b = {
k1: v1,
k2: v2,
};
</code></pre>
</li>
</ul>
</li>
<li><p>尽量静态化</p>
<ul>
<li>定义后尽量不添加新的属性</li>
<li><p>使用<code>Object.assign</code>方法添加属性</p>
<pre><code class="lang-js">  // bad
  const a = {};
  a.x = 3;

  // if reshape unavoidable
  const a = {};
  Object.assign(a, { x: 3 });

  // good
  const a = { x: null };
  a.x = 3;
</code></pre>
</li>
<li>动态属性名: 可在创造对象的时候，用属性表达式定义<pre><code class="lang-js">  // bad
  const obj = {
      id: 5,
      name: &#39;San Francisco&#39;,
  };
  obj[getKey(&#39;enabled&#39;)] = true;
</code></pre>
<pre><code class="lang-js">  // good
  const obj = {
    id: 5,
    name: &#39;San Francisco&#39;
    ,[getKey(&#39;enabled&#39;)]: true,
  };
</code></pre>
</li>
</ul>
</li>
<li><p>尽量简洁表达属性和方法（易于描述和书写）</p>
<pre><code class="lang-js"> var ref = &#39;some value&#39;;

 // bad
 const atom = {
   ref: ref,
   value: 1,
   addValue: function (value) {
     return atom.value + value;
   },
 };

 // good
 const atom = {
   ref,
   value: 1,
   addValue(value) {
     return atom.value + value;
   },
 };
</code></pre>
</li>
</ol>
<h3 id="header-49">Function</h3>
<ol>
<li><p>建议尽量使用箭头函数的情况：</p>
<ul>
<li>立即执行函数<pre><code class="lang-js">  (() =&gt; {
    console.log(&#39;Welcome to the Internet.&#39;);
  })();
</code></pre>
</li>
<li><p>原来一些需要使用函数表达式的场合</p>
<pre><code class="lang-js">  // bad
  [1, 2, 3].map(function (x) {
    return x * x;
  });

  // good
  [1, 2, 3].map((x) =&gt; {
    return x * x;
  });

  // best
  [1, 2, 3].map(x =&gt; x * x);
</code></pre>
</li>
<li><p>取代Function.prototype.bind(不再用 self/_this/that 绑定 this)</p>
<pre><code class="lang-js">  // bad
  const self = this;
  const boundMethod = function(...params) {
    return method.apply(self, params);
  }

  // acceptable
  const boundMethod = method.bind(this);

  // best
  const boundMethod = (...params) =&gt; method.apply(this, params);
</code></pre>
</li>
<li>注：简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法</li>
</ul>
</li>
<li><p>函数参数</p>
<ul>
<li><p>使用rest运算符<code>...</code>代替<code>arguments</code>变量 (arguments 是一个类似数组的对象，而rest运算符可以提供一个真正的数组)</p>
<pre><code class="lang-js">  // bad
  function concatenateAll() {
    const args = Array.prototype.slice.call(arguments);
    return args.join(&#39;&#39;);
  }

  // good
  function concatenateAll(...args) {
    return args.join(&#39;&#39;);
  }
</code></pre>
</li>
<li><p>使用默认值语法设置参数的默认值</p>
<pre><code class="lang-js">  // bad
  function handleThings(opts) {
    opts = opts || {};
  }

  // good
  function handleThings(opts = {}) {
    // ...
  }
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="header-50">Class</h3>
<ol>
<li><p>用Class取代需要 prototype的操作（Class语法更简洁易理解）</p>
<pre><code class="lang-js"> // bad
 function Queue(contents = []) {
   this._queue = [...contents];
 }
 Queue.prototype.pop = function() {
   const value = this._queue[0];
   this._queue.splice(0, 1);
   return value;
 }

 // good
 class Queue {
   constructor(contents = []) {
     this._queue = [...contents];
   }
   pop() {
     const value = this._queue[0];
     this._queue.splice(0, 1);
     return value;
   }
 }
</code></pre>
</li>
<li><p>用extends实现继承（extend语法更简单，且不会有破坏instanceof运算的危险）</p>
<pre><code class="lang-js"> // bad
 const inherits = require(&#39;inherits&#39;);
 function PeekableQueue(contents) {
   Queue.apply(this, contents);
 }
 inherits(PeekableQueue, Queue);
 PeekableQueue.prototype.peek = function() {
   return this._queue[0];
 }

 // good
 class PeekableQueue extends Queue {
   peek() {
     return this._queue[0];
   }
 }
</code></pre>
</li>
</ol>
<h3 id="header-51">Module</h3>
<ol>
<li><p>使用import取代require</p>
<pre><code class="lang-js"> // bad
 const moduleA = require(&#39;moduleA&#39;);
 const func1 = moduleA.func1;
 const func2 = moduleA.func2;

 // good
 import { func1, func2 } from &#39;moduleA&#39;;
</code></pre>
</li>
<li><p>使用export取代module.exports</p>
<pre><code class="lang-js"> // commonJS的写法
 var React = require(&#39;react&#39;);
 var Breadcrumbs = React.createClass({
   render() {
     return &lt;nav /&gt;;
   }
 });
 module.exports = Breadcrumbs;

 // ES6的写法
 import React from &#39;react&#39;;
 class Breadcrumbs extends React.Component {
   render() {
     return &lt;nav /&gt;;
   }
 };
 export default Breadcrumbs;
</code></pre>
</li>
<li><p>尽量不使用通配符来确保至少有一个默认输出(export default)</p>
<pre><code class="lang-js"> // bad
 import * as myObject from &#39;./importModule&#39;;

 // good
 import myObject from &#39;./importModule&#39;;
</code></pre>
</li>
</ol>
<h3 id="header-52">ESLint</h3>
<p>一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码</p>
<ol>
<li><p>安装</p>
<pre><code class="lang-shell"> // 安装ESLint
 $ npm i -g eslint

 //安装 Airbnb 语法规则
 $ npm i -g eslint-config-airbnb

 //安装import、a11y、react 插件
 $ npm i -g eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react
</code></pre>
</li>
<li><p>配置（项目的根目录下新建一个.eslintrc文件）</p>
<pre><code class="lang-json"> {
   &quot;extends&quot;: &quot;eslint-config-airbnb&quot;
 }
</code></pre>
</li>
<li><p>使用，eg：</p>
<ul>
<li><p>index.js</p>
<pre><code class="lang-js">  var unusued = &#39;I have no purpose!&#39;;

  function greet() {
      var message = &#39;Hello, World!&#39;;
      alert(message);
  }

  greet();
</code></pre>
</li>
<li><p>使用 ESLint 检查index.js，发现错误</p>
<pre><code class="lang-js">  $ eslint index.js
  index.js
    1:1  error  Unexpected var, use let or const instead          no-var
    1:5  error  unusued is defined but never used                 no-unused-vars
    4:5  error  Expected indentation of 2 characters but found 4  indent
    4:5  error  Unexpected var, use let or const instead          no-var
    5:5  error  Expected indentation of 2 characters but found 4  indent

  × 5 problems (5 errors, 0 warnings)
</code></pre>
<ul>
<li>不应该使用var命令，而要使用let或const</li>
<li>定义了变量，却没有使用</li>
<li>行首缩进为 4 个空格，而不是规定的 2 个空格</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="header-53">Reference</h2>
<ul>
<li><a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="noopener">阮一峰 ECMAScript 6 入门</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">Object.create()</a></li>
</ul>
  </section>
</article>

      <hr/>
      
<section class="post-comment">
	
		<div id="gitment_container"></div>

<link rel="stylesheet" href="/gitment/default.css">
<script src="/gitment/gitment.browser.js"></script>


<script type="text/javascript">
	var gitment = new Gitment({
	  id: document.location.pathname,
	  owner: 'chenjin-zero',
	  repo: 'blogComment',
	  oauth: {
	    client_id: '36a09bb7399efe69c6ce',
	    client_secret: 'ad9ad546b23b708c71d92e513dc36e0486179dea',
	  }
	})
      
	gitment.render('gitment_container')
</script>
	
</section>

    </div>
  </div>
</body>

<script src="/jquery/dist/jquery.min.js"></script>
<script src="/bootstrap/dist/js/bootstrap.min.js"></script>


	<script src="/highlight/highlight.pack.js"></script>
	<script type="text/javascript">
		hljs.initHighlightingOnLoad();
	</script>



<script type="text/javascript">

  $(document).ready(function(){
    var sidebarCtrl=$("#sidebar-ctrl");
    var sidebar=$("#sidebar");
    var wrapper=$("#wrapper");
    sidebarCtrl.on("click",function(event){
        //alert("click");
        sidebar.toggleClass("sidebar-toggle");
        wrapper.toggleClass("sidebar-toggle");
        sidebarCtrl.toggleClass("sidebar-toggle");
        sidebarCtrl.toggleClass("active");
    })
  });
</script>


</html>
