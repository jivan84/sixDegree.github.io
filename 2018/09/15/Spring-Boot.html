<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Spring Boot</title>
  
  <!-- Meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="Spring">
  
  

  <!-- Feed -->
  
    <link rel="alternative" href="/atom.xml" title="SixDegree" type="application/atom+xml">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/bootstrap/dist/css/bootstrap.css">
  
	
		<link rel="stylesheet" href="/highlight/styles/tomorrow-night-bright.css">
	
    
  
  <link rel="stylesheet" href="/css/fontello.css">
  <link rel="stylesheet" href="/css/style.css">

  <!-- Site Analyse -->
  
	<script>
	var userID='2bbb83cc0f781dd7502e9d5e19661866';
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?"+userID;
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>


</head>

<body data-spy="scroll" data-target="#nav-catalog">
  <div id="top-push"></div>
<a href="#top-push" id="go-top">
	<span class="glyphicon glyphicon-chevron-up"></span>
</a>
  <aside id="sidebar">
    <section class="sidebar-header">Catalog</section>
     <nav id="nav-catalog">
        <ol class="sidebar-nav nav"><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-1"><span class="sidebar-nav nav-text">Starter</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-2"><span class="sidebar-nav nav-text">三大特性</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-3"><span class="sidebar-nav nav-text">Web</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-4"><span class="sidebar-nav nav-text">基本使用</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-5"><span class="sidebar-nav nav-text">Hello World(使用嵌入式容器)</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-6"><span class="sidebar-nav nav-text">Hello World(使用独立容器)</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-7"><span class="sidebar-nav nav-text">Hello World</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-8"><span class="sidebar-nav nav-text">热部署</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-9"><span class="sidebar-nav nav-text">单元测试</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-10"><span class="sidebar-nav nav-text">属性配置</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-11"><span class="sidebar-nav nav-text">AOP</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-12"><span class="sidebar-nav nav-text">异常处理</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-13"><span class="sidebar-nav nav-text">装配</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-14"><span class="sidebar-nav nav-text">Spring 装配技术</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-15"><span class="sidebar-nav nav-text">模式注解装配</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-16"><span class="sidebar-nav nav-text">模块装配</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-17"><span class="sidebar-nav nav-text">条件装配</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-4"><a class="sidebar-nav nav-link" href="#header-18"><span class="sidebar-nav nav-text">工厂加载机制</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-19"><span class="sidebar-nav nav-text">SpringBoot自动装配</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-20"><span class="sidebar-nav nav-text">SpringApplication</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-21"><span class="sidebar-nav nav-text">使用</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-22"><span class="sidebar-nav nav-text">启动过程</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-23"><span class="sidebar-nav nav-text">源码分析</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-24"><span class="sidebar-nav nav-text">使用扩展</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-25"><span class="sidebar-nav nav-text">Spring事件监听模型</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-26"><span class="sidebar-nav nav-text">外部化配置</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-27"><span class="sidebar-nav nav-text">加载外部化配置（XML方式）</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-28"><span class="sidebar-nav nav-text">Annotation方式</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-29"><span class="sidebar-nav nav-text">源码分析</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-30"><span class="sidebar-nav nav-text">获取Environment</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-31"><span class="sidebar-nav nav-text">实时扩展外部化配置属性源</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-32"><span class="sidebar-nav nav-text">Servlet</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-33"><span class="sidebar-nav nav-text">Servlet 容器启动初始化</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-34"><span class="sidebar-nav nav-text">Servlet 嵌入式容器启动初始化</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-35"><span class="sidebar-nav nav-text">组件Servlet源码分析</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-36"><span class="sidebar-nav nav-text">Servlet异步支持(3.0+)</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-37"><span class="sidebar-nav nav-text">WebMVC</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-38"><span class="sidebar-nav nav-text">模版视图之JSP</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-39"><span class="sidebar-nav nav-text">模版视图之Thymeleaf</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-40"><span class="sidebar-nav nav-text">多视图处理</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-41"><span class="sidebar-nav nav-text">内容协商视图解析器</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-42"><span class="sidebar-nav nav-text">REST</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-43"><span class="sidebar-nav nav-text">跨域</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-44"><span class="sidebar-nav nav-text">WebMVC 源码分析</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-45"><span class="sidebar-nav nav-text">SpringBoot自动装配</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-46"><span class="sidebar-nav nav-text">装载ThymeleafViewResolver</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-47"><span class="sidebar-nav nav-text">ContentNegotiatingViewResolver</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-48"><span class="sidebar-nav nav-text">DispatcherServlet</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-49"><span class="sidebar-nav nav-text">WebFlux</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-50"><span class="sidebar-nav nav-text">Java 并发模型</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-51"><span class="sidebar-nav nav-text">Reactive</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-52"><span class="sidebar-nav nav-text">Reactor</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-53"><span class="sidebar-nav nav-text">WebFlux</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-54"><span class="sidebar-nav nav-text">Reference</span></a></li></ol>
    </nav>
  </aside>
  <span id="sidebar-ctrl" class="glyphicon glyphicon-list-alt circle"></span>
  <div id="wrapper">
    <header>
  <nav class="navbar navbar-default">
    <div class="container-fluid">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#nav-menu" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/">SixDegree</a>
      </div>
      <div class="collapse navbar-collapse" id="nav-menu">
        <ul class="nav navbar-nav navbar-right">
          
              <li  >
                <a href="/">Blogs</a>
              </li>
          
              <li  >
                <a href="/tags.html">Tags</a>
              </li>
          
              <li  >
                <a href="/about.html">About</a>
              </li>
          
          
              <li>
                <a href="/atom.xml" target="_blank">
                  <span class="icon-rss"></span>
                </a>
              </li>
          
              <li>
                <a href="http://github.com/sixdegree" target="_blank">
                  <span class="icon-github"></span>
                </a>
              </li>
          
        </ul>
      </div>
    </div>
  </nav>
</header>



    <div class="container">
      <article class="detail" role="main">
  <section class="post-header">
    <h1 class="post-title">Spring Boot</h1>
    <ul class="post-meta">
      <li>
        <span class="glyphicon glyphicon-calendar"></span>
        <time datetime="2018-09-14T16:00:00.000Z">2018-09-15</time>
      </li>
      
        <li>
         <span class="glyphicon glyphicon-tags"></span>
          
            <a href="/tags.html#tag-Java">Java</a>
          
            <a href="/tags.html#tag-Spring">Spring</a>
          
        </li>
      
    </ul>
  </section>
  <section class="post-content">
    <h2 id="header-1">Starter</h2>
<blockquote>
<p>Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can &quot;just run&quot;.</p>
</blockquote>
<ul>
<li>全新框架，目的是简化Spring应用的搭建和开发过程，不需要定义样板化的配置（例如xml文件）</li>
<li>从根本上讲是一些库的集合（使用Maven／Gradle 构建项目，无需自行管理这些库的版本）</li>
<li>特点：<ul>
<li>简化Maven配置</li>
<li>自动配置Spring</li>
<li>创建独立的Spring应用程序</li>
<li>嵌入Web容器，无需部署war包（直接<code>java -jar</code> 就可运行）</li>
<li>提供生产就绪型功能（如指标，健康检查和外部配置）</li>
</ul>
</li>
<li>场景：<ul>
<li>开发Restful风格的微服务架构</li>
<li>微服务，自动化，横向扩展</li>
<li>精简配置与整合其他工具</li>
</ul>
</li>
<li>Vesion:<ul>
<li>SpringBoot 1.x - Spring 4.x</li>
<li>SpringBoot 2.x - Spring 5.x</li>
</ul>
</li>
</ul>
<p><img src="/2018/09/15/springboot.png" alt="Spring Boot"></p>
<h3 id="header-2">三大特性</h3>
<ol>
<li><p>自动装配组件： Web MVC，Web Flux，JDBC,...</p>
<ul>
<li>激活：<code>@EnableAutoConfiguration</code><pre><code class="lang-java">  @EnableAutoConfiguration
  public class App {
      public static void main(String[] args) { 
          SpringApplication.run(App.class,args);
      }
  }
</code></pre>
</li>
<li>实现：<code>XxxAutoConfiguration</code> , eg: <code>WebMvcAutoConfiguration</code><pre><code class="lang-java">  @Configuration
  @ConditionalOnWebApplication(type = Type.SERVLET)
  @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })
  @ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
  @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
  @AutoConfigureAfter({ DispatcherServletAutoConfiguration.class,ValidationAutoConfiguration.class })
  public class WebMvcAutoConfiguration {
      @Bean
      //...
  }
</code></pre>
</li>
<li>配置：<code>/META-INF/spring.factories</code>,eg: the spring.factories file under spring-boot-autoconfigure-xxx.jar<pre><code>  # Auto Configure
  org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
  org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
  org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
  org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\
  org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\
  ...
</code></pre></li>
</ul>
</li>
<li><p>嵌入式Web容器：</p>
<ul>
<li>Web Servlet: <code>Tomcat</code>，<code>Jetty</code>，<code>Undertow</code></li>
<li>Web Reactive: <code>Netty Web Server</code></li>
</ul>
</li>
<li><p>生产准备特性：</p>
<ul>
<li>dependency: <code>spring-boot-starter-actuator</code></li>
<li><code>application.properties</code>:<pre><code>  # 开放所有的Web Endpoints
  # management.endpoints.web.exposure.include=*
  management.endpoints.web.exposure.include=health,info
</code></pre></li>
<li>visit <code>/actuator</code> (eg：<code>http://localhost:8080/actuator</code> )</li>
<li>jconsole </li>
<li>端点：各类Web和JMX Endpoints<ul>
<li>指标: 内建Metrics，自定义Metrics (visit: <code>/actuator/metrics</code> )</li>
<li>健康检查: Health，HealthIndicator (visit <code>/actuator/health</code> )</li>
<li>外部化配置 (visit <code>/actuator/configprops</code> )</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="header-3">Web</h3>
<ol>
<li><p>传统Servlet</p>
<ul>
<li>jar: javax.servlet-api (或embed server jar，eg： tomcat-embed-core)</li>
<li>核心组件:<code>Servlet</code>,<code>Filter,Listener</code></li>
<li>注入：<ul>
<li>Servlet注解: <code>@WebServlet</code>,<code>@WebFilter</code>,<code>@WebListener</code></li>
<li>Spring Bean: <code>@Bean</code></li>
<li>SpringBoot:<code>RegistrationBean</code>,<code>@ServletComponentScan</code>,<code>ServletContextInitializer</code></li>
</ul>
</li>
<li>Servlet 3.0 规范：加入异步Servlet</li>
<li>Servlet 3.1 规范：加入非阻塞Servlet</li>
</ul>
</li>
<li><p>Spring WebMVC</p>
<ul>
<li>jar: <code>spring-webmvc</code> (dependency: <code>spring-web</code>)</li>
<li>核心组件(jar: <code>spring-webmvc</code>, package：<code>o.s.w.servlet...</code>)：<ul>
<li>总控 <code>DispatcherServlet</code></li>
<li>处理器管理<ul>
<li>映射 <code>HandlerMapping</code> (eg: RequestMappingHandlerMapping)</li>
<li>适配 <code>HandlerAdapter</code> (eg: RequestMappingHandlerAdapter)</li>
<li>执行 <code>HandlerExecutionChain</code></li>
</ul>
</li>
<li>异常解析器 <code>HandlerExceptionResolver</code></li>
<li>HandlerMethod: <code>@RequestMapping</code>/<code>@XxxMapping</code>标注的方法<ul>
<li>HandlerMethod参数解析器: <code>HandlerMethodArgumentResolver</code></li>
<li>HandlerMethod返回值解析器: <code>HandlerMethodReturnValueHandler</code></li>
</ul>
</li>
<li>视图解析器 <code>ViewResolver</code><ul>
<li>国际化 <code>LocaleResolver</code>,<code>LocaleContextResolver</code></li>
<li>个性化 <code>ThemeResolver</code></li>
<li>内容协商 <code>ContentNegotiatingViewResolver</code></li>
<li>默认 <code>InternalResourceViewResolver</code></li>
</ul>
</li>
<li>视图渲染 <code>View</code>, eg:<ul>
<li><code>RedirectView</code></li>
<li><code>JstlView</code></li>
<li><code>ThymeleafView</code></li>
</ul>
</li>
<li>配置 <ul>
<li><code>WebMvcConfigurer</code></li>
<li><code>ContentNegotiationConfigurer</code></li>
</ul>
</li>
</ul>
</li>
<li>注解：<ul>
<li><code>@Controller</code>,<code>@ControllerAdvice</code>,<code>@ExceptionHandler</code></li>
<li><code>@RequestMapping</code>（<code>@GetMapping</code>,<code>@PostMapping</code>,...)</li>
<li><code>@RequestBody</code>,<code>@RequestParm</code>,<code>@RequestHeader</code>,<code>@PathVariable</code>,<code>@CookieValue</code></li>
<li><code>@RestController</code>,<code>@RestControllerAdvice</code>,<code>@ResponseBody</code>(for Rest)</li>
<li><code>@ModelAttribute</code>,<code>@Valid</code>,<code>@Validated</code></li>
</ul>
</li>
</ul>
</li>
<li><p>Spring WebFlux</p>
<ul>
<li>jar: <code>spring-webflux</code> (dependency: <code>spring-web</code>,<code>reactor-core</code>)</li>
<li>是<code>Reactive</code>思想的一种实现（数据流<code>Data Stream</code>，非阻塞 <code>Non-Blocking</code>，推模式<code>push-based</code>，背压<code>Backpressure</code>）</li>
<li>依赖<code>Reactor</code>类库(jar:<code>reactor-core</code>)<ul>
<li>依赖<code>reactive-streams</code><ul>
<li>核心组件：<code>Publisher</code>,<code>Subscriber</code>,<code>Subscription</code>,<code>Processor</code></li>
<li>背压处理</li>
</ul>
</li>
<li>核心组件：<code>Mono</code>,<code>Flux</code>,<code>Scheduler</code></li>
</ul>
</li>
<li>依赖<code>SpringWeb</code>类库(jar: <code>spring-web</code>)<ul>
<li><code>HttpHandler</code>: <code>Mono&lt;Void&gt; handle(ServerHttpRequest request, ServerHttpResponse response);</code></li>
<li><code>WebHandler</code>: <code>Mono&lt;Void&gt; handle(ServerWebExchange exchange);</code></li>
</ul>
</li>
<li>编程模型：<ul>
<li>注解式驱动 <a href="https://docs.spring.io/spring/docs/5.0.x/spring-framework-reference/web-reactive.html#webflux-controller">Annotated Controllers</a>: 同WebMvc使用的注解</li>
<li>函数式端点 <a href="https://docs.spring.io/spring/docs/5.0.x/spring-framework-reference/web-reactive.html#webflux-fn">Functional Endpoints</a> : 使用<code>RouterFunction</code>(功能上代替Contoller+HandleMethod)</li>
</ul>
</li>
<li>核心组件(功能大同WebMvc, jar: <code>spring-webflux</code>， package：<code>o.s.w.reactive...</code>):<ul>
<li>总控 <code>DispatcherHandler</code> (implements <code>WebHandler</code>)</li>
<li>处理器管理<ul>
<li>映射 <code>HandlerMapping</code> (eg: RequestMappingHandlerMapping)</li>
<li>适配 <code>HandlerAdapter</code> (eg: RequestMappingHandlerAdapter)</li>
<li>执行 <code>HandlerResult</code></li>
</ul>
</li>
<li>异常处理 <code>HandlerResult#exceptionHandler</code></li>
<li>HandlerMethod: <code>@RequestMapping</code>/<code>@XxxMapping</code>标注的方法<ul>
<li>HandlerMethod参数解析器: <code>HandlerMethodArgumentResolver</code></li>
<li>Handler返回值解析器: <code>HandlerResultHandler</code><ul>
<li><code>ResponseBodyResultHandler</code></li>
<li><code>ResponseEntityResultHandler</code></li>
<li><code>ServerResponseResultHandler</code></li>
<li><code>ViewResolutionResultHandler</code><ul>
<li><code>RequestedContentTypeResolverBuilder</code></li>
<li><code>RequestedContentTypeResolver</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>视图解析器 <code>ViewResolver</code></li>
<li>视图渲染 <code>View</code>, eg:<ul>
<li><code>RedirectView</code></li>
<li><code>FreeMarkerView</code></li>
<li><code>HttpMessageWriterView</code></li>
</ul>
</li>
<li>配置 <ul>
<li><code>WebFluxConfigurer</code></li>
<li><code>WebFluxConfigurationSupport</code></li>
</ul>
</li>
<li>for Functional Endpoints(函数式端点方式)<ul>
<li><code>RouterFunction</code></li>
<li><code>RouterFunctionMapping</code> (implements HandlerMapping)</li>
<li><code>HandlerFunctionAdapter</code> (implements HandlerAdapter)</li>
</ul>
</li>
</ul>
</li>
<li>使用场景：不适合RT（响应）敏感的RPC框架/Web应用，适合请求慢慢执行的场景（把请求丢过来，不care什么时候完成，完成后通知你下就即可），Reactive可以提升吞吐量，但RunTime反而会变得更长，且出现响应超时等问题    </li>
<li><code>Spring WebMVC</code> vs. <code>Spring WebFlux</code><ul>
<li>均能使用注解驱动Controller,WebFlux还能使用函数式端点方式</li>
<li>主要不同点在于并发模型和阻塞特性：<ul>
<li>Spring WebMvc: Servlet应用,通常是阻塞服务,Servlet容器一般使用较大的线程池处理请求</li>
<li>Spring WebFlux: Reactive应用,通常是非阻塞服务，服务器可使用少量、固定大小的线程池处理请求</li>
</ul>
</li>
<li>目前WebFlux并未优于WebMvc:<ul>
<li>性能上没有明显的速度提升(甚至性能结果稍微更恶劣)</li>
<li>在编程友好性方面,Reactive编程尽管没有新增大量的代码,却使编码(和调试)变得复杂了</li>
<li>缺少文档</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="header-4">基本使用</h2>
<h3 id="header-5">Hello World(使用嵌入式容器)</h3>
<ol>
<li><p>创建SpringBoot项目</p>
<ul>
<li>方式一： 使用 <a href="http://start.spring.io">start spring</a><pre><code>  // 1. 网页中配置GAV：
  Spring Boot: 2.0.0
  Group: com.cj
  Artifact: springboot-demo-first
  Dependencies: Reactive Web
  //=&gt; Generate Project
  // 2. Download project and import to IDEA 
  import project from external model -&gt; Maven
</code></pre></li>
<li>方式二：使用 Maven命令行<pre><code class="lang-bash">  # 1. mvn archetype:generate 创建项目
  &gt; mvn archetype:generate -DinteractiveMode=false -DgroupId=com.cj -DartifactId=springboot-demo-second -Dversion=0.0.1-SNAPSHOT
  # 2. import the project to IDEA
</code></pre>
<ul>
<li>方式三：使用IDEA的Spring Initializr工具创建（Community版本不支持）<pre><code class="lang-bash">File -&gt; New -&gt; Project -&gt; Spring Initializr
Initializr Server URL: http://start.spring.io -&gt; Next -&gt; 输入GAV等配置信息
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>配置依赖包（pom.xml )</p>
<ul>
<li>basic<ul>
<li><code>spring-boot-starter</code>：核心模块，包括自动配置支持、日志和YAML，</li>
<li><code>spring-boot-starter-test</code>：测试模块，包括JUnit、Hamcrest、Mockito</li>
</ul>
</li>
<li>web<ul>
<li><code>spring-boot-starter-web</code>: 引入Web模块(支持SpringMVC),默认内嵌tomcat(by including: <code>spring-boot-starter-tomcat</code>)</li>
<li><code>spring-boot-starter-webflux</code>：引入webflux模块(支持Reactive)，默认内嵌Reactor Netty(by including:<code>spring-boot-starter-reactor-netty</code>)</li>
</ul>
</li>
<li>embed web server -- no need to deploy WAR files , refer <a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#howto-use-another-web-server">How to use another web-server</a><ul>
<li><code>spring-boot-starter-tomcat</code></li>
<li><code>spring-boot-starter-jetty</code></li>
<li><code>spring-boot-starter-undertow</code></li>
<li><code>spring-boot-starter-reactor-netty</code></li>
</ul>
</li>
<li><p>plugin</p>
<ul>
<li><code>spring-boot-maven-plugin</code></li>
</ul>
</li>
<li><p>Sample1: a typical pom</p>
<pre><code class="lang-xml">  &lt;!-- Inherit defaults from Spring Boot --&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;
  &lt;/parent&gt;

  &lt;!-- Add typical dependencies for a web application,也可使用spring-boot-starter-webflux --&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;!-- Package as an executable jar --&gt;
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
</code></pre>
</li>
<li>Sample2: use another web server<pre><code class="lang-xml">  &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;exclusions&gt;
            &lt;!-- Exclude the Tomcat dependency --&gt;
            &lt;exclusion&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
            &lt;/exclusion&gt;
        &lt;/exclusions&gt;
  &lt;/dependency&gt;
  &lt;!-- Use Jetty instead --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;
  &lt;/dependency&gt;
</code></pre>
</li>
</ul>
</li>
<li><p>Coding</p>
<pre><code class="lang-java"> // 1. App.java
 @SpringBootApplication
 public class App {
     public static void main( String[] args ){
         SpringApplication.run(App.class, args);
     }
 }

 // 2. controller/HelloWorldController.java
 @RestController
 public class HelloWorldController {
     @GetMapping(&quot;&quot;)
     public String index(){
         return &quot;Hello World!&quot;;
     }
 }
</code></pre>
</li>
<li><p>运行/发布</p>
<ul>
<li>方式一： IDEA中run App.java （适用于：开发环境调试 ）</li>
<li><p>方式二：打Jar/War包运行 （适用于： 生产环境，使用脚本启动 ）</p>
<pre><code class="lang-bash">  # 1.打包 ( -U  表示更新maven包)
  cd myProject
  mvn -Dmaven.test.skip -U clean package
  cd web/target

  # 2. 运行jar
  # pom.xml中配置packaging为jar
  java -jar myProject-xxx.jar

  # 3. 运行war
  # pom.xml中配置packaging为war (需要有webapp/WEB-INFO/web.xml文件)，也可将war包放入外部tomcat中运行
  java -jar myProject-xxx.war
</code></pre>
</li>
<li><p>方式三：Maven Plugin运行 （适用于： 无图形化界面的开发环境 ）</p>
<pre><code class="lang-bash">  # 1.打包安装到本地仓库
  cd myProject
  mvn -Dmaven.test.skip -U clean install

  # 2.运行
  mvn spring-boot:run
</code></pre>
</li>
</ul>
</li>
<li>visit <code>http://localhost:8080</code> to verify -&gt; should show &quot;Hello World!&quot; in the page</li>
</ol>
<h3 id="header-6">Hello World(使用独立容器)</h3>
<ol>
<li><p>pom.xml</p>
<pre><code class="lang-xml"> &lt;packaging&gt;war&lt;/packaging&gt;
 &lt;dependencies&gt;
     &lt;dependency&gt;
       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
       &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
       &lt;exclusions&gt;
           &lt;!-- Exclude the Tomcat dependency --&gt;
           &lt;exclusion&gt;
               &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
               &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
           &lt;/exclusion&gt;
       &lt;/exclusions&gt;
     &lt;/dependency&gt;
     &lt;!-- Servlet 3.1 API 依赖--&gt;
     &lt;dependency&gt;
       &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
       &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
       &lt;scope&gt;provided&lt;/scope&gt;
     &lt;/dependency&gt;
 &lt;/dependencies&gt;
 &lt;build&gt;
     &lt;plugins&gt;
       &lt;plugin&gt;
         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
         &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
       &lt;/plugin&gt;
     &lt;/plugins&gt;
 &lt;/build&gt;
</code></pre>
</li>
<li><p>Coding</p>
<pre><code class="lang-java"> // 1. SpringBootServletInitializer(implements WebApplicationInitializer)
 public class MySpringBootServletInitializer extends SpringBootServletInitializer{

      protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
          System.out.println(&quot;MySpringBootServletInitializer configure&quot;);
          builder.sources(App.class);
          return builder;
      }
  }

  @SpringBootApplication
  public class App {
  }

 // 2. controller/HelloWorldController.java
 @RestController
 public class HelloWorldController {
     @GetMapping(&quot;&quot;)
     public String index(){
         return &quot;Hello World!&quot;;
     }
 }
</code></pre>
</li>
<li><p>打包运行</p>
<pre><code class="lang-bash"> cd myProject
 mvn -Dmaven.test.skip -U clean package
 ＃ 将target下生成的war包丢到Servlet容器运行（eg：Tomcat）
</code></pre>
</li>
<li><p>也可使用maven插件直接打包运行，eg: 使用Jetty plugin，运行<code>jetty:run</code></p>
<pre><code class="lang-xml"> &lt;!-- pom.xml 中增加 jetty plugin --&gt;
 &lt;plugin&gt;
     &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;
     &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;
     &lt;version&gt;9.4.12.v20180830&lt;/version&gt;
     &lt;configuration&gt;
      &lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt;
       &lt;webApp&gt;
        &lt;contextPath&gt;/demo&lt;/contextPath&gt;
      &lt;/webApp&gt;
      &lt;httpConnector&gt;
          &lt;port&gt;9090&lt;/port&gt;
          &lt;idleTimeout&gt;60000&lt;/idleTimeout&gt;
      &lt;/httpConnector&gt;
      &lt;stopKey&gt;foo&lt;/stopKey&gt;
         &lt;stopPort&gt;9999&lt;/stopPort&gt;
     &lt;/configuration&gt;
 &lt;/plugin&gt;
</code></pre>
</li>
</ol>
<h3 id="header-7">Hello World</h3>
<p><strong> Summary </strong></p>
<ol>
<li><p>嵌入式容器</p>
<ul>
<li>package:<code>war</code>/<code>jar</code></li>
<li>dependency jar: <code>spring-boot-starter-web</code> (default including <code>spring-boot-starter-tomcat</code>,也可exclude default，then include other embed servlet container)</li>
<li>coding: <code>@SpringBootAplication</code> + <code>main()</code></li>
<li><code>run</code> main 或者 <code>java -jar xxx</code>运行可执行包 或者 <code>mvn spring-boot:run</code></li>
</ul>
</li>
<li><p>独立容器</p>
<ul>
<li>package:<code>war</code></li>
<li>dependency jar:<code>spring-boot-starter-web</code> (exlude default embed tomcat) + <code>javax.servlet-api&lt;scope&gt;provided&lt;/scope&gt;</code>(or include other container include servlet api,eg: <code>spring-boot-starter-tomcat</code>)</li>
<li>coding: <code>@SpringBootApplication</code> + <code>extends SpringBootServletInitializer(implements WebApplicationInitializer)</code></li>
<li>将war包发布到tomcat容器运行 或者 使用maven jetty plugin <code>jetty:run</code></li>
</ul>
</li>
</ol>
<p><strong> eg: 整合上面两种运行方式 </strong></p>
<ol>
<li><p>pom.xml</p>
<pre><code class="lang-xml"> &lt;packaging&gt;war&lt;/packaging&gt;
 &lt;dependencies&gt;
     &lt;dependency&gt;
       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
       &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
       &lt;exclusions&gt;
           &lt;!-- Exclude the Tomcat dependency --&gt;
           &lt;exclusion&gt;
               &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
               &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
           &lt;/exclusion&gt;
       &lt;/exclusions&gt;
     &lt;/dependency&gt;
     &lt;!-- 兼容嵌入式运行(embed tomcat 中包含了servlet api）--&gt;
     &lt;dependency&gt;
         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
         &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
         &lt;scope&gt;provided&lt;/scope&gt;
     &lt;/dependency&gt;
 &lt;/dependencies&gt;
 &lt;build&gt;
     &lt;plugins&gt;
       &lt;plugin&gt;
         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
         &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
       &lt;/plugin&gt;
     &lt;/plugins&gt;
 &lt;/build&gt;
</code></pre>
</li>
<li><p>Coding</p>
<pre><code class="lang-java"> // 1. 使用嵌入式Servlet容器：App main 运行
 @SpringBootApplication
 public class App {
     public static void main( String[] args ){
             SpringApplication.run(App.class, args);
         }
 }

 // 2. 使用独立Servlet容器：打包发布到运行的Servlet容器
 // extends SpringBootServletInitializer(implements WebApplicationInitializer)
 public class MySpringBootServletInitializer extends SpringBootServletInitializer{
  protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
      System.out.println(&quot;MySpringBootServletInitializer configure&quot;);
      builder.sources(App.class);
      return builder;
  }
 }
</code></pre>
</li>
</ol>
<h3 id="header-8">热部署</h3>
<p>监听classpath下的文件（class类，配置文件）变化，自动重启应用
（默认静态资源改变：<code>/public</code>，<code>/resource</code>，<code>/META-INF</code>,...，会重新加载，但不会重启应用）</p>
<ul>
<li><p>方式一：使用<code>springloaded</code> </p>
<pre><code class="lang-xml">  &lt;plugins&gt;
    &lt;plugin&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
    &lt;dependencies&gt;
    &lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;springloaded&lt;/artifactId&gt;
    &lt;version&gt;1.2.8.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
</code></pre>
</li>
<li><p>方式二：使用<code>spring-boot-devtools</code></p>
<pre><code class="lang-xml">  &lt;dependency&gt;
     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
     &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
     &lt;optional&gt;true&lt;/optional&gt;
  &lt;/dependency&gt;
</code></pre>
<ul>
<li><p>额外配置示例：</p>
<pre><code>  #热部署生效
  spring.devtools.restart.enabled: true

  #设置重启的目录
  #spring.devtools.restart.additional-paths: src/main/java
  #classpath目录下的WEB-INF文件夹内容修改不重启
  spring.devtools.restart.exclude: WEB-INF/**
</code></pre></li>
</ul>
</li>
<li><p>启动运行：</p>
<ul>
<li>方式一： <code>mvn spring-boot:run</code></li>
<li>方式二：直接运行<code>main</code>方法</li>
</ul>
</li>
<li><p>注：热部署自身不会去主动编译 Java 文件</p>
</li>
<li><p>示例：配置在Java 文件改动时，自动编译成 Class 文件（然后热部署工具创造的新的类加载器才会加载改变后的 Class 文件）</p>
<ul>
<li><code>IDEA</code> ：使用工具时配置自动编译：<pre><code>  1. File -&gt; Settings -&gt; Complier -&gt; 勾选Make project automatically
  2. Shift+Ctrl+Alt+/，Shift+Ctrl+A -&gt; Registry -&gt; 勾选compiler.automake.allow.when.app.running
</code></pre><ul>
<li><code>Eclipse</code>：<pre><code class="lang-xml">&lt;plugins&gt;
     &lt;plugin&gt;
     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
&lt;configuration&gt;
     &lt;fork&gt;true&lt;/fork&gt;
&lt;/configuration&gt;
&lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong> 热部署 VS. 热加载 </strong></p>
<ol>
<li><p>共点：编译／部署项目不重启服务器，都基于Java的类加载器实现 （在容器启动时，启动一后台线程，定时监测class文件的时间戳，判断是否变化了）</p>
</li>
<li><p>热部署：在服务器运行时重新部署项目 —— 多用于生产环境 （会释放内存，比热加载更加干净彻底）</p>
</li>
<li><p>热加载：在运行时重新加载改变的class —— 多用于开发环境 （ 直接修改字节码的方式，难以监控和记录逻辑变化）</p>
</li>
</ol>
<p><strong> 配置Tomcat实现热部署的三种方式: </strong></p>
<ul>
<li><p>方式一：直接将项目（解压后的web项目）放在tomcat的<code>webapp</code>目录下</p>
</li>
<li><p>方式二：<code>%tomcat_home%/conf/server.xml</code>的<code>&lt;host&gt;</code>内添加<code>&lt;context&gt;</code>配置</p>
<pre><code class="lang-xml">   &lt;Context debug=&quot;0&quot; docBase=&quot;D:/space/web&quot; path=&quot;/hot&quot; privileged=&quot;true&quot; reloadable=&quot;true&quot;/&gt;
   &lt;!-- 
    注意配置了path（虚拟路径），访问网址需使用此项目名/hot
    将项目目录下的内容（META-INF,WEB-INF,...）copy到docBase的指定路径
   --&gt;
</code></pre>
</li>
<li><p>方式三：<code>%tomcat_home%/conf/Catalina/localhost</code>目录下添加一个xml文件,eg: <code>hot.xml</code></p>
<pre><code class="lang-xml">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
  &lt;Context docBase=&quot;D:/space/web&quot; reloadable=&quot;true&quot;/&gt;
  &lt;!-- 注意xml文件名为hot，则访问网址使用此项目名/hot --&gt;
</code></pre>
</li>
</ul>
<h3 id="header-9">单元测试</h3>
<ol>
<li><p>Test Service:</p>
<pre><code class="lang-java"> @RunWith(SpringRunner.class)
 @SpringBootTest(classes=TagServiceTest.class)
 public class TagServiceTest {

     @Autowired
     private TagService tagService;

     @Test
     @Transactional
     public void listTest(){
         List&lt;Tag&gt; list=this.tagService.list(&quot;Benefit&quot;);
         for(Tag item:list) {
             System.out.println(item);
         }
     }
 }
</code></pre>
</li>
<li><p>Test Controller:</p>
<pre><code class="lang-java"> @RunWith(SpringRunner.class)
 @SpringBootTest
 @AutoConfigureMockMvc
 public class HelloControllerTest {

     @Autowired
     private MockMvc mvc;

     @Test
     public void sayHello() throws Exception {
         mvc.perform(MockMvcRequestBuilders.get(&quot;/say&quot;).accept(MediaType.APPLICATION_JSON))
             .andExpect(status().isOk())
             .andExpect(content().string(equalTo(&quot;Hello world!&quot;)))
             ;
     }
 }
</code></pre>
</li>
<li><p>Test Web:</p>
<pre><code class="lang-java"> @RunWith(SpringRunner.class)
 @SpringBootTest(webEnvironment=SpringBootTest.WebEnvironment.RANDOM_PORT)
 public class HelloControllerIT {

     @LocalServerPort
     private int port;

     private URL base;

     @Autowired
     private TestRestTemplate template;

     @Before
     public void setup() throws MalformedURLException {
         this.base=new URL(&quot;http://localhost:&quot;+port+&quot;/hello&quot;);
         System.out.println(base);
     }

     @Test
     public void say() throws Exception {
         ResponseEntity&lt;String&gt; response=template.getForEntity(base.toString()+&quot;/say&quot;, String.class);
         assertThat(response.getBody(),equalTo(&quot;Hello world!&quot;));
     }
 }
</code></pre>
</li>
</ol>
<h3 id="header-10">属性配置</h3>
<p>Refer <a href="https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle/#common-application-properties">Common application properties</a>                </p>
<ol>
<li><p>配置文件：<code>resources/application.properties</code> 或 <code>resources/application.yml</code></p>
</li>
<li><p>注解：</p>
<ul>
<li><code>@Value</code>, eg: <code>@Value(${content})</code></li>
<li><code>@ConfigurationProperties</code>,eg: <code>@ConfigurationProperties(prefix = &quot;hello&quot;)</code></li>
</ul>
</li>
</ol>
<p><strong> 示例1：<code>@Value</code>,<code>@ConfigurationProperties</code>使用 </strong></p>
<ol>
<li><p>配置文件<code>resources/application.yml</code></p>
<pre><code> say:
   prefix: &quot;Hi&quot;
   target: &quot;Tom&quot;
   times: 5
 content: &quot;Test: ${say.prefix} ${say.target}&quot;
</code></pre></li>
<li><p>获取注入配置的属性值</p>
<pre><code class="lang-java"> // 1. 使用@ConfigurationProperties
 // config/SayProperties.java
 @Component
 @ConfigurationProperties(prefix = &quot;say&quot;)
 public class SayProperties {
     private String prefix;
     private String target;
     private Integer times;

     /*getter and setter...*/
 }

 // 2. 使用@Value
 // controller/SayController
 @RestController
 public class SayController {

     @Value(&quot;${content}&quot;)
     private String content;
     @Autowired
     private SayProperties sayProperties;

     @GetMapping(&quot;/testSay&quot;)
     public String say(){
         return content+&quot; -- &quot;+sayProperties;
     }
 }
</code></pre>
</li>
<li><p>visit <code>http://localhost:8080/testSay</code> to verify,shoud see: &quot;Test: Hi Tom -- SayProperties [prefix=Hi, target=Tom, times=5]&quot;</p>
</li>
</ol>
<p><strong> 示例2：多环境配置（不同环境使用不同配置） </strong></p>
<ol>
<li><p>resource/application-dev.yml</p>
<pre><code> server:
   port: 8080
   servlet:
     context-path: /hello
 say:
   prefix: &quot;Hi&quot;
   target: &quot;DevEnv&quot;
   times: 5
</code></pre></li>
<li><p>resource/application-prod.yml</p>
<pre><code> server:
   port: 8090
   servlet:
     context-path: /hello
 say:
   prefix: &quot;Hi&quot;
   target: &quot;ProdEnv&quot;
   times: 5
</code></pre></li>
<li><p>resource/application.yml</p>
<pre><code> spring:
   profiles:
     active: dev
 content: &quot;Test: ${say.prefix} ${say.target}&quot;
</code></pre></li>
<li><p>Verify</p>
<pre><code class="lang-bash"> cd springboot-helloworld
 mvn -Dmaven.test.skip -U clean package

 # Note：cmd line args的优先级高于properties file的配置

 # test dev
 # visit: http://localhost:8080/hello/testSay
 # should show: Test: Hi DevEnv -- SayProperties [prefix=Hi, target=DevEnv, times=5]
 java -jar target/springboot-helloworld-0.0.1-SNAPSHOT.jar

 # test prod 
 # visit: http://localhost:8090/hello/testSay
 # should show: Test: Hi ProdEnv -- SayProperties [prefix=Hi, target=ProdEnv, times=5]
 java -jar target/springboot-helloworld-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod
</code></pre>
</li>
</ol>
<h3 id="header-11">AOP</h3>
<ul>
<li>一种编程范式，与语言无关，是一种程序设计思想,eg:<ul>
<li><code>AOP</code> 面向切面 Aspect Oriented Programming</li>
<li><code>OOP</code> 面向对象 Object Oriented Programming</li>
<li><code>POP</code> 面向过程 Procedure Oriented Programming</li>
</ul>
</li>
<li>从面向过程到面向对象，换了个角度看世界，换个姿势处理问题</li>
<li>AOP 将通用逻辑从业务逻辑中分离出来</li>
<li>应用：AOP统一处理请求日志，记录每一个http请求</li>
</ul>
<pre><code class="lang-xml">&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>aspect/HttpAspect.java</p>
<pre><code class="lang-java">@Aspect
@Component
public class HttpAspect{

    @PointCut(&quot;execution(...)&quot;)
    public void log(){}

    @Before(&quot;log()&quot;)
    public void doBefore(JoinPorint joinPoint ){
        ...
    }
}
</code></pre>
<h3 id="header-12">异常处理</h3>
<p><code>@ExceptionHandler</code></p>
<pre><code class="lang-java">@Controller
public class HelloController {
    @RequestMapping(value=&quot;/{num}&quot;,method=RequestMethod.GET)
    public String doExTest(@PathVariable int num,Model model){
        model.addAttribute(&quot;message&quot;,&quot;number:&quot;+num);
        return &quot;index&quot;;
    }

    @ExceptionHandler(Throwable.class)
    public ResponseEntity&lt;String&gt; onException(Throwable ex){
        return ResponseEntity.ok(&quot;handle exception:&quot;+ex.getMessage());
    }
}
</code></pre>
<p>或者：</p>
<pre><code class="lang-java">@Controller
public class HelloController {
    @RequestMapping(value=&quot;/{num}&quot;,method=RequestMethod.GET)
    public String doExTest(@PathVariable int num,Model model){
        model.addAttribute(&quot;message&quot;,&quot;number:&quot;+num);
        return &quot;index&quot;;
    }
}

@ControllerAdvice(assignableTypes=HelloController.class)
public class HelloControllerAdvice {

    @ExceptionHandler(Throwable.class)
    public ResponseEntity&lt;String&gt; onException(Throwable ex){
        return ResponseEntity.ok(&quot;handle exception:&quot;+ex.getMessage());
    }
}
</code></pre>
<h2 id="header-13">装配</h2>
<ol>
<li><p>Spring装配技术：</p>
<ul>
<li>模式注解装配：<code>@Component</code>,<code>@Repository</code>,<code>@Service</code>,<code>@Controller</code>,<code>@Configuration</code></li>
<li>Enable模块装配: <code>@Enable模块</code></li>
<li>条件装配:<code>@Profile</code>,<code>@Conditional</code></li>
<li>工厂加载机制: <code>SpringFactoriesLoader</code> + <code>META-INF/spring.factories</code></li>
</ul>
</li>
<li><p>SpringBoot自动装配：</p>
<ul>
<li>依赖Spring装配技术，基于约定大于配置的原则，实现自动装配</li>
<li>实现步骤：<ul>
<li>激活自动装配 <code>@EnableAutoConfiguration</code></li>
<li>实现装配 <code>XxxAutoConfiguration</code></li>
<li>配置 <code>META-INF/spring.factories</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="header-14">Spring 装配技术</h3>
<h4 id="header-15">模式注解装配</h4>
<ol>
<li><p>模式注解(Stereotype Annotations):</p>
<blockquote>
<p>an annotation that is used to declare the role that a component plays within the application.</p>
</blockquote>
</li>
<li><p>模式注解装配：<code>@ComponentScan</code>/<code>&lt;context:component-scan&gt;</code></p>
<blockquote>
<p>扫描并找到<code>@Component</code>或者其派生Annotation(eg: <code>@Repository</code>,<code>@Service</code>,<code>@Controller</code>,<code>@Configuration</code>) 标注的Class，将它们注册为Spring Bean</p>
</blockquote>
</li>
<li><p>使用示例：</p>
<ul>
<li>使用<code>&lt;context:component-scan&gt;</code><pre><code class="lang-xml">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans.xsd
      http://www.springframework.org/schema/context 
      http://www.springframework.org/schema/context/springcontext.xsd&quot;&gt;
      &lt;!-- 激活注解驱动特性 --&gt;
      &lt;context:annotation-config /&gt;
      &lt;!-- 找到指定package下@Component及其派生标注的类，注册为SpringBean对象 --&gt;
      &lt;context:component-scan base-package=&quot;com.cj.demo&quot; /&gt;
  &lt;/beans&gt;
</code></pre>
</li>
<li>使用<code>@ComponentScan</code><pre><code class="lang-java">  @ComponentScan(basePackages=&quot;com.cj.demo&quot;)
  public class HelloWorldSpringScanApplication {
       public static void main(String[] args) {
          ConfigurableApplicationContext context = new SpringApplicationBuilder(HelloWorldSpringScanApplication.class)
              .web(WebApplicationType.NONE)
              .run(args);                    
          Hello hello = context.getBean(&quot;hello&quot;,Hello.class);
          System.out.println(&quot;Hello Bean : &quot;+hello);    
          context.close();
      }
  }
</code></pre>
</li>
</ul>
</li>
</ol>
<h4 id="header-16">模块装配</h4>
<p><code>@Enable模块</code> （模块：具备相同领域的功能组件集合， 组合所形成一个独立的单元）</p>
<ol>
<li><p>Spring Framework 3.1 开始支持,eg:</p>
<table class="table">
<thead>
<tr>
<th style="text-align:left">框架实现</th>
<th style="text-align:left">@Enable注解模块</th>
<th style="text-align:left">激活模块</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Spring Framework</td>
<td style="text-align:left"><code>@EnableWebMvc</code></td>
<td style="text-align:left">Web MVC 模块</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>@EnableTransactionManagement</code></td>
<td style="text-align:left">事务管理模块</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>@EnableCaching</code></td>
<td style="text-align:left">Caching（缓存）模块</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>@EnableMBeanExport</code></td>
<td style="text-align:left">JMX（Java管理扩展）模块</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>@EnableAsync</code></td>
<td style="text-align:left">异步处理模块</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>@EnableWebFlux</code></td>
<td style="text-align:left">Web Flux 模块</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>@EnableAspectJAutoProxy</code></td>
<td style="text-align:left">AspectJ 代理模块</td>
</tr>
<tr>
<td style="text-align:left">Spring Boot</td>
<td style="text-align:left"><code>@EnableAutoConfiguration</code></td>
<td style="text-align:left">自动装配模块</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>@EnableManagementContext</code></td>
<td style="text-align:left">Actuator 管理模块</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>@EnableConfigurationProperties</code></td>
<td style="text-align:left">配置属性绑定模块</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>@EnableOAuth2Sso</code></td>
<td style="text-align:left">OAuth2 单点登录模块</td>
</tr>
<tr>
<td style="text-align:left">Spring Cloud</td>
<td style="text-align:left"><code>@EnableEurekaServer</code></td>
<td style="text-align:left">Eureka服务器模块</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>@EnableConfigServer</code></td>
<td style="text-align:left">配置服务器模块</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>@EnableFeignClients</code></td>
<td style="text-align:left">Feign客户端模块</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>@EnableZuulProxy</code></td>
<td style="text-align:left">服务网关 Zuul 模块</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>@EnableCircuitBreaker</code></td>
<td style="text-align:left">服务熔断模块</td>
</tr>
</tbody>
</table>
</li>
<li><p>实现方式：</p>
<ul>
<li><p>注解驱动方式,eg: <code>@EnableWebMvc</code></p>
<pre><code class="lang-java">  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.TYPE)
  @Documented
  @Import(DelegatingWebMvcConfiguration.class) // import: Configuration class
  public @interface EnableWebMvc {
  }

  @Configuration
  public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {
      //@Bean,eg:
      // RequestMappingHandlerMapping
      // RequestMappingHandlerAdapter
      // ContentNegotiationManager
      // ...
  }
</code></pre>
</li>
<li><p>接口编程方式,eg: <code>@EnableCaching</code></p>
<pre><code class="lang-java">  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @Documented
  @Import(CachingConfigurationSelector.class) // import: interface ImportSelector 实现类，用于获取Configuration类名
  public @interface EnableCaching {
      //...
  }

  public interface ImportSelector {
      /**
       * Select and return the names of which class(es) should be imported based on
       * the {@link AnnotationMetadata} of the importing @{@link Configuration} class.
       */
      String[] selectImports(AnnotationMetadata importingClassMetadata);
  }

  public class CachingConfigurationSelector 
      extends AdviceModeImportSelector&lt;EnableCaching&gt; { 
      // Note: AdviceModeImportSelector implements ImportSelector

      // 实现interface ImportSelector#selectImports(AnnotationMetadata importingClassMetadata)
      // 返回要import的Congifuration类名
      // eg:
      // return new String[] { AutoProxyRegistrar.class.getName(), ProxyCachingConfiguration.class.getName() };
      // return new String[] { AnnotationConfigUtils.CACHE_ASPECT_CONFIGURATION_CLASS_NAME };
  }
</code></pre>
</li>
</ul>
</li>
<li><p>示例：自定义一个<code>@EnableHelloWorld</code>并使用</p>
<ul>
<li><p>方式一：<code>@EnableHelloWorld</code> Import <code>Configuration class</code></p>
<pre><code class="lang-java">  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.TYPE)
  @Documented
  @Import(HelloWorldConfiguration.class)
  public @interface EnableHelloWorld {
  }

  //@Configuration
  public class HelloWorldConfiguration {

      // @Bean：
      // 方法级别上的注解，产生一个Bean对象并交给Spring管理，默认bean的名称就是其方法名
      // 好处：
      // 1. 动态获取一个Bean对象
      // 2. 可将非Spring组件交给Spring管理
      @Bean
      public String helloWorld() {
          return new String(&quot;Hello world!&quot;);
      }

      @Bean
      public HelloController helloController() {
          return new HelloController();
      }
  }
</code></pre>
</li>
<li><p>方式二：<code>@EnableHelloWorld</code> Import <code>ImportSelector implements Class</code> that used to return <code>Configuration Classname</code> (适合需要使用多个Configuration类的情况）</p>
<pre><code class="lang-java">  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.TYPE)
  @Documented
  @Import(HelloWorldImportSelector.class)
  public @interface EnableHelloWorld {
  }

  public class HelloWorldImportSelector implements ImportSelector {
      @Override
      public String[] selectImports(AnnotationMetadata importingClassMetadata) {
          // 更灵活，例如可在这里加入判断分支
          return new String[]{HelloWorldConfiguration.class.getName()};
      }
  }

  // HelloWorldConfiguration 内容同上
  public class HelloWorldConfiguration {
      // @Bean
      // ...
  ｝
</code></pre>
</li>
<li><p>测试使用<code>@EnableHelloWorld</code></p>
<pre><code class="lang-java">  @EnableHelloWorld
  public class HelloWorldSpringEnableApplication {
      public static void main(String[] args) {
          ConfigurableApplicationContext context = new SpringApplicationBuilder(HelloWorldSpringScanApplication.class)
              .web(WebApplicationType.NONE)
              .run(args);

          HelloController helloController = context.getBean(&quot;helloController&quot;,HelloController.class);
          System.out.println(&quot;helloController Bean : &quot;+helloController);    

          String helloWorld = context.getBean(&quot;helloWorld&quot;,String.class);
          System.out.println(&quot;helloWorld Bean : &quot;+helloWorld);    

          context.close();
      }
  }
  // Result:
  // helloController Bean : com.cj.outside.HelloController@12164beb
  // helloWorld Bean : Hello world!
</code></pre>
</li>
</ul>
</li>
</ol>
<h4 id="header-17">条件装配</h4>
<p>Bean装配时根据前置判断是否装配该Bean</p>
<ul>
<li>实现方式：<ul>
<li>注解方式： 使用<code>@Profile</code> 配置化条件装配（Spring 3.1+）</li>
<li>编程方式： 使用<code>@Conditional</code> 编程条件装配 （Spring 4.0+）</li>
</ul>
</li>
</ul>
<ol>
<li><p><code>@Profile</code> 配置化条件装配（Spring 3.1+）</p>
<pre><code class="lang-java"> @Profile(&quot;Java7&quot;)
 @Service
 public class Java7CalculateService implements CalculateService {

     @Override
     public Integer sum(Integer... values) {
         Integer sum=0;
         for(Integer item:values) {
             sum+=item;
         }
         System.out.println(&quot;Java7 sum result:&quot;+sum);
         return sum;
     }
 }

 @Profile(&quot;Java8&quot;)
 @Service
 public class Java8CalculateService implements CalculateService {

     @Override
     public Integer sum(Integer... values) {

         Integer sum=Stream.of(values).reduce(0, Integer::sum);
         System.out.println(&quot;Java8 sum result:&quot;+sum);
         return sum;
     }
 }

 public interface CalculateService {
     public Integer sum(Integer...values);
 }

 // Test
 @ComponentScan(basePackages=&quot;com.cj.autoconfig.service&quot;)
 public class ProfileApplication {
     public static void main(String[] args) {
         ConfigurableApplicationContext context = new SpringApplicationBuilder(ProfileApplication.class)
             .web(WebApplicationType.NONE)
             .profiles(&quot;Java8&quot;)        // switch Profile
             .run(args);

         CalculateService calculateService = context.getBean(CalculateService.class);
         System.out.println(&quot;calculateService Bean : &quot;+calculateService);    
         calculateService.sum(1,2,3,4,5,6,7,8,9,10);

         context.close();
     }
 }
</code></pre>
</li>
<li><p><code>@Conditional</code> 编程条件装配 （Spring 4.0+）</p>
<pre><code class="lang-java"> // 自定义一个Annotation
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ ElementType.TYPE, ElementType.METHOD })
 @Documented
 @Conditional(SystemPropertyCondition.class)
 public @interface ConditionalOnSystemProperty {
     String name() default &quot;&quot;;
     String value() default &quot;&quot;;
 }

 // Condition实现类
 public class SystemPropertyCondition implements Condition {
     @Override
     public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
         Map&lt;String, Object&gt; attrs= metadata.getAnnotationAttributes(ConditionalOnSystemProperty.class.getName());
         String name=String.valueOf(attrs.get(&quot;name&quot;));
         String value=String.valueOf(attrs.get(&quot;value&quot;));
         String systemPropertyValue=System.getProperty(name);
         System.out.println(&quot;condition--&quot;+value+&quot; vs. &quot;+systemPropertyValue);
         return systemPropertyValue.equals(value);
     }
 }

 // Test
 public class ConditionApplication {

     @Bean
     @ConditionalOnSystemProperty(name=&quot;user.name&quot;,value=&quot;jinc&quot;)
     public String helloWorld() {
         return &quot;Hello world!&quot;;
     }

     public static void main(String[] args) {
         ConfigurableApplicationContext context = new SpringApplicationBuilder(ConditionApplication.class)
                 .web(WebApplicationType.NONE)
                 .run(args);

         String helloWorld = context.getBean(&quot;helloWorld&quot;,String.class);    
         System.out.println(&quot;helloWorld Bean:&quot;+helloWorld);

         context.close();
     }
 }
</code></pre>
</li>
</ol>
<h4 id="header-18">工厂加载机制</h4>
<p>使用<code>SpringFactoriesLoader</code> ：</p>
<pre><code class="lang-java">public abstract class SpringFactoriesLoader {
    public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;
    public static &lt;T&gt; List&lt;T&gt; loadFactories(Class&lt;T&gt; factoryClass, @Nullable ClassLoader classLoader) {
        ClassLoader classLoaderToUse = classLoader!=null? classLoader:SpringFactoriesLoader.class.getClassLoader();
        List&lt;String&gt; factoryNames = loadFactoryNames(factoryClass, classLoaderToUse);
        List&lt;T&gt; result = new ArrayList&lt;&gt;(factoryNames.size());
        for (String factoryName : factoryNames) {
            result.add(instantiateFactory(factoryName, factoryClass, classLoaderToUse));
        }
        AnnotationAwareOrderComparator.sort(result);
        return result;
    }
}
</code></pre>
<ul>
<li>方法：<ul>
<li><code>SpringFactoriesLoader#loadFactoryNames</code> ： 读取配置文件获取要装载的类名</li>
<li><code>SpringFactoriesLoader#loadFactories</code> ： 按顺序装载配置的类的实例 </li>
</ul>
</li>
<li>配置：<code>META-INF/spring.factories</code></li>
<li>排序：<code>AnnotationAwareOrderComparator#sort</code> （要装载的类可通过注解<code>@Order</code>或<code>implements Ordered</code>来配置顺序）</li>
<li>使用示例：<code>SpringApplication#getSpringFactoriesInstances</code></li>
</ul>
<h3 id="header-19">SpringBoot自动装配</h3>
<p>依赖Spring装配技术，基于约定大于配置的原则，实现自动装配</p>
<ol>
<li><p>实现步骤：</p>
<ul>
<li>实现装配配置类 <code>XxxAutoConfiguration</code><pre><code class="lang-java">  @Configuration
  public class XxxxConfiguration {
      //@Bean
      // ...
  }
</code></pre>
</li>
<li>配置 <code>META-INF/spring.factories</code>到resources下    <pre><code>  # Auto Configure
  org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
  xxx.xxx....xxx.XxxAutoConfiguration,\
  #...
</code></pre></li>
<li>激活自动装配 <code>@EnableAutoConfiguration</code><pre><code class="lang-java">  @SpringBootApplication     // @SpringBootApplication中使用了@EnableAutoConfiguration，会激活自动装配
  public class App {
      SpringApplication.run(App.class, args)
  }
</code></pre>
</li>
</ul>
</li>
<li><p>源码分析：SpringBoot自动装配WebMvc模块</p>
<ul>
<li><p><code>@EnableAutoConfiguration</code>: Spring<code>@Enable模块</code>装配技术</p>
<pre><code class="lang-java">  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @Documented
  @Inherited
  @AutoConfigurationPackage
  @Import(AutoConfigurationImportSelector.class)    //  import: interface ImportSelector 实现类，用于获取Configuration类名 
  public @interface EnableAutoConfiguration {
      String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;
      Class&lt;?&gt;[] exclude() default {};
      String[] excludeName() default {};
  }

  public class AutoConfigurationImportSelector
          implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware,
          BeanFactoryAware, EnvironmentAware, Ordered {
      //...
      @Override
      public String[] selectImports(AnnotationMetadata annotationMetadata) {
          if (!isEnabled(annotationMetadata)) {
              return NO_IMPORTS;
          }
          AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader
                                                  .loadMetadata(this.beanClassLoader);
          AnnotationAttributes attributes = getAttributes(annotationMetadata);
          List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,attributes);
              =&gt;{
                  List&lt;String&gt; configurations = SpringFactoriesLoader
                          .loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());        
                      // 使用Spring工厂加载机制（读取配置文件`META-INF/spring.factories`）获取Configuration类名
                  Assert.notEmpty(configurations,
                          &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;
                          + &quot;are using a custom packaging, make sure that file is correct.&quot;);
                  return configurations;
              }
          // remove duplicates,remove exclusions,filter,fire imported events of exclusions
          //..
          return StringUtils.toStringArray(configurations);
      }    
  }

  // =&gt; `SpringFactoriesLoader` : 
  public abstract class SpringFactoriesLoader {
      public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;
      public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) {
          String factoryClassName = factoryClass.getName();
          return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());
      }
      //...
  }

  // =&gt; `META-INF/spring.factories` (jar: spring-boot-autoconfigure): 配置装载了`WebMvcAutoConfiguration`配置类
  # Auto Configure
  org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
  org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
  org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
  org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\
  org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\
  #...
</code></pre>
</li>
<li><code>WebMvcAutoConfiguration</code>：负责WebMvc相关Bean装配的Configure类 <pre><code class="lang-java">  @Configuration                            // 使用了Spring模式装配
  @ConditionalOnWebApplication            // 使用了Spring 条件装配
  @ConditionalOnClass({ Servlet.class, DispatcherServlet.class,WebMvcConfigurerAdapter.class })
  @ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
  @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
  @AutoConfigureAfter(DispatcherServletAutoConfiguration.class)
  public class WebMvcAutoConfiguration {
      //@Bean
  }
</code></pre>
</li>
<li><p><code>@SpringBootApplication</code>中使用了<code>@EnableAutoConfiguration</code>,使用<code>@SpringBootApplication</code>就会激活使用自动装配这个功能模块</p>
<pre><code class="lang-Java">  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @Documented
  @Inherited
  @SpringBootConfiguration
  @EnableAutoConfiguration            // 使用了自动装配模块
  @ComponentScan(excludeFilters = {
          @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
          @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
  public @interface SpringBootApplication {
      @AliasFor(annotation = EnableAutoConfiguration.class)
      Class&lt;?&gt;[] exclude() default {};

      @AliasFor(annotation = EnableAutoConfiguration.class)
      String[] excludeName() default {};

      @AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;)
      String[] scanBasePackages() default {};

      @AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackageClasses&quot;)
      Class&lt;?&gt;[] scanBasePackageClasses() default {};
  }
</code></pre>
</li>
</ul>
</li>
<li><p>示例：自定义一个配置类，实现自动装配</p>
<ol>
<li><p>自定义一个配置类 <code>HelloWorldAutoConfiguration</code></p>
<ul>
<li>方式一：<pre><code class="lang-java">  @Configuration
  @ConditionalOnSystemProperty(name=&quot;user.name&quot;,value=&quot;jinc&quot;)
  public class HelloWorldAutoConfiguration {
      @Bean
      public String helloWorld() {
          System.out.println(&quot;new bean:helloWrold&quot;);
          return new String(&quot;Hello world!&quot;);
      }
      @Bean
      public HelloController helloController() {
          System.out.println(&quot;new bean:helloController&quot;);
          return new HelloController();
      }
  }
</code></pre>
</li>
<li><p>方式二：使用了Spring的<code>@Enable模块</code>装配技术</p>
<pre><code class="lang-java">  @Configuration
  @EnableHelloWorld                                            // Spring @Enable模块装配
  @ConditionalOnSystemProperty(name=&quot;user.name&quot;,value=&quot;jinc&quot;)
  public class HelloWorldAutoConfiguration {
  }

  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.TYPE)
  @Documented
  @Import(HelloWorldConfiguration.class)
  public @interface EnableHelloWorld {

  }

  public class HelloWorldImportSelector implements ImportSelector {
      @Override
      public String[] selectImports(AnnotationMetadata importingClassMetadata) {
          System.out.println(&quot;HelloWorld--selectImports&quot;);
          return new String[] {HelloWorldConfiguration.class.getName()};
      }
  }
  public class HelloWorldConfiguration {
      @Bean
      public String helloWorld() {
          System.out.println(&quot;new bean:helloWrold&quot;);
          return new String(&quot;Hello world!&quot;);
      }
      @Bean
      public HelloController helloController() {
          System.out.println(&quot;new bean:helloController&quot;);
          return new HelloController();
      }
  }
</code></pre>
</li>
</ul>
</li>
<li>在<code>resources/META-INF/spring.factories</code>中配置自定义的AutoConfiguration类<pre><code class="lang-properties"> org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
 com.cj.autoconfig.auto.HelloWorldAutoConfiguration
</code></pre>
</li>
<li><p>激活自动装配，并测试</p>
<pre><code class="lang-java"> @EnableAutoConfiguration                // 激活自动装配 或使用@SpringBootApplication也可
 public class HelloWorldAutoApplication {
     public static void main(String[] args) {
         ConfigurableApplicationContext context = new SpringApplicationBuilder(HelloWorldAutoApplication.class)
             .web(WebApplicationType.NONE)
             .run(args);

         HelloController helloController = context.getBean(&quot;helloController&quot;,HelloController.class);
         System.out.println(&quot;helloController Bean : &quot;+helloController);    

         String helloWorld = context.getBean(&quot;helloWorld&quot;,String.class);
         System.out.println(&quot;helloWorld Bean : &quot;+helloWorld);    

         context.close();
     }
 }
</code></pre>
</li>
</ol>
</li>
</ol>
<h2 id="header-20">SpringApplication</h2>
<p><code>SpringApplication</code> : SpringBoot启动运行 (jar:<code>spring-boot</code>)</p>
<h3 id="header-21">使用</h3>
<ol>
<li><p><code>SpringApplication.run</code></p>
<pre><code class="lang-java"> ConfigurableApplicationContext ctx=SpringApplication.run(ApplicationConfiguration.class, args);
</code></pre>
</li>
<li><p><code>new SpringApplication</code></p>
<pre><code class="lang-java"> //SpringApplication app = new SpringApplication(ApplicationConfiguration.class);
 SpringApplication app = new SpringApplication();
 Set&lt;String&gt; sources = new HashSet&lt;String&gt;();
 sources.add(ApplicationConfiguration.class.getName());
 app.setSources(sources);
 app.setWebApplicationType(WebApplicationType.NONE);
 app.setAdditionalProfiles(&quot;Java8&quot;);
 ConfigurableApplicationContext context=app.run(args);
</code></pre>
</li>
<li><p><code>new SpringApplicationBuilder</code></p>
<pre><code class="lang-java"> ConfigurableApplicationContext context = new SpringApplicationBuilder(ApplicationConfiguration.class)
                 .web(WebApplicationType.NONE)    // NONE,SERVLET,REACTIVE
                 .profiles(&quot;Java8&quot;)
                 .run(args);
</code></pre>
</li>
</ol>
<p><strong> 示例：</strong></p>
<ol>
<li><p>最简式：</p>
<pre><code class="lang-java"> @SpringBootApplication
 public class DemoSpringApplication {
     public static void main(String[] args) {
         SpringApplication.run(DemoSpringApplication.class,args)
     }
 }
</code></pre>
</li>
<li><p>可配置式：</p>
<pre><code class="lang-java"> public class DemoSpringApplication {
     public static void main(String[] args) {

         // 1
 //        ConfigurableApplicationContext context=SpringApplication.run(ApplicationConfiguration.class, args);

         // 2
 //        //SpringApplication app = new SpringApplication(ApplicationConfiguration.class);
 //        SpringApplication app = new SpringApplication();
 //        Set&lt;String&gt; sources = new HashSet&lt;String&gt;();
 //        sources.add(ApplicationConfiguration.class.getName());
 //        app.setSources(sources);
 //        app.setWebApplicationType(WebApplicationType.NONE);
 //        app.setAdditionalProfiles(&quot;Java8&quot;);
 //        ConfigurableApplicationContext context=app.run(args);

         // 3
         ConfigurableApplicationContext context = new SpringApplicationBuilder(ApplicationConfiguration.class)
                 .web(WebApplicationType.NONE)    // NONE,SERVLET,REACTIVE
                 .profiles(&quot;Java8&quot;)
                 .run(args);

         /*
          - WebApplicationType.NONE:
             + ConfigurableApplicationContext: AnnotationConfigApplicationContext 
             + Environment: StandardEnvironment

          - WebApplicationType.SERVLET:
             + ConfigurableApplicationContext: AnnotationConfigServletWebServerApplicationContext
             + Environment: StandardServletEnvironment

          - WebApplicationType.REACTIVE:
             + ConfigurableApplicationContext: AnnotationConfigReactiveWebServerApplicationContext
             + Environment: StandardEnvironment
         */
         System.out.println(&quot;ConfigurableApplicationContext 类型：&quot; + context.getClass().getName());    
         System.out.println(&quot;Environment 类型：&quot; + context.getEnvironment().getClass().getName());

         CalculateService calculateService = context.getBean(CalculateService.class);
         System.out.println(&quot;calculateService Bean : &quot;+calculateService);    
         calculateService.sum(1,2,3,4,5,6,7,8,9,10);

         context.close();
     }

     @SpringBootApplication
     public static class ApplicationConfiguration {

     }
 }
</code></pre>
</li>
</ol>
<h3 id="header-22">启动过程</h3>
<ol>
<li><p>准备阶段（构造函数）</p>
<ul>
<li>1.1 推断<code>WebApplicationType</code>：根据当前应用ClassPath 中是否存在相关实现类来推断WebApplication的类型<ul>
<li><code>WebApplicationType.REACTIVE</code>: Web Reactive</li>
<li><code>WebApplicationType.SERVLET</code>: Web Servlet</li>
<li><code>WebApplicationType.NONE</code>: 非Web</li>
</ul>
</li>
<li>1.2 加载<code>ApplicationContextInitializer</code>上下文初始器: 利用 Spring 工厂加载机制，实现类实例化，并排序对象集合</li>
<li>1.3 加载<code>ApplicationListener</code> 事件监听器: 利用 Spring 工厂加载机制，实现类实例化，并排序对象集合</li>
<li>1.4 推断引导类（<code>Main Class</code>）: 根据 Main 线程执行堆栈判断实际的引导类</li>
</ul>
</li>
<li><p>运行阶段 （run函数）</p>
<ul>
<li>2.1 加载并运行<code>SpringApplicationRunListeners</code>运行监听器，监听SpringBoot／Spring事件</li>
<li>2.2 创建 <code>Environment</code>： 根据准备阶段推断的<code>WebApplicationType</code>创建对应的<code>ConfigurableEnvironment</code>实例<ul>
<li>Web Reactive： <code>StandardEnvironment</code></li>
<li>Web Servlet： <code>StandardServletEnvironment</code></li>
<li>非 Web： <code>StandardEnvironment</code></li>
</ul>
</li>
<li>2.3 创建Spring应用上下文：根据准备阶段推断的<code>WebApplicationType</code>创建对应的<code>ConfigurableApplicationContext</code>实例<ul>
<li>Web Reactive： <code>AnnotationConfigReactiveWebServerApplicationContext</code></li>
<li>Web Servlet： <code>AnnotationConfigServletWebServerApplicationContext</code></li>
<li>非 Web： <code>AnnotationConfigApplicationContext</code></li>
</ul>
</li>
<li>2.4 加载<code>SpringBootExceptionReporter</code>故障分析报告（利用 Spring 工厂加载机制），供以后失败时使用</li>
<li>2.5 加载Bean到应用上下文：加载Annotation/XML配置的Bean给Spring管理</li>
</ul>
</li>
</ol>
<h3 id="header-23">源码分析</h3>
<ol>
<li><p>constructor:</p>
<ul>
<li><code>WebApplicationType</code> Web应用类型<ul>
<li>WebApplicationType.REACTIVE</li>
<li>WebApplicationType.SERVLET</li>
<li>WebApplicationType.NONE</li>
</ul>
</li>
<li><code>ApplicationContextInitializer</code> 上下文初始器<pre><code class="lang-java">  public interface ApplicationContextInitializer&lt;C extends ConfigurableApplicationContext&gt; {
      /**
       * Initialize the given application context.
       * @param applicationContext the application to configure
       */
      void initialize(C applicationContext);
  }
</code></pre>
</li>
<li><code>ApplicationListener</code> 事件监听器<pre><code class="lang-java">  @FunctionalInterface
  public interface ApplicationListener&lt;E extends ApplicationEvent&gt; 
      extends EventListener {
      /**
       * Handle an application event.
       * @param event the event to respond to
       */
      void onApplicationEvent(E event);
  }
</code></pre>
</li>
<li><code>Main Class</code></li>
</ul>
</li>
<li><p>run:</p>
<ul>
<li><code>SpringApplicationRunListener</code> 运行监听器<pre><code class="lang-java">  public interface SpringApplicationRunListener {
      void starting();
      void environmentPrepared(ConfigurableEnvironment environment);
      void contextPrepared(ConfigurableApplicationContext context);
      void contextLoaded(ConfigurableApplicationContext context);
      void started(ConfigurableApplicationContext context);
      void running(ConfigurableApplicationContext context);
      void failed(ConfigurableApplicationContext context, Throwable exception);
  }
</code></pre>
<ul>
<li>eg: SpringBoot实现类<code>EventPublishingRunListener</code> (order:0)<table class="table">
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">实现</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0. EventPublishingRunListener(application,args)</td>
<td style="text-align:left">构造方法</td>
<td style="text-align:left">application.getListeners() -&gt; SimpleApplicationEventMulticaster#addApplicationListener 所以此Listener下面广播的Event会被SpringApplication的ApplicationListener监听到</td>
</tr>
<tr>
<td style="text-align:left">1. starting()</td>
<td style="text-align:left">应用开始启动</td>
<td style="text-align:left">广播 ApplicationStartingEvent</td>
</tr>
<tr>
<td style="text-align:left">2. environmentPrepared(env)</td>
<td style="text-align:left">Environment准备好了（允许将其调整了）</td>
<td style="text-align:left">广播 ApplicationEnvironmentPreparedEvent</td>
</tr>
<tr>
<td style="text-align:left">3. contextPrepared(ctx)</td>
<td style="text-align:left">ApplicationContext准备好了（允许将其调整了）</td>
<td style="text-align:left">／</td>
</tr>
<tr>
<td style="text-align:left">4. contextLoaded(ctx)</td>
<td style="text-align:left">ApplicationContext装载好了（但仍未启动）</td>
<td style="text-align:left">广播 ApplicationPreparedEvent</td>
</tr>
<tr>
<td style="text-align:left">5. started(ctx)</td>
<td style="text-align:left">ApplicationContext已刷新，应用启动完成（此时 Spring Bean 已完成初始化）</td>
<td style="text-align:left">广播 ApplicationStartedEvent</td>
</tr>
<tr>
<td style="text-align:left">6. running(ctx)</td>
<td style="text-align:left">应用开始运行</td>
<td style="text-align:left">广播 ApplicationReadyEvent</td>
</tr>
<tr>
<td style="text-align:left">7. failed(ctx,Throwable)</td>
<td style="text-align:left">应用运行失败</td>
<td style="text-align:left">广播 ApplicationFailedEvent</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li><code>listeners.starting()</code></li>
<li><code>ConfigurableEnvironment</code> 环境对象<ul>
<li>StandardEnvironment (for REACTIVE,NONE)</li>
<li>StandardServletEnvironment (for SERVLET)</li>
<li><code>listeners.environmentPrepared(environment)</code></li>
</ul>
</li>
<li><code>ConfigurableApplicationContext</code> 应用上下文<ul>
<li>AnnotationConfigReactiveWebServerApplicationContext (for REACTIVE)</li>
<li>AnnotationConfigServletWebServerApplicationContext (for SERVLET)</li>
<li>AnnotationConfigServletWebServerApplicationContext (for NONE)</li>
</ul>
</li>
<li><code>SpringBootExceptionReporter</code> 故障分析报告<pre><code class="lang-java">  @FunctionalInterface
  public interface SpringBootExceptionReporter {
          boolean reportException(Throwable failure);
  }
</code></pre>
</li>
<li>prepare context<ul>
<li>context.setEnvironment(environment)</li>
<li>applyInitializers(context): <code>ApplicationContextInitializer#initialize</code></li>
<li><code>listeners.contextPrepared(context);</code></li>
<li>load sources</li>
<li><code>listeners.contextLoaded(context);</code></li>
</ul>
</li>
<li>refresh context<ul>
<li><code>AbstractApplicationContext#refresh</code></li>
</ul>
</li>
<li><code>listeners.started(context)</code>;</li>
<li><code>listeners.running(context)</code>;</li>
</ul>
</li>
<li><p>总结 key：</p>
<ul>
<li><code>WebApplicationType.NONE/SERVLET/REACTIVE</code></li>
<li><code>ApplicationContextInitializer#initialize(ctx)</code></li>
<li><code>ApplicationListener#onApplicationEvent(event)</code></li>
<li>mainClass</li>
<li><code>SpringApplicationRunListener#starting,environmentPrepared,contextPrepared,contextLoaded,started,running,failed</code> (eg: <code>EventPublishingRunListener</code>)</li>
<li><code>ConfigurableEnvironment</code> (StandardEnvironment,StandardServletEnvironment)</li>
<li><code>ConfigurableApplicationContext</code> (AnnotationConfigServletWebServerApplicationContext,AnnotationConfigReactiveWebServerApplicationContext)</li>
<li><code>SpringBootExceptionReporter#reportException</code></li>
<li>context: setEnvironment,applyInitializers(trigger <code>ApplicationContextInitializer#initialize</code>),loadSources, refresh</li>
</ul>
</li>
</ol>
<p><strong> 源码：</strong></p>
<pre><code class="lang-java">package org.springframework.boot;
public class SpringApplication {

    // 1. 构造函数（准备阶段）
    public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) {
        this.resourceLoader = resourceLoader;
        Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);
        this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));

        // 1.1 根据当前应用ClassPath中是否存在相关实现类来推断WebApplication的类型
        this.webApplicationType = deduceWebApplicationType();
        ＝&gt;{
            if (ClassUtils.isPresent(REACTIVE_WEB_ENVIRONMENT_CLASS, null)
                &amp;&amp; !ClassUtils.isPresent(MVC_WEB_ENVIRONMENT_CLASS, null)) {
                return WebApplicationType.REACTIVE;
            }
            for (String className : WEB_ENVIRONMENT_CLASSES) {
                if (!ClassUtils.isPresent(className, null)) {
                    return WebApplicationType.NONE;
                }
            }
            return WebApplicationType.SERVLET;

        }

        // 1.2 加载`ApplicationContextInitializer`上下文初始器(利用 Spring 工厂加载机制)
        setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
        =&gt;{
            getSpringFactoriesInstances(ApplicationContextInitializer.class);
            // META-INF/spring.factories (jar:spring-boot-autoconfigure):
            # Initializers
            org.springframework.context.ApplicationContextInitializer=\
            org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\
            org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener

            // META-INF/spring.factories (jar:spring-boot):
            # Application Context Initializers
            org.springframework.context.ApplicationContextInitializer=\
            org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\
            org.springframework.boot.context.ContextIdApplicationContextInitializer,\
            org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\
            org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer
        }

        // 1.3 加载`ApplicationListener` 事件监听器 (利用 Spring 工厂加载机制)
        setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
        =&gt;{
            getSpringFactoriesInstances(ApplicationListener.class);
            // META-INF/spring.factories (jar:spring-boot-autoconfigure):
            # Application Listeners
            org.springframework.context.ApplicationListener=\
            org.springframework.boot.autoconfigure.BackgroundPreinitializer

            // META-INF/spring.factories (jar:spring-boot-autoconfigure):
            # Application Listeners
            org.springframework.context.ApplicationListener=\
            org.springframework.boot.ClearCachesApplicationListener,\
            org.springframework.boot.builder.ParentContextCloserApplicationListener,\
            org.springframework.boot.context.FileEncodingApplicationListener,\
            org.springframework.boot.context.config.AnsiOutputApplicationListener,\
            org.springframework.boot.context.config.ConfigFileApplicationListener,\
            org.springframework.boot.context.config.DelegatingApplicationListener,\
            org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\
            org.springframework.boot.context.logging.LoggingApplicationListener,\
            org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener
        }

        // 1.4 推断引导类（Main Class）: 根据 Main 线程执行堆栈判断实际的引导类
        this.mainApplicationClass = deduceMainApplicationClass();
        =&gt;{
            try {
                StackTraceElement[] stackTrace = new RuntimeException().getStackTrace();
                for (StackTraceElement stackTraceElement : stackTrace) {
                    if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) {
                        return Class.forName(stackTraceElement.getClassName());
                    }
                }
            }
            catch (ClassNotFoundException ex) {
                // Swallow and continue
            }
            return null;
        }
    }

    // 2. run函数（运行阶段）
    public ConfigurableApplicationContext run(String... args) {
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        ConfigurableApplicationContext context = null;
        Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();
        configureHeadlessProperty();

        // 2.1 加载运行`SpringApplicationRunListeners`运行监听器（利用 Spring 工厂加载机制）
        SpringApplicationRunListeners listeners = getRunListeners(args);
        =&gt;{
            Class&lt;?&gt;[] types = new Class&lt;?&gt;[] { SpringApplication.class, String[].class };
            return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances(
                    SpringApplicationRunListener.class, types, this, args));

            // META-INF/spring.factories (jar:spring-boot):
            # Run Listeners
            org.springframework.boot.SpringApplicationRunListener=\
            org.springframework.boot.context.event.EventPublishingRunListener
        }
        listeners.starting();    // Trigger: SpringApplicationRunListener#starting

        try {
            ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);

            // 2.2 创建`Environment`: 根据准备阶段(构造函数中)推断的`WebApplicationType`，创建对应的`ConfigurableEnvironment`实例
            ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments);
            =&gt;{
                // Create and configure the environment
                ConfigurableEnvironment environment = getOrCreateEnvironment();
                configureEnvironment(environment, applicationArguments.getSourceArgs());
                listeners.environmentPrepared(environment);     // Trigger: SpringApplicationRunListener#environmentPrepared
                bindToSpringApplication(environment);
                if (this.webApplicationType == WebApplicationType.NONE) {
                    environment = new EnvironmentConverter(getClassLoader())
                            .convertToStandardEnvironmentIfNecessary(environment);
                }
                ConfigurationPropertySources.attach(environment);
                return environment;
            }

            configureIgnoreBeanInfo(environment);
            Banner printedBanner = printBanner(environment);

            // 2.3 创建Spring应用上下文：根据准备阶段推断的`WebApplicationType`创建对应的`ConfigurableApplicationContext`实例
            context = createApplicationContext();
            =&gt;{
                Class&lt;?&gt; contextClass = this.applicationContextClass;
                if (contextClass == null) {
                    try {
                        switch (this.webApplicationType) {
                        case SERVLET:
                            contextClass = Class.forName(DEFAULT_WEB_CONTEXT_CLASS);
                            break;
                        case REACTIVE:
                            contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);
                            break;
                        default:
                            contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);
                        }
                    }
                    catch (ClassNotFoundException ex) {
                        throw new IllegalStateException(
                                &quot;Unable create a default ApplicationContext, &quot;
                                + &quot;please specify an ApplicationContextClass&quot;,
                                ex);
                    }
                }
                return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);
            }

            // 2.4 加载`SpringBootExceptionReporter`故障分析报告（利用 Spring 工厂加载机制），供以后失败时使用
            exceptionReporters = getSpringFactoriesInstances(
                    SpringBootExceptionReporter.class,
                    new Class[] { ConfigurableApplicationContext.class }, context);
            =&gt;{
                // META-INF/spring.factories (jar:spring-boot):
                # Error Reporters
                org.springframework.boot.SpringBootExceptionReporter=\
                org.springframework.boot.diagnostics.FailureAnalyzers
            }

            // 2.5 加载Bean到应用上下文：加载Annotation/XML配置的Bean给Spring管理
            prepareContext(context, environment, listeners, applicationArguments,printedBanner);
            =&gt;{
                context.setEnvironment(environment);
                postProcessApplicationContext(context);    
                applyInitializers(context);                // Trigger: ApplicationContextInitializer#initialize
                listeners.contextPrepared(context);        // Trigger: SpringApplicationRunListener#contextPrepared

                // Add boot specific singleton beans
                context.getBeanFactory().registerSingleton(&quot;springApplicationArguments&quot;,applicationArguments);
                if (printedBanner != null) {
                    context.getBeanFactory().registerSingleton(&quot;springBootBanner&quot;, printedBanner);
                }

                // Load the sources
                Set&lt;Object&gt; sources = getAllSources();
                Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);
                load(context, sources.toArray(new Object[0]));

                listeners.contextLoaded(context);        // Trigger: SpringApplicationRunListener#contextLoaded
            }
            refreshContext(context);
            =&gt;{
                ((AbstractApplicationContext) applicationContext).refresh();    //Trigger: AbstractApplicationContext#refresh
            }
            afterRefresh(context, applicationArguments);
            stopWatch.stop();
            if (this.logStartupInfo) {
                new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
            }
            listeners.started(context);                                      // Trigger: SpringApplicationRunListener#started
            callRunners(context, applicationArguments);
        }
        catch (Throwable ex) {
            handleRunFailure(context, ex, exceptionReporters, listeners); // Trigger: SpringApplicationRunListener#failed
            throw new IllegalStateException(ex);
        }
        try {
            listeners.running(context);                                     // Trigger: SpringApplicationRunListener#running
        }
        catch (Throwable ex) {
            handleRunFailure(context, ex, exceptionReporters, null);     // Trigger: SpringApplicationRunListener#failed
            throw new IllegalStateException(ex);
        }
        return context;
    }
}
</code></pre>
<h3 id="header-24">使用扩展</h3>
<ul>
<li><p>利用Spring工厂加载机制，按指定顺序装载自定义的扩展类</p>
</li>
<li><p>示例1: 装载自定义的<code>ApplicationInitializer</code></p>
<ol>
<li><p>自定义 <code>ApplicationInitializer</code></p>
<pre><code class="lang-java"> @Order(Ordered.HIGHEST_PRECEDENCE+10)
 public class HelloApplicationInitializer&lt;C extends ConfigurableApplicationContext&gt; 
     implements ApplicationContextInitializer&lt;C&gt; {

     @Override
     public void initialize(C applicationContext) {
         System.out.println(&quot;Hello: ApplicationContext id=&quot;+applicationContext.getId());
     }

 }
 public class WorldApplicationInitializer&lt;C extends ConfigurableApplicationContext&gt; 
     implements ApplicationContextInitializer&lt;C&gt;,Ordered {

     @Override
     public void initialize(C applicationContext) {
         System.out.println(&quot;World: ApplicationContext id=&quot;+applicationContext.getId());
     }

     @Override
     public int getOrder() {
         return Ordered.HIGHEST_PRECEDENCE+10-1;
     }
 }
</code></pre>
</li>
<li><p>配置<code>META-INF/spring.factories</code></p>
<pre><code> # ApplicationContextInitializer
 org.springframework.context.ApplicationContextInitializer=\
 com.cj.application.initializer.HelloApplicationInitializer,\
 com.cj.application.initializer.WorldApplicationInitializer
</code></pre></li>
<li><p>测试</p>
<pre><code class="lang-java"> public class DemoSpringApplication {
     public static void main(String[] args) {
         SpringApplication.run(DemoSpringApplication.class, args);
     }
 }
 /*
 Result:
 World: ApplicationContext id=org.springframework.context.annotation.AnnotationConfigApplicationContext@69b794e2
 Hello: ApplicationContext id=org.springframework.context.annotation.AnnotationConfigApplicationContext@69b794e2
 */
</code></pre>
</li>
</ol>
</li>
<li><p>示例2: 装载自定义的<code>ApplicationListener</code></p>
<ol>
<li><p>自定义 <code>ApplicationListener</code></p>
<pre><code class="lang-java"> // HelloApplicationListener -- 监听所有ApplicationEvent
 @Order(Ordered.HIGHEST_PRECEDENCE+20)
 public class HelloApplicationListener&lt;C extends ApplicationEvent&gt; implements ApplicationListener&lt;C&gt;{

     @Override
     public void onApplicationEvent(C event) {
         System.out.println(&quot;Hello ApplicationEvent: &quot;+event.getClass().getSimpleName());
     }
 }

 // WorldApplicationListener -- 监听 ContextRefreshedEvent
 public class WorldApplicationListener implements ApplicationListener&lt;ContextRefreshedEvent&gt;,Ordered{
     @Override
     public void onApplicationEvent(ContextRefreshedEvent event) {
         System.out.println(&quot;World ApplicationEvent: &quot;+event.getClass().getSimpleName());
     }
     @Override
     public int getOrder() {
         return Ordered.HIGHEST_PRECEDENCE+30;
     }
 }

 // MySmartApplicationListener -- 监听所有ApplicationEvent，处理ApplicationEnvironmentPreparedEvent
 public class MySmartApplicationListener implements SmartApplicationListener{
     @Override
     public void onApplicationEvent(ApplicationEvent event) {
         System.out.println(&quot;MySmart ApplicationEvent: &quot;+ event.getClass().getSimpleName());
         if (event instanceof ApplicationEnvironmentPreparedEvent) {
             ApplicationEnvironmentPreparedEvent preparedEvent = (ApplicationEnvironmentPreparedEvent) event;
             Environment environment = preparedEvent.getEnvironment();
             System.out.println(&quot;environment: &quot; + environment);
         }
     }
     @Override
     public boolean supportsEventType(Class&lt;? extends ApplicationEvent&gt; eventType) {
         return ApplicationEnvironmentPreparedEvent.class.isAssignableFrom(eventType)
                 || ContextRefreshedEvent.class.isAssignableFrom(eventType);
     }
     @Override
     public boolean supportsSourceType(Class&lt;?&gt; sourceType) {
         return true;
     }
     @Override
     public int getOrder() {
         return Ordered.HIGHEST_PRECEDENCE+25;
     }
 }
</code></pre>
</li>
<li>配置<code>META-INF/spring.factories</code><pre><code class="lang-java"> # ApplicationListener
 # Listener处理顺序（根据Order排序）：Hello -&gt; MySmart -&gt; World
 org.springframework.context.ApplicationListener=\
 com.cj.application.listener.HelloApplicationListener,\
 com.cj.application.listener.WorldApplicationListener,\
 com.cj.application.listener.MySmartApplicationListener
</code></pre>
</li>
<li><p>测试</p>
<pre><code class="lang-java"> public class DemoSpringApplication {
     public static void main(String[] args) {
         SpringApplication.run(DemoSpringApplication.class, args);
     }
 }
 /*
 Hello ApplicationEvent: ApplicationStartingEvent

 Hello ApplicationEvent: ApplicationEnvironmentPreparedEvent
 MySmart ApplicationEvent: ApplicationEnvironmentPreparedEvent
 environment: StandardEnvironment {activeProfiles=[Java8], defaultProfiles=[default], propertySources=[MapPropertySource {name=&#39;systemProperties&#39;}, OriginAwareSystemEnvironmentPropertySource {name=&#39;systemEnvironment&#39;}, RandomValuePropertySource {name=&#39;random&#39;}]}

 World: ApplicationContext id=org.springframework.context.annotation.AnnotationConfigApplicationContext@15d9bc04
 Hello: ApplicationContext id=org.springframework.context.annotation.AnnotationConfigApplicationContext@15d9bc04

 Hello ApplicationEvent: ApplicationPreparedEvent

 Hello ApplicationEvent: ContextRefreshedEvent
 MySmart ApplicationEvent: ContextRefreshedEvent
 World ApplicationEvent: ContextRefreshedEvent

 Hello ApplicationEvent: ApplicationStartedEvent
 Hello ApplicationEvent: ApplicationReadyEvent
 Hello ApplicationEvent: ContextClosedEvent
 */
</code></pre>
</li>
</ol>
</li>
</ul>
<h3 id="header-25">Spring事件监听模型</h3>
<ul>
<li>事件(Event): <code>ApplicationEvent</code>,<code>ApplicationContextEvent</code></li>
<li>监听器(Listener): <code>ApplicationListener</code>,<code>@EventListener</code></li>
<li>广播器(Multicaster): <code>ApplicationEventMulticaster</code> (执行模式:同步或异步)</li>
<li><p>示例：<code>ApplicationContext</code>注册<code>Listener</code> &amp; 发送<code>Event</code></p>
<pre><code class="lang-java">  public class DemoSpringApplicationEvent {
       public static void main(String[] args) {
          // 创建上下文
          AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();

          // 注册应用事件监听器
          context.addApplicationListener(event -&gt; {
              if(event instanceof PayloadApplicationEvent){
                  PayloadApplicationEvent payloadEvent=(PayloadApplicationEvent)event;
                  System.out.println(&quot;监听到Payload事件: &quot; + payloadEvent.getPayload());
              }else
                  System.out.println(&quot;监听到事件: &quot; + event.getClass().getSimpleName()
                      +&quot;[source=&quot;+event.getSource()+&quot;]&quot;);
          });

          // 启动上下文
          context.refresh();
          // 发送事件
          context.publishEvent(&quot;HelloWorld&quot;);
          context.publishEvent(new ApplicationEvent(&quot;Outside&quot;) {});

          // 关闭上下文
          context.close();
      }
  }

  /*
  监听到事件: ContextRefreshedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@50cbc42f: startup date [Feb Oct 09 02:03:32 CST 2018]; root of context hierarchy]
  监听到Payload事件: HelloWorld
  监听到事件: [source=Outside]
  监听到事件: ContextClosedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@50cbc42f: startup date [Sun Feb 09 02:03:32 CST 2018]; root of context hierarchy]
  */
</code></pre>
</li>
</ul>
<h2 id="header-26">外部化配置</h2>
<p>Refer <a href="https://docs.spring.io/spring-boot/docs/2.0.2.RELEASE/reference/htmlsingle/#boot-features-external-config">SpringBoot Doc</a></p>
<blockquote>
<p>Spring Boot allows you to externalize your configuration so you can work with the same application code in different environments. You can use properties files, YAML files, environment variables and command-line arguments to externalize configuration.</p>
</blockquote>
<p>加载外部配置资源的内容到程序变量中用于动态控制：</p>
<ol>
<li><p>外部化配置资源（保存到<code>PropertySource</code>对象）</p>
<ul>
<li>常见的加载项顺序：<ul>
<li><code>@TestPropertySource#properties</code></li>
<li><code>@SpringBootTest#properties</code></li>
<li><code>@TestPropertySource#location</code></li>
<li>cmd line args (eg:<code>-Duser.id=13</code>)</li>
<li>system properties (eg:<code>-Duser.city.post_code=0731</code>),可通过<code>System.getProperties()</code>获取</li>
<li>os env variables (eg:<code>USER_CITY_POST_CODE=001</code>)</li>
<li>application property files/yaml variants (eg:<code>user.city.post-code=0571</code>)<ul>
<li><code>application-{profile}.properties</code>outside pkg jar</li>
<li><code>application-{profile}.properties</code> packaged inside jar</li>
<li><code>application.properties</code> outside pkg jar</li>
<li><code>application.properties</code> packaged inside jar</li>
</ul>
</li>
<li><code>@PropertySouce</code> on <code>@Configuration</code> class</li>
<li>default properties</li>
</ul>
</li>
<li>注意：<ul>
<li>前面的优先级更高（后面同属性的值不会覆盖前面已经加载到的）</li>
<li>允许松散绑定（特例：<code>@ConditionalOnProperty</code> prefix name 要与 <code>application.properties</code> 完全一致,在环境变量里面,允许松散绑定）</li>
</ul>
</li>
<li><code>PropertySource</code><ul>
<li>带有名称的外部化配置属性源(eg source : Properties file,YAML file,environment variables, and command-line arguments,Map键值对)</li>
<li>主要方法：<code>abstract Object getProperty(String name)</code></li>
<li>与<code>Environment</code>对应关系 <ul>
<li><code>Environment</code> : <code>PropertySources</code>:<code>PropertySource</code>= 1:1:N</li>
<li>eg: <code>ConfigurableEnvironment</code> : <code>MutablePropertySources</code>:<code>PropertySource</code> = 1:1:N</li>
<li>参考<code>SpringApplication#run</code> -&gt; <code>prepareEnvironment</code> -&gt; <code>configureEnvironment</code> -&gt; <code>configurePropertySources</code></li>
</ul>
</li>
<li>查看Environment中加载各个的PropertySource: <code>environment.getPropertySources().forEach</code><pre><code class="lang-java">  MutablePropertySources propertySources=environment.getPropertySources();
  propertySources.forEach(item-&gt;{
      System.out.printf(&quot;[%s] : %s\n&quot;, item.getName(), item);
  });
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>绑定到变量</p>
<ul>
<li>XML方式：<code>&lt;bean&gt;</code> -&gt; <code>&lt;property name=&quot;xxx&quot; value=&quot;${...}&quot; /&gt;</code></li>
<li>Annotation方式: <code>@Value</code> ,<code>@ConfigurationProperties</code></li>
</ul>
</li>
</ol>
<h3 id="header-27">加载外部化配置（XML方式）</h3>
<p>示例：</p>
<ol>
<li><p>Spring应用</p>
<ul>
<li><p>Key:</p>
<ul>
<li>配置装载属性占位符：<code>PropertyPlaceholderConfigurer</code>，装载外部化配置文件</li>
<li>配置bean：<code>&lt;property name=&quot;xxx&quot; value=&quot;${...}&quot; /&gt;</code>，注意bean需要有get/set方法</li>
</ul>
</li>
<li><p>domain: User</p>
<pre><code class="lang-java">  public class User{
      private Long id;
      private String name;
      private Integer age;
      // get/set function -- must need!
  }
</code></pre>
</li>
<li><p>resouces/spring-context.xml</p>
<pre><code class="lang-xml">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
      &lt;!-- 属性占位符配置--&gt;
      &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;
          &lt;!-- Properties 文件 classpath 路径 --&gt;
          &lt;property name=&quot;location&quot; value=&quot;classpath:test.properties&quot;/&gt;
          &lt;!-- 文件字符编码 --&gt;
          &lt;property name=&quot;fileEncoding&quot; value=&quot;UTF-8&quot;/&gt;
      &lt;/bean&gt;  
      &lt;!-- User Bean --&gt;
      &lt;bean id=&quot;user&quot; class=&quot;com.cj.demo1.domain.User&quot;&gt;
          &lt;property name=&quot;id&quot; value=&quot;${user.id}&quot;/&gt;
          &lt;property name=&quot;name&quot; value=&quot;${user.name}&quot;/&gt;
      &lt;/bean&gt;
  &lt;/beans&gt;
</code></pre>
</li>
<li><p>resources/test.properties</p>
<pre><code>  user.id=12
  user.name=Tom
</code></pre></li>
<li><p>verify</p>
<pre><code class="lang-java">  public class SpringPlaceholderApp {
       public static void main(String[] args) {
          String[] locations = {&quot;spring-context.xml&quot;};
          ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(locations);
          User user = ctx.getBean(&quot;user&quot;, User.class);
          System.err.println(user);    // User{id=12, name=&#39;Tom&#39;, age=null}
          ctx.close();
      }
  }
</code></pre>
</li>
</ul>
</li>
<li><p>SpringBoot应用</p>
<ul>
<li>Key：<ul>
<li>自动装配不需要另外配置装载属性占位符：<code>PropertyPlaceholderConfigurer</code></li>
<li>配置bean：<code>&lt;property name=&quot;xxx&quot; value=&quot;${...}&quot; /&gt;</code>，注意bean需要有get/set方法</li>
</ul>
</li>
<li><p>domain: User</p>
<pre><code class="lang-java">  public class User{
      private Long id;
      private String name;
      private Integer age;
      // get/set function -- must need!
  }
</code></pre>
</li>
<li><p>resources/bean.xml</p>
<pre><code class="lang-xml">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
      &lt;!-- User Bean --&gt;
      &lt;bean id=&quot;user&quot; class=&quot;com.cj.demo1.domain.User&quot;&gt;
          &lt;property name=&quot;id&quot; value=&quot;${user.id}&quot;/&gt;
          &lt;property name=&quot;name&quot; value=&quot;${user.name}&quot;/&gt;
      &lt;/bean&gt;
  &lt;/beans&gt;
</code></pre>
</li>
<li><p>resources/application.properties</p>
<pre><code>  user.id=15
  user.name=Lucy
</code></pre></li>
<li><p>verify</p>
<pre><code class="lang-java">  @ImportResource(&quot;bean.xml&quot;) // 加载 XML 文件
  @EnableAutoConfiguration
  public class SpringBootPlaceholderApp {
      public static void main(String[] args) {
          ConfigurableApplicationContext ctx =
                  new SpringApplicationBuilder(SpringBootPlaceholderApp.class)
                          .web(WebApplicationType.NONE) // 非 Web 应用
                          .run(args);
          User user = ctx.getBean(&quot;user&quot;, User.class);
          System.err.println(user);
          System.err.printf(&quot;System.getProperty(\&quot;%s\&quot;) : %s \n&quot;, &quot;user.name&quot;, System.getProperty(&quot;user.name&quot;));            
          ConfigurableEnvironment environment = ctx.getEnvironment();
          environment.getPropertySources().forEach(item-&gt;{
              System.out.printf(&quot;[%s] : %s\n&quot;, item.getName(), item);
          });            
          ctx.close();
      }
  }
  // Note：
  // 会发现不是Tom，而是User{id=15, name=&#39;cj&#39;, age=null}
  // 因为System Property的优先级高于property file
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="header-28">Annotation方式</h3>
<ol>
<li><code>@Value</code></li>
<li><code>@ConfigurationProperties</code></li>
<li>扩展：<ul>
<li><code>@Validated</code> 校验</li>
<li><code>@ConditionalOnProperty</code> 判断</li>
</ul>
</li>
</ol>
<h3 id="header-29">源码分析</h3>
<p>SpringBoot中<code>Environment</code>的生命周期（参考<code>SpringApplication#run</code>）</p>
<ul>
<li><p>Key：</p>
<ul>
<li>prepareEnvironment:<ul>
<li>create</li>
<li>configure: <code>PropertySources</code></li>
<li>trigger <code>SpringApplicationRunListener#environmentPrepared</code></li>
<li>convert</li>
</ul>
</li>
<li>prepareContext:<ul>
<li>setEnvironment</li>
<li>trigger <code>ApplicationContextInitializer#initialize</code></li>
<li>trigger <code>SpringApplicationRunListener#contextPrepared</code></li>
<li>...</li>
<li>trigger <code>SpringApplicationRunListener#contextLoaded</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>PropertySource</code></p>
<pre><code class="lang-java">  public abstract class PropertySource&lt;T&gt; {
      protected final String name;
      protected final T source;
      public abstract Object getProperty(String name);
      //...
  }
</code></pre>
<ul>
<li>ConfigurationPropertySourcesPropertySource</li>
<li>AnnotationsPropertySource</li>
<li>CommandLinePropertySource<T></li>
<li>MapPropertySource</li>
<li>ServletConfigPropertySource</li>
<li>ServletContextPropertySource</li>
<li>...</li>
</ul>
</li>
<li><p><code>SpringApplication#run</code>:</p>
<pre><code class="lang-java">  // 1. SpringApplicationRunListeners
  // 2. ConfigurableEnvironment: 
  ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments);
  =&gt;{
      // Create and configure the environment
      ConfigurableEnvironment environment = getOrCreateEnvironment();
      configureEnvironment(environment, applicationArguments.getSourceArgs());
      =&gt;{
          // Add, remove or re-order any {@link PropertySource}s in this application&#39;s environment.
          configurePropertySources(environment, args);
          // setActiveProfiles for this application&#39;s environment.
          configureProfiles(environment, args);
      }

      listeners.environmentPrepared(environment);    // Trigger: SpringApplicationRunListener#environmentPrepared

      bindToSpringApplication(environment);
      if (this.webApplicationType == WebApplicationType.NONE) {
          environment = new EnvironmentConverter(getClassLoader())
                  .convertToStandardEnvironmentIfNecessary(environment);
      }
      ConfigurationPropertySources.attach(environment);
      return environment;
  }
  // 3. ConfigurableApplicationContext
  // 4. SpringBootExceptionReporter
  // 5. prepare context
  prepareContext(context, environment, listeners, applicationArguments,printedBanner);
  =&gt;{
      context.setEnvironment(environment);
      postProcessApplicationContext(context);    
      applyInitializers(context);                // Trigger: ApplicationContextInitializer#initialize
      listeners.contextPrepared(context);        // Trigger: SpringApplicationRunListener#contextPrepared

      //...
      listeners.contextLoaded(context);        // Trigger: SpringApplicationRunListener#contextLoaded
  }
  // 6. refresh context
</code></pre>
</li>
</ul>
<h3 id="header-30">获取<code>Environment</code></h3>
<ul>
<li><p>方法／构造器</p>
<pre><code class="lang-java">  @Component
  public class A{
      private Environment environment;
      @Autowired
      public A(Environment environment){
          this.environment = environment;
      }
  }
</code></pre>
<pre><code class="lang-java">  @Configuration
  public class B{
      @Bean
      @Autowired    // will auto inject Environment,not add this annotation still work.
      public String hello(Environment environment){
          return environment.getRequiredProperty(&quot;say&quot;, String.class);
      }
  }
</code></pre>
</li>
<li><p><code>@Autowired</code></p>
<pre><code class="lang-java">  @Component
  public class A{
      @Autowired
      private Environment environment;
  }
</code></pre>
</li>
<li><p>implements<code>BeanFactoryAware</code></p>
<pre><code class="lang-java"> @Component
 public class A implements BeanFactoryAware {
     private Environment environment;
     @Override
     public void setBeanFactory(BeanFactory beanFactory) 
         throws BeansException {
         this.environment=beanFactory.getBean(Environment.class);
     }
 }
</code></pre>
</li>
<li><p>implements <code>EnvironmentAware</code></p>
<pre><code class="lang-java">  @Component
  public class A implements EnvironmentAware{
      private Environment environment;
      @Override
      public void setEnvironment(Environment environment) {
          this.environment=environment;
      }
  }
</code></pre>
</li>
</ul>
<h3 id="header-31">实时扩展外部化配置属性源</h3>
<p>实时扩展外部化配置属性源: 基于<code>Environment</code>抽象实现</p>
<ul>
<li><code>Environment</code> 可以</li>
<li><code>@Value</code> 不行</li>
<li><code>@ConfiguratinProperties</code> 不行</li>
</ul>
<ol>
<li><p>可考虑扩展以下类，并依据Spring工厂加载机制配置装配：</p>
<ul>
<li><code>SpringApplicationRunListener#environmentPrepared</code><pre><code class="lang-java">  EventPublishingRunListener#environmentPrepared 
      -&gt; ApplicationListener#onApplicationEvent : ApplicationEnvironmentPreparedEvent
          -&gt; ConfigFileApplicationListener#onApplicationEvent : ApplicationEnvironmentPreparedEvent
              -&gt; EnvironmentPostProcessor#postProcessEnvironment : ApplicationEnvironmentPreparedEvent
</code></pre>
<ul>
<li><code>ApplicationListener#onApplicationEvent</code></li>
<li><code>EnvironmentPostProcessor#postProcessEnvironment</code></li>
</ul>
</li>
<li><code>ApplicationContextInitializer#initialize</code></li>
<li><code>SpringApplicationRunListener#contextPrepared</code></li>
<li><code>SpringApplicationRunListener#contextLoaded</code></li>
<li>注：根据Environment生命周期，需在refresh context前，且注意触发调用顺序（参考<code>SpringApplication#run</code>）</li>
</ul>
</li>
<li><p>示例</p>
<ul>
<li><p>示例1：使用<code>EnvironmentPostProcessor#postProcessEnvironment</code>自定义实现类</p>
<pre><code class="lang-java">  public class ExtendPropertySourcesEnvironmentPostProcessor implements EnvironmentPostProcessor{
      @Override
      public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
          System.err.println(&quot;execute ExtendPropertySourcesEnvironmentPostProcessor#postProcessEnvironment: put user.id=60&quot;);
          MutablePropertySources propertySources=environment.getPropertySources();
          Map&lt;String,Object&gt; source=new HashMap&lt;String,Object&gt;();
          source.put(&quot;user.id&quot;,60);
          MapPropertySource ps=new MapPropertySource(&quot;from-postProcessEnvironment&quot;, source);
          propertySources.addFirst(ps);
      }
  }

  // config: resources/META-INF/spring.factories
  # EnvironmentPostProcessor
  org.springframework.boot.env.EnvironmentPostProcessor=\
  com.cj.demo2.processor.ExtendPropertySourcesEnvironmentPostProcessor
</code></pre>
</li>
<li><p>示例2：使用<code>ApplicationListener#onApplicationEvent</code>自定义实现类</p>
<pre><code class="lang-java">  // after `ConfigFileApplicationListener`
  public class ExtendPropertySourcesApplicationListener implements ApplicationListener&lt;ApplicationEnvironmentPreparedEvent&gt; {
      @Override
      public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) {
          System.err.println(&quot;execute ExtendPropertySourcesApplicationListener#onApplicationEvent(ApplicationEnvironmentPreparedEvent): put user.id=55&quot;);
          MutablePropertySources propertySources=event.getEnvironment().getPropertySources();
          Map&lt;String,Object&gt; source=new HashMap&lt;String,Object&gt;();
          source.put(&quot;user.id&quot;,55);
          MapPropertySource ps=new MapPropertySource(&quot;from-applicationEnvironmentPreparedEvent&quot;, source);
          propertySources.addFirst(ps);
      }
  }

  // config: resources/META-INF/spring.factories
  # Application Listeners
  org.springframework.context.ApplicationListener=\
  com.cj.demo2.listener.ExtendPropertySourcesApplicationListener
</code></pre>
</li>
<li><p>示例3：使用<code>SpringApplicationRunListener#environmentPrepared</code>自定义实现类</p>
<pre><code class="lang-java">  // after `EventPublishingRunListener`
  public class ExtendPropertySourcesRunListener implements SpringApplicationRunListener,Ordered{
      private final SpringApplication application;
      private final String[] args;
      public ExtendPropertySourcesRunListener(SpringApplication application, String[] args) {
          this.application = application;
          this.args = args;
      }
      @Override
      public int getOrder() {
          return 1;    // set after EventPublishingRunListener(order=0)
      }
      @Override
      public void environmentPrepared(ConfigurableEnvironment environment) {
          System.err.println(&quot;execute ExtendPropertySourcesRunListener#environmentPrepared: put user.id=50&quot;);
          MutablePropertySources propertySources=environment.getPropertySources();
          Map&lt;String,Object&gt; source=new HashMap&lt;String,Object&gt;();
          source.put(&quot;user.id&quot;,50);
          MapPropertySource ps=new MapPropertySource(&quot;from-environmentPrepared&quot;, source);
          propertySources.addFirst(ps);
      }
      //...
  }

  // config: resources/META-INF/spring.factories
  # Run Listeners, Refer META-INF/spring.factories (jar:spring-boot):
  org.springframework.boot.SpringApplicationRunListener=\
  com.cj.demo2.listener.ExtendPropertySourcesRunListener
</code></pre>
</li>
<li><p>示例4：使用<code>ApplicationContextInitializer#initialize</code>自定义实现类</p>
<pre><code class="lang-java">  public class ExtendPropertySourcesApplicationContextInitializer&lt;C extends ConfigurableApplicationContext&gt; implements ApplicationContextInitializer&lt;C&gt; {
      @Override
      public void initialize(ConfigurableApplicationContext applicationContext) {
          System.err.println(&quot;execute ExtendPropertySourcesApplicationContextInitializer#initialize: put user.id=65&quot;);
          MutablePropertySources propertySources=applicationContext.getEnvironment().getPropertySources();
          Map&lt;String,Object&gt; source=new HashMap&lt;String,Object&gt;();
          source.put(&quot;user.id&quot;,65);
          MapPropertySource ps=new MapPropertySource(&quot;from-applicationContextInitialize&quot;, source);
          propertySources.addFirst(ps);
      }
  }

  // config: resources/META-INF/spring.factories
  # Application Context Initializers
  org.springframework.context.ApplicationContextInitializer=\
  com.cj.demo2.initializer.ExtendPropertySourcesApplicationContextInitializer
</code></pre>
</li>
</ul>
</li>
</ol>
<h2 id="header-32">Servlet</h2>
<p>Servlet:</p>
<blockquote>
<p>是一种基于 Java 技术的 Web 组件，用于生成动态内容，由容器管理。
类似于其他 Java 技术组件，Servlet 是平台无关的 Java 类组成，且由 Java Web 服务器加载执行。通常情况，由 Servlet容器提供运行时环境。</p>
</blockquote>
<p>Servlet 容器/引擎:</p>
<blockquote>
<p>作为Web服务器或应用服务器的一部分，管理Servlets实例以及它们的生命周期
通过请求和响应对话，提供Web Client与Servlets交互的能力</p>
</blockquote>
<p>从功能上:</p>
<blockquote>
<p>Servlet 介于 CGI（Common Gateway Interface）与服务扩展（如：Netscape Server API 或 Apache 模块）之间</p>
</blockquote>
<p>在体系上:</p>
<blockquote>
<p>Servlet 技术（或者规范）属于 Java EE 技术（规范）的一部分</p>
</blockquote>
<ol>
<li><p>Servlet 版本</p>
<table class="table">
<thead>
<tr>
<th style="text-align:left">规范版本</th>
<th style="text-align:left">发布时间</th>
<th style="text-align:left">Java 平台</th>
<th style="text-align:left">主要更新</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Servlet 4.0</td>
<td style="text-align:left">2017 年 9 月</td>
<td style="text-align:left">Java EE 8</td>
<td style="text-align:left">支持 HTTP/2</td>
</tr>
<tr>
<td style="text-align:left">Servlet 3.1</td>
<td style="text-align:left">2013 年 5 月</td>
<td style="text-align:left">Java EE 7</td>
<td style="text-align:left">非阻塞 I/O、HTTP 协议更新机制（WebSocket）</td>
</tr>
<tr>
<td style="text-align:left">Servlet 3.0</td>
<td style="text-align:left">2009 年 12 月</td>
<td style="text-align:left">Java EE 6</td>
<td style="text-align:left">可插拔、简化部署、异步 Servlet、安全、文件上传</td>
</tr>
<tr>
<td style="text-align:left">Servlet 2.5</td>
<td style="text-align:left">2005 年 9 月</td>
<td style="text-align:left">Java EE 5</td>
<td style="text-align:left">Annotation 支持</td>
</tr>
<tr>
<td style="text-align:left">Servlet 2.4</td>
<td style="text-align:left">2003 年 11 月</td>
<td style="text-align:left">J2EE 1.4</td>
<td style="text-align:left">web.xml 支持 XML Scheme</td>
</tr>
<tr>
<td style="text-align:left">Servlet 2.3</td>
<td style="text-align:left">2001 年 8 月</td>
<td style="text-align:left">J2EE 1.3</td>
<td style="text-align:left">新增 Filter、事件/监听器、Wrapper</td>
</tr>
<tr>
<td style="text-align:left">Servlet 2.2</td>
<td style="text-align:left">1999 年 8 月</td>
<td style="text-align:left">J2EE 1.2</td>
<td style="text-align:left">作为 J2EE 的一部分， 以 .war 文件作为独立 web 应用</td>
</tr>
</tbody>
</table>
</li>
<li><p>Servlet 核心组件 (Servlet,Filter,Listener,Context)</p>
<table class="table">
<thead>
<tr>
<th style="text-align:left">核心组件 API</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">起始版本</th>
<th style="text-align:left">Spring Framework 代表实现</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">javax.servlet.Servlet</td>
<td style="text-align:left">动态内容组件</td>
<td style="text-align:left">1.0</td>
<td style="text-align:left">DispatcherServlet</td>
</tr>
<tr>
<td style="text-align:left">javax.servlet.Filter</td>
<td style="text-align:left">Servlet 过滤器</td>
<td style="text-align:left">2.3</td>
<td style="text-align:left">CharacterEncodingFilter</td>
</tr>
<tr>
<td style="text-align:left">javax.servlet.ServletContext</td>
<td style="text-align:left">Servlet 应用上下文</td>
<td style="text-align:left">/</td>
<td style="text-align:left">/</td>
</tr>
<tr>
<td style="text-align:left">javax.servlet.AsyncContext</td>
<td style="text-align:left">异步上下文</td>
<td style="text-align:left">3.0</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">javax.servlet.ServletContextListener</td>
<td style="text-align:left">ServletContext 生命周期监听器</td>
<td style="text-align:left">2.3</td>
<td style="text-align:left">ContextLoaderListener</td>
</tr>
<tr>
<td style="text-align:left">javax.servlet.ServletRequestListener</td>
<td style="text-align:left">ServletRequest 生命周期监听器</td>
<td style="text-align:left">2.3</td>
<td style="text-align:left">RequestContextListener</td>
</tr>
<tr>
<td style="text-align:left">javax.servlet.http.HttpSessionListener</td>
<td style="text-align:left">HttpSession 生命周期监听器</td>
<td style="text-align:left">2.3</td>
<td style="text-align:left">HttpSessionMutexListener</td>
</tr>
<tr>
<td style="text-align:left">javax.servlet.AsyncListener</td>
<td style="text-align:left">异步上下文监听器</td>
<td style="text-align:left">3.0</td>
<td style="text-align:left">StandardServletAsyncWebRequest</td>
</tr>
<tr>
<td style="text-align:left">javax.servlet.ServletContainerInitializer</td>
<td style="text-align:left">Servlet 容器初始化器</td>
<td style="text-align:left">3.0</td>
<td style="text-align:left">SpringServletContainerInitializer</td>
</tr>
</tbody>
</table>
</li>
<li><p>Servlet 组件的生命周期</p>
<ul>
<li><code>Servlet</code><ul>
<li>init(ServletConfig)</li>
<li>service(ServletRequest,ServletResponse)</li>
<li>destroy()</li>
</ul>
</li>
<li><code>Filter</code><ul>
<li>init(FilterConfig)</li>
<li>doFilter(ServletRequest,ServletResponse,FilterChain)</li>
<li>destroy()</li>
</ul>
</li>
<li><code>Listener</code><ul>
<li>contextInitialized(ServletContextEvent)</li>
<li>contextDestroyed(ServletContextEvent)</li>
</ul>
</li>
</ul>
</li>
<li><p>Servlet 组件注册</p>
<table class="table">
<thead>
<tr>
<th style="text-align:left">组件</th>
<th style="text-align:left">传统方式</th>
<th style="text-align:left">注解方式</th>
<th style="text-align:left">编程方式（利用Servlet SPI：<code>ServletContainerInitializer#onStartup(classes,ctx)</code>）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Servlet</td>
<td style="text-align:left">web.xml: <code>&lt;servlet&gt;</code>,<code>&lt;servlet-mapping&gt;</code></td>
<td style="text-align:left"><code>@WebServlet</code></td>
<td style="text-align:left">ServletContext#addServlet</td>
</tr>
<tr>
<td style="text-align:left">Filter</td>
<td style="text-align:left">web.xml: <code>&lt;filter&gt;</code>,<code>&lt;filter-mapping&gt;</code></td>
<td style="text-align:left"><code>@WebFilter</code></td>
<td style="text-align:left">ServletContext#addFilter</td>
</tr>
<tr>
<td style="text-align:left">Listener</td>
<td style="text-align:left">web.xml: <code>&lt;listener&gt;</code>,<code>&lt;context-param&gt;</code></td>
<td style="text-align:left"><code>@WebListener</code></td>
<td style="text-align:left">ServletContext#addListener</td>
</tr>
</tbody>
</table>
</li>
<li><p>Servlet容器</p>
<table class="table">
<thead>
<tr>
<th style="text-align:left">Servlet容器</th>
<th style="text-align:left">启动</th>
<th style="text-align:left">初始化器</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">独立Servlet容器</td>
<td style="text-align:left">独立Servlet容器 -&gt; 启动 App</td>
<td style="text-align:left">Servlet SPI(3.0): <code>ServletContainerInitializer</code>; Spring 适配：<code>SpringServletContainerInitializer</code>+ <code>@HandlesTypes(WebApplicationInitializer.class)</code></td>
</tr>
<tr>
<td style="text-align:left">嵌入式Servlet容器</td>
<td style="text-align:left">App －&gt; 启动嵌入式Servlet容器</td>
<td style="text-align:left">SpringBoot: <code>ServletContextInitializer</code></td>
</tr>
</tbody>
</table>
</li>
<li><p>Servlet -&gt; Spring -&gt; SpringBoot:</p>
<table class="table">
<thead>
<tr>
<th style="text-align:left">Jar</th>
<th style="text-align:left">XML方式</th>
<th style="text-align:left">注解方式</th>
<th style="text-align:left">编程方式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Servlet</td>
<td style="text-align:left">web.xml</td>
<td style="text-align:left">@WebServlet等</td>
<td style="text-align:left">interface <code>ServletContainerInitializer</code></td>
</tr>
<tr>
<td style="text-align:left">Spring(独立Servlet容器)</td>
<td style="text-align:left">&radic;</td>
<td style="text-align:left">&radic;</td>
<td style="text-align:left"><code>SpringServletContainerInitializer</code>(implements ServletContainerInitializer) + <code>@HandlesTypes(WebApplicationInitializer.class)</code></td>
</tr>
<tr>
<td style="text-align:left">SpringBoot(独立Servlet容器)</td>
<td style="text-align:left">&times;</td>
<td style="text-align:left">&radic;</td>
<td style="text-align:left"><code>SpringBootServletInitializer</code>(implements WebApplicationInitializer) <br/> note: 支持使用<code>ServletContextInitializer</code>注入的Servlet组件 <br/> eg: <br/> @Bean ServletContextInitializer <br/> @Bean ServletRegisterBean,FilterRegisterBean,ServletListenerRegisterBean (implements ServletContextInitializer)</td>
</tr>
<tr>
<td style="text-align:left">SpringBoot(嵌入式Servlet容器)</td>
<td style="text-align:left">&times;</td>
<td style="text-align:left">limited: need to add <code>@ServletComponentScan</code></td>
<td style="text-align:left">only can use <code>ServletContextInitializer</code> <br/> note: 不支持使用<code>SpringBootServletInitializer</code>(implements WebApplicationInitializer)</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h3 id="header-33">Servlet 容器启动初始化</h3>
<p><code>ServletContainerInitializer</code> Servlet容器初始化器</p>
<ol>
<li><p>Servlet interface (jar: <code>javax.servlet-api</code> / <code>tomcat-embed-core</code>)</p>
<pre><code class="lang-java"> package javax.servlet;
 public interface ServletContainerInitializer {
     public void onStartup(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx) throws ServletException; 
 }
</code></pre>
<ul>
<li><code>Servlet 3.0</code> 新增的一个接口，主要用于在容器启动阶段通过<code>编程风格</code>注册Servlet/Filter/Listener，以取代通过<code>web.xml</code>配置注册</li>
<li>这样利于开发内聚的web应用框架，例如：对于SpringWeb应用，<code>Servlet3.0</code>前需要在<code>web.xml</code>中配置注册一些Spring实现的Servlet/Filter/Listener组件,相当于将框架和容器紧耦合了; <code>3.x</code>后注册的功能内聚到Spring里，这个SpringWeb应用就变成了一个即插即用的组件，不用依据应用环境定义一套新的配置</li>
<li>参考：<ul>
<li><a href="https://blog.csdn.net/lqzkcx3/article/details/78507169">Servlet3.0研究之ServletContainerInitializer接口</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI3MTEwODc5Ng==&amp;mid=2650859531&amp;idx=1&amp;sn=02830d72d4bacd00c82314d0281f3eb2&amp;chksm=f13297d8c6451ece93dd5abbfff1cce10e440414838e2864d3c5b8fa794a1acc91cca0e4343f&amp;mpshare=1&amp;scene=23&amp;srcid=0920wmSB9KfBqsVAQTLYz3ly#rd">Tomcat 中 的可插拔以及 SCI 的实现原理</a></li>
</ul>
</li>
</ul>
</li>
<li><p>Spring实现类 <code>SpringServletContainerInitializer</code> (Version 3.1后): 接受启动<code>WebApplicationInitializer</code>类型的initializers (jar: <code>spring-web</code>)</p>
<pre><code class="lang-java"> package org.springframework.web;
 @HandlesTypes(WebApplicationInitializer.class)
 public class SpringServletContainerInitializer implements ServletContainerInitializer {
     @Override
     public void onStartup(@Nullable Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext) throws ServletException{
         List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;&gt;();
         for:webAppInitializerClasses
             initializers.add
         AnnotationAwareOrderComparator.sort(initializers);
         for:initializers
             initializer.onStartup(servletContext)
     }
 }

 /**
  * Interface to be implemented in Servlet 3.0+ environments in order to configure the
  * {@link ServletContext} programmatically -- as opposed to (or possibly in conjunction
  * with) the traditional {@code web.xml}-based approach.
  */
 public interface WebApplicationInitializer {
     /**
      * Configure the given {@link ServletContext} with any servlets, filters, listeners
      * context-params and attributes necessary for initializing this web application. 
      */
     void onStartup(ServletContext servletContext) throws ServletException;
 }
</code></pre>
<ul>
<li><code>WebApplicationInitializer</code> 实现类：<ul>
<li>AbstractContextLoaderInitializer<ul>
<li>AbstractDispatcherServletInitializer    编程驱动<ul>
<li>AbstractAnnotationConfigDispatcherServletInitializer 注解驱动</li>
</ul>
</li>
</ul>
</li>
<li>AbstractReactiveWebInitializer</li>
<li>AbstractSecurityWebApplicationInitializer</li>
<li>SpringBootServletInitializer (jar: spring-boot)</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong> Spring WebMvc 示例：</strong></p>
<p>Key:</p>
<ul>
<li>使用xml配置WebMvc相关组件</li>
<li>使用<code>web.xml</code> 或者自定义的<code>WebApplicationInitializer</code>实现类注册<code>DispatcherServlet</code></li>
<li>自定义一个Servlet，并通过<code>@WebServlet</code>注册</li>
<li>使用独立Servlet启动运行</li>
</ul>
<ol>
<li><p>pom.xml</p>
<pre><code class="lang-xml"> &lt;packaging&gt;war&lt;/packaging&gt;
 &lt;dependencies&gt;
     &lt;!-- Spring Web MVC 依赖 --&gt;
     &lt;dependency&gt;
          &lt;groupId&gt;org.springframework&lt;/groupId&gt;
          &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
     &lt;/dependency&gt;

     &lt;!-- Servlet 3.1 API 依赖--&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
          &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
          &lt;scope&gt;provided&lt;/scope&gt;
      &lt;/dependency&gt;
 &lt;/dependencies&gt;
 &lt;build&gt;
     &lt;finalName&gt;demo&lt;/finalName&gt;
     &lt;plugins&gt; 
         &lt;!-- jetty:run --&gt;
         &lt;plugin&gt;
           &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;
           &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;
           &lt;version&gt;9.4.12.v20180830&lt;/version&gt;
           &lt;configuration&gt;
             &lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt;
              &lt;webApp&gt;
               &lt;contextPath&gt;/demo&lt;/contextPath&gt;
             &lt;/webApp&gt;
             &lt;httpConnector&gt;
                 &lt;port&gt;9090&lt;/port&gt;
                 &lt;idleTimeout&gt;60000&lt;/idleTimeout&gt;
             &lt;/httpConnector&gt;
             &lt;stopKey&gt;foo&lt;/stopKey&gt;
                &lt;stopPort&gt;9999&lt;/stopPort&gt;
           &lt;/configuration&gt;
         &lt;/plugin&gt;

         &lt;!-- tomcat --&gt;
         &lt;!-- mvn -Dmaven.test.skip -U clean package --&gt;
         &lt;!-- java -jar target/xxx-war-exec.jar --&gt;
         &lt;!-- visit: http://localhost:8080/demo --&gt;
         &lt;plugin&gt;
             &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
             &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
             &lt;version&gt;2.1&lt;/version&gt;
             &lt;executions&gt;
                 &lt;execution&gt;
                     &lt;id&gt;tomcat-run&lt;/id&gt;
                     &lt;goals&gt;
                         &lt;goal&gt;exec-war-only&lt;/goal&gt;
                     &lt;/goals&gt;
                     &lt;phase&gt;package&lt;/phase&gt;
                     &lt;configuration&gt;
                         &lt;!-- ServletContext path --&gt;
                         &lt;path&gt;/demo&lt;/path&gt;
                     &lt;/configuration&gt;
                 &lt;/execution&gt;
             &lt;/executions&gt;
         &lt;/plugin&gt;

     &lt;/plugins&gt;
 &lt;/build&gt;
</code></pre>
</li>
<li><p>/src/main/webapp/WEB-INF/app-context.xml (配置Web MVC组件)</p>
<pre><code class="lang-xml"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
     xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
     xsi:schemaLocation=&quot;
     http://www.springframework.org/schema/beans
     http://www.springframework.org/schema/beans/spring-beans.xsd
     http://www.springframework.org/schema/context
     http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

     &lt;context:component-scan base-package=&quot;com.cj.demo&quot;/&gt;
     &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;
     &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;
     &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
         &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;
         &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
         &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
     &lt;/bean&gt;
 &lt;/beans&gt;
</code></pre>
</li>
<li>/src/main/webapp/jsp/index.jsp<pre><code class="lang-html"> This index page: Hello World
</code></pre>
</li>
<li>Controller<pre><code class="lang-java"> @Controller
 public class HelloController {
     @RequestMapping(value={&quot;/&quot;},method=RequestMethod.GET)
     public String index() {
         return &quot;index&quot;;
     }
 }
</code></pre>
</li>
<li><p>部署 DispatcherServlet</p>
<ul>
<li>使用<code>web.xml</code>的传统方式注册Servlet组件<pre><code class="lang-xml">  &lt;web-app&gt;
      &lt;!-- 配置注册 DispatchServlet--&gt;
      &lt;servlet&gt;
           &lt;servlet-name&gt;app&lt;/servlet-name&gt;
           &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
           &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
           &lt;init-param&gt;
              &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
              &lt;param-value&gt;/WEB-INF/app-context.xml&lt;/param-value&gt; &lt;!-- classpath*:/META-INF/spring/spring-context.xml --&gt;
          &lt;/init-param&gt;
       &lt;/servlet&gt;
       &lt;servlet-mapping&gt;
           &lt;servlet-name&gt;app&lt;/servlet-name&gt;
           &lt;url-pattern&gt;/&lt;/url-pattern&gt;
       &lt;/servlet-mapping&gt;
  &lt;/web-app&gt;
</code></pre>
</li>
<li><p>编程取代传统的<code>web.xml</code>方式注册Servlet组件（ Spring <code>SpringServletContainerInitializer</code> -&gt; <code>WebApplicationInitializer#onStartup</code> ）</p>
<pre><code class="lang-java">  // 使用自定义的WebApplicationInitializer实现类注册DispatchServlet
  /*
  WebApplicationInitializer
      - AbstractContextLoaderInitializer
          - AbstractDispatcherServletInitializer
              - AbstractAnnotationConfigDispatcherServletInitializer
  */
  @ImportResource(&quot;/WEB-INF/app-context.xml&quot;)
  public class MyAnnotationConfigDispatcherServletInitializer 
      extends AbstractAnnotationConfigDispatcherServletInitializer{

      @Override
      protected Class&lt;?&gt;[] getRootConfigClasses() {    //web.xml
          return new Class[0];
      }
      @Override
      protected Class&lt;?&gt;[] getServletConfigClasses() {    // DispatchServlet
          System.out.println(&quot;get servlet config classes.......&quot;);
          return new Class[] {this.getClass()};
      }
      @Override
      protected String[] getServletMappings() {
          System.out.println(&quot;get servlet mappings......&quot;);
          return new String[]{&quot;/&quot;};
      }
  }
</code></pre>
</li>
</ul>
</li>
<li><p>自定义一个<code>Servlet</code>并注入</p>
<pre><code class="lang-java"> // 自定义一个Servlet，使用注解@WebServlet来注入此Servlet (不依赖ComponentScan)
 @WebServlet(urlPatterns=&quot;/myServlet&quot;,name=&quot;myServlet&quot;,asyncSupported=true)
 public class MyServlet extends HttpServlet{
     public MyServlet() {
         println(&quot;MyServlet!&quot;);
     }
     protected void doGet(HttpServletRequest req,HttpServletResponse resp)
             throws ServletException,IOException {
         println(&quot;Hello world!&quot;);
          if(req.isAsyncSupported()) {
             AsyncContext ctx=req.startAsync();
             ctx.setTimeout(500L);
             ctx.start(()-&gt;{
                 try{
                     println(&quot;Async Hello world!&quot;);    
                     resp.getWriter().println(&quot;Async Hello world!&quot;);
                     ctx.complete();    // must call complete
                 }catch(IOException e){
                     e.printStackTrace();
                 }
             });
         }
         resp.getWriter().println(&quot;Hello world!&quot;);
     }
     private static void println(Object object) {
         String threadName = Thread.currentThread().getName();
         System.out.println(&quot;MyServlet[&quot; + threadName + &quot;]: &quot; + object);
     }
 }
</code></pre>
</li>
<li><p>verify: pom.xml maven build... -&gt; <code>jetty:run</code> (使用tomcat maven插件生成可运行的jar包也可以)</p>
<ul>
<li><code>curl -i http://localhost:9090/demo/</code></li>
<li><code>curl -i http://localhost:9090/demo/myServlet</code></li>
</ul>
</li>
</ol>
<p><strong> SpringBoot WebMvc 示例：</strong></p>
<p>Key:</p>
<ul>
<li>使用<code>@EnableAutoConfiguration</code>自动装配DispatcherServlet</li>
<li>使用XML/Annotation(<code>@Configuration</code>) 配置WebMvc相关组件 （Spring中也可使用这种注解配置方式 + <code>@ComponentScan(basePackages=&quot;com.cj.demo&quot;)</code>配置扫描到配置类）</li>
<li>使用<code>SpringBootServletInitializer</code>配置主引导类 (SpringBootServletInitializer implements WebApplicationInitializer)</li>
<li><p>使用<code>独立Servlet</code>启动运行</p>
</li>
<li><p>pom.xml</p>
<pre><code class="lang-xml"> &lt;packaging&gt;war&lt;/packaging&gt;
 &lt;dependencies&gt;
     &lt;!-- Spring Boot 依赖 --&gt;
     &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
          &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
          &lt;exclusions&gt;
               &lt;!-- Exclude the Tomcat dependency --&gt;
               &lt;exclusion&gt;
                   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                   &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
               &lt;/exclusion&gt;
          &lt;/exclusions&gt;
     &lt;/dependency&gt; 

     &lt;!-- Servlet 3.1 API 依赖--&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
          &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
          &lt;scope&gt;provided&lt;/scope&gt;
      &lt;/dependency&gt;
 &lt;/dependencies&gt;
 &lt;build&gt;
     &lt;finalName&gt;demo&lt;/finalName&gt;
     &lt;plugins&gt; 
         &lt;!-- jetty:run --&gt;
         &lt;plugin&gt;
           &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;
           &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;
           &lt;version&gt;9.4.12.v20180830&lt;/version&gt;
           &lt;configuration&gt;
             &lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt;
              &lt;webApp&gt;
               &lt;contextPath&gt;/demo&lt;/contextPath&gt;
             &lt;/webApp&gt;
             &lt;httpConnector&gt;
                 &lt;port&gt;9090&lt;/port&gt;
                 &lt;idleTimeout&gt;60000&lt;/idleTimeout&gt;
             &lt;/httpConnector&gt;
             &lt;stopKey&gt;foo&lt;/stopKey&gt;
                &lt;stopPort&gt;9999&lt;/stopPort&gt;
           &lt;/configuration&gt;
         &lt;/plugin&gt;
     &lt;/plugins&gt;
 &lt;/build&gt;
</code></pre>
</li>
<li><p>使用<code>@Configuration</code>注解方式配置WebMvc组件</p>
<pre><code class="lang-java"> package com.cj.demo.config;
 @Configuration
 // 还可以implements WebMvcConfigurer，方便实现更多配置，例如: @Override addInterceptors
 public class WebMvcConfig {
     /*
      &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
         &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;
         &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
         &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
      &lt;/bean&gt;
      */
     @Bean
     public ViewResolver viewResolver(){
         InternalResourceViewResolver viewResolver=new InternalResourceViewResolver();
         viewResolver.setViewClass(JstlView.class);
         viewResolver.setPrefix(&quot;/WEB-INF/jsp/&quot;);
         viewResolver.setSuffix(&quot;.jsp&quot;);
         return viewResolver;
     }
 }
</code></pre>
</li>
<li><p>/src/main/webapp/jsp/index.jsp</p>
<pre><code class="lang-html"> This index page: Hello World
</code></pre>
</li>
<li><p>Controller</p>
<pre><code class="lang-java"> @Controller
 public class HelloController {
     @RequestMapping(value={&quot;/&quot;},method=RequestMethod.GET)
     public String index() {
         return &quot;index&quot;;
     }
 }
</code></pre>
</li>
<li><p>通过<code>SpringBootServletInitializer</code>配置主引导类</p>
<pre><code class="lang-java"> package com.cj.demo.initializer;
 // Note：SpringBootServletInitializer implements WebApplicationInitializer)
 public class MySpringBootServletInitializer extends SpringBootServletInitializer{

     protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
         System.out.println(&quot;MySpringBootServletInitializer configure&quot;);
         builder.sources(SpringBootDemoApp.class);
         return builder;
     }
 }

 @EnableAutoConfiguration
 public class SpringBootDemoApp {
 }
</code></pre>
</li>
<li><p>verify: <code>pom.xml</code> -&gt; maven build... -&gt; <code>jetty:run</code> -&gt; <code>curl -i http://localhost:9090/demo/</code></p>
</li>
</ul>
<h3 id="header-34">Servlet 嵌入式容器启动初始化</h3>
<p>SpringBoot 实现 (jar: spring-boot) ：</p>
<ol>
<li><p><code>ServletContextInitializer</code></p>
<pre><code class="lang-java"> package org.springframework.boot.web.servlet;
 @FunctionalInterface
 public interface ServletContextInitializer{
     void onStartup(ServletContext servletContext) throws ServletException;
 }
</code></pre>
<ul>
<li>为减少风险，嵌入式容器（eg: embed jetty/tomcat/...) 不能使用Servlet interface <code>ServletContainerInitializer</code>和Spring interface<code>WebApplicationInitializer</code>. Refer <a href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/htmlsingle/#boot-features-embedded-container-context-initializer">27.4.2 Servlet Context Initialization</a></li>
<li>SpringBoot中提供<code>ServletContextInitializer</code>接口（代替嵌入式容器无法使用的Servlet interface <code>ServletContainerInitializer</code>）来实现<code>ServletContext</code>的initialization.</li>
</ul>
</li>
<li><p><code>ServletContextInitializer</code>实现类</p>
<ul>
<li>RegistrationBean<ul>
<li>DynamicRegistrationBean<D extends Registration.Dynamic><ul>
<li>AbstractFilterRegistrationBean<T extends Filter><ul>
<li>DelegatingFilterProxyRegistrationBean</li>
<li>FilterRegistrationBean<T extends Filter> : <code>@WebFilter</code></li>
</ul>
</li>
<li>ServletRegistrationBean<T extends Servlet> : <code>@WebServlet</code></li>
</ul>
</li>
<li>ServletListenerRegistrationBean<T extends EventListener> : <code>@WebListener</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>@ServletComponentScan</code></p>
<ul>
<li>嵌入式容器无法自动识别并处理Servlet注解<code>@WebServlet</code>／<code>@WebFilter</code>／<code>@WebListener</code></li>
<li>SpringBoot提供<code>@ServletComponentScan</code>来扫描识别这些Servlet注解</li>
<li>处理过程：扫描 package -&gt; <code>@WebServlet</code>/<code>@WebFilter</code>/<code>@WebListener</code> -&gt; <code>RegistrationBean</code> BeanDefinition -&gt; <code>RegistrationBean</code>Bean: 嵌入式容器调用<code>ServletContextInitializer#onStartup(ServletContext)</code>时装配识别出的Servlet组件</li>
</ul>
</li>
<li><p>部分源码：</p>
<pre><code class="lang-java"> @Target(ElementType.TYPE)
 @Retention(RetentionPolicy.RUNTIME)
 @Documented
 @Import(ServletComponentScanRegistrar.class)
 public @interface ServletComponentScan

 package org.springframework.boot.web.servlet;
 class ServletComponentScanRegistrar implements ImportBeanDefinitionRegistrar {
     @Override
     public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
             BeanDefinitionRegistry registry) {
         Set&lt;String&gt; packagesToScan = getPackagesToScan(importingClassMetadata);
         updatePostProcessor/addPostProcessor(registry, packagesToScan);
         =&gt;{
             GenericBeanDefinition beanDefinition = new GenericBeanDefinition();
             beanDefinition.setBeanClass(ServletComponentRegisteringPostProcessor.class); // Note !
             beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(packagesToScan);
             beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
             registry.registerBeanDefinition(BEAN_NAME, beanDefinition);
         } 
     }
 }
 //=&gt;
 class ServletComponentRegisteringPostProcessor implements BeanFactoryPostProcessor, ApplicationContextAware {
     private static final List&lt;ServletComponentHandler&gt; HANDLERS;
     static {
         List&lt;ServletComponentHandler&gt; servletComponentHandlers = new ArrayList&lt;&gt;();
         servletComponentHandlers.add(new WebServletHandler());    // For @WebServlet
         servletComponentHandlers.add(new WebFilterHandler());    // For @WebFilter
         servletComponentHandlers.add(new WebListenerHandler()); // For @WebListener
         HANDLERS = Collections.unmodifiableList(servletComponentHandlers);
     }
     @Override
     public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)
             throws BeansException {
         if (isRunningInEmbeddedWebServer()) {    // Note: only for embed webserver!
             ClassPathScanningCandidateComponentProvider componentProvider = createComponentProvider();
             for (String packageToScan : this.packagesToScan) 
                 scanPackage(componentProvider, packageToScan);
                 =&gt; {
                     for beanDef:componentProvider.findCandidateComponents(packageToScan)
                         for handler:HANDLERS
                             handler.handle(beanDef,this.applicationContext)
                 }
         }
     }
 }
 //=&gt; eg: WebServletHandler
 class WebServletHandler extends ServletComponentHandler {
     WebServletHandler() {
         super(WebServlet.class);
     }

     @Override
     public void doHandle(Map&lt;String, Object&gt; attributes,
         ScannedGenericBeanDefinition beanDefinition,BeanDefinitionRegistry registry) {
         BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(ServletRegistrationBean.class); // Note !
         builder.addPropertyValue(...); // ...
         registry.registerBeanDefinition(name, builder.getBeanDefinition());
     }
 }
 //=&gt; 
 //ServletRegistrationBean extends RegistrationBean implements ServletContextInitializer
 ServletRegistrationBean#onStartup(ServletContext)
</code></pre>
</li>
<li><p>总结：Spring Boot 嵌入式Servlet容器限制</p>
<table class="table">
<thead>
<tr>
<th style="text-align:left">Servlet 特性</th>
<th style="text-align:left">兼容性</th>
<th style="text-align:left">解决方案</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">web.xml</td>
<td style="text-align:left">不支持</td>
<td style="text-align:left">ServletContextInitializer/RegistrationBean @Bean 注册</td>
</tr>
<tr>
<td style="text-align:left">ServletContainerInitializer</td>
<td style="text-align:left">不支持</td>
<td style="text-align:left">ServletContextInitializer</td>
</tr>
<tr>
<td style="text-align:left">@WebServlet 等</td>
<td style="text-align:left">有限支持</td>
<td style="text-align:left">依赖@ServletComponentScan</td>
</tr>
</tbody>
</table>
</li>
</ol>
<p><strong> SpringBoot 示例：</strong></p>
<p>Key：</p>
<ul>
<li>使用xml/annotation方式配置WebMvc组件</li>
<li>使用<code>@EnableAutoConfiguration</code>自动部署DispatcherServlet</li>
<li>自定义Servlet，通过<code>@WebServlet</code>+<code>@ServletComponentScan</code>，或<code>RegistrationBean</code>,或<code>ServletContextInitializer#onStartup-&gt;servletContext.addServlet</code>方式注册</li>
<li><p>使用嵌入式容器（直接运行main方法）/独立容器启动进行验证</p>
</li>
<li><p>pom.xml</p>
<pre><code class="lang-xml"> &lt;dependencies&gt;
     &lt;!-- default embed webserver by spring-boot-starter-tomcat--&gt;
     &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
          &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
     &lt;/dependency&gt; 
 &lt;/dependencies&gt;
</code></pre>
</li>
<li><p>使用XML方式配置Web MVC组件：/src/main/webapp/WEB-INF/app-context.xml</p>
<pre><code class="lang-xml"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
     xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
     xsi:schemaLocation=&quot;
     http://www.springframework.org/schema/beans
     http://www.springframework.org/schema/beans/spring-beans.xsd
     http://www.springframework.org/schema/context
     http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

     &lt;context:component-scan base-package=&quot;com.cj.demo&quot;/&gt;
     &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;
     &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;
     &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
         &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;
         &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
         &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
     &lt;/bean&gt;
 &lt;/beans&gt;
</code></pre>
</li>
<li><p>/src/main/webapp/jsp/index.jsp</p>
<pre><code class="lang-html"> This index page: Hello World
</code></pre>
</li>
<li><p>Controller</p>
<pre><code class="lang-java"> @Controller
 public class HelloController {
     @RequestMapping(value={&quot;/&quot;},method=RequestMethod.GET)
     public String index() {
         return &quot;index&quot;;
     }
 }
</code></pre>
</li>
<li><p>部署 DispatcherServlet</p>
<pre><code> // @SpringBootApplication 包括 @EnableAutoConfiguration
 // 会自动通过DispatcherServletAutoConfiguration来注入DispatchServlet(mapped=/)
 @SpringBootApplication(scanBasePackages=&quot;com.cj.demo&quot;)
 public class SpringBootStartApp {
     public static void main(String[] args) {
         SpringApplication.run(SpringBootStartApp.class, args);
     }
 }
</code></pre></li>
<li><p>自定义一个Servlet并注入</p>
<pre><code class="lang-java"> // 自定义一个Servlet
 public class MyServlet extends HttpServlet{
     public MyServlet() {
         println(&quot;MyServlet!&quot;);
     }
     protected void doGet(HttpServletRequest req,HttpServletResponse resp)
             throws ServletException,IOException {
         println(&quot;Hello world!&quot;);
          if(req.isAsyncSupported()) {
             AsyncContext ctx=req.startAsync();
             ctx.setTimeout(500L);
             ctx.start(()-&gt;{
                 try{
                     println(&quot;Async Hello world!&quot;);    
                     resp.getWriter().println(&quot;Async Hello world!&quot;);
                     ctx.complete();    // must call complete
                 }catch(IOException e){
                     e.printStackTrace();
                 }
             });
         }
         resp.getWriter().println(&quot;Hello world!&quot;);
     }
     private static void println(Object object) {
         String threadName = Thread.currentThread().getName();
         System.out.println(&quot;MyServlet[&quot; + threadName + &quot;]: &quot; + object);
     }
 }
</code></pre>
<ul>
<li>方式一：使用<code>RegistrationBean</code><pre><code class="lang-java">  @Bean
  public ServletRegistrationBean&lt;Servlet&gt; myServletRegistrationBean(){
      return new ServletRegistrationBean&lt;Servlet&gt;(new MyServlet(),&quot;/myServlet&quot;);    // default asyncSupported is true.
  }
</code></pre>
</li>
<li>方式二：使用<code>@WebServlet</code> + <code>@ServletComponentScan</code><ul>
<li>在自定义Servlet上添加<code>@WebServlet(urlPatterns=&quot;/myServlet&quot;,name=&quot;myServlet&quot;,asyncSupported=true)</code></li>
<li>在main class上添加<code>@ServletComponentScan(basePackages=&quot;com.cj.demo.servlet&quot;)</code> 以扫描到使用<code>@WebServlet</code>注入的Servlet</li>
<li>Note： <code>@ServletComponentScan</code> only effective for EmbeddedWebServer, will scan @WebServlet,@WebFilter,@WebListener</li>
</ul>
</li>
<li>方式三：使用<code>ServletContextInitializer#onStartup-&gt;servletContext.addServlet</code><pre><code class="lang-java">  @Bean
  public ServletContextInitializer myServletContextInitializer(){
      return servletContext-&gt;{
          ServletRegistration.Dynamic reg=servletContext.addServlet(&quot;myServlet&quot;, new MyAsyncServlet());
          reg.addMapping(&quot;/myServlet&quot;);
          reg.setAsyncSupported(true);        // set asyncSupported to be true
      };
  }
</code></pre>
</li>
<li>注：<ul>
<li>以上优先级 <code>RegistrationBean</code> &gt; <code>@ServletComponentScan</code> &gt; <code>ServletContextInitializer</code></li>
<li>同mappingUrl/servletName，优先级高的先注册了会自动skip掉后来的 (特： 若重复发生在ServletContextInitializer中，会报错，嵌入式容器启动失败)</li>
</ul>
</li>
</ul>
</li>
<li><p>verify: run <code>main</code></p>
<ul>
<li><code>curl -i http://localhost:8080/</code>        -&gt; OK</li>
<li><code>curl -i http://localhost:8080/myServlet</code> -&gt; OK</li>
</ul>
</li>
</ul>
<h3 id="header-35">组件Servlet源码分析</h3>
<ul>
<li><p><code>Servlet</code> (jar: servlet-api)</p>
<ul>
<li><code>GenericServlet</code> (jar: servlet-api)<ul>
<li><code>HttpServletBean</code> -&gt; <code>FrameworkServlet</code> -&gt; <code>DispatchServlet</code> (jar:spring-webmvc)    </li>
</ul>
</li>
</ul>
</li>
<li><p><code>servlet-api</code>: javax.servlet.http (eg: javax.servlet-api-3.1.0.jar)</p>
<ul>
<li><code>Servlet</code> (init,service,destroy,getServletConfig)<ul>
<li><code>GenericServlet</code> (abstract service,init,...)<ul>
<li><code>HttpServlet</code> (service,doGet,doPost,doXxx...)</li>
</ul>
</li>
</ul>
</li>
<li><p>Source Code：</p>
<pre><code class="lang-java">  interface Servlet
  {
      public void init(ServletConfig config) throws ServletException;
      public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException;
      public void destroy();
      public ServletConfig getServletConfig();
          =&gt;{ //ServletConfig:
              public String getServletName();
              public ServletContext getServletContext();
              public String getInitParameter(String name);
              public Enumeration&lt;String&gt; getInitParameterNames();
          }
      public String getServletInfo();
  }

  abstract class GenericServlet implements Servlet, ServletConfig,java.io.Serializable
  {
      // ...
      public void init(ServletConfig config) throws ServletException {
          this.config = config;
          this.init();
      }
      public abstract void service(ServletRequest req, ServletResponse res) throws ServletException, IOException;
  }

  abstract class HttpServlet extends GenericServlet 
  {
      @Override
      public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException{
           service((HttpServletRequest)request, (HttpServletResponse)response); // protected func
              =&gt;{
                  req.getMethod()? doHead/doGet/doPost/doPut/doXxx...    // protected func
              }
      }
  }
</code></pre>
</li>
</ul>
</li>
<li><p>Spring: org.springframework.web.servlet (jar: <code>spring-webmvc</code>)</p>
<ul>
<li><code>HttpServletBean</code> : final init -&gt; initBeanWrapper,initServletBean<ul>
<li><code>FrameworkServlet</code> : final initServletBean -&gt; initWebApplicationContext -&gt; onRefresh; service -&gt; abstract doService<ul>
<li><code>DispatchServlet</code> : onRefresh -&gt; initStrategies; doService -&gt; doDispatch</li>
</ul>
</li>
</ul>
</li>
<li><p><code>DispatchServlet</code></p>
<ul>
<li>init:<pre><code class="lang-java">  HttpServlet.init(ServletConfig)
  -&gt; final HttpServletBean.init()
   -&gt; final FrameworkServlet.initServletBean()
    -&gt; protected FrameworkServlet.initWebApplicationContext()
      -&gt; protected DispatcherServlet.onRefresh(wac)
       -&gt; protected DispatcherServlet.initStrategies(wac)
          {    
              // 初始化 DispatcherServlet 各种组件
              initMultipartResolver
              initLocaleResolver
              initThemeResolver
              initHandlerMappings
              initHandlerAdapters
              initHandlerExceptionResolvers
              initRequestToViewNameTranslator
              initViewResolvers
              initFlashMapManager
          }
</code></pre>
</li>
<li>Service:<pre><code class="lang-java">  public HttpServlet.service(ServletRequest,ServletResponse) 
  -&gt; protected FrameworkServlet.service(HttpServletRequest,HttpServletResponse)
   -&gt; protected HttpServlet.service(HttpServletRequest,HttpServletResponse)
    -&gt; final FrameworkServlet.doGet/doPost/doPut/doDelete/doOptions/doTrace(req,resp)
     -&gt; abstract FrameworkServlet.doService(req,resp)
      -&gt; protected DispatchServlet.doService(req,resp)
       -&gt; protected DispatchServlet.doDispatch(req,resp)
           {
              HandlerExecutionChain mappedHandler = getHandler(processedRequest);
              HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
              ModelAndView mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
              processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);                    
           }
</code></pre>
</li>
</ul>
</li>
<li><p>Source Code：</p>
<pre><code class="lang-java">  abstract class HttpServletBean extends HttpServlet implements EnvironmentCapable, EnvironmentAware 
  {    
      @Override
      public final void init() throws ServletException {
          PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);
          BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);
          ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());
          bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));
          initBeanWrapper(bw); // protected func
          bw.setPropertyValues(pvs, true);
          initServletBean(); // protected func
      }
  }

  public abstract class FrameworkServlet extends HttpServletBean implements ApplicationContextAware 
  {
      public FrameworkServlet() {}
      public FrameworkServlet(WebApplicationContext webApplicationContext) {
          this.webApplicationContext = webApplicationContext;
      }

      @Override
      protected final void initServletBean() throws ServletException {
          this.webApplicationContext = initWebApplicationContext();
              =&gt;{
                  WebApplicationContext rootContext = WebApplicationContextUtils
                              .getWebApplicationContext(getServletContext());
                  WebApplicationContext wac = this.webApplicationContext;
                  wac!=null &amp;&amp; instanceof ConfigurableWebApplicationContext =&gt; wac.setParent(rootContext); 
                  configureAndRefreshWebApplicationContext(wac);
                  wac!=null =&gt; wac = findWebApplicationContext()
                  wac!=null =&gt; wac = createWebApplicationContext(rootContext)
                  if(!this.refreshEventReceived) 
                      onRefresh(wac); 
                          =&gt; {
                              // DispatchServlet#onRefresh: 
                              initStrategies(context);
                                  =&gt;{
                                      initMultipartResolver(context);
                                      initLocaleResolver(context);
                                      initThemeResolver(context);
                                      initHandlerMappings(context);
                                      initHandlerAdapters(context);
                                      initHandlerExceptionResolvers(context);
                                      initRequestToViewNameTranslator(context);
                                      initViewResolvers(context);
                                      initFlashMapManager(context);
                                  }
                          }
                  if (this.publishContext)
                      getServletContext().setAttribute(getServletContextAttributeName(), wac);
                  return wac;
              }
          initFrameworkServlet();
      }

      @Override
      protected void service(HttpServletRequest request, HttpServletResponse response)
              throws ServletException, IOException {
          HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());
          if (httpMethod == HttpMethod.PATCH || httpMethod == null) 
              processRequest(request, response);
          else
              super.service(request, response);
              =&gt; {
                  FrameworkServlet#doGet/doPost/doPut/doDelete/doOptions/doTrace 
                    =&gt; FrameworkServlet#processRequest(request,response)
              }
      }

      protected final void processRequest(HttpServletRequest request, HttpServletResponse response)
              throws ServletException, IOException {
          initContextHolders(request, localeContext, requestAttributes);
          doService(request, response);
          =&gt;{
              // DispatchServlet#doService:
              doDispatch(request, response);
              =&gt;{
                  HandlerExecutionChain mappedHandler = getHandler(processedRequest);
                  HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
                  ModelAndView mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
                  processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
              }
          }
          resetContextHolders(request, previousLocaleContext, previousAttributes);
          publishRequestHandledEvent(request, response, startTime, failureCause);
      }
  }
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="header-36">Servlet异步支持(3.0+)</h3>
<ol>
<li><p>技术：        </p>
<ul>
<li><code>DeferredResult</code> （spring-web)</li>
<li><code>Callable</code>            (java)</li>
<li><code>CompletionStage</code>    (java)</li>
</ul>
</li>
<li><p>示例：</p>
<pre><code class="lang-java"> package com.cj.demo.controller;

 @RestController
 public class HelloAsyncController {

     @GetMapping(&quot;/hello&quot;)
     public String hello() {
         return &quot;Hello!&quot;;
     }

     @GetMapping(&quot;/deffered&quot;)
     public DeferredResult&lt;String&gt; helloDeffered(){
         DeferredResult&lt;String&gt; result=new DeferredResult&lt;&gt;(50L);
         result.setResult(&quot;[DefferedResult] Hello world!&quot;);
         println(&quot;[DefferedResult] Hello world!&quot;);

         result.onCompletion(()-&gt;{
             println(&quot;[DefferedResult] execute complete&quot;);
         });
         result.onTimeout(()-&gt;{
             println(&quot;[DefferedResult] execute timeout&quot;);
         });
         return result;
     }

     @GetMapping(&quot;/callable&quot;)
     public Callable&lt;String&gt; helloCallable() {
         final long startTime = System.currentTimeMillis();
         println(&quot;[Callable] Hello world!&quot;);

         return () -&gt; {
             long costTime = System.currentTimeMillis() - startTime;
             println(&quot;[Callable] cost &quot; + costTime + &quot; ms.&quot;);
             return &quot;[Callable] Hello world!&quot;;
         };
     } 

     @GetMapping(&quot;/completionStage&quot;)
     public CompletionStage&lt;String&gt; helloCompletionStage() {
         final long startTime = System.currentTimeMillis();
         println(&quot;[CompletionStage] Hello world!&quot;);

         return CompletableFuture.supplyAsync(() -&gt; {
             long costTime = System.currentTimeMillis() - startTime;
             println(&quot;[CompletionStage] cost &quot; + costTime + &quot; ms.&quot;);
             return &quot;[CompletionStage] Hello world!&quot;;
         });
     }

     private static void println(Object object) {
         String threadName = Thread.currentThread().getName();
         System.out.println(&quot;HelloAsyncController[&quot; + threadName + &quot;]: &quot; + object);
     }
 }
</code></pre>
<ul>
<li>visit：<code>/deffered</code>,<code>/callable</code>,<code>/completionStage</code></li>
</ul>
</li>
</ol>
<h2 id="header-37">WebMVC</h2>
<p><img src="/2018/09/15/webmvc.png" alt="webmvc"></p>
<ol>
<li><p>核心组件 (jar:<code>spring-webmvc</code>)</p>
<table class="table">
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">组件</th>
<th style="text-align:left">主要方法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><code>DispatcherServlet</code></td>
<td style="text-align:left">doService,doDispatch</td>
<td style="text-align:left">总控 HttpServlet#service -&gt; FrameworkServlet#service -&gt; DispatcherServlet#doService -&gt; DispatcherServlet#doDispatch</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><code>MultipartResolver</code></td>
<td style="text-align:left">resolveMultipart -&gt; MultipartHttpServletRequest</td>
<td style="text-align:left">解析多部分请求（如: 文件上传），封装Request为<code>MultipartHttpServletRequest</code>对象</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><code>HandlerMapping</code></td>
<td style="text-align:left">getHandler -&gt; HandlerExecutionChain(Handler+Interceptors)</td>
<td style="text-align:left">mapping <code>Request</code>:<code>Handler (+HandlerInterceptors)</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">eg: <code>RequestMappingHandlerMapping</code>支持标注<code>@RequestMapping</code>的<code>method</code></td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><code>HandlerAdapter</code></td>
<td style="text-align:left">handle -&gt; ModelAndView(modelMap+viewName)</td>
<td style="text-align:left">invoke <code>Handler</code> -&gt; resolveArgument + doInvoke + handleReturnValue -&gt; <code>ModelAndView(modelMap+viewName)</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">eg: 1. <code>RequestMappingHandlerAdapter</code>支持标注<code>@RequestMapping</code>的<code>method</code> invoke and handle</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">eg: 2. <code>RequestResponseBodyMethodProcessor</code>(implements <code>HandlerMethodArgumentResolver</code>)支持标注<code>@RequestBody</code>的<code>method</code>的arguments resolve</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">eg: 3. <code>RequestResponseBodyMethodProcessor</code>(implements <code>HandlerMethodReturnValueHandler</code>)支持标注<code>@ResponseBody</code>的<code>method</code>的returnValue handle</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><code>HandlerExceptionResolver</code></td>
<td style="text-align:left">resolveException -&gt; ModelAndView</td>
<td style="text-align:left">处理以上发生的异常，返回一个<code>ModelAndView</code>对象供后续渲染处理</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><code>LocaleResolver</code></td>
<td style="text-align:left">resolveLocale -&gt; Locale</td>
<td style="text-align:left">从Request中解析出本地化对象<code>Locale</code> 供后面解析View及View的渲染使用，实现国际化</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><code>ViewResolver</code></td>
<td style="text-align:left">resolveViewName -&gt; View</td>
<td style="text-align:left">根据<code>ModelAndView#viewName</code> + <code>Locale</code> 解析得到最佳 <code>View</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">eg: ContentNegotiatingViewResolver</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">eg: InternalResourceViewResolver</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">eg: ThymeleafViewResolver</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><code>View</code></td>
<td style="text-align:left">render</td>
<td style="text-align:left">渲染视图(ctx: <code>ModelAndView#modelMap</code>)，得到最终效果供Response</td>
</tr>
</tbody>
</table>
</li>
<li><p>常用注解 (jar: <code>spring-web</code>: <code>org.springframework.web.bind.annotation</code>)</p>
<ul>
<li>控制器:<ul>
<li><code>@Controller</code></li>
<li><code>@RestController</code> = <code>@Controller</code>+<code>@ResponseBody</code></li>
</ul>
</li>
<li>映射:<ul>
<li><code>@RequestMapping</code></li>
<li><code>@GetMapping</code>,<code>@PostMapping</code>,<code>@PutMapping</code>,<code>@DeleteMapping</code>,<code>@PatchMapping</code></li>
</ul>
</li>
<li>请求:<ul>
<li><code>@RequestParam</code></li>
<li><code>@PathVariable</code></li>
<li><code>@CookieValue</code></li>
<li><code>@RequestPart</code></li>
<li><code>@RequestHeader</code></li>
<li><code>@RequestBody</code></li>
</ul>
</li>
<li>响应:<ul>
<li><code>@ResponseBody</code></li>
</ul>
</li>
<li>拦截（切面通知／处理）:<ul>
<li><code>@ControllerAdvice</code></li>
<li><code>@RestControllerAdvice</code></li>
<li><code>@ExceptionHandler</code></li>
</ul>
</li>
<li>属性: <ul>
<li><code>@ModelAttribute</code></li>
<li><code>@RequestAttribute</code></li>
<li><code>@SessionAttribute</code></li>
</ul>
</li>
<li>跨域:<ul>
<li><code>@CrossOrigin</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<ol>
<li><p>视图处理</p>
<ul>
<li>视图解析 <code>ViewResolver#resolveViewName</code> -&gt; <code>View</code><ul>
<li>Order</li>
<li>return Matched View</li>
<li>Resource Location</li>
</ul>
</li>
<li>视图渲染 <code>View#render</code><ul>
<li>Context</li>
<li>TemplateEngine</li>
</ul>
</li>
</ul>
</li>
<li><p>内容协商处理</p>
<ul>
<li>解析器 <code>ContentNegotiatingViewResolver</code> (resolveViewName)</li>
<li>工厂 <code>ContentNegotiationManagerFactoryBean</code>（构建ContentNegotiationManager）</li>
<li>管理器 <code>ContentNegotiationManager</code>（管理ContentNegotiationStrategy）</li>
<li>策略 <code>ContentNegotiationStrategy</code> (resolveMediaTypes)</li>
<li>配置 <code>ContentNegotiationConfigurer</code></li>
</ul>
</li>
<li><p>框架：</p>
<ul>
<li><code>Spring WebMvc</code><ul>
<li>WebMvc总控DispatcherServlet注册: <code>web.xml</code> / <code>WebApplicationInitializer</code></li>
<li>WebMvc其他组件配置：<code>.xml</code> / <code>@Configuration</code> </li>
<li>独立Servlet容器启动运行</li>
</ul>
</li>
<li><code>SpringBoot WebMvc</code>(依赖<code>SpringWebMvc</code>，只是增加了自动化装配和配置部分)<ul>
<li>自动装配 <code>@EnableAutoConfiguration</code> : <ul>
<li>DispatcherServletAutoConfiguration: 装配WebMvc总控DispatcherServlet</li>
<li>ServletWebServerFactoryAutoConfiguration: 装配Servlet容器</li>
<li>WebMvcAutoConfiguration: 装配WebMvc其他组件</li>
</ul>
</li>
<li>配置: 自定义配置类装配 / 外部化配置<ul>
<li>自定义类 <code>@Configuration</code>(可implements <code>WebMvcConfigurer</code>方便添加其他配置)+<code>@Bean</code></li>
<li>外部化配置 <code>WebMvcProperties</code> : <code>spring.mvc.xxx</code> (eg: resources/application.properties)</li>
</ul>
</li>
<li>独立／嵌入式Servlet容器启动运行</li>
</ul>
</li>
<li>示例：参考上章 Servlet的例子<ul>
<li>Spring: Xml 方式</li>
<li>Spring: Annotation方式</li>
<li>SpringBoot: Auto config</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="header-38">模版视图之JSP</h3>
<p>Key:</p>
<ul>
<li>视图解析器：<code>InternalResourceViewResolver</code></li>
<li>视图：<code>JstlView</code></li>
<li>外部化配置：<code>WebMvcProperties</code></li>
</ul>
<p><strong> 示例(SpringBoot WebMvc)：</strong></p>
<ol>
<li><p>pom.xml</p>
<pre><code class="lang-xml"> &lt;dependencies&gt;
     &lt;dependency&gt;
         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
         &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
     &lt;/dependency&gt;
     &lt;!-- jstl --&gt;
     &lt;dependency&gt;
         &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
         &lt;artifactId&gt;jstl&lt;/artifactId&gt;
     &lt;/dependency&gt;
     &lt;!-- 对jsp的支持的依赖 --&gt;
     &lt;dependency&gt;
         &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
         &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;
         &lt;scope&gt;provided&lt;/scope&gt;
     &lt;/dependency&gt;
 &lt;/dependencies&gt;
</code></pre>
</li>
<li><p>JSP Template：src/main/webapp/WEB-INF/jsp/hello.jsp</p>
<pre><code class="lang-xml"> &lt;!-- 使用jsp指令生成xml格式的文件: --&gt;
 &lt;jsp:root 
     xmlns:jsp=&quot;http://java.sun.com/JSP/Page&quot; 
     xmlns:c=&quot;http://java.sun.com/jsp/jstl/core&quot;
     version=&quot;2.0&quot;&gt;
     &lt;jsp:directive.page isELIgnored=&quot;false&quot;/&gt;
     &lt;Hello&gt;
         &lt;message&gt;${message}&lt;/message&gt;
         &lt;language&gt;${acceptLanguage}&lt;/language&gt;
         &lt;jsessionId&gt;${jsessionId}&lt;/jsessionId&gt;
         &lt;users&gt;
         &lt;c:forEach items=&quot;${users}&quot;  var=&quot;u&quot;&gt;
           &lt;user&gt;${u}&lt;/user&gt;
         &lt;/c:forEach&gt;
         &lt;/users&gt;
     &lt;/Hello&gt;
 &lt;/jsp:root&gt;
</code></pre>
</li>
<li><p>Configure: resources/application.properties</p>
<ul>
<li>方式一：自定义配置类<pre><code class="lang-java">  @Configuration
  public class WebMvcConfig {
      /*
       &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
          &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;
          &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
          &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
       &lt;/bean&gt;
       */
      @Bean
      public ViewResolver viewResolver(){
          InternalResourceViewResolver viewResolver=new InternalResourceViewResolver();
          viewResolver.setViewClass(JstlView.class);
          viewResolver.setPrefix(&quot;/WEB-INF/jsp/&quot;);
          viewResolver.setSuffix(&quot;.jsp&quot;);
          return viewResolver;
      }
  }
</code></pre>
</li>
<li>方式二：外部化配置(eg: resources/application.properties)<pre><code>  spring.mvc.view.prefix = /WEB-INF/jsp/
  spring.mvc.view.suffix = .jsp
</code></pre></li>
</ul>
</li>
<li><p>Controller: </p>
<ul>
<li>方式一：直接使用<code>Model#addAttribute</code><pre><code class="lang-java">  @Controller
  public class HelloController {
      @RequestMapping(value={&quot;/&quot;},method=RequestMethod.GET)
      public String index(@RequestHeader(&quot;Accept-Language&quot;) String acceptLanguage
              ,@CookieValue(&quot;JSESSIONID&quot;) String jsessionId
              ,Model model) {
          List&lt;String&gt; users=new ArrayList&lt;String&gt;();
          users.add(&quot;Tom&quot;);
          users.add(&quot;Susan&quot;);
          users.add(&quot;Jack&quot;);
          model.addAttribute(&quot;users&quot;, users);
          model.addAttribute(&quot;message&quot;, &quot;Where are you?&quot;);
          model.addAttribute(&quot;acceptLanguage&quot;,acceptLanguage);
          model.addAttribute(&quot;jsessionId&quot;,jsessionId);
          System.out.println(model);
          return &quot;index&quot;;
      }
  }
</code></pre>
</li>
<li>方式二：使用<code>@ModelAttribute</code><pre><code class="lang-java">  @Controller
  public class HelloController {
      @RequestMapping(value={&quot;/&quot;},method=RequestMethod.GET)
      public String index(Model model){
          List&lt;String&gt; users=new ArrayList&lt;String&gt;();
          users.add(&quot;Tom&quot;);
          users.add(&quot;Susan&quot;);
          users.add(&quot;Jack&quot;);
          model.addAttribute(&quot;users&quot;, users);
          return &quot;index&quot;;
      }
      @ModelAttribute(&quot;message&quot;)
      public String message(){
          return &quot;Where are you?&quot;;
      }
      @ModelAttribute(&quot;acceptLanguage&quot;)
      public String acceptLanguage(@RequestHeader(&quot;Accept-Language&quot;) String acceptLanguage){
          return acceptLanguage;
      }
      @ModelAttribute(&quot;jsessionId&quot;)
      public String jsessionId(@CookieValue(&quot;JSESSIONID&quot;) String jsessionId){
          return jsessionId;
      }
  }
</code></pre>
</li>
<li>方式三：使用<code>@ControllerAdvice</code><pre><code class="lang-java">  @Controller
  public class HelloController {
      @RequestMapping(value={&quot;/&quot;},method=RequestMethod.GET)
      public String index(Model model){
          return &quot;index&quot;;
      }
      @RequestMapping(value=&quot;/{num}&quot;,method=RequestMethod.GET)
      public String doExTest(@PathVariable int num,Model model){
          model.addAttribute(&quot;message&quot;,&quot;number:&quot;+num);
          return &quot;index&quot;;
      }
  }
  @ControllerAdvice(assignableTypes=HelloController.class)
  public class HelloControllerAdvice {
      @ModelAttribute(&quot;message&quot;)
      public String message(){
          return &quot;Where are you?&quot;;
      }
      @ModelAttribute(&quot;acceptLanguage&quot;)
      public String acceptLanguage(@RequestHeader(&quot;Accept-Language&quot;) String acceptLanguage){
          return acceptLanguage;
      }
      @ModelAttribute(&quot;jsessionId&quot;)
      public String jsessionId(@CookieValue(&quot;JSESSIONID&quot;) String jsessionId){
          return jsessionId;
      }
      @ExceptionHandler(Throwable.class)
      public ResponseEntity&lt;String&gt; onException(Throwable ex){
          return ResponseEntity.ok(&quot;handle exception:&quot;+ex.getMessage());
      }
  }
</code></pre>
</li>
</ul>
</li>
<li><p>Main</p>
<pre><code class="lang-java"> @SpringBootApplication
 public class WebMvcViewApp {
     public static void main(String[] args) {
         SpringApplication.run(WebMvcViewApp.class,args);
     }
 }
</code></pre>
</li>
<li><p>Visit: <code>http://localhost:8080/</code></p>
<pre><code class="lang-xml"> &lt;Hello&gt;
     &lt;message&gt;Where are you?&lt;/message&gt;
     &lt;language&gt;zh-CN,zh;q=0.9,en;q=0.8&lt;/language&gt;
     &lt;jsessionId&gt;node08vobe92o7xci1sb3hf7pn3dm56.node0&lt;/jsessionId&gt;
     &lt;users&gt;
         &lt;user&gt;Tom&lt;/user&gt;
         &lt;user&gt;Susan&lt;/user&gt;
         &lt;user&gt;Jack&lt;/user&gt;
     &lt;/users&gt;
 &lt;/Hello&gt;
</code></pre>
</li>
</ol>
<h3 id="header-39">模版视图之Thymeleaf</h3>
<p>Key:</p>
<ul>
<li>视图解析器ViewResolver：<code>ThymeleafViewResolver</code></li>
<li>视图View：<code>ThymeleaflView</code></li>
<li>模板引擎ITemplateEngine : <code>SpringTemplateEngine</code>/<code>SpringWebFluxTemplateEngine</code></li>
<li>外部化配置：<code>ThymeleafProperties</code></li>
</ul>
<p><strong> 示例(SpringBoot WebMvc)：</strong></p>
<ol>
<li><p>pom.xml</p>
<pre><code class="lang-xml"> &lt;dependency&gt;
       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
       &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
     &lt;/dependency&gt;
     &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
     &lt;/dependency&gt;
</code></pre>
</li>
<li><p>Thymeleaf Template: resources/templates/thymeleaf/hello.html</p>
<pre><code class="lang-html"> &lt;p th:text=&quot;${message}&quot;&gt;!!!&lt;/p&gt;
</code></pre>
</li>
<li><p>Configure: resources/application.properties</p>
<pre><code> # ThymeleafProperties
 spring.thymeleaf.prefix=classpath:/templates/thymeleaf/
 spring.thymeleaf.suffix=.html
 spring.thymeleaf.cache = false
</code></pre></li>
<li><p>Controller</p>
<pre><code class="lang-java"> @Controller
 public class HelloController {
     @GetMapping(&quot;/hello&quot;)
     public String hello() {
         model.addAttribute(&quot;message&quot;, &quot;Hello World&quot;);
         return &quot;hello&quot;;
     }
 }
</code></pre>
</li>
<li><p>Main</p>
<pre><code class="lang-java"> @SpringBootApplication
 public class WebMvcViewApp {
     public static void main(String[] args) {
         SpringApplication.run(WebMvcViewApp.class,args);
     }
 }
</code></pre>
</li>
<li><p>Visit: <code>http://localhost:8080/hello</code></p>
</li>
</ol>
<p><strong> Thymeleaf模版处理流程: </strong></p>
<p><a href="https://www.thymeleaf.org/">官网</a> | <a href="https://www.thymeleaf.org/documentation.html">Doc</a> | <a href="https://www.thymeleaf.org/doc/articles/standarddialect5minutes.html">Quict Start</a></p>
<ol>
<li><p>资源定位（模板来源 ）:</p>
<ul>
<li>文件资源： File</li>
<li>ClassPath资源： ClassLoader</li>
<li>统一资源： URL</li>
<li>Web资源： ServletContext</li>
<li>Spring 资源： ResourceLoader &amp; Resource</li>
</ul>
</li>
<li><p>渲染上下文（变量来源 ）: </p>
<ul>
<li>Spring Web MVC: <code>Model</code></li>
<li>Servlet: <code>Attribute</code></li>
<li>Thyemeaf: <code>Context</code></li>
</ul>
</li>
<li><p>模板引擎（模板渲染）</p>
<ul>
<li>Thymeleaf模板引擎：<code>interface ITemplateEngine</code><ul>
<li>Thymeleaf 原生实现: TemplateEngine</li>
<li>Spring 实现: SpringTemplateEngine</li>
<li>Spring WebFlux 实现: SpringWebFluxTemplateEngine</li>
</ul>
</li>
</ul>
</li>
<li><p>示例：使用 Thymeleaf API 渲染内容</p>
<pre><code class="lang-java"> public class ThymeleafTemplateEngineStarter {
     public static void main(String[] args) throws IOException {
         // 1. 资源定位，获取模板内容
         //String content = &quot;&lt;p th:text=\&quot;${message}\&quot;&gt;!!!&lt;/p&gt;&quot;;

         // 从 classpath:/templates/thymeleaf/hello.html 读取内容
         ResourceLoader resourceLoader = new DefaultResourceLoader();
         Resource resource = resourceLoader.getResource(&quot;classpath:/templates/thymeleaf/hello.html&quot;);
         File templateFile = resource.getFile();
         FileInputStream inputStream = new FileInputStream(templateFile);
         ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
         IOUtils.copy(inputStream, outputStream);
         inputStream.close();
         String content = outputStream.toString(&quot;UTF-8&quot;);

         // 2. 创建渲染上下文
         Context context = new Context();
         context.setVariable(&quot;message&quot;, &quot;Hello,World&quot;);

         // 3. 使用模板引擎进行渲染
         SpringTemplateEngine templateEngine = new SpringTemplateEngine();
         String result = templateEngine.process(content, context);
         System.out.println(result);
     }
 }
</code></pre>
<p> resources/templates/thymeleaf/hello.html</p>
<pre><code class="lang-html"> &lt;p th:text=&quot;${message}&quot;&gt;!!!&lt;/p&gt;
</code></pre>
</li>
</ol>
<h3 id="header-40">多视图处理</h3>
<p><strong> 示例：多视图处理器并存</strong></p>
<ul>
<li>视图处理器：<ul>
<li>ContentNegotiatingViewResolver<ul>
<li>ThymeleafViewResolver</li>
<li>InternalResourceViewResolver</li>
</ul>
</li>
<li>ThymeleafViewResolver</li>
<li>InternalResourceViewResolver</li>
</ul>
</li>
<li>注意：<ul>
<li>ViewResolver Order</li>
<li>ViewResolver 模板资源查找 </li>
</ul>
</li>
<li><p>总结：</p>
<ul>
<li>按照ViewResolver Order，返回第一个可以resolve的View去render（eg：下面的两个Debug示例都只能有一个正确返回）</li>
<li>找不到Resource时就抛出异常</li>
</ul>
</li>
<li><p>pom.xml</p>
<pre><code class="lang-xml"> &lt;dependencies&gt;
     &lt;dependency&gt;
       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
       &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
     &lt;/dependency&gt;

     &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
     &lt;/dependency&gt;

     &lt;!-- jstl --&gt;
     &lt;dependency&gt;
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
      &lt;artifactId&gt;jstl&lt;/artifactId&gt;
     &lt;/dependency&gt;
     &lt;!-- 对jsp的支持的依赖 --&gt;
     &lt;dependency&gt;
       &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
       &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;
       &lt;scope&gt;provided&lt;/scope&gt;
     &lt;/dependency&gt;
 &lt;/dependencies&gt;

 &lt;build&gt;
     &lt;plugins&gt;
         &lt;plugin&gt;
             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
             &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
         &lt;/plugin&gt;
     &lt;/plugins&gt;
 &lt;/build&gt;
</code></pre>
</li>
<li><p>Template:</p>
<ul>
<li>thymeleaf: resources/templates/thymeleaf/hello.html<pre><code class="lang-html">  &lt;p th:text=&quot;${message}&quot;&gt;!!!&lt;/p&gt;
</code></pre>
</li>
<li>jsp: webapp/WEB-INF/jsp/index.jsp<pre><code class="lang-xml">  &lt;jsp:root 
  xmlns:jsp=&quot;http://java.sun.com/JSP/Page&quot; 
  xmlns:c=&quot;http://java.sun.com/jsp/jstl/core&quot;
  version=&quot;2.0&quot;&gt;
      &lt;jsp:directive.page isELIgnored=&quot;false&quot;/&gt;
      &lt;Hello&gt;
           &lt;message&gt;${message}&lt;/message&gt;
      &lt;/Hello&gt;
  &lt;/jsp:root&gt;
</code></pre>
</li>
</ul>
</li>
<li><p>configure: resources/application.properties：</p>
<pre><code> # ThymeleafProperties
 spring.thymeleaf.prefix=classpath:/templates/thymeleaf/
 spring.thymeleaf.suffix=.html
 spring.thymeleaf.cache = false

 # WebMvcProperties
 spring.mvc.view.prefix = /WEB-INF/jsp/
 spring.mvc.view.suffix = .jsp
</code></pre></li>
<li><p>Controller</p>
<pre><code class="lang-java"> @Controller
 public class HelloController {

     @GetMapping(&quot;/&quot;)
     public String index() {
         return &quot;index&quot;;
     }
     @GetMapping(&quot;/hello&quot;)
     public String hello() {
         return &quot;hello&quot;;
     }
     @ModelAttribute(&quot;message&quot;)
     public String message(){
         return &quot;Where are you?&quot;;
     }
 }
</code></pre>
</li>
<li><p>Main</p>
<pre><code class="lang-java"> @SpringBootApplication
 public class WebMvcViewApp {
     public static void main(String[] args) {
         SpringApplication.run(WebMvcViewApp.class,args);
     }
 }
</code></pre>
</li>
<li><p>默认ThymeleafViewResolver的Order在InternalResourceViewResolver之前</p>
<ul>
<li>Debug得到：<ul>
<li>Ordered ViewResolver List:<ul>
<li>ContentNegotiatingViewResolver<ul>
<li>BeanNameViewResolver</li>
<li>ThymeleafViewResolver</li>
<li>ViewResolverComposite</li>
<li>InternalResourceViewResolver</li>
</ul>
</li>
<li>BeanNameViewResolver</li>
<li>ThymeleafViewResolver</li>
<li>ViewResolverComposite</li>
<li>InternalResourceViewResolver</li>
</ul>
</li>
<li>Verify: <ul>
<li>Visit: <a href="http://localhost:8080/">http://localhost:8080/</a>    =&gt; Error(500:Error resolving template &quot;index&quot;, template might not exist or might not be accessible by any of the configured Template Resolvers)</li>
<li>Visit: <a href="http://localhost:8080/hello">http://localhost:8080/hello</a> =&gt; Success </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>将InternalResourceViewResolver(JstlView)顺序提到ThymeleafViewResolver(ThymeleafView)之前</p>
<ul>
<li><p>注释掉resources/application.properties中<code>WebMvcProperties</code>相关的配置</p>
<pre><code class="lang-properties">  # ThymeleafProperties
  spring.thymeleaf.prefix=classpath:/templates/thymeleaf/
  spring.thymeleaf.suffix=.html
  spring.thymeleaf.cache = false

  # WebMvcProperties
  # spring.mvc.view.prefix = /WEB-INF/jsp/
  # spring.mvc.view.suffix = .jsp
</code></pre>
</li>
<li>自定义一个Configuration类，装载新配置的InternalResourceViewResolver<pre><code class="lang-java">  @Configuration
  public class WebMvcConfig {
      @Bean
      public InternalResourceViewResolver viewResolver() {
          InternalResourceViewResolver viewResolver=new InternalResourceViewResolver();
          viewResolver.setPrefix(&quot;/WEB-INF/jsp/&quot;);
          viewResolver.setSuffix(&quot;.jsp&quot;);
          // ThymeleafAutoConfiguration: ThymeleafViewResolver Ordered.LOWEST_PRECEDENCE - 5
          viewResolver.setOrder(Ordered.LOWEST_PRECEDENCE-10);
          return viewResolver;
      } 
  }
</code></pre>
</li>
<li>Debug得到:<ul>
<li>Ordered ViewResolver List:<ul>
<li>InternalResourceViewResolver</li>
<li>BeanNameViewResolver</li>
<li>ViewResolverComposite</li>
<li>ThymeleafViewResolver</li>
</ul>
</li>
<li>Verify: <ul>
<li>Visit: <a href="http://localhost:8080/">http://localhost:8080/</a>    =&gt; Success</li>
<li>Visit: <a href="http://localhost:8080/hello">http://localhost:8080/hello</a> =&gt; Error(404)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>由于WebMvcProperties不提供order配置，所以无法通过外部化配置修改ViewResolver的顺序</li>
<li><p>由于上面使用了<code>public InternalResourceViewResolver viewResolver()</code>装载了一个name为<code>viewResolver</code>,class为<code>InternalResourceViewResolver</code>的Bean，所以就不会再装载<code>ContentNegotiatingViewResolver</code>和默认的<code>InternalResourceViewResolver</code>了（具体可参考<code>WebMvcAutoConfiguration</code>中的相关配置）</p>
<pre><code class="lang-java">  @Configuration
  @ConditionalOnWebApplication(type = Type.SERVLET)
  @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })
  @ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
  @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
  @AutoConfigureAfter({ DispatcherServletAutoConfiguration.class,
          ValidationAutoConfiguration.class })
  public class WebMvcAutoConfiguration {
      // ...

      @Configuration
      @Import(EnableWebMvcConfiguration.class)
      @EnableConfigurationProperties({ WebMvcProperties.class, ResourceProperties.class })
      @Order(0)
      public static class WebMvcAutoConfigurationAdapter
              implements WebMvcConfigurer, ResourceLoaderAware {
          // ... 

          @Bean
          @ConditionalOnMissingBean
          public InternalResourceViewResolver defaultViewResolver() {
              InternalResourceViewResolver resolver = new InternalResourceViewResolver();
              resolver.setPrefix(this.mvcProperties.getView().getPrefix());
              resolver.setSuffix(this.mvcProperties.getView().getSuffix());
              return resolver;
          }

          @Bean
          @ConditionalOnBean(ViewResolver.class)
          @ConditionalOnMissingBean(name = &quot;viewResolver&quot;, value = ContentNegotiatingViewResolver.class)
          public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) {
              ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver();
              resolver.setContentNegotiationManager(
                      beanFactory.getBean(ContentNegotiationManager.class));
              // ContentNegotiatingViewResolver uses all the other view resolvers to locate
              // a view so it should have a high precedence
              resolver.setOrder(Ordered.HIGHEST_PRECEDENCE);
              return resolver;
          }
      }
  }
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="header-41">内容协商视图解析器</h3>
<p><code>ContentNegotiatingViewResolver</code> (implements <code>ViewResolver</code>):</p>
<ol>
<li>优先级：最高（order=Ordered.HIGHEST_PRECEDENCE）</li>
<li>成员：<ul>
<li>包含<code>List&lt;ViewResolver&gt;</code>列表: 会包含除自己以外的所有装载的<code>ViewResolver</code>（按顺序）</li>
<li>包含内容协商管理工厂<code>ContentNegotiationManagerFactoryBean</code>: 生成内容协商管理器<code>ContentNegotiationManager</code></li>
<li>包含内容协商管理器<code>ContentNegotiationManager</code>: 管理内容协商策略<code>List&lt;ContentNegotiationStrategy&gt;</code>（用于获取HTTP Request的<code>MediaType</code>列表）</li>
</ul>
</li>
<li>方法：<ul>
<li><code>@Override resolveViewName-&gt;View</code><ul>
<li><code>getMediaTypes</code>： 获取与produce mediaType兼容的HTTP Request <code>MediaType</code>列表</li>
<li><code>getCandidateViews</code>： 获取所有可能的<code>View</code> (<code>ViewResolver#resolveViewName</code>视图解析得到的<code>View</code>)</li>
<li><code>getBestView</code>: 从上面获取的View中选取最佳匹配的<code>View</code><ul>
<li>HTTP Request <code>MediaType</code> &lt;-&gt; ViewResolver View <code>contentType</code> : 第一个匹配的那个View</li>
<li>注：<code>ViewResolver 顺序</code> 和 <code>Request的MediaType</code>匹配规则（Accept 头策略，请求参数策略，...）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>配置：<ul>
<li>自定义配置类：<code>@Configuration</code> + <code>implements WebMvcConfigurer</code> + <code>@Override configureContentNegotiation(ContentNegotiationConfigurer configurer)</code></li>
<li>外部化配置：<code>WebMvcProperties.Contentnegotiation</code></li>
</ul>
</li>
</ol>
<p><strong> 示例: 多视图处理器内容协商 </strong> </p>
<ol>
<li><p>上面Case，修改自定义配置类:</p>
<pre><code class="lang-java"> @Configuration
 public class WebMvcConfig {        
     // 1. 修改bean name为 myViewResolver
     // 不与ContentNegotiatingViewResolver装载条件冲突,则系统会自动加载ContentNegotiatingViewResolver
     // ContentNegotiatingViewResolver装载条件：
     // @ConditionalOnBean(ViewResolver.class)
     // @ConditionalOnMissingBean(name = &quot;viewResolver&quot;, value = ContentNegotiatingViewResolver.class)，
     // 2. set viewResolver content-type (to distinguish with other viewResolvers&#39;)
     @Bean
     public InternalResourceViewResolver myViewResolver() {
         InternalResourceViewResolver viewResolver=new InternalResourceViewResolver();
         viewResolver.setPrefix(&quot;/WEB-INF/jsp/&quot;);
         viewResolver.setSuffix(&quot;.jsp&quot;);
         // ThymeleafAutoConfiguration: ThymeleafViewResolver Ordered.LOWEST_PRECEDENCE - 5
         viewResolver.setOrder(Ordered.LOWEST_PRECEDENCE-10);
         // Set ViewResolver Content-Type
         viewResolver.setContentType(&quot;text/xml;charset=UTF-8&quot;);
         return viewResolver;
     } 
 }
</code></pre>
</li>
<li><p>配置：</p>
<ul>
<li>方式一： 外部化配置<pre><code>  # WebMvcProperties contentnegotiation
  # ?format=pdf
  spring.mvc.contentnegotiation.favorParameter = true
  # /users.pdf
  spring.mvc.contentnegotiation.favorPathExtension = true
</code></pre></li>
<li>方式二： 自定义Configuration类<pre><code class="lang-java">  @Configuration
  public class WebMvcConfig implements WebMvcConfigurer {
      //...
      @Override
      public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
          configurer.favorParameter(true)
                  .favorPathExtension(true);
      }
  }
</code></pre>
</li>
</ul>
</li>
<li><p>Debug得到：</p>
<ul>
<li>Ordered ViewResolver List:<ul>
<li>ContentNegotiatingViewResolver<ul>
<li>InternalResourceViewResolver ( Content-Type: text/xml;charset=UTF-8 )</li>
<li>BeanNameViewResolver</li>
<li>ThymeleafViewResolver ( Content-Type: text/html;charset=UTF-8 )</li>
<li>ViewResolverComposite</li>
</ul>
</li>
<li>InternalResourceViewResolver    </li>
<li>BeanNameViewResolver</li>
<li>ThymeleafViewResolver</li>
<li>ViewResolverComposite</li>
</ul>
</li>
<li>Verify:<ul>
<li><a href="http://localhost:8080/?format=xml">http://localhost:8080/?format=xml</a> =&gt; Success (InternalResourceViewResolver resolved,show jsp page)</li>
<li><a href="http://localhost:8080/">http://localhost:8080/</a>  Accept:text/xml =&gt; Success (match InternalResourceViewResolver resolved, show jsp page)</li>
<li><a href="http://localhost:8080/hello">http://localhost:8080/hello</a> =&gt; Success (ThymeleafViewResolver resolved, show thymeleaf page)</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="header-42">REST</h3>
<blockquote>
<p>REST = RESTful = Representational State Transfer,is one way of providing interoperability between computer systems on the Internet.</p>
</blockquote>
<ol>
<li><p>架构约束</p>
<ul>
<li>统一接口(Uniform interface) <ul>
<li>资源识别(Identification of resources)<ul>
<li>URI(Uniform Resource Identifier ) </li>
</ul>
</li>
<li>资源操作(Manipulation of resources through representations)<ul>
<li>HTTP verbs:GET、PUT、POST、DELETE </li>
</ul>
</li>
<li>自描述消息(Self-descriptive messages)<ul>
<li>Content-Type</li>
<li>MIME-Type</li>
<li>Media Type: application/javascript、text/html</li>
</ul>
</li>
<li>超媒体(HATEOAS)<ul>
<li>Hypermedia As The Engine Of Application State</li>
</ul>
</li>
</ul>
</li>
<li>C/S架构(Client-Server) </li>
<li>无状态(Stateless) </li>
<li>可缓存(Cacheable) </li>
<li>分层系统(Layered System) </li>
<li>按需代码(Code on demand)(可选)</li>
</ul>
</li>
<li><p>WebMvc Rest支持</p>
<ul>
<li>控制器：@Controller,@RestController (= @Controller+@ResponseBody)</li>
<li>映射：@RequestMapping,@XxxMapping(eg: @GetMapping,@PostMapping,@PutMapping,@DeleteMapping,@PatchMapping)</li>
<li>请求：@RequestParam,@PathVariable,@CookieValue,@RequestBody,@RequestHeader,RequestEntity(header+body)</li>
<li>响应：@ResponseBody,ResponseEntity(header+body),ResponseCookie</li>
<li>拦截：@ControllerAdvice,@RestControllerAdvice,interface HandlerInterceptor</li>
</ul>
</li>
<li><p>核心组件</p>
<ul>
<li><code>HandlerMethod</code>: 被<code>@RequestMapping/@XxxMapping</code>标注的方法 </li>
<li><code>RequestMappingHandlerMapping#getHandler</code>: 找到map <code>RequestMappingInfo</code>的<code>HandlerMethod</code><ul>
<li><code>RequestMappingInfo</code>: 存储解析出的@RequestMapping信息<ul>
<li>methods : @RequestMapping#method</li>
<li>params :  @RequestMapping#params</li>
<li>headers : @RequestMapping#headers</li>
<li>consumes : @RequestMapping#consumes 请求头 <code>Content-Type</code> 媒体类型映射</li>
<li>produces : @RequestMapping#produces  响应头 <code>Content-Type</code> 媒体类型映射 </li>
</ul>
</li>
</ul>
</li>
<li><code>RequestMappingHandlerAdapter#handle</code>: <code>HandlerMethod</code>的invoke and handle<ul>
<li><code>HandlerMethodArgumentResolver#resolveArgument</code> 处理方法参数解析器(解析HTTP请求内容为<code>HandlerMethod</code>的参数) <ul>
<li><code>RequestResponseBodyMethodProcessor</code>: 支持标注<code>@RequestBody</code>的<code>method</code>的arguments resolve<ul>
<li><code>HttpMessageConverter#read</code> : HTTP消息转换器，read: 反序列化HttpRequest</li>
</ul>
</li>
</ul>
</li>
<li><code>HandlerMethodReturnValueHandler#handleReturnValue</code> 处理方法返回值解析器(解析<code>HandlerMethod</code>返回值为HTTP响应内容)<ul>
<li><code>RequestResponseBodyMethodProcessor</code>: 支持标注<code>@ResponseBody</code>的<code>method</code>的returnValue handle<ul>
<li><code>ContentNegotiationManager#resolveMediaTypes</code> : 内容协商管理器，解析请求的媒体类型，返回合法的MediaTypes</li>
<li><code>HttpMessageConverter#write</code> : HTTP消息转换器，write: 序列化HttpResponse</li>
<li>注：ModelAndViewContainer#setRequestHandled:true -&gt; ModelAndView null -&gt; no viewResolver#resolveViewName and View#render call !</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>MediaType 媒体类型</p>
<ul>
<li>请求的媒体类型: <code>ContentNegotiationManager#resolveMediaTypes</code><ul>
<li>解析出HTTP Request中的媒体类型 (eg: <code>text/html</code>,<code>application/json</code>)</li>
<li>使用<code>ContentNegotiationStrategy#resolveMediaTypes</code>，有各种解析策略，例如：<ul>
<li>固定 MediaType : FixedContentNegotiationStrategy </li>
<li>&quot;Accept&quot; 请求头: HeaderContentNegotiationStrategy </li>
<li>请求参数: ParameterContentNegotiationStrategy </li>
<li>路径扩展名: PathExtensionContentNegotiationStrategy</li>
</ul>
</li>
<li>解析成功,返回合法 MediaType 列表</li>
<li>解析失败,返回单元素 <code>MediaType.ALL</code>(<code>*/*</code>) 媒体类型列表</li>
</ul>
</li>
<li>可消费的媒体类型: <code>@RequestMapping#consumes</code><ul>
<li>请求头 <code>Content-Type</code>的媒体类型</li>
<li>若请求头中的<code>Content-Type</code>和consumes中配置的不兼容，则该HandlerMethod不会被匹配到执行</li>
</ul>
</li>
<li>可生成的媒体类型: <code>@RequestMapping#produces</code>: <ul>
<li>响应头 <code>Content-Type</code> 的媒体类型</li>
<li>若配置了，则使用配置的MediaType列表</li>
<li>若未配置，则使用已注册的 HttpMessageConverter列表支持的MediaType列表</li>
<li>可用来匹配支持的<code>HttpMessageConverter</code>以序列化生成响应内容和生成响应头的<code>Content-Type</code>内容<ul>
<li>找到与请求的媒体类型兼容的MediaType列表，使用第一个匹配支持的HttpMessageConverter进行序列化，生成响应内容；</li>
<li>若未找到匹配的，则抛出415 HttpMediaTypeNotAcceptableException；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong> 示例：REST </strong></p>
<ol>
<li>pom.xml<pre><code class="lang-xml"> &lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
 &lt;/dependency&gt;
</code></pre>
</li>
<li><p>Controller</p>
<pre><code class="lang-java"> @RestController
 public class UserController {

     @GetMapping(value=&quot;/say&quot;)
     public String say(@RequestParam(required = false) String message) {
         return &quot;Say:&quot; + message;
     }

     @GetMapping(value=&quot;/saylimit&quot;,consumes=&quot;application/json&quot;,produces=&quot;text/html;charset=UTF-8&quot;)
     public String saylimit(@RequestParam(required = false) String message) {
         return &quot;Saylimit:&quot; + message;
     }

     @GetMapping(&quot;/users&quot;)
     public Object listUsers() {
         List&lt;User&gt; users=new ArrayList&lt;User&gt;();
         users.add(new User(1,&quot;Tom&quot;));
         users.add(new User(2,&quot;Lucy&quot;));
         users.add(new User(3,&quot;Jack&quot;));
         return users;
     }

     @PostMapping(&quot;/users&quot;)
     public Object addUser(@RequestBody User user) {
         System.out.println(&quot;addUser:&quot;+user);
         return user;
     }
 }
</code></pre>
</li>
<li>main<pre><code class="lang-java"> @SpringBootApplication
 public class WebMvcRestApp {
     public static void main( String[] args ){
         SpringApplication.run(WebMvcRestApp.class, args);
     }
 }
</code></pre>
</li>
<li><p>Verify</p>
<ul>
<li><p>Get <code>/say?message=123</code></p>
<pre><code class="lang-bash">  $ curl -i http://localhost:8080/say?message=123
  HTTP/1.1 200
  Content-Type: text/plain;charset=UTF-8
  Content-Length: 7
  Date: Thu, 13 Dec 2018 07:43:44 GMT

  Say:123

  $ curl -i -H &quot;Content-Type:application/json&quot; http://localhost:8080/say?message=123

  HTTP/1.1 200
  Content-Type: text/plain;charset=UTF-8
  Content-Length: 7
  Date: Thu, 13 Dec 2018 08:44:02 GMT

  Say:123
</code></pre>
</li>
<li><p>Get <code>/saylimit?message=123</code></p>
<pre><code class="lang-bash">  $ curl -i http://localhost:8080/saylimit?message=123
  HTTP/1.1 415
  Content-Type: application/json;charset=UTF-8
  Transfer-Encoding: chunked
  Date: Thu, 13 Dec 2018 08:28:49 GMT

  {&quot;timestamp&quot;:&quot;2018-12-13T08:42:21.574+0000&quot;,&quot;status&quot;:415,&quot;error&quot;:&quot;Unsupported Media Type&quot;,&quot;message&quot;:&quot;Content type &#39;&#39; not supported&quot;,&quot;path&quot;:&quot;/saylimit&quot;}

  $ curl -i -H &quot;Content-Type:application/json&quot; http://localhost:8080/saylimit?message=123
  HTTP/1.1 200
  Content-Type: text/html;charset=UTF-8
  Content-Length: 12
  Date: Thu, 13 Dec 2018 08:43:05 GMT

  Saylimit:123
</code></pre>
</li>
<li><p>Get <code>/users</code></p>
<pre><code class="lang-bash">  $ curl -i http://localhost:8080/users
  HTTP/1.1 200
  Content-Type: application/json;charset=UTF-8
  Transfer-Encoding: chunked
  Date: Thu, 13 Dec 2018 07:45:47 GMT

  [{&quot;id&quot;:1,&quot;name&quot;:&quot;Tom&quot;},{&quot;id&quot;:2,&quot;name&quot;:&quot;Lucy&quot;},{&quot;id&quot;:3,&quot;name&quot;:&quot;Jack&quot;}]
</code></pre>
</li>
<li><p>Post <code>/users</code></p>
<pre><code class="lang-bash">  $ curl -i -X POST -d &quot;id=22&amp;name=Ketty&quot; http://localhost:8080/users
  HTTP/1.1 415
  Content-Type: application/json;charset=UTF-8
  Transfer-Encoding: chunked
  Date: Thu, 13 Dec 2018 07:47:13 GMT

  {&quot;timestamp&quot;:&quot;2018-12-13T07:47:13.352+0000&quot;,&quot;status&quot;:415,&quot;error&quot;:&quot;Unsupported Media Type&quot;,&quot;message&quot;:&quot;Content type &#39;application/x-www-form-urlencoded;charset=UTF-8&#39; not supported&quot;,&quot;path&quot;:&quot;/users&quot;}

  $ curl -i -X POST -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;id&quot;:22, &quot;name&quot;:&quot;Ketty&quot;}&#39; http://localhost:8080/users
  HTTP/1.1 200
  Content-Type: application/json;charset=UTF-8
  Transfer-Encoding: chunked
  Date: Thu, 13 Dec 2018 07:51:14 GMT

  {&quot;id&quot;:22,&quot;name&quot;:&quot;Ketty&quot;}
</code></pre>
</li>
</ul>
</li>
</ol>
<p><strong> 扩展示例：实现 <code>Content-Type</code> 为 <code>text/properties</code> 媒体类型的请求与响应，中间转换使用<code>Properties</code>对象 </strong></p>
<p>实现：</p>
<ul>
<li>方式一：依赖REST的<code>@RequestBody</code>和<code>@ResponseBody</code>(会使用<code>RequestResponseBodyMethodProcessor</code>-&gt;<code>HttpMessageConverter#read/write</code>)<ul>
<li>自定义<code>HttpMessageConverter</code>实现类来support <code>text/properties</code>媒体类型的 read &amp; write <ul>
<li>read: Request -&gt; Properties</li>
<li>write: Properties -&gt; Response</li>
</ul>
</li>
<li><code>@Configuration</code> + <code>implements WebMvcConfigurer</code>+ <code>@Override extendMessageConverters -&gt; converters#add/set</code></li>
</ul>
</li>
<li>方式二；不依赖REST的<code>@RequestBody</code>和<code>@ResponseBody</code><ul>
<li>自定义<code>HandlerMethodArgumentResolver</code>实现类，<code>@Override resolveArgument</code> 实现<code>text/properties</code> 媒体类型的请求解析为方法参数的<code>Properties</code>对象</li>
<li>自定义<code>HandlerMethodReturnValueHandler</code>实现类，<code>@Override handleReturnValue</code> 实现<code>Properties</code>类型方法返回值转化为<code>text/properties</code>媒体类型响应内容</li>
<li><code>@Configuration</code> + <code>implements WebMvcConfigurer</code>+ <code>@Override addArgumentResolvers</code> &amp; <code>@Override addReturnValueHandlers</code></li>
<li>注：上面自定义的实现类可复用上面自定义<code>HttpMessageConverter</code>实现类的<code>read/write</code>方法</li>
</ul>
</li>
</ul>
<p>示例（方式一）：    </p>
<ol>
<li><p>自定义HttpMessageConverter：        </p>
<pre><code class="lang-java"> public class PropertiesHttpMessageConverter extends AbstractGenericHttpMessageConverter&lt;Properties&gt;{

     public PropertiesHttpMessageConverter() {
         // 设置支持的 MediaType
         super(new MediaType(&quot;text&quot;, &quot;properties&quot;));
     }

     @Override
     public Properties read(Type type, Class&lt;?&gt; contextClass, HttpInputMessage inputMessage)
             throws IOException, HttpMessageNotReadableException {
         return readInternal(null, inputMessage);
     }

     @Override
     protected void writeInternal(Properties properties, Type type, HttpOutputMessage outputMessage)
             throws IOException, HttpMessageNotWritableException {

         MediaType mediaType = outputMessage.getHeaders().getContentType();
         Charset charset = mediaType.getCharset();
         charset = (charset == null) ? Charset.forName(&quot;UTF-8&quot;) : charset;
         Writer writer = new OutputStreamWriter(outputMessage.getBody(), charset);
         properties.store(writer,&quot;From PropertiesHttpMessageConverter&quot;);
     }

     @Override
     protected Properties readInternal(Class&lt;? extends Properties&gt; clazz, HttpInputMessage inputMessage)
             throws IOException, HttpMessageNotReadableException {

         MediaType mediaType = inputMessage.getHeaders().getContentType();
         Charset charset = mediaType.getCharset();
         charset = (charset == null) ? Charset.forName(&quot;UTF-8&quot;) : charset;
         InputStreamReader reader = new InputStreamReader(inputMessage.getBody(),charset);
         Properties properties = new Properties();
         properties.load(reader);
         return properties;
     }
 }
</code></pre>
</li>
<li>Configure: <code>WebMvcConfigurer#extendMessageConverters</code><pre><code class="lang-java"> @Configuration
 public class WebMvcConfig implements WebMvcConfigurer {    
     @Override
     public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {
         converters.add(new PropertiesHttpMessageConverter());
     }
 }
</code></pre>
</li>
<li><p>Controller</p>
<pre><code class="lang-java"> @RestController
 public class UserController {
     //...

     @PostMapping(value=&quot;/props&quot;,consumes = &quot;text/properties;charset=UTF-8&quot;)    // Content-Type 过滤媒体类型
     public Object addProp(@RequestBody Properties prop) {
         System.out.println(&quot;addProp:&quot;+prop);
         return prop;
     }
 }
</code></pre>
</li>
<li>main<pre><code class="lang-java"> @SpringBootApplication
 public class WebMvcRestApp {
     public static void main( String[] args ){
         SpringApplication.run(WebMvcRestApp.class, args);
     }
 }
</code></pre>
</li>
<li><p>Verify</p>
<pre><code class="lang-bash"> $ curl -i X POST -H &quot;Content-Type: text/properties&quot; -d &#39;id:22&#39; http://localhost:8080/props
 HTTP/1.1 200
 Content-Type: application/json;charset=UTF-8
 Transfer-Encoding: chunked
 Date: Thu, 13 Dec 2018 09:13:34 GMT

 {&quot;id&quot;:&quot;22&quot;}
</code></pre>
</li>
</ol>
<h3 id="header-43">跨域</h3>
<ul>
<li>注解驱动 <code>@CrossOrigin</code></li>
<li>代码驱动 <code>WebMvcConfigurer#addCorsMappings</code></li>
<li>过滤 <code>CorsFilter</code></li>
</ul>
<p><strong> 示例：</strong></p>
<ol>
<li><p>pom.xml</p>
<pre><code> &lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
 &lt;/dependency&gt;
 &lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
 &lt;/dependency&gt;
</code></pre></li>
<li><p>Controller</p>
<pre><code class="lang-java"> @Controller
 public class HelloController {
     @GetMapping(&quot;/&quot;)
     public String hello() {
         return &quot;index&quot;;
     }
 }

 @RestController
 public class UserController {

     //@CrossOrigin(&quot;*&quot;)
     @GetMapping(value=&quot;/say&quot;)
     public String say(@RequestParam(required = false) String message) {
         return &quot;Say:&quot; + message;
     }
 }
</code></pre>
</li>
<li><p>Configure</p>
<pre><code class="lang-java"> @Configuration
 public class WebMvcConfig implements WebMvcConfigurer {    
     public void addCorsMappings(CorsRegistry registry) {
         registry.addMapping(&quot;/**&quot;).allowedOrigins(&quot;*&quot;);
     }
 }
</code></pre>
</li>
<li><p>resources/templates/index.html</p>
<pre><code class="lang-html"> &lt;!DOCTYPE html&gt;
 &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
 &lt;head&gt;
     &lt;title&gt;CORS 示例&lt;/title&gt;
     &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;
     &lt;script src=&quot;https://code.jquery.com/jquery-3.3.1.min.js&quot; &gt;&lt;/script&gt;
 &lt;/head&gt;
 &lt;body&gt;
 &lt;div id=&quot;message&quot;&gt;&lt;/div&gt;
 &lt;/body&gt;
 &lt;script&gt;
 $(document).ready(function(){
      // Ajax 跨域 GET 请求
      $.get( &quot;http://api.rest.org:8080/say?message=Hello&quot;, function( data ) {
         alert( data );
         $( &quot;#message&quot; ).html( data );
      });
 });
 &lt;/script&gt;
 &lt;/html&gt;
</code></pre>
</li>
<li><p>Visit <a href="http://localhost:8080/">http://localhost:8080/</a></p>
</li>
</ol>
<h2 id="header-44">WebMVC 源码分析</h2>
<h3 id="header-45">SpringBoot自动装配</h3>
<p>Key：</p>
<ol>
<li>配置类：<ul>
<li>DispatcherServlet : <code>DispatcherServletAutoConfiguration</code></li>
<li>WebMvc : <code>WebMvcAutoConfiguration</code> (替换<code>@EnableWebMvc</code>)</li>
<li>Servlet容器 ： <code>ServletWebServerFactoryAutoConfiguration</code></li>
</ul>
</li>
<li>装载顺序：<ul>
<li>绝对顺序： <code>@AutoConfigureOrder</code></li>
<li>相对顺序： <code>@AutoConfigureAfter</code></li>
</ul>
</li>
<li>装配条件<ul>
<li>Web 类型判断 <code>@ConditionalOnWebApplication(type = Type.SERVLET)</code></li>
<li>API 判断 <code>@ConditionalOnClass</code></li>
<li>Bean 判断 <code>@ConditionalOnMissingBean</code>,<code>@ConditionalOnBean</code></li>
</ul>
</li>
<li>外部化配置<ul>
<li>Web MVC 配置: <code>WebMvcProperties</code></li>
<li>资源配置: <code>ResourceProperties</code></li>
</ul>
</li>
</ol>
<p><strong> 部分源码：</strong></p>
<ol>
<li><p>META-INF/spring.factories:(jar:spring-boot-autoconfig)</p>
<pre><code class="lang-xml"> # Auto Configure
 org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
 org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\
 org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\
 org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\
 #...
</code></pre>
</li>
<li><p><code>ServletWebServerFactoryAutoConfiguration</code>,<code>DispatcherServletAutoConfiguration</code>,<code>WebMvcAutoConfiguration</code> 配置类:</p>
<pre><code class="lang-java"> // Servlet容器 配置类
 @Configuration
 @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
 @ConditionalOnClass(ServletRequest.class)
 @ConditionalOnWebApplication(type = Type.SERVLET)
 @EnableConfigurationProperties(ServerProperties.class)
 @Import({ ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,
         ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,
         ServletWebServerFactoryConfiguration.EmbeddedJetty.class,
         ServletWebServerFactoryConfiguration.EmbeddedUndertow.class })
 public class ServletWebServerFactoryAutoConfiguration {
     //...
 }

 // DispatcherServlet 配置类
 @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
 @Configuration
 @ConditionalOnWebApplication(type = Type.SERVLET)
 @ConditionalOnClass(DispatcherServlet.class)
 @AutoConfigureAfter(ServletWebServerFactoryAutoConfiguration.class)
 @EnableConfigurationProperties(ServerProperties.class)
 public class DispatcherServletAutoConfiguration {
     //...
 }

 // WebMvc 配置类
 @Configuration
 @ConditionalOnWebApplication(type = Type.SERVLET)
 @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })
 @ConditionalOnMissingBean(WebMvcConfigurationSupport.class)        // 若已经有了WebMvcConfigurer.class则不会装载WebMvcAutoConfiguration
 @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
 @AutoConfigureAfter({ DispatcherServletAutoConfiguration.class,
         ValidationAutoConfiguration.class })
 public class WebMvcAutoConfiguration {
     //...
     @Configuration
     @Import(EnableWebMvcConfiguration.class)
     @EnableConfigurationProperties({ WebMvcProperties.class, ResourceProperties.class })
     @Order(0)
     public static class WebMvcAutoConfigurationAdapter
             implements WebMvcConfigurer, ResourceLoaderAware {
         //...
     }
 }
</code></pre>
</li>
<li><p>注：</p>
<ul>
<li>使用springboot自动装配，可不再使用<code>web.xml</code>配置</li>
<li><p><code>@EnableWebMvc</code>会装载<code>WebMvcConfigurationSupport</code>,所以使用了<code>@EnableWebMvc</code>后，<code>WebMvcAutoConfiguration</code>就不注入了（即WebMvc模块自动装载会失效)</p>
<pre><code class="lang-java">  // EnableWebMvc会装载Class：`WebMvcConfigurationSupport`
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.TYPE)
  @Documented
  @Import(DelegatingWebMvcConfiguration.class)
  public @interface EnableWebMvc {
  }

  @Configuration
  public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {
      //...
  }
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="header-46">装载ThymeleafViewResolver</h3>
<p>加入<code>spring-boot-starter-thymeleaf</code>依赖包后，SpringBoot会自动装载<code>ThymeleafViewResolver</code></p>
<p>部分源码：</p>
<ol>
<li><p><code>META-INF/spring.factories</code>(jar: spring-boot-autoconfig)</p>
<pre><code> # Auto Configure
 org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
 org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\
 #...

 # Template availability providers
 org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider=\
 org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\
 org.springframework.boot.autoconfigure.mustache.MustacheTemplateAvailabilityProvider,\
 org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAvailabilityProvider,\
 org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\
 org.springframework.boot.autoconfigure.web.servlet.JspTemplateAvailabilityProvider
</code></pre></li>
<li><p><code>ThymeleafAutoConfiguration</code></p>
<pre><code class="lang-java"> @Configuration
 @EnableConfigurationProperties(ThymeleafProperties.class)
 @ConditionalOnClass(TemplateMode.class)
 @AutoConfigureAfter({ WebMvcAutoConfiguration.class, WebFluxAutoConfiguration.class })
 public class ThymeleafAutoConfiguration {
     @Configuration
     @ConditionalOnMissingBean(name = &quot;defaultTemplateResolver&quot;)
     static class DefaultTemplateResolverConfiguration {
         // ...
     }

     @Configuration
     protected static class ThymeleafDefaultConfiguration {
         // ...
     }

     @Configuration
     @ConditionalOnWebApplication(type = Type.SERVLET)
     @ConditionalOnProperty(name = &quot;spring.thymeleaf.enabled&quot;, matchIfMissing = true)
     static class ThymeleafWebMvcConfiguration {
         // ...
         @Configuration
         static class ThymeleafViewResolverConfiguration {
             private final ThymeleafProperties properties;
             private final SpringTemplateEngine templateEngine;
             @Bean
             @ConditionalOnMissingBean(name = &quot;thymeleafViewResolver&quot;)
             public ThymeleafViewResolver thymeleafViewResolver() {
                 ThymeleafViewResolver resolver = new ThymeleafViewResolver();
                 resolver.setTemplateEngine(this.templateEngine);
                 resolver.setCharacterEncoding(this.properties.getEncoding().name());
                 resolver.setContentType(
                         appendCharset(this.properties.getServlet().getContentType(),
                                 resolver.getCharacterEncoding()));
                 resolver.setExcludedViewNames(this.properties.getExcludedViewNames());
                 resolver.setViewNames(this.properties.getViewNames());
                 // This resolver acts as a fallback resolver (e.g. like a
                 // InternalResourceViewResolver) so it needs to have low precedence
                 resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 5);
                 resolver.setCache(this.properties.isCache());
                 return resolver;
             }
             // ...
         }
     }

     @Configuration
     @ConditionalOnWebApplication(type = Type.REACTIVE)
     @ConditionalOnProperty(name = &quot;spring.thymeleaf.enabled&quot;, matchIfMissing = true)
     static class ThymeleafReactiveConfiguration {
         // ...
     }

     @Configuration
     @ConditionalOnWebApplication(type = Type.REACTIVE)
     @ConditionalOnProperty(name = &quot;spring.thymeleaf.enabled&quot;, matchIfMissing = true)
     static class ThymeleafWebFluxConfiguration {
         // ...
     }

     //...
 }
</code></pre>
</li>
<li><p>ConfigurationProperties: ThymeleafProperties</p>
<pre><code class="lang-java"> @ConfigurationProperties(prefix = &quot;spring.thymeleaf&quot;)
 public class ThymeleafProperties {

     private static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8;
     public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;;
     public static final String DEFAULT_SUFFIX = &quot;.html&quot;;
     private String prefix = DEFAULT_PREFIX;
     private String suffix = DEFAULT_SUFFIX;
     private boolean cache = true;
     //...

     public static class Servlet {
         private MimeType contentType = MimeType.valueOf(&quot;text/html&quot;);
         // get/setContentType
     }
 }
</code></pre>
</li>
<li><p>ThymeleafTemplateAvailabilityProvider</p>
<pre><code class="lang-java"> public class ThymeleafTemplateAvailabilityProvider
         implements TemplateAvailabilityProvider {
     @Override
     public boolean isTemplateAvailable(String view, Environment environment,
             ClassLoader classLoader, ResourceLoader resourceLoader) {
         if (ClassUtils.isPresent(&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;,
                 classLoader)) {
             String prefix = environment.getProperty(&quot;spring.thymeleaf.prefix&quot;,
                     ThymeleafProperties.DEFAULT_PREFIX);
             String suffix = environment.getProperty(&quot;spring.thymeleaf.suffix&quot;,
                     ThymeleafProperties.DEFAULT_SUFFIX);
             return resourceLoader.getResource(prefix + view + suffix).exists();
         }
         return false;
     }
 }
</code></pre>
</li>
</ol>
<h3 id="header-47">ContentNegotiatingViewResolver</h3>
<!-- ![contentNegotiatingViewResolver](2018-09-15-Spring-Boot/contentNegotiatingViewResolver.png) -->
<p><code>ContentNegotiatingViewResolver</code>:</p>
<ul>
<li>成员：<ul>
<li>Order: <ul>
<li><code>Ordered.HIGHEST_PRECEDENCE</code> 最高优先级</li>
</ul>
</li>
<li>视图解析器列表<code>List&lt;ViewResolver&gt;</code>: 会包含除自己以外的所有装载的<code>ViewResolver</code>（按顺序）<ul>
<li>ViewResolver#resolveViewName(viewName,local) -&gt; View</li>
</ul>
</li>
<li>内容协商管理工厂<code>ContentNegotiationManagerFactoryBean</code>: 用于生成内容协商管理器<code>ContentNegotiationManager</code><ul>
<li>ContentNegotiationManagerFactoryBean#build() -&gt; ContentNegotiationManager</li>
</ul>
</li>
<li>内容协商管理器<code>ContentNegotiationManager</code>: 管理内容协商策略<code>ContentNegotiationStrategy</code>（用于获取HTTP Request的<code>MediaType</code>列表）<ul>
<li><code>List&lt;ContentNegotiationStrategy&gt;</code> , eg:<ul>
<li>固定 MediaType : FixedContentNegotiationStrategy </li>
<li>&quot;Accept&quot; 请求头: HeaderContentNegotiationStrategy </li>
<li>请求参数: ParameterContentNegotiationStrategy </li>
<li>路径扩展名: PathExtensionContentNegotiationStrategy</li>
</ul>
</li>
<li><code>ContentNegotiationManager#resolveMediaTypes(request)</code> -&gt; List<MediaType></li>
<li><code>ContentNegotiationManager#resolveFileExtensions(mediaType)</code> -&gt; List<String></li>
</ul>
</li>
</ul>
</li>
<li>Override 方法：<code>resolveViewName</code><ul>
<li><code>getMediaTypes</code>: 获取与produce兼容的HTTP Request <code>MediaType</code> （使用<code>ContentNegotiationManager</code>的<code>ContentNegotiationStrategy</code>获取HTTP Request <code>MediaType</code>）</li>
<li><code>getCandidateViews</code>: 获取所有可能的View (ViewResolver视图解析得到View)</li>
<li><code>getBestView</code>: 从上面获取的View中选取最佳匹配的View<ul>
<li>HTTP Request <code>MediaType</code> &lt;-&gt; ViewResolver View <code>contentType</code> : 第一个匹配的那个View</li>
<li>注：<code>ViewResolver 顺序</code> 和 <code>Request的MediaType</code>（Accept 头策略，请求参数策略，...）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong> 部分源码：</strong></p>
<p>Key:</p>
<ul>
<li><p>Member vars:</p>
<ul>
<li><code>order</code>: Ordered.HIGHEST_PRECEDENCE</li>
<li><code>ContentNegotiationManager</code></li>
<li><code>ContentNegotiationManagerFactoryBean</code></li>
<li><code>List&lt;ViewResolver&gt;</code> viewResolvers</li>
<li><code>List&lt;View&gt;</code> defaultViews</li>
</ul>
</li>
<li><p>@Override <code>resolveViewName</code></p>
<ul>
<li><code>List&lt;MediaType&gt; requestedMediaTypes</code> = getMediaTypes(((ServletRequestAttributes) attrs).getRequest());<ul>
<li><code>List&lt;MediaType&gt; acceptableMediaTypes</code> = this.contentNegotiationManager.resolveMediaTypes(new ServletWebRequest(request));</li>
<li><code>List&lt;MediaType&gt; producibleMediaTypes</code> = new ArrayList&lt;&gt;(request.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE));</li>
<li>foreach acceptableMediaTypes -&gt; foreach producibleMediaTypes -&gt; acceptable.isCompatibleWith(producible) -&gt; add</li>
<li>MediaType.sortBySpecificityAndQuality</li>
</ul>
</li>
<li><code>List&lt;View&gt; candidateViews</code> = getCandidateViews(viewName, locale, requestedMediaTypes);<ul>
<li>foreach this.viewResolvers<ul>
<li>candidateViews.add(viewResolver.resolveViewName(viewName, locale))</li>
<li>extensions = this.contentNegotiationManager.resolveFileExtensions(requestedMediaType);</li>
<li>foreach extensions -&gt; candidateViews.add(viewResolver.resolveViewName(viewName + &#39;.&#39; + extension, locale))</li>
</ul>
</li>
<li>candidateViews.addAll(this.defaultViews)</li>
</ul>
</li>
<li><code>View bestView</code> = getBestView(candidateViews, requestedMediaTypes, attrs);<ul>
<li>foreach candidateViews -&gt; instanceof SmartView &amp;&amp; isRedirectView -&gt; return candidateView</li>
<li>foreach requestedMediaType:requestedMediaTypes<ul>
<li>foreach candidateView:candidateViews<ul>
<li>candidateContentType = MediaType.parseMediaType(candidateView.getContentType())</li>
<li>requestMediaType.isCompatibleWith(candidateContentType) -&gt; return candidateView</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>return <code>bestView</code></li>
</ul>
</li>
</ul>
<ol>
<li><p><code>ContentNegotiatingViewResolver#resolveViewName</code> -&gt; <code>View</code></p>
<ul>
<li>getMediaTypes</li>
<li>getCandidateViews</li>
<li><p>getBestView</p>
<pre><code class="lang-java">public class ContentNegotiatingViewResolver 
  extends WebApplicationObjectSupport 
  implements ViewResolver, Ordered, InitializingBean {

  private int order = Ordered.HIGHEST_PRECEDENCE;
  @Nullable
  private ContentNegotiationManager contentNegotiationManager;
  private final ContentNegotiationManagerFactoryBean cnmFactoryBean = new ContentNegotiationManagerFactoryBean();
  @Nullable
  private List&lt;View&gt; defaultViews;
  @Nullable
  private List&lt;ViewResolver&gt; viewResolvers;

  @Override
  protected void initServletContext(ServletContext servletContext) {
      Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(obtainApplicationContext(), ViewResolver.class).values();
      if (this.viewResolvers == null) {
          this.viewResolvers = new ArrayList&lt;&gt;(matchingBeans.size());
          for (ViewResolver viewResolver : matchingBeans) {
              if (this != viewResolver) {
                  this.viewResolvers.add(viewResolver);
              }
          }
      }
      else {
          for (int i = 0; i &lt; this.viewResolvers.size(); i++) {
              ViewResolver vr = this.viewResolvers.get(i);
              if (matchingBeans.contains(vr)) {
                  continue;
              }
              String name = vr.getClass().getName() + i;
              obtainApplicationContext().getAutowireCapableBeanFactory().initializeBean(vr, name);
          }

      }
      AnnotationAwareOrderComparator.sort(this.viewResolvers);    // sort!
      this.cnmFactoryBean.setServletContext(servletContext);
  }

  @Override
  public void afterPropertiesSet() {
      if (this.contentNegotiationManager == null) {
          this.contentNegotiationManager = this.cnmFactoryBean.build();
      }
  }

  @Override
  @Nullable
  public View resolveViewName(String viewName, Locale locale) throws Exception {
      RequestAttributes attrs = RequestContextHolder.getRequestAttributes();
      Assert.state(attrs instanceof ServletRequestAttributes, &quot;No current ServletRequestAttributes&quot;);
      List&lt;MediaType&gt; requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest());
      if (requestedMediaTypes != null) {
          List&lt;View&gt; candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes);
          View bestView = getBestView(candidateViews, requestedMediaTypes, attrs);
          if (bestView != null) {
              return bestView;
          }
      }
      if (this.useNotAcceptableStatusCode) {
          if (logger.isDebugEnabled()) {
              logger.debug(&quot;No acceptable view found; returning 406 (Not Acceptable) status code&quot;);
          }
          return NOT_ACCEPTABLE_VIEW;
      }
      else {
          logger.debug(&quot;No acceptable view found; returning null&quot;);
          return null;
      }
  }

  @Nullable
  protected List&lt;MediaType&gt; getMediaTypes(HttpServletRequest request) {
      try {
          ServletWebRequest webRequest = new ServletWebRequest(request);
          List&lt;MediaType&gt; acceptableMediaTypes = this.contentNegotiationManager.resolveMediaTypes(webRequest);
          List&lt;MediaType&gt; producibleMediaTypes = getProducibleMediaTypes(request);
          Set&lt;MediaType&gt; compatibleMediaTypes = new LinkedHashSet&lt;&gt;();
          for (MediaType acceptable : acceptableMediaTypes) {
              for (MediaType producible : producibleMediaTypes) {
                  if (acceptable.isCompatibleWith(producible)) {
                      compatibleMediaTypes.add(getMostSpecificMediaType(acceptable, producible));
                  }
              }
          }
          List&lt;MediaType&gt; selectedMediaTypes = new ArrayList&lt;&gt;(compatibleMediaTypes);
          MediaType.sortBySpecificityAndQuality(selectedMediaTypes);
          return selectedMediaTypes;
      }
      catch (HttpMediaTypeNotAcceptableException ex) {
          return null;
      }
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  private List&lt;MediaType&gt; getProducibleMediaTypes(HttpServletRequest request) {
      Set&lt;MediaType&gt; mediaTypes = (Set&lt;MediaType&gt;)
              request.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);
      if (!CollectionUtils.isEmpty(mediaTypes)) {
          return new ArrayList&lt;&gt;(mediaTypes);
      }
      else {
          return Collections.singletonList(MediaType.ALL);
      }
  }

  private List&lt;View&gt; getCandidateViews(String viewName, Locale locale, List&lt;MediaType&gt; requestedMediaTypes)
          throws Exception {
      List&lt;View&gt; candidateViews = new ArrayList&lt;&gt;();
      if (this.viewResolvers != null) {
          for (ViewResolver viewResolver : this.viewResolvers) {
              View view = viewResolver.resolveViewName(viewName, locale);
              if (view != null) {
                  candidateViews.add(view);
              }
              for (MediaType requestedMediaType : requestedMediaTypes) {
                  List&lt;String&gt; extensions = this.contentNegotiationManager.resolveFileExtensions(requestedMediaType);
                  for (String extension : extensions) {
                      String viewNameWithExtension = viewName + &#39;.&#39; + extension;
                      view = viewResolver.resolveViewName(viewNameWithExtension, locale);
                      if (view != null) {
                          candidateViews.add(view);
                      }
                  }
              }
          }
      }
      if (!CollectionUtils.isEmpty(this.defaultViews)) {
          candidateViews.addAll(this.defaultViews);
      }
      return candidateViews;
  }

  @Nullable
  private View getBestView(List&lt;View&gt; candidateViews, List&lt;MediaType&gt; requestedMediaTypes, RequestAttributes attrs) {
      for (View candidateView : candidateViews) {
          if (candidateView instanceof SmartView) {
              SmartView smartView = (SmartView) candidateView;
              if (smartView.isRedirectView()) {
                  if (logger.isDebugEnabled()) {
                      logger.debug(&quot;Returning redirect view [&quot; + candidateView + &quot;]&quot;);
                  }
                  return candidateView;
              }
          }
      }
      for (MediaType mediaType : requestedMediaTypes) {
          for (View candidateView : candidateViews) {
              if (StringUtils.hasText(candidateView.getContentType())) {
                  MediaType candidateContentType = MediaType.parseMediaType(candidateView.getContentType());
                  if (mediaType.isCompatibleWith(candidateContentType)) {
                      if (logger.isDebugEnabled()) {
                          logger.debug(&quot;Returning [&quot; + candidateView + &quot;] based on requested media type &#39;&quot; +
                                  mediaType + &quot;&#39;&quot;);
                      }
                      attrs.setAttribute(View.SELECTED_CONTENT_TYPE, mediaType, RequestAttributes.SCOPE_REQUEST);
                      return candidateView;
                  }
              }
          }
      }
      return null;
  }

  //...
}
</code></pre>
</li>
</ul>
</li>
<li><p><code>ContentNegotiationManagerFactoryBean#build</code> -&gt; <code>new ContentNegotiationManager(strategies)</code></p>
<pre><code class="lang-java"> public class ContentNegotiationManagerFactoryBean
         implements FactoryBean&lt;ContentNegotiationManager&gt;, ServletContextAware, InitializingBean {
     // ...

     public ContentNegotiationManager build() {
         List&lt;ContentNegotiationStrategy&gt; strategies = new ArrayList&lt;&gt;();

         if (this.strategies != null) {
             strategies.addAll(this.strategies);
         }
         else {
             if (this.favorPathExtension) {
                 PathExtensionContentNegotiationStrategy strategy;
                 if (this.servletContext != null &amp;&amp; !useRegisteredExtensionsOnly()) {
                     strategy = new ServletPathExtensionContentNegotiationStrategy(this.servletContext, this.mediaTypes);
                 }
                 else {
                     strategy = new PathExtensionContentNegotiationStrategy(this.mediaTypes);
                 }
                 strategy.setIgnoreUnknownExtensions(this.ignoreUnknownPathExtensions);
                 if (this.useRegisteredExtensionsOnly != null) {
                     strategy.setUseRegisteredExtensionsOnly(this.useRegisteredExtensionsOnly);
                 }
                 strategies.add(strategy);
             }

             if (this.favorParameter) {
                 ParameterContentNegotiationStrategy strategy = new ParameterContentNegotiationStrategy(this.mediaTypes);
                 strategy.setParameterName(this.parameterName);
                 if (this.useRegisteredExtensionsOnly != null) {
                     strategy.setUseRegisteredExtensionsOnly(this.useRegisteredExtensionsOnly);
                 }
                 else {
                     strategy.setUseRegisteredExtensionsOnly(true);  // backwards compatibility
                 }
                 strategies.add(strategy);
             }

             if (!this.ignoreAcceptHeader) {
                 strategies.add(new HeaderContentNegotiationStrategy());
             }

             if (this.defaultNegotiationStrategy != null) {
                 strategies.add(this.defaultNegotiationStrategy);
             }
         }

         this.contentNegotiationManager = new ContentNegotiationManager(strategies);
         return this.contentNegotiationManager;
     }
 }
</code></pre>
</li>
<li><p>ContentNegotiationManager</p>
<ul>
<li>resolveMediaTypes: <code>ContentNegotiationStrategy#resolveMediaTypes</code></li>
<li><p>resolveFileExtensions: <code>MediaTypeFileExtensionResolver#resolveFileExtensions</code></p>
<pre><code class="lang-java">public class ContentNegotiationManager implements ContentNegotiationStrategy, MediaTypeFileExtensionResolver {

  private final List&lt;ContentNegotiationStrategy&gt; strategies = new ArrayList&lt;&gt;();
  private final Set&lt;MediaTypeFileExtensionResolver&gt; resolvers = new LinkedHashSet&lt;&gt;();

  @Override
  public List&lt;MediaType&gt; resolveMediaTypes(NativeWebRequest request) throws HttpMediaTypeNotAcceptableException {
      for (ContentNegotiationStrategy strategy : this.strategies) {
          List&lt;MediaType&gt; mediaTypes = strategy.resolveMediaTypes(request);
          if (mediaTypes.equals(MEDIA_TYPE_ALL_LIST)) {
              continue;
          }
          return mediaTypes;
      }
      return MEDIA_TYPE_ALL_LIST;
  }

  @Override
  public List&lt;String&gt; resolveFileExtensions(MediaType mediaType) {
      Set&lt;String&gt; result = new LinkedHashSet&lt;&gt;();
      for (MediaTypeFileExtensionResolver resolver : this.resolvers) {
          result.addAll(resolver.resolveFileExtensions(mediaType));
      }
      return new ArrayList&lt;&gt;(result);
  }

  // ... 
}

@FunctionalInterface
public interface ContentNegotiationStrategy {
  List&lt;MediaType&gt; MEDIA_TYPE_ALL_LIST = Collections.singletonList(MediaType.ALL);
  List&lt;MediaType&gt; resolveMediaTypes(NativeWebRequest webRequest)
          throws HttpMediaTypeNotAcceptableException;
｝
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="header-48">DispatcherServlet</h3>
<p><img src="/2018/09/15/webmvc-handler.png" alt="webmvc"></p>
<!-- 
![webmvc](2018-09-15-Spring-Boot/webmvc-view.png)

![webmvc-view](2018-09-15-Spring-Boot/webmvc-rest.png) 
-->
<p>package org.springframework.web.servlet;</p>
<ol>
<li><p><code>DispatcherServlet#doDispatch(request,response)</code></p>
<ul>
<li>HandlerExecutionChain { handler(eg:HandlerMethod) &amp; interceptorList }<ul>
<li>List<HandlerMapping> handlerMappings</li>
<li>HandlerMapping#getHandler!=null</li>
</ul>
</li>
<li>HandlerAdapter<ul>
<li>List<HandlerAdapter> handlerAdapters</li>
<li>HandlerAdapter#support</li>
</ul>
</li>
<li>ModelAndView { model:ModelMap,view(eg:viewName) }<ul>
<li>HandlerAdapter#handle</li>
<li>HandlerAdapter#invokeHandlerMethod</li>
</ul>
</li>
<li>View<ul>
<li>List<ViewResolver> viewResolvers</li>
<li>ViewResolver#resolveViewName(ModelAndView#view,local)</li>
</ul>
</li>
<li>View#render(ModelAndView#model)</li>
</ul>
</li>
<li><p><code>HandlerMapping#getHandler -&gt; HandlerExecutionChain</code></p>
<pre><code class="lang-java"> /*
 HandlerMapping
     - AbstractHandlerMapping
         + AbstractHandlerMethodMapping&lt;T&gt;
             - RequestMappingInfoHandlerMapping&lt;RequestMappingInfo&gt;
                 * RequestMappingHandlerMapping
         + AbstractUrlHandlerMapping
             - AbstractDetectingUrlHandlerMapping
                 * BeanNameUrlHandlerMapping
             - SimpleUrlHandlerMapping
         + EmptyHandlerMapping
 */
</code></pre>
<ul>
<li>AbstractHandlerMapping<ul>
<li>getHandler<ul>
<li>abstract getHandlerInternal</li>
</ul>
</li>
</ul>
</li>
<li>AbstractHandlerMethodMapping<T><ul>
<li>afterPropertiesSet -&gt; initHandlerMethods -&gt; detectHandlerMethods<ul>
<li>abstract getMappingForMethod</li>
<li>registerHandlerMethod</li>
</ul>
</li>
<li>override getHandlerInternal -&gt; lookupHandlerMethod<ul>
<li>abstract getMatchingMapping</li>
<li>protected handleMatch</li>
<li>protected handleNoMatch</li>
</ul>
</li>
</ul>
</li>
<li>RequestMappingInfoHandlerMapping<RequestMappingInfo><ul>
<li>override getMatchingMapping</li>
<li>override handleMatch</li>
<li>override handleNoMatch</li>
</ul>
</li>
<li>RequestMappingHandlerMapping<ul>
<li>override getMappingForMethod -&gt; createRequestMappingInfo</li>
</ul>
</li>
</ul>
</li>
<li><p><code>HandlerAdapter#handle -&gt; ModelAndView{modelMap,viewName}</code></p>
<pre><code class="lang-java"> /*
 HandlerAdapter
     - AbstractHandlerMethodAdapter
         * RequestMappingHandlerAdapter
     - HttpRequestHandlerAdapter
     - SimpleControllerHandlerAdapter
     - SimpleServletHandlerAdapter

 HandlerMethodArgumentResolver
     - AbstractMessageConverterMethodArgumentResolver
         + AbstractMessageConverterMethodProcessor
             * RequestResponseBodyMethodProcessor
             * HttpEntityMethodProcessor
         + RequestPartMethodArgumentResolver
     - ...

 HandlerMethodReturnValueHandler
     - AbstractMessageConverterMethodProcessor
         * RequestResponseBodyMethodProcessor
         * HttpEntityMethodProcessor
     - ...

 HttpMessageConverter
     - AbstractHttpMessageConverter&lt;T&gt;
         + AbstractGenericHttpMessageConverter&lt;T&gt;
             - AbstractJackson2HttpMessageConverter
                 * MappingJackson2HttpMessageConverter
                 * MappingJackson2XmlHttpMessageConverter
                 * ...
             - AbstractJsonHttpMessageConverter
                 * GsonHttpMessageConverter
                 * JsonbHttpMessageConverter
             - PropertiesHttpMessageConverter
             - ResourceRegionHttpMessageConverter
         + ByteArrayHttpMessageConverter
         + ObjectToStringHttpMessageConverter
         + ResourceHttpMessageConverter
         + StringHttpMessageConverter
         + ...
     - ...
 */
</code></pre>
<ul>
<li>AbstractHandlerMethodAdapter<ul>
<li>support: expects the handler to be an <code>HandlerMethod</code><ul>
<li>abstract supportsInternal</li>
</ul>
</li>
<li>handler<ul>
<li>abstract handleInternal</li>
</ul>
</li>
</ul>
</li>
<li>RequestMappingHandlerAdapter<ul>
<li>afterPropertiesSet</li>
<li>override supportsInternal : return true</li>
<li>override handleInternal -&gt; invokeHandleMethod -&gt; ServletInvocableHandlerMethod#invokeAndHandle<ul>
<li>getMethodArgumentValues(HandlerMethodArgumentResolverComposite#resolveArgument)</li>
<li>doInvoke</li>
<li>handleReturnValue (HandlerMethodReturnValueHandlerComposite#handleReturnValue)</li>
</ul>
</li>
</ul>
</li>
<li>RequestResponseBodyMethodProcessor (extends AbstractMessageConverterMethodProcessor)<ul>
<li>resolve method args for <code>@RequestBody</code>(implements HandlerMethodArgumentResolver)<ul>
<li>supportsParameter</li>
<li>resolveArgument<ul>
<li>HttpMessageConverter#canRead</li>
<li>HttpMessageConverter#read</li>
</ul>
</li>
</ul>
</li>
<li>handle return value for <code>@ResponseBody</code>(implements HandlerMethodReturnValueHandler) <ul>
<li>supportsReturnType</li>
<li>handleReturnValue<ul>
<li>HttpMessageConverter#canWrite</li>
<li>HttpMessageConverter#write</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>ViewResolver#resolveViewName(ModelAndView#viewName) -&gt; View</code></p>
<pre><code class="lang-java"> /*
 ViewResolver
  - AbstractCachingViewResolver
      + ResourceBundleViewResolver
      + ThymeleafViewResolver
          - AjaxThymeleafViewResolver
      + UrlBasedViewResolver
          - AbstractTemplateViewResolver
              * FreeMarkerViewResolver
              * GroovyMarkupViewResolver
          - InternalResourceViewResolver
          - ...
      + XmlViewResolver
  - BeanNameViewResolver
  - ContentNegotiatingViewResolver
  - ViewResolverComposite
 */
</code></pre>
<ul>
<li>ThymeleafViewResolver (Integer.MAX_VALUE)</li>
<li>ContentNegotiatingViewResolver (Ordered.HIGHEST_PRECEDENCE)</li>
<li>InternalResourceViewResolver (Ordered.LOWEST_PRECEDENCE)</li>
<li>ViewResolverComposite (Ordered.LOWEST_PRECEDENCE)</li>
</ul>
</li>
<li><p><code>View#render(ModelAndView#modelMap)</code></p>
<pre><code class="lang-java"> /*
 View
     - AbstractView
         + AbstractFeedView&lt;T extends WireFeed&gt;
             * AbstractAtomFeedView
             * AbstractRssFeedView
         + AbstractJackson2View
             * MappingJackson2JsonView
             * MappingJackson2XmlView
         + AbstractPdfView
         + AbstractUrlBasedView
             - AbstractTemplateView
                 * FreeMarkerView
                 * GroovyMarkupView
             - InternalResourceView
                 * JstlView
             - RedirectView
             - AbstractPdfStamperView
             - ScriptTemplateView
             - TilesView
             - XsltView
         + AbstractXlsView
             - AbstractXlsxView
                 * AbstractXlsxStreamingView
         + MarshallingView
     - AbstractThymeleafView
         + ThymeleafView
             - AjaxThymeleafView
                 * FlowAjaxThymeleafView
 */
</code></pre>
<ul>
<li>JstlView</li>
<li>ThymeleafView</li>
<li>FreeMarkerView</li>
<li>RedirectView</li>
<li>MappingJackson2JsonView</li>
</ul>
</li>
</ol>
<p><strong> 部分源码：</strong></p>
<ol>
<li><p>DispatcherServlet (总控)</p>
<pre><code class="lang-java">// 1. DispatcherServlet
public class DispatcherServlet extends FrameworkServlet {

 @Override
 protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception
 =&gt; doDispatch(request, response);

 protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception
 =&gt; {
     // 2.1 HandlerMapping -&gt; HandlerExecutionChain: handler &amp; interceptorList
     // eg: RequestMappingHandlerMapping -&gt; HandlerExecutionChain: handler (HandlerMethod) &amp; interceptorList
     HandlerExecutionChain mappedHandler = getHandler(processedRequest);
     =&gt; {
         for (HandlerMapping hm : this.handlerMappings) {
             HandlerExecutionChain handler = hm.getHandler(request);
             if (handler != null) {
                 return handler;
             }
         }
     }

     // 2.2 HandlerAdapter
     // eg: RequestMappingHandlerAdapter
     HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
     =&gt;{
         for (HandlerAdapter ha : this.handlerAdapters) {
             if (ha.supports(handler)) {
                 return ha;
             }
         }
     }

     // 2.3 HandlerAdapter -&gt; invoke handlerMethod -&gt; ModelAndView: ModelMap &amp; View (eg: viewName) &amp; HttpStatus
     ModelAndView mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

     // 2.4 ViewResolver -&gt; View -&gt; Render &amp; Response
     processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
     =&gt;{
         if(dispatchException!=null){
             if dispatchException instanceof ModelAndViewDefiningException
                 mv = ((ModelAndViewDefiningException) exception).getModelAndView();
             else
                 mv = processHandlerException(request, response, handler, exception);
                     /*=&gt; {
                         for (HandlerExceptionResolver handlerExceptionResolver : this.handlerExceptionResolvers) {
                             exMv = handlerExceptionResolver.resolveException(request, response, handler, ex);
                             if (exMv != null) {
                                 break;
                             }
                         }
                     }*/
         }
         render(mv, request, response);
         =&gt;{
             String viewName = mv.getViewName();
             View view = resolveViewName(viewName, mv.getModelInternal(), locale, request);
                 /*=&gt; {
                     for (ViewResolver viewResolver : this.viewResolvers) {
                         View view = viewResolver.resolveViewName(viewName, locale);
                         if (view != null) {
                             return view;
                         }
                     }
                 }*/
             view.render(mv.getModelInternal(), request, response);
         }
         mappedHandler.triggerAfterCompletion(request, response, null);
     }

     // final{...}
 }
}
</code></pre>
</li>
<li><p>HandlerMapping: RequestMappingHandlerMapping</p>
<ul>
<li>内部相当于维护了一个<code>Map&lt;RequestMappingInfo,HandlerMethod&gt;</code>，<code>getHandler</code>时根据当前<code>request</code>找到匹配的<code>HandlerMethod</code></li>
<li>AbstractHandlerMethodMapping<T> (extends AbstractHandlerMapping)<pre><code class="lang-java">  // 1. afterPropertiesSet -- 会注册所有mapping（requestMapping和各个Class method关系）
  //        -&gt; initHandlerMethods 
  //            -&gt; detectHandlerMethods 
  //                -&gt; call abstract func:getMappingForMethod
  protected void initHandlerMethods() {
      //Looking for request mappings in application context
      String[] beanNames = (this.detectHandlerMethodsInAncestorContexts ?
              BeanFactoryUtils.beanNamesForTypeIncludingAncestors(obtainApplicationContext(), Object.class) :
              obtainApplicationContext().getBeanNamesForType(Object.class));
      for (String beanName : beanNames) {
          if (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) {
              Class&lt;?&gt; beanType = obtainApplicationContext().getType(beanName);
              if (beanType != null &amp;&amp; isHandler(beanType))
                  detectHandlerMethods(beanName);
                  =&gt;{
                      //detectHandlerMethods(handler):
                      Class&lt;?&gt; handlerType = (handler instanceof String ?
                              obtainApplicationContext().getType(handler) : handler.getClass());
                      final Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);
                      Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,
                              method -&gt; {
                                  return getMappingForMethod(method, userType); // abstract func!
                              });
                      // request handler methods found on ${userType}.${methods}
                      methods.forEach((method, mapping) -&gt; {
                          Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);
                          registerHandlerMethod(handler, invocableMethod, mapping);
                      });
                  }
          }
      }
      handlerMethodsInitialized(getHandlerMethods());
  }
  // 2. getHandlerInternal -- 找到与request匹配的HandleMethod
  //        -&gt; lookupHandlerMethod 
  //            -&gt; call abstract func: getMatchingMapping
  //            -&gt; call protected func: handleMatch
  //            -&gt; call protected func: handleNoMatch
  protected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception {
      String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);
      //Looking up handler method for the request path
      this.mappingRegistry.acquireReadLock();
      try {
          HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);
          return (handlerMethod != null ? handlerMethod.createWithResolvedBean() : null);
      }
      finally {
          this.mappingRegistry.releaseReadLock();
      }
  }
  protected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception {
      List&lt;Match&gt; matches = new ArrayList&lt;&gt;();
      List&lt;T&gt; directPathMatches = this.mappingRegistry.getMappingsByUrl(lookupPath);
      if (directPathMatches != null) {
          addMatchingMappings(directPathMatches, matches, request);
          // foreach directPathMatches to get MatchingMaping by call abstract getMatchingMapping:
          /*
              for:directPathMatches{
                  T match = getMatchingMapping(mapping, request);    // abstract func!
                  if match!=null
                      matches.add(new Match(match, this.mappingRegistry.getMappings().get(mapping)));
              }                    
          */
      }
      if (matches.isEmpty()) {
          // No choice but to go through all mappings...
          addMatchingMappings(this.mappingRegistry.getMappings().keySet(), matches, request);
      }
      if (!matches.isEmpty()) {
          Comparator&lt;Match&gt; comparator = new MatchComparator(getMappingComparator(request));
          matches.sort(comparator);
          Match bestMatch = matches.get(0);
          if (matches.size() &gt; 1) {
              if (CorsUtils.isPreFlightRequest(request)) {
                  return PREFLIGHT_AMBIGUOUS_MATCH;
              }
              Match secondBestMatch = matches.get(1);
              if (comparator.compare(bestMatch, secondBestMatch) == 0) {
                  Method m1 = bestMatch.handlerMethod.getMethod();
                  Method m2 = secondBestMatch.handlerMethod.getMethod();
                  throw new IllegalStateException(&quot;Ambiguous handler methods mapped for HTTP path &#39;&quot; +
                          request.getRequestURL() + &quot;&#39;: {&quot; + m1 + &quot;, &quot; + m2 + &quot;}&quot;);
              }
          }
          handleMatch(bestMatch.mapping, lookupPath, request);    // protected func!
          return bestMatch.handlerMethod;
      }
      else {
          return handleNoMatch(this.mappingRegistry.getMappings().keySet(), lookupPath, request);  // protected func!
      }
  }
</code></pre>
</li>
<li><p>RequestMappingInfoHandlerMapping (extends AbstractHandlerMethodMapping<RequestMappingInfo>)</p>
<pre><code class="lang-java">  // 1. getMatchingMapping
  //        -&gt;RequestMappingInfo#getMatchingCondition
  @Override
  protected RequestMappingInfo getMatchingMapping(RequestMappingInfo info, HttpServletRequest request) {
      return info.getMatchingCondition(request);
      =&gt;{
          // RequestMappingInfo#getMatchingCondition:
          RequestMethodsRequestCondition methods = this.methodsCondition.getMatchingCondition(request);
          ParamsRequestCondition params = this.paramsCondition.getMatchingCondition(request);
          HeadersRequestCondition headers = this.headersCondition.getMatchingCondition(request);
          ConsumesRequestCondition consumes = this.consumesCondition.getMatchingCondition(request);
          ProducesRequestCondition produces = this.producesCondition.getMatchingCondition(request);
          if (methods == null || params == null || headers == null || consumes == null || produces == null) {
              return null;
          }
          PatternsRequestCondition patterns = this.patternsCondition.getMatchingCondition(request);
          if (patterns == null) {
              return null;
          }
          RequestConditionHolder custom = this.customConditionHolder.getMatchingCondition(request);
          if (custom == null) {
              return null;
          }
          return new RequestMappingInfo(this.name, patterns,
                  methods, params, headers, consumes, produces, custom.getCondition());
      }
  }

  // 2. handleMatch
  @Override
  protected void handleMatch(RequestMappingInfo info, String lookupPath, HttpServletRequest request) {
      request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, lookupPath);
      Set&lt;String&gt; patterns = info.getPatternsCondition().getPatterns();
      //bestPattern,uriVariables,decodedUriVariables -&gt; request.setAttribute(xxx,xxx)
      //...
  }

  // 3. handleNoMatch
  @Override
  protected HandlerMethod handleNoMatch(
          Set&lt;RequestMappingInfo&gt; infos, String lookupPath, HttpServletRequest request) throws ServletException{
      PartialMatchHelper helper = new PartialMatchHelper(infos, request);
      helper.hasMethodsMismatch(): throw new HttpRequestMethodNotSupportedException(request.getMethod(), methods);
      helper.hasConsumesMismatch(): throw new HttpMediaTypeNotSupportedException(contentType, new ArrayList&lt;&gt;(mediaTypes));
      helper.hasProducesMismatch(): throw new HttpMediaTypeNotAcceptableException(new ArrayList&lt;&gt;(mediaTypes));
      helper.hasParamsMismatch(): throw new UnsatisfiedServletRequestParameterException(conditions, request.getParameterMap());
      return null;
  }
</code></pre>
</li>
<li>RequestMappingHandlerMapping (extends RequestMappingInfoHandlerMapping)<pre><code class="lang-java">  // 1. getMappingForMethod 
  //        -&gt; createRequestMappingInfo:
  protected RequestMappingInfo createRequestMappingInfo(
              RequestMapping requestMapping, @Nullable RequestCondition&lt;?&gt; customCondition) {
      RequestMappingInfo.Builder builder = RequestMappingInfo
              .paths(resolveEmbeddedValuesInPatterns(requestMapping.path()))
              .methods(requestMapping.method())
              .params(requestMapping.params())
              .headers(requestMapping.headers())
              .consumes(requestMapping.consumes())
              .produces(requestMapping.produces())
              .mappingName(requestMapping.name());
      if (customCondition != null)
          builder.customCondition(customCondition);
      return builder.options(this.config).build();
  }
  // 2. class 成员变量: contentNegotiationManager
  private ContentNegotiationManager contentNegotiationManager = new ContentNegotiationManager();
</code></pre>
</li>
</ul>
</li>
<li><p>HandlerAdapter: RequestMappingHandlerAdapter</p>
<ul>
<li><p>RequestMappingHandlerAdapter (extends AbstractHandlerMethodAdapter)</p>
<pre><code class="lang-java">  // 1. constructor : initial messageConverters : List&lt;HttpMessageConverter&lt;?&gt;&gt;
  public RequestMappingHandlerAdapter() {
      StringHttpMessageConverter stringHttpMessageConverter = new StringHttpMessageConverter();
      stringHttpMessageConverter.setWriteAcceptCharset(false); // See SPR-7316
      this.messageConverters = new ArrayList&lt;HttpMessageConverter&lt;?&gt;&gt;();
      this.messageConverters.add(new ByteArrayHttpMessageConverter());
      this.messageConverters.add(stringHttpMessageConverter);
      this.messageConverters.add(new SourceHttpMessageConverter&lt;Source&gt;());
      this.messageConverters.add(new AllEncompassingFormHttpMessageConverter());
  }
  // 2. afterPropertiesSet: initial argumentResolvers,returnValueHandlers,...
  //        -&gt; this.argumentResolvers : HandlerMethodArgumentResolverComposite
  //        -&gt; this.initBinderArgumentResolvers : HandlerMethodArgumentResolverComposite
  //        -&gt; this.returnValueHandlers : HandlerMethodReturnValueHandlerComposite
  @Override
  public void afterPropertiesSet(){
      initControllerAdviceCache();
      if (this.argumentResolvers == null) {
          List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();
          /*
          =&gt;{
              //resolvers.add(...)
              //...
              // use RequestResponseBodyMethodProcessor to resolve @RequestBody method arguments
              resolvers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice));
              //...
          }*/
          this.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers)
      }
      if (this.initBinderArgumentResolvers == null) {
          List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();
          this.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);
      }
      if (this.returnValueHandlers == null) {
          List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();
          /*
              =&gt;{
                  //handlers.add(...)
                  //...
                  // use RequestResponseBodyMethodProcessor to handle @ResponseBody return value
                  handlers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(),
                      this.contentNegotiationManager, this.requestResponseBodyAdvice));
                  //...
              }
          */
          this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);
      }
  }

  // 3. handleInternal 
  //        -&gt; invokeHandleMethod
  //            -&gt; ServletInvocableHandlerMethod#invokeAndHandle :
  //                -&gt; getMethodArgumentValues
  //                -&gt; doInvoke
  //                -&gt; handleReturnValue
  @Override
  protected final ModelAndView handleInternal(HttpServletRequest request,
          HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {
      // ...
  }
</code></pre>
</li>
<li><p>ServletInvocableHandlerMethod (extends InvocableHandlerMethod)</p>
<pre><code class="lang-java">  // 1. invokeAndHandle
  //        -&gt; getMethodArgumentValues(HandlerMethodArgumentResolverComposite#resolveArgument)
  //        -&gt; doInvoke
  //        -&gt; handleReturnValue (HandlerMethodReturnValueHandler#handleReturnValue)
  public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,
              Object... providedArgs) throws Exception 
  =&gt;{
      // 1. resolveArgument(HandlerMethodArgumentResolver#resolveArgument) 
      //        =&gt; args -&gt; handlerMethod -&gt; returnValue
      Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);    
          =&gt; {
              // InvocableHandlerMethod#invokeForRequest:
              Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);
                  /*    
                  InvocableHandlerMethod#getMethodArgumentValues:{
                      MethodParameter[] parameters = getMethodParameters();
                      for:parameters{
                          args[i] = resolveProvidedArgument(parameter, providedArgs)
                          if (args[i] == null &amp;&amp; this.argumentResolvers.supportsParameter(parameter))
                              args[i] = this.argumentResolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);
                      }
                  }    
                  */
              // 2. doInvoke
              Object returnValue = doInvoke(args);
              return returnValue;
          }

      // 3. handleReturnValue (HandlerMethodReturnValueHandler#handleReturnValue)
      this.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
  }

  // 2. class 成员变量：argumentResolvers －－ use to resolveArgument
  private HandlerMethodArgumentResolverComposite argumentResolvers = new HandlerMethodArgumentResolverComposite();
  /*
      class HandlerMethodArgumentResolverComposite {
          private final List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers = new LinkedList&lt;&gt;();
          @Override
          public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
              NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception{
              HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);
              =&gt;{
                  for resolver: this.argumentResolvers{
                      if (resolver.supportsParameter(parameter))
                          return resolver;
                  }
              }
              return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);
          }
      }
  */

  // 3. class 成员变量：returnValueHandlers －－ use to handleReturnValue
  private HandlerMethodReturnValueHandlerComposite returnValueHandlers;
  /*
      class HandlerMethodReturnValueHandlerComposite {
          private final List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers = new ArrayList&lt;&gt;();
          @Override
          public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,
                  ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception{
              HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);
              =&gt;{
                  for:this.returnValueHandlers{
                      if(handler.supportsReturnType(returnType))
                          return handler;
                  }
              }
              handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);
          }
      }
  */
</code></pre>
</li>
<li>RequestResponseBodyMethodProcessor: resolve args for <code>@RequestBody</code>  &amp; handle return value for <code>@ResponseBody</code><pre><code class="lang-java">  /**
   * Resolves method arguments annotated with {@code @RequestBody} and handles return
   * values from methods annotated with {@code @ResponseBody} by reading and writing
   * to the body of the request or response with an {@link HttpMessageConverter}.
   */
  public class RequestResponseBodyMethodProcessor extends AbstractMessageConverterMethodProcessor {
      @Override
      public boolean supportsParameter(MethodParameter parameter) {
          return parameter.hasParameterAnnotation(RequestBody.class);
      }
      @Override
      public boolean supportsReturnType(MethodParameter returnType) {
          return (AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody.class) ||
                  returnType.hasMethodAnnotation(ResponseBody.class));
      }
      @Override
      public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
              NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception{
          Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());
              /*
                  //AbstractMessageConverterMethodArgumentResolver#readWithMessageConverters:
                  contentType: get from requestHeader
                  for:this.messageConverters{
                      if(converter.canRead(...))
                          return converter.read(...) // HttpMessageConverter#read
                  }
              */
          return adaptArgumentIfNecessary(arg, parameter);
      }
      @Override
      public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,
              ModelAndViewContainer mavContainer, NativeWebRequest webRequest){
          writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage)
              /*
              //AbstractMessageConverterMethodProcessor#writeWithMessageConverters:
              acceptableMediaTypes &amp; producibleMediaTypes =&gt; Compatible &amp;&amp; Concrete =&gt; mediaTypes
                  =&gt; {
                      AcceptableMediaTypes: this.contentNegotiationManager.resolveMediaTypes(new ServletWebRequest(request));
                      producibleMediaTypes: 
                          mediaTypes = (Set&lt;MediaType&gt;) request.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);
                          or:
                              for: this.messageConverters{
                                  if(converter.canWrite(...))
                                      result.addAll(converter.getSupportedMediaTypes())
                              }
                  }
              for: this.messageConverters{
                  if(converter.canWrite(...)){
                      outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType,converter.getClass(),
                      inputMessage, outputMessage);
                      addContentDispositionHeader(inputMessage, outputMessage);
                      converter.write(outputValue, selectedMediaType, outputMessage);    // HttpMessageConverter#write
                  }
              }                    
              */
      }
  }
</code></pre>
</li>
</ul>
</li>
</ol>
<h2 id="header-49">WebFlux</h2>
<ul>
<li>jar: <code>spring-webflux</code> (dependency: <code>spring-web</code>,<code>reactor-core</code>)</li>
<li>是<code>Reactive</code>思想的一种实现（数据流<code>Data Stream</code>，非阻塞 <code>Non-Blocking</code>，推模式<code>push-based</code>，背压<code>Backpressure</code>）</li>
<li>依赖<code>Reactor</code>类库(jar:<code>reactor-core</code>)<ul>
<li>依赖<code>reactive-streams</code><ul>
<li>核心组件：<code>Publisher</code>,<code>Subscriber</code>,<code>Subscription</code>,<code>Processor</code></li>
<li>背压处理</li>
</ul>
</li>
<li>核心组件：<code>Mono</code>,<code>Flux</code>,<code>Scheduler</code></li>
</ul>
</li>
<li>依赖<code>SpringWeb</code>类库(jar: <code>spring-web</code>)<ul>
<li><code>HttpHandler</code>: <code>Mono&lt;Void&gt; handle(ServerHttpRequest request, ServerHttpResponse response);</code></li>
<li><code>WebHandler</code>: <code>Mono&lt;Void&gt; handle(ServerWebExchange exchange);</code></li>
</ul>
</li>
<li>编程模型：<ul>
<li>注解式驱动 <a href="https://docs.spring.io/spring/docs/5.0.x/spring-framework-reference/web-reactive.html#webflux-controller">Annotated Controllers</a>: 同WebMvc使用的注解</li>
<li>函数式端点 <a href="https://docs.spring.io/spring/docs/5.0.x/spring-framework-reference/web-reactive.html#webflux-fn">Functional Endpoints</a> : 使用<code>RouterFunction</code></li>
</ul>
</li>
<li>核心组件(功能大同WebMvc, jar: <code>spring-webflux</code>， package：<code>o.s.w.reactive...</code>):<ul>
<li>总控 <code>DispatcherHandler</code> (implements <code>WebHandler</code>)</li>
<li>处理器管理<ul>
<li>映射 <code>HandlerMapping</code> (eg: RequestMappingHandlerMapping)</li>
<li>适配 <code>HandlerAdapter</code> (eg: RequestMappingHandlerAdapter)</li>
<li>执行 <code>HandlerResult</code></li>
</ul>
</li>
<li>异常处理 <code>HandlerResult#exceptionHandler</code></li>
<li>HandlerMethod: <code>@RequestMapping</code>/<code>@XxxMapping</code>标注的方法<ul>
<li>HandlerMethod参数解析器: <code>HandlerMethodArgumentResolver</code></li>
<li>Handler返回值解析器: <code>HandlerResultHandler</code><ul>
<li><code>ResponseBodyResultHandler</code></li>
<li><code>ResponseEntityResultHandler</code></li>
<li><code>ServerResponseResultHandler</code></li>
<li><code>ViewResolutionResultHandler</code><ul>
<li><code>RequestedContentTypeResolverBuilder</code></li>
<li><code>RequestedContentTypeResolver</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>视图解析器 <code>ViewResolver</code></li>
<li>视图渲染 <code>View</code>, eg:<ul>
<li><code>RedirectView</code></li>
<li><code>FreeMarkerView</code></li>
<li><code>HttpMessageWriterView</code></li>
</ul>
</li>
<li>配置 <ul>
<li><code>WebFluxConfigurer</code></li>
<li><code>WebFluxConfigurationSupport</code></li>
</ul>
</li>
<li>for Functional Endpoints(函数式端点方式)<ul>
<li><code>RouterFunction</code><pre><code class="lang-java">  @FunctionalInterface 
  // 标注表示这是一个函数式接口
  // 只能标注在接口上，且该接口只有一个抽象方法（接口默认方法以及声明中覆盖 Object 的公开方法不算）
  // 标注后此接口的实例可被 Lambda 表示式、方法引用或构造器引用创建
  public interface RouterFunction&lt;T extends ServerResponse&gt; {
      Mono&lt;HandlerFunction&lt;T&gt;&gt; route(ServerRequest request);
      // default:
      // and,andOther,andRoute,andNest,filter,accept
  }
</code></pre>
</li>
<li><code>RouterFunctionMapping</code> (implements HandlerMapping)</li>
<li><code>HandlerFunctionAdapter</code> (implements HandlerAdapter)</li>
</ul>
</li>
</ul>
</li>
<li>使用场景：不适合RT（响应）敏感的RPC框架/Web应用，适合请求慢慢执行的场景（把请求丢过来，不care什么时候完成，完成后通知你下就即可），Reactive可以提升吞吐量，但RunTime反而会变得更长，且出现响应超时等问题    </li>
<li><code>Spring WebMVC</code> vs. <code>Spring WebFlux</code><ul>
<li>均能使用注解驱动Controller,WebFlux还能使用函数式端点方式</li>
<li>主要不同点在于并发模型和阻塞特性：<ul>
<li>Spring WebMvc: Servlet应用,通常是阻塞服务,Servlet容器一般使用较大的线程池处理请求</li>
<li>Spring WebFlux: Reactive应用,通常是非阻塞服务，服务器可使用少量、固定大小的线程池处理请求</li>
</ul>
</li>
<li>目前WebFlux并未优于WebMvc:<ul>
<li>性能上没有明显的速度提升(甚至性能结果稍微更恶劣)</li>
<li>在编程友好性方面,Reactive编程尽管没有新增大量的代码,却使编码(和调试)变得复杂了</li>
<li>缺少文档</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="header-50">Java 并发模型</h3>
<ul>
<li>阻塞／非阻塞 (编程模型)<table class="table">
<thead>
<tr>
<th style="text-align:left">IO</th>
<th style="text-align:left">NIO</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">阻塞</td>
<td style="text-align:left">非阻塞</td>
</tr>
<tr>
<td style="text-align:left">面向流</td>
<td style="text-align:left">面向缓冲</td>
</tr>
<tr>
<td style="text-align:left">线程被阻塞直到读／写完</td>
<td style="text-align:left">无数据可读／写时，该线程可继续做其他事</td>
</tr>
<tr>
<td style="text-align:left">一个线程只管理一个输入输出通道</td>
<td style="text-align:left">一个线程可以管理多个输入输出通道</td>
</tr>
<tr>
<td style="text-align:left">使用场景：少量的连接使用较高的带宽，一次发送大量的数据</td>
<td style="text-align:left">使用场景：聊天服务器要管理很多个连接，每次只是发送少量的数据，一个线程就可以管理多个连接，提升系统吞吐量</td>
</tr>
</tbody>
</table>
</li>
<li>同步／异步 (线程模型)</li>
<li>组合：<ul>
<li>阻塞 &amp; 同步／异步,eg:<ul>
<li>迭代器模式(Iterator): 阻塞同步</li>
<li>Future#get: blocking &amp; 异步－&gt;串行</li>
</ul>
</li>
<li>非阻塞 &amp; 同步／异步，eg:<ul>
<li>Observer模式（观察者模式,事件/监听者模式）: 非阻塞</li>
<li>Reactor模式（反应堆模式）: 非阻塞同步</li>
<li>Proactor模式 : 非阻塞异步 </li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong> 示例：数据加载（阻塞任务） + 同步／异步 </strong></p>
<ol>
<li>在各个任务间没有数据依赖关系的情况下：<ul>
<li>单线程 -&gt; 串行：时间消耗线性累加</li>
<li>多线程 －&gt; 并行：时间消耗取最大者,性能和资源利用率明显地得到提升</li>
</ul>
</li>
<li>在任务间有依赖时:<ul>
<li>依赖任务不论是否在同一线程，都会串行执行（又回到了阻塞模式）</li>
<li>与非依赖的异步任务，还是并行执行</li>
</ul>
</li>
<li>总结：如果任务间有依赖，或则设置强制等待某个任务结束，并发模型并不会提高执行效率</li>
</ol>
<pre><code class="lang-java">public class AsyncTest {
    private long startTime;
    public void load(String source,int seconds) {
        try {
            long startTime = System.currentTimeMillis();
            long milliseconds = TimeUnit.SECONDS.toMillis(seconds);
            Thread.sleep(milliseconds);
            long costTime = System.currentTimeMillis() - startTime;
            System.out.printf(&quot;[Thread : %s] %s cost :  %d ms \n&quot;,Thread.currentThread().getName(), source, costTime);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
    @Before
    public void before() {
        startTime = System.currentTimeMillis();
    }
    @After
    public void after() {
        long costTime = System.currentTimeMillis() - startTime;
        System.out.println(&quot;total cost:&quot; + costTime + &quot; ms&quot;);
    }

    // 同步：只有一个main线程 ＝&gt; 串行执行
    // total cost: 1.x + 2.x  + 3.x &gt; 6s (有些线程调度切换等花费掉的时间)
    // Detail:
    // [Thread : main] loadConfigurations cost :  1005 ms 
    // [Thread : main] loadUsers cost :  2005 ms 
    // [Thread : main] loadOrders cost :  3005 ms 
    // total cost:6016 ms
    @Test
    public void serialLoadTest(){ 
        load(&quot;loadConfigurations&quot;,1);
        load(&quot;loadUsers&quot;,2);
        load(&quot;loadOrders&quot;,3);
    }

    // 异步: 多线程 ＝&gt; 并行执行
    // main线程通过轮询来检查是否都完成了，各个子任务间无依赖，也不会阻塞main线程
    // total cost: max(1.x, 2.x, 3.x)  = 3.x &gt; 3s
    // Detail:
    // [Thread : pool-1-thread-1] loadConfigurations cost :  1000 ms 
    // [Thread : pool-1-thread-2] loadUsers cost :  2002 ms 
    // [Thread : pool-1-thread-3] loadOrders cost :  3005 ms 
    // total cost:3063 ms
    @Test
    public void parallelLoadTest() {    
        ExecutorService executorService = Executors.newFixedThreadPool(3); // 创建线程池
        CompletionService&lt;String&gt; completionService = new ExecutorCompletionService&lt;String&gt;(executorService);
        completionService.submit(()-&gt;{load(&quot;loadConfigurations&quot;,1);}, null);      //  耗时 &gt;= 1s
        completionService.submit(()-&gt;{load(&quot;loadUsers&quot;,2);}, null);               //  耗时 &gt;= 2s
        completionService.submit(()-&gt;{load(&quot;loadOrders&quot;,3);}, null);              //  耗时 &gt;= 3s
        int count = 0;
        while (count &lt; 3) { // 等待三个任务完成
            if (completionService.poll() != null) {
                count++;
            }
        }
        executorService.shutdown();
    }

    // 异步：多线程 + Future#get() ＝&gt; 并行－&gt;串行执行, main thead 阻塞
    // 多个任务提交后,返回的多个Future逐一调用get()方法时,将会依次blocking main thread(等待直到当前任务执行完成),从而任务的执行从并行变为串行执行
    // total cost: 1.x + 2.x + 3.x &gt; 6s 
    // Detail:
    // [Thread : pool-1-thread-1] loadConfigurations cost :  1001 ms 
    // [Thread : pool-1-thread-2] loadUsers cost :  2005 ms 
    // [Thread : pool-1-thread-3] loadConfigurations cost :  3006 ms 
    // total cost:6077 ms
    @Test
    public void futureBlockingLoadTest() {
       ExecutorService executorService = Executors.newFixedThreadPool(3); // 创建线程池
       runCompletely(executorService.submit(()-&gt;{load(&quot;loadConfigurations&quot;,1);}));
       runCompletely(executorService.submit(()-&gt;{load(&quot;loadUsers&quot;,2);}));
       runCompletely(executorService.submit(()-&gt;{load(&quot;loadConfigurations&quot;,3);}));
       executorService.shutdown();
    }
    private void runCompletely(Future&lt;?&gt; future) {
        try {
            future.get();
        } catch (Exception e) {
        }
    }

    // 异步：多线程  ＝&gt; main 和 sub-thread并行，sub-thread串行执行任务且完成时触发回调
    // Detail:
    // Hello
    // [Thread : ForkJoinPool.commonPool-worker-1] loadConfigurations cost :  1004 ms 
    // [Thread : ForkJoinPool.commonPool-worker-1] loadUsers cost :  2004 ms 
    // [Thread : ForkJoinPool.commonPool-worker-1] loadOrders cost :  3005 ms 
    // [Thread ：ForkJoinPool.commonPool-worker-1] Complete 6072ms
    @Test
    public void chainLoadTest() throws InterruptedException {
        // main -&gt; submit -&gt; ...
        // sub-thread : F1 -&gt; F2 -&gt; F3
        CompletableFuture
            .runAsync(()-&gt;{load(&quot;loadConfigurations&quot;,1);})
            .thenRun(()-&gt;{load(&quot;loadUsers&quot;,2);})
            .thenRun(()-&gt;{load(&quot;loadOrders&quot;,3);})
            .whenComplete((result, throwable) -&gt; { // 完成时回调
                long costTime = System.currentTimeMillis() - startTime;
                System.out.println(&quot;[Thread ：&quot; + Thread.currentThread().getName() + &quot;] Complete &quot;+costTime+&quot;ms&quot;);
            })
            .exceptionally(throwable-&gt;{
                System.out.println(&quot;[Thread ：&quot; + Thread.currentThread().getName() + &quot;] Exception&quot;);
                return null;
            })
            //.join()    // 等待完成
            ; 

        System.out.println(&quot;Hello&quot;);
        Thread.sleep(8000);
    }

    // Java GUI 事件/监听者模式（即观察者模式）的并发模型可为同步或异步
    // 通过回调`Callbacks`实现非阻塞
    // 注意：`Callbacks Hell`, 监听的维度很多时则对应的Callback实现也会很多
    @Test
    public void callbackTest() throws IOException {
        JFrame jFrame = new JFrame(&quot;GUI 示例&quot;);
        jFrame.setBounds(500, 300, 400, 300);
        LayoutManager layoutManager = new BorderLayout(400, 300);
        jFrame.setLayout(layoutManager);
        jFrame.addMouseListener(new MouseAdapter() { // callback 1
         @Override
         public void mouseClicked(MouseEvent e) {
             System.out.printf(&quot;[线程 : %s] 鼠标点击，坐标(X : %d, Y : %d)\n&quot;,
                     Thread.currentThread().getName(), e.getX(), e.getY());
         }
        });
        jFrame.addWindowListener(new WindowAdapter() {  // callback 2
         @Override
         public void windowClosing(WindowEvent e) {
             System.out.printf(&quot;[线程 : %s] 清除 jFrame... \n&quot;, Thread.currentThread().getName());
             jFrame.dispose(); // 清除 jFrame
         }

         @Override
         public void windowClosed(WindowEvent e) {
             System.out.printf(&quot;[线程 : %s] 退出程序... \n&quot;, Thread.currentThread().getName());
             System.exit(0); // 退出程序
         }
        });
        System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName());
        jFrame.setVisible(true);

        System.in.read();
    }
}
</code></pre>
<h3 id="header-51">Reactive</h3>
<ol>
<li><p>Reactive 思想</p>
<ul>
<li>非阻塞下同步／异步执行 -- 多功能<ul>
<li>阻塞导致性能瓶颈和浪费资源，但非阻塞也不一定提升性能</li>
<li>增加线程可能会引起资源竞争和并发问题</li>
</ul>
</li>
<li>数据在生产与消费间的平衡（背压）</li>
</ul>
</li>
<li><p>Reactive Programming (编程模型)</p>
<ul>
<li>观察者模式(observer pattern)的延伸</li>
<li>处理流式数据（streams: sequenced data/events）</li>
<li>非阻塞下的同步／异步执行 （no-blocking)</li>
<li>推拉相结合（push-based and pull-based）</li>
<li>响应数据传播时的变化 (responsive)</li>
<li>结合背压（Backpressure）技术处理数据生产与消费的平衡问题</li>
<li><code>Observable</code> vs <code>Iterable</code>: An Observable(RxJava) is the asynchronous/push “dual” to the synchronous/pull Iterable<ul>
<li>Observer 观察者：被动通知（非阻塞回调方式），推动模式（eg: 服务器端推送到客户端）</li>
<li>Iterator 迭代器：主动触发（循环遍历），拉动模式(eg: 客户端主动for循环)<table class="table">
<thead>
<tr>
<th style="text-align:left">event</th>
<th style="text-align:left">Iterable (pull)</th>
<th style="text-align:left">Observable (push)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">data</td>
<td style="text-align:left">T next()</td>
<td style="text-align:left">onNext(T)</td>
</tr>
<tr>
<td style="text-align:left">discover error</td>
<td style="text-align:left">throws Exception</td>
<td style="text-align:left">onError(Exception)</td>
</tr>
<tr>
<td style="text-align:left">complete</td>
<td style="text-align:left">!hasNext()</td>
<td style="text-align:left">onCompleted()</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>注：观察者模式（即事件/监听者模式）的并发模型可为同步或异步，eg:<ul>
<li>Spring （同步/异步）事件/监听器：<ul>
<li>事件： ApplicationEvent</li>
<li>事件监听器： ApplicationListener</li>
<li>事件广播器： ApplicationEventMulticaster</li>
<li>事件发布器： ApplicationEventPublisher</li>
</ul>
</li>
<li>Servlet 同步事件/监听器:<ul>
<li>事件： ServletContextEvent</li>
<li>事件监听器： ServletContextListener</li>
</ul>
</li>
<li>Servlet 异步事件/监听器:<ul>
<li>事件： AsyncEvent</li>
<li>事件监听器： AsyncListener    </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Reactive 实现框架</p>
<ul>
<li>RxJava (Reactive Extensions)</li>
<li>Reactor (Spring/SpringBoot WebFlux使用此Reactive类库）</li>
<li>Flow API (Java 9)</li>
<li>注：Java 原生技术Stream的限制Stream属于迭代器模式，拉模式）<ul>
<li>有限操作符</li>
<li>不支持背压</li>
<li>不支持订阅</li>
</ul>
</li>
</ul>
</li>
<li><p>场景</p>
<ul>
<li>管理流式数据在异步边界的交换(reactive-streams)<ul>
<li>govern the exchange of stream data</li>
<li>across an asynchronous boundary</li>
</ul>
</li>
<li>通常并非让应用运行更快速，而是要利用较少的资源提升伸缩性(SpringFramework)<ul>
<li>generally do not make applications run faster</li>
<li>scale with a small, fixed number of threads and less memory</li>
</ul>
</li>
<li>更好可读性 more readable (ReactiveX)</li>
<li>结构性,高层次并发抽象 High level abstraction (Reactor)</li>
</ul>
</li>
</ol>
<h3 id="header-52">Reactor</h3>
<ul>
<li>jar: <code>reactor-core</code> (dependency jar: <code>reactive-streams</code>)</li>
<li>核心API：<ul>
<li><code>Mono</code> : 0~1的非阻塞结果(类似<code>Optional</code>,点对点模式)，实现 reactive-streams <code>Publisher</code></li>
<li><code>Flux</code> : 0~N的非阻塞序列(类似<code>Stream</code>,发布/订阅者模式),实现 reactive-streams <code>Publisher</code></li>
<li><code>Scheduler</code> : Reactor调度线程池<table class="table">
<thead>
<tr>
<th style="text-align:left">线程池</th>
<th style="text-align:left">方法</th>
<th style="text-align:left">内部名称</th>
<th style="text-align:left">线程名称</th>
<th style="text-align:left">线程数量</th>
<th style="text-align:left">线程idel时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">单复用线程</td>
<td style="text-align:left">Schedulers.single()</td>
<td style="text-align:left">single</td>
<td style="text-align:left">single</td>
<td style="text-align:left">1</td>
<td style="text-align:left">Long Live</td>
</tr>
<tr>
<td style="text-align:left">弹性线程池</td>
<td style="text-align:left">Schedulers.elastic()</td>
<td style="text-align:left">elastic</td>
<td style="text-align:left">elastic-evictor-{num}</td>
<td style="text-align:left">无限制（unbounded）</td>
<td style="text-align:left">60s</td>
</tr>
<tr>
<td style="text-align:left">并行线程池</td>
<td style="text-align:left">Schedulers.parallel()</td>
<td style="text-align:left">parallel</td>
<td style="text-align:left">parallel-{num}</td>
<td style="text-align:left">处理器数量</td>
<td style="text-align:left">60s</td>
</tr>
</tbody>
</table>
<ul>
<li>底层实现：<code>ScheduledThreadPoolExecutor</code></li>
<li>查看当前线程：<code>Schedulers.immediate()</code> ( 等价于 <code>Thread.currentThread()</code> )</li>
</ul>
</li>
</ul>
</li>
<li><p><code>reactive-streams</code>：</p>
<ul>
<li>定义<blockquote>
<p>Reactive Streams is a standard and specification for Stream-oriented libraries for the JVM that</p>
<ul>
<li>process a potentially unbounded number of elements</li>
<li>in sequence,</li>
<li>asynchronously passing elements between components,</li>
<li>with mandatory non-blocking backpressure.</li>
</ul>
</blockquote>
</li>
<li>核心API ( package: <code>org.reactivestreams</code>)<ul>
<li><code>Publisher</code> ：数据发布者（上游）<pre><code class="lang-java">  public interface Publisher&lt;T&gt; {
      public void subscribe(Subscriber&lt;? super T&gt; s);
  }
</code></pre>
</li>
<li><code>Subscriber</code> ：数据订阅者（下游）<pre><code class="lang-java">  public interface Subscriber&lt;T&gt; {
      public void onSubscribe(Subscription s);    // 当下游订阅时
      public void onNext(T t);                    // 当下游接收数据时
      public void onError(Throwable t);            // 当数据流（Data Streams）执行错误时
      public void onComplete();                    // 当数据流（Data Streams）执行完成时
  }
</code></pre>
</li>
<li><code>Subscription</code> ：订阅信号 (Subscriber to Publisher -- 背压)<pre><code class="lang-java">  public interface Subscription {
      public void request(long n);    // 限定请求上游元素的数量
      public void cancel();            // 请求停止发送数据并且清除资源
  }
</code></pre>
</li>
<li><code>Processor</code> ：<code>Publisher</code>和<code>Subscriber</code>综合体（中游，承上启下）<pre><code class="lang-java">  public interface Processor&lt;T, R&gt; extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; {
  }
</code></pre>
</li>
</ul>
</li>
<li>背压处理(backpressure handle)：<ul>
<li>publisher side maintains a higher rate than the subscriber</li>
<li>mediate between threads to be bounded (传播上游信号，eg: request process at most n elements; halt sending )</li>
<li>下游<code>Subscriber</code>工作在无边界<code>unbounded</code>大小的数据流水线，当上游<code>Publisher</code>提供数据的速率快于下游<code>Subscriber</code>的消费数据速率时，下游<code>Subscriber</code>将通过传播信号<code>request</code>到上游<code>Publisher</code>: 请求限制数据的数量(limit number)或通知上游停止数据生产(halt)</li>
</ul>
</li>
</ul>
</li>
<li><p>示例：<code>Flux</code></p>
<ol>
<li>pom.xml<pre><code class="lang-xml"> &lt;dependency&gt;
     &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
     &lt;artifactId&gt;reactor-core&lt;/artifactId&gt;
 &lt;/dependency&gt;
</code></pre>
</li>
<li><p>lambde编程方式</p>
<pre><code class="lang-java">
 private static void println(Object object) {
     String threadName = Thread.currentThread().getName();
     System.out.println(&quot;[Thread:&quot; + threadName + &quot;] &quot; + object);
 }

 // 同步
 @Test
 public void fluxSyncFunctinalProgramingTest() {
     println(&quot;Run fluxSyncFunctinalProgramingTest ...&quot;);
     Flux.just(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)             // Sequence: A -&gt; B -&gt; C
         .map(value -&gt; &quot;+&quot; + value)         // &quot;A&quot; -&gt; &quot;+A&quot; 
         .subscribe(
                 ReactorTest::println,     // 数据消费 = onNext(T)
                 ReactorTest::println,     // 异常处理 = onError(Throwable)
                 () -&gt; {                 // 完成回调 = onComplete()
                     println(&quot;Complete!&quot;);
                 },
                 subscription -&gt; {         // 背压操作 onSubscribe(Subscription)
                     subscription.request(Integer.MAX_VALUE); // 请求的元素数量
                     subscription.cancel();     // 取消上游传输数据到下游
                 }
         );
     /*
      Summary:
      subscription.request(0);    =&gt; Exception (n must &gt;0)
      subscription.request(2);    =&gt; main: +A -&gt; +B
      subscription.request(5);    =&gt; main: +A -&gt; +B -&gt; +C -&gt; Complete!
      subscription.request(2); subscription.cancel(); =&gt; main: +A -&gt; +B
      subscription.request(5); subscription.cancel(); =&gt; main: +A -&gt; +B -&gt; +C -&gt; Complete!
      subscription.cancel(); ... =&gt; none
      */
 }

   // 异步
 @Test
 public void fluxAsyncFunctionalProgramingTest() throws InterruptedException {
     println(&quot;Run fluxAsyncFunctionalProgramingTest ...&quot;);
     Flux.just(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)
         .publishOn(Schedulers.elastic())     // 线程池切换
         .map(value -&gt; &quot;+&quot; + value)
         .subscribe(
                 ReactorTest::println,
                 ReactorTest::println,
                 () -&gt; {
                     println(&quot;Complete!&quot;);
                 },
                 subscription -&gt; {
                     subscription.request(5);
                  // subscription.cancel();
                 }
         );
     /*
      Summary:
      subscription.request(2); =&gt; elastic-2: +A -&gt; +B
      subscription.request(5); =&gt; elastic-2: +A -&gt; +B -&gt; +C -&gt; Complete!
      subscription.request(2);subscription.cancel(); =&gt; none
     */            
 }
</code></pre>
</li>
<li>传统编程方式<pre><code class="lang-java"> @Test
 public void fluxResponseProgramingTest() {
     println(&quot;Run fluxResponseProgramingTest ...&quot;);
     Flux.just(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)
         //.publishOn(Schedulers.elastic()) 
         .map(value -&gt; &quot;+&quot; + value)
         .subscribe(new Subscriber&lt;String&gt;() {
             private Subscription subscription;
             private int count = 0;
             @Override
             public void onSubscribe(Subscription s) {
                 subscription = s;
                 subscription.request(1);
             }
             @Override
             public void onNext(String s) {
                 if (count == 2) {
                     throw new RuntimeException(&quot;故意抛异常！&quot;);
                 }
                 println(s);
                 count++;
                 subscription.request(1);
             }
             @Override
             public void onError(Throwable t) {
                 println(t.getMessage());
             }
             @Override
             public void onComplete() {
                 println(&quot;Complete&quot;);
             }
         });            
     /*
      Summary:
      1. sync =&gt; main: +A -&gt; +B -&gt; Exception
      2. async: .publishOn(Schedulers.elastic()) =&gt; main: +A -&gt; +B 
      */
 }
</code></pre>
</li>
</ol>
</li>
</ul>
<h3 id="header-53">WebFlux</h3>
<p><strong> 示例: </strong></p>
<ol>
<li><p>注解驱动,函数式端点驱动</p>
<pre><code class="lang-java"> @SpringBootApplication
 @RestController
 public class WebFluxApp {
     public static void main(String[] args) {
         SpringApplication.run(WebFluxApp.class,args);
     }

     private static void println(String message) {
         System.out.println(&quot;[&quot; + Thread.currentThread().getName() + &quot;] : &quot; + message);
     }

     @GetMapping(&quot;/mvc&quot;)
     public String mvc() {
         println(&quot;mvc&quot;);
         return &quot;MVC&quot;;
     }

     @GetMapping(&quot;/mono&quot;)
     public Mono&lt;String&gt; mono() {
         println(&quot;mono&quot;);
         return Mono.just(&quot;Mono&quot;);
     }

     @Bean
     public RouterFunction&lt;ServerResponse&gt; hello(){
         // curl -i localhost:8080/hello
         // curl -i -H &quot;Content-Type:application/json&quot; localhost:8080/hello2
         // curl -i localhost:8080/hello3
         return RouterFunctions
                 .route(RequestPredicates.GET(&quot;/hello&quot;)
                         ,serverRequest-&gt;{
                             return ServerResponse.ok().body(Mono.just(&quot;Hello World!&quot;),String.class);
                         })
                 .andRoute(RequestPredicates.GET(&quot;/hello2&quot;).and(RequestPredicates.contentType(MediaType.APPLICATION_JSON))
                         ,this::hello2Handler)
                 .andRoute(RequestPredicates.GET(&quot;/hello3&quot;), this::hello3Handler);
     }

     public Mono&lt;ServerResponse&gt; hello2Handler(ServerRequest request){
         Mono&lt;String&gt; helloMono=Mono.just(&quot;Hello World 2&quot;);
         return ServerResponse.ok().body(helloMono,String.class);
     }

     public Mono&lt;ServerResponse&gt; hello3Handler(ServerRequest request){
         Flux&lt;String&gt; helloFlux=Flux.just(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;);
         return ServerResponse.ok().body(helloFlux,String.class);
     }
 }
</code></pre>
</li>
<li><p>非阻塞调用阻塞</p>
<pre><code class="lang-java"> @Configuration
 public class RouterFunctionConfiguration {
      @Bean
     //@Autowired
     public RouterFunction&lt;ServerResponse&gt; listUsers(UserRepository userRepository){
         return RouterFunctions.route(RequestPredicates.GET(&quot;/users&quot;)
                 ,request -&gt; {
                     Collection&lt;User&gt; users = userRepository.list();    // 阻塞
                     Flux&lt;User&gt; userFlux = Flux.fromIterable(users); // 非阻塞
                     return ServerResponse.ok().body(userFlux,User.class);
                 });
     }
 }

 @RestController
 public class UserController {
     private final UserRepository userRepository;
     @Autowired
     public UserController(UserRepository userRepository) {
         this.userRepository = userRepository;
     }
     @PostMapping(&quot;/users&quot;)
     public User save(@RequestParam String name){
         User user = new User();
         user.setName(name);
         if(userRepository.save(user)){
             System.out.printf(&quot;Save %s Successful! \n&quot;,user);
         }
         return user;
     }
 }

 @Repository
 public class UserRepository {
     private final ConcurrentMap&lt;Integer,User&gt; users = new ConcurrentHashMap&lt;Integer,User&gt;();
     private final static AtomicInteger idGenerator = new AtomicInteger();
     public boolean save(User user){
         Integer id = idGenerator.incrementAndGet();
         user.setId(id);
         return users.put(id,user)==null;
     }
     public Collection&lt;User&gt; list(){
         return users.values();
     }
 }

 // Domain:
 // User(Integer id,String name)
 // ...

 // main:
 @SpringBootApplication
 public class App {
     public static void main(String[] args) {
         SpringApplication.run(App.class,args);
     }
     /* Verify:
      *  curl -i -X POST localhost:8080/users?name=Tom
      *  curl -i -X POST localhost:8080/users?name=Lucy
      *  curl -i localhost:8080/users
      * */
 }
</code></pre>
</li>
</ol>
<!-- 
1. 初始化流程
    ![WebFlux 初始化流程](2018-09-15-Spring-Boot/webflux-init.png)

2. 执行流程
    - 注解驱动执行流程
        ![WebFlux 注解驱动执行流程](2018-09-15-Spring-Boot/webflux-annotation.png)
    - 函数式端点驱动执行流程
        ![WebFlux 函数式端点驱动执行流程](2018-09-15-Spring-Boot/webflux-functional.png)
-->
<h2 id="header-54">Reference</h2>
<ul>
<li><a href="https://github.com/sixDegree/springboot-demo">Demo</a></li>
<li><a href="https://docs.spring.io/spring/docs/5.0.x/spring-framework-reference/">SpringFramework Doc</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/htmlsingle/">SpringBoot Doc</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.0.x/reference/htmlsingle/#howto-convert-an-existing-application-to-spring-boot">Convert an Existing Application to Spring Boot</a></li>
</ul>
  </section>
</article>

      <hr/>
      
<section class="post-comment">
	
		<div id="gitment_container"></div>

<link rel="stylesheet" href="/gitment/default.css">
<script src="/gitment/gitment.browser.js"></script>


<script type="text/javascript">
	var gitment = new Gitment({
	  id: document.location.pathname,
	  owner: 'chenjin-zero',
	  repo: 'blogComment',
	  oauth: {
	    client_id: '36a09bb7399efe69c6ce',
	    client_secret: 'ad9ad546b23b708c71d92e513dc36e0486179dea',
	  }
	})
      
	gitment.render('gitment_container')
</script>
	
</section>

    </div>
  </div>
</body>

<script src="/jquery/dist/jquery.min.js"></script>
<script src="/bootstrap/dist/js/bootstrap.min.js"></script>


	<script src="/highlight/highlight.pack.js"></script>
	<script type="text/javascript">
		hljs.initHighlightingOnLoad();
	</script>






<script type="text/javascript">

  $(document).ready(function(){
    var sidebarCtrl=$("#sidebar-ctrl");
    var sidebar=$("#sidebar");
    var wrapper=$("#wrapper");
    sidebarCtrl.on("click",function(event){
        //alert("click");
        sidebar.toggleClass("sidebar-toggle");
        wrapper.toggleClass("sidebar-toggle");
        sidebarCtrl.toggleClass("sidebar-toggle");
        sidebarCtrl.toggleClass("active");
    })
  });
</script>


</html>
